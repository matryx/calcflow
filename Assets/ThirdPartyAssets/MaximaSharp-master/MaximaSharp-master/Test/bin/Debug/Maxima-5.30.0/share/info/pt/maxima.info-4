This is maxima.info, produced by makeinfo version 4.13 from maxima.texi.

Este é o Manual do Maxima no formato Texinfo

   Copyright 1994, 2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).     Um sistema de álgebra computacional.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Definições para Teoria dos Números,  Prev: Teoria dos Números,  Up: Teoria dos Números

31.1 Definições para Teoria dos Números
=======================================

 -- Função: bern (<n>)
     Retorna o <n>'ésimo número de Bernoulli para o inteiro <n>.
     Números de Bernoulli iguais a zero são suprimidos se `zerobern'
     for `false'.

     Veja também `burn'.

          (%i1) zerobern: true$
          (%i2) map (bern, [0, 1, 2, 3, 4, 5, 6, 7, 8]);
                            1  1       1      1        1
          (%o2)       [1, - -, -, 0, - --, 0, --, 0, - --]
                            2  6       30     42       30
          (%i3) zerobern: false$
          (%i4) map (bern, [0, 1, 2, 3, 4, 5, 6, 7, 8]);
                      1  1    1   5     691   7    3617  43867
          (%o4) [1, - -, -, - --, --, - ----, -, - ----, -----]
                      2  6    30  66    2730  6    510    798


 -- Função: bernpoly (<x>, <n>)
     Retorna o <n>'ésimo polinómio de Bernoulli na variável <x>.


 -- Função: bfzeta (<s>, <n>)
     Retorna a função zeta de Riemann para o argumento <s>.  O valor de
     retorno é um grande inteiro em ponto flutuante (bfloat); <n> é o
     número de dígitos no valor de retorno.

     `load ("bffac")' chama essa função.


 -- Função: bfhzeta (<s>, <h>, <n>)
     Retorna a função zeta de Hurwitz para os argumentos <s> e <h>.  O
     valor de retorno é um grande inteiro em ponto flutuante (bfloat);
     <n> é o números de dígitos no valor de retorno.

     A função zeta de Hurwitz é definida como

          sum ((k+h)^-s, k, 0, inf)

     `load ("bffac")' chama essa função.


 -- Função: binomial (<x>, <y>)
     O coeficiente binomial `<x>!/(<y>! (<x> - <y>)!)'.  Se <x> e <y>
     forem inteiros, então o valor numérico do coeficiente binomial é
     calculado.  Se <y>, ou <x - y>, for um inteiro, o the coeficiente
     binomial é expresso como um polinómio.

     Exemplos:

          (%i1) binomial (11, 7);
          (%o1)                          330
          (%i2) 11! / 7! / (11 - 7)!;
          (%o2)                          330
          (%i3) binomial (x, 7);
                  (x - 6) (x - 5) (x - 4) (x - 3) (x - 2) (x - 1) x
          (%o3)   -------------------------------------------------
                                        5040
          (%i4) binomial (x + 7, x);
                (x + 1) (x + 2) (x + 3) (x + 4) (x + 5) (x + 6) (x + 7)
          (%o4) -------------------------------------------------------
                                         5040
          (%i5) binomial (11, y);
          (%o5)                    binomial(11, y)


 -- Função: burn (<n>)
     Retorna o <n>'ésimo número de Bernoulli para o inteiro <n>.
     `burn' pode ser mais eficitente que `bern' para valores grandes e
     isolados de <n> (talvez <n> maior que 105 ou algo parecido), como
     `bern' calcula todos os números de Bernoulli até o índice <n>
     antes de retornar.

     `burn' explora a observação que números de Bernoulli (racionais)
     podem ser aproximados através de zetas (transcendentes) com
     eficiência tolerável.

     `load ("bffac")' chama essa função.


 -- Função: cf (<expr>)
     Converte <expr> em uma fração contínua.  <expr> é uma expressão
     compreendendo frações contínuas e raízes quadradas de inteiros.
     Operandos na expressão podem ser combinados com operadores
     aritméticos.  Com excessão de frações contínuas e raízes quadradas,
     factores na expressão devem ser números inteiros ou racionais.
     Maxima não conhece operações sobre frações contínuas fora de `cf'.

     `cf' avalia seus argumentos após associar `listarith' a `false'.
     `cf' retorna uma fração contínua, representada como uma lista.

     Uma fração contínua `a + 1/(b + 1/(c + ...))' é representada
     através da lista `[a, b, c, ...]'.  Os elementos da lista `a',
     `b', `c', ... devem avaliar para inteiros.  <expr> pode também
     conter `sqrt (n)' onde `n' é um inteiro.  Nesse caso `cf'
     fornecerá tantos termos de fração contínua quantos forem o valor
     da variável `cflength' vezes o período.

     Uma fração contínua pode ser avaliada para um número através de
     avaliação da representação aritmética retornada por `cfdisrep'.
     Veja também `cfexpand' para outro caminho para avaliar uma
     fração contínua.

     Veja também `cfdisrep', `cfexpand', e `cflength'.

     Exemplos:

        * <expr> é uma expressão compreendendo frações contínuas e
          raízes quadradas de inteiros.

               (%i1) cf ([5, 3, 1]*[11, 9, 7] + [3, 7]/[4, 3, 2]);
               (%o1)               [59, 17, 2, 1, 1, 1, 27]
               (%i2) cf ((3/17)*[1, -2, 5]/sqrt(11) + (8/13));
               (%o2)        [0, 1, 1, 1, 3, 2, 1, 4, 1, 9, 1, 9, 2]

        * `cflength' controla quantos períodos de fração contínua são
          computados para números algébricos, números irracionais.

               (%i1) cflength: 1$
               (%i2) cf ((1 + sqrt(5))/2);
               (%o2)                    [1, 1, 1, 1, 2]
               (%i3) cflength: 2$
               (%i4) cf ((1 + sqrt(5))/2);
               (%o4)               [1, 1, 1, 1, 1, 1, 1, 2]
               (%i5) cflength: 3$
               (%i6) cf ((1 + sqrt(5))/2);
               (%o6)           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2]

        * Um fração contínua pode ser avaliado através da avaliação da
          representação aritmética retornada por `cfdisrep'.

               (%i1) cflength: 3$
               (%i2) cfdisrep (cf (sqrt (3)))$
               (%i3) ev (%, numer);
               (%o3)                   1.731707317073171

        * Maxima não conhece operações sobre frações contínuas fora de
          `cf'.

               (%i1) cf ([1,1,1,1,1,2] * 3);
               (%o1)                     [4, 1, 5, 2]
               (%i2) cf ([1,1,1,1,1,2]) * 3;
               (%o2)                  [3, 3, 3, 3, 3, 6]


 -- Função: cfdisrep (<list>)
     Constrói e retorna uma expressão aritmética comum da forma `a +
     1/(b + 1/(c + ...))' a partir da representação lista de uma
     fração contínua `[a, b, c, ...]'.

          (%i1) cf ([1, 2, -3] + [1, -2, 1]);
          (%o1)                     [1, 1, 1, 2]
          (%i2) cfdisrep (%);
                                            1
          (%o2)                     1 + ---------
                                              1
                                        1 + -----
                                                1
                                            1 + -
                                                2


 -- Função: cfexpand (<x>)
     Retorna uma matriz de numeradores e denominadores dos último
     (columa 1) e penúltimo (columa 2) convergentes da fração contínua
     <x>.

          (%i1) cf (rat (ev (%pi, numer)));

          `rat' replaced 3.141592653589793 by 103993/33102 = 3.141592653011902
          (%o1)                  [3, 7, 15, 1, 292]
          (%i2) cfexpand (%);
                                   [ 103993  355 ]
          (%o2)                    [             ]
                                   [ 33102   113 ]
          (%i3) %[1,1]/%[2,1], numer;
          (%o3)                   3.141592653011902


 -- Variável de opção: cflength
     Valor por omissão: 1

     `cflength' controla o número de termos da fração contínua que a
     função `cf' fornecerá, como o valor de `cflength' vezes o período.
     Dessa forma o padrão é fornecer um período.

          (%i1) cflength: 1$
          (%i2) cf ((1 + sqrt(5))/2);
          (%o2)                    [1, 1, 1, 1, 2]
          (%i3) cflength: 2$
          (%i4) cf ((1 + sqrt(5))/2);
          (%o4)               [1, 1, 1, 1, 1, 1, 1, 2]
          (%i5) cflength: 3$
          (%i6) cf ((1 + sqrt(5))/2);
          (%o6)           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2]


 -- Função: divsum (<n>, <k>)
 -- Função: divsum (<n>)
     `divsum (<n>, <k>)' retorna a adição dos divisores de <n> elevados
     à <k>'ésima potência.

     `divsum (<n>)' retorna a adição dos divisores de <n>.

          (%i1) divsum (12);
          (%o1)                          28
          (%i2) 1 + 2 + 3 + 4 + 6 + 12;
          (%o2)                          28
          (%i3) divsum (12, 2);
          (%o3)                          210
          (%i4) 1^2 + 2^2 + 3^2 + 4^2 + 6^2 + 12^2;
          (%o4)                          210


 -- Função: euler (<n>)
     Retorna o <n>'ésimo número de Euler para o inteiro <n> não
     negativo.

     Para a constante de Euler-Mascheroni, veja `%gamma'.

          (%i1) map (euler, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
          (%o1)    [1, 0, - 1, 0, 5, 0, - 61, 0, 1385, 0, - 50521]


 -- Constante: %gamma
     A constante de Euler-Mascheroni, 0.5772156649015329 ....


 -- Função: factorial (<x>)
     Representa a função factorial. Maxima trata `factorial (<x>)' da
     mesma forma que `<x>!'.  Veja `!'.


 -- Função: fib (<n>)
     Retorna o <n>'ésimo número de Fibonacci.  `fib(0)' igual a 0 e
     `fib(1)' igual a 1, e `fib (-<n>)' igual a `(-1)^(<n> + 1) *
     fib(<n>)'.

     Após chamar `fib', `prevfib' é iguala `fib (<x> - 1)', o número de
     Fibonacci anterior ao último calculado.

          (%i1) map (fib, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
          (%o1)         [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]


 -- Função: fibtophi (<expr>)
     Expressa números de Fibonacci que aparecem em <expr> em termos da
     constante `%phi', que é `(1 + sqrt(5))/2', aproximadamente
     1.61803399.

     Exemplos:

          (%i1) fibtophi (fib (n));
                                     n             n
                                 %phi  - (1 - %phi)
          (%o1)                  -------------------
                                     2 %phi - 1
          (%i2) fib (n-1) + fib (n) - fib (n+1);
          (%o2)          - fib(n + 1) + fib(n) + fib(n - 1)
          (%i3) fibtophi (%);
                      n + 1             n + 1       n             n
                  %phi      - (1 - %phi)        %phi  - (1 - %phi)
          (%o3) - --------------------------- + -------------------
                          2 %phi - 1                2 %phi - 1
                                                    n - 1             n - 1
                                                %phi      - (1 - %phi)
                                              + ---------------------------
                                                        2 %phi - 1
          (%i4) ratsimp (%);
          (%o4)                           0


 -- Função: ifactors (<n>)
     Para um inteiro positivo <n> retorna a factoração de <n>. Se
     `n=p1^e1..pk^nk' for a decomposição de <n> em factores primos,
     `ifactors' retorna `[[p1, e1], ... , [pk, ek]]'.

     Os métodos de factoração usados são divisões triviais por primos
     até 9973, o método rho de Pollard e o método da curva elíptica.

          (%i1) ifactors(51575319651600);
          (%o1)     [[2, 4], [3, 2], [5, 2], [1583, 1], [9050207, 1]]
          (%i2) apply("*", map(lambda([u], u[1]^u[2]), %));
          (%o2)                        51575319651600


 -- Função: inrt (<x>, <n>)
     Retorna a parte inteira da <n>'ésima raíz do valor absoluto de <x>.

          (%i1) l: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]$
          (%i2) map (lambda ([a], inrt (10^a, 3)), l);
          (%o2) [2, 4, 10, 21, 46, 100, 215, 464, 1000, 2154, 4641, 10000]


 -- Função: inv_mod (<n>, <m>)
     Calcula o  inverso de <n> módulo <m>.  `inv_mod (n,m)' retorna
     `false', se <n> modulo <m> for zero.

          (%i1) inv_mod(3, 41);
          (%o1)                           14
          (%i2) ratsimp(3^-1), modulus=41;
          (%o2)                           14
          (%i3) inv_mod(3, 42);
          (%o3)                          false


 -- Função: jacobi (<p>, <q>)
     Retorna símbolo de Jacobi de <p> e <q>.

          (%i1) l: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]$
          (%i2) map (lambda ([a], jacobi (a, 9)), l);
          (%o2)         [1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0]


 -- Função: lcm (<expr_1>, ..., <expr_n>)
     Retorna o menor múltiplo comum entre seus argumentos.  Os
     argumentos podem ser expressões gerais também inteiras.

     `load ("functs")' chama essa função.


 -- Função: minfactorial (<expr>)
     Examina <expr> procurando por ocorrências de dois factoriais que
     diferem por um inteiro.  `minfactorial' então converte um em um
     polinómio vezes o outro.

          (%i1) n!/(n+2)!;
                                         n!
          (%o1)                       --------
                                      (n + 2)!
          (%i2) minfactorial (%);
                                          1
          (%o2)                    ---------------
                                   (n + 1) (n + 2)


 -- Função: next_prime (<n>)
     Retorna o menor primo maior que <n>.

          (%i1) next_prime(27);
          (%o1)                       29


 -- Função: partfrac (<expr>, <var>)
     Expande a expressão <expr> em frações parciais com relação à
     variável principal <var>.  `partfrac' faz uma decomposição
     completa de fração parcial.  O algoritmo utilizado é baseado no
     facto que os denominadores de uma expansão de fração parcial (os
     factores do denominador original) são relativamente primos.  Os
     numeradores podem ser escritos como combinação linear dos
     denominadores, e a expansão acontece.

          (%i1) 1/(1+x)^2 - 2/(1+x) + 2/(2+x);
                                2       2        1
          (%o1)               ----- - ----- + --------
                              x + 2   x + 1          2
                                              (x + 1)
          (%i2) ratsimp (%);
                                           x
          (%o2)                 - -------------------
                                   3      2
                                  x  + 4 x  + 5 x + 2
          (%i3) partfrac (%, x);
                                2       2        1
          (%o3)               ----- - ----- + --------
                              x + 2   x + 1          2
                                              (x + 1)


 -- Função: power_mod (<a>, <n>, <m>)
     Usa um algoritmo modular para calcular `a^n mod m' onde <a> e <n>
     são inteiros e <m> é um inteiro positivo.  Se <n> for negativo,
     `inv_mod' é usada para encontrar o inverso modular.

          (%i1) power_mod(3, 15, 5);
          (%o1)                          2
          (%i2) mod(3^15,5);
          (%o2)                          2
          (%i3) power_mod(2, -1, 5);
          (%o3)                          3
          (%i4) inv_mod(2,5);
          (%o4)                          3


 -- Função: primep (<n>)
     Teste de primalidade. Se `primep (n)' retornar `false', <n> é um
     número compostro e se esse teste retornar `true', <n> é um número
     primo com grande probabilidade.

     Para <n> menor que 341550071728321 uma versão deterministra do
     teste de Miller-Rabin é usada. Se `primep (n)' retornar `true',
     então <n> é um número primo.

     Para <n> maior que 34155071728321 `primep' usa
     `primep_number_of_tests' que é os testes de pseudo-primalidade de
     Miller-Rabin e um teste de pseudo-primalidade de Lucas. A
     probabilidade que <n> irá passar por um teste de Miller-Rabin é
     menor que 1/4. Usando o valor padrão 25 para
     `primep_number_of_tests', a probabilidade de <n> passar no teste
     sendo composto é muito menor que 10^-15.


 -- Variável de opção: primep_number_of_tests
     Valor por omissão: 25

     Número de testes de Miller-Rabin usados em `primep'.

 -- Função: prev_prime (<n>)
     Retorna o maior primo menor que <n>.

          (%i1) prev_prime(27);
          (%o1)                       23

 -- Função: qunit (<n>)
     Retorna a principal unidade do campo dos números quadráticos reais
     `sqrt (<n>)' onde <n> é um inteiro, i.e., o elemento cuja norma é
     unidade.  Isso é importante para resolver a equação de Pell `a^2 -
     <n> b^2 = 1'.

          (%i1) qunit (17);
          (%o1)                     sqrt(17) + 4
          (%i2) expand (% * (sqrt(17) - 4));
          (%o2)                           1


 -- Função: totient (<n>)
     Retorna o número de inteiros menores que ou iguais a <n> que são
     relativamente primos com <n>.


 -- Variável de opção: zerobern
     Valor por omissão: `true'

     Quando `zerobern' for `false', `bern' exclui os números de
     Bernoulli que forem iguais a zero.  Veja `bern'.


 -- Função: zeta (<n>)
     Retorna a função zeta de Riemann se <x> for um inteiro negativo,
     0, 1, ou número par positivo, e retorna uma forma substantiva
     `zeta (<n>)' para todos os outros argumentos, incluindo não
     inteiros racionais, ponto flutuante, e argumentos complexos.

     Veja também `bfzeta' e `zeta%pi'.

          (%i1) map (zeta, [-4, -3, -2, -1, 0, 1, 2, 3, 4, 5]);
                                               2              4
                     1        1     1       %pi            %pi
          (%o1) [0, ---, 0, - --, - -, inf, ----, zeta(3), ----, zeta(5)]
                    120       12    2        6              90


 -- Variável de opção: zeta%pi
     Valor por omissão: `true'

     Quando `zeta%pi' for `true', `zeta' retorna uma expressão
     proporcional a `%pi^n' para inteiro par `n'.  De outra forma,
     `zeta' retorna uma forma substantiva `zeta (n)' para inteiro par
     `n'.

          (%i1) zeta%pi: true$
          (%i2) zeta (4);
                                           4
                                        %pi
          (%o2)                         ----
                                         90
          (%i3) zeta%pi: false$
          (%i4) zeta (4);
          (%o4)                        zeta(4)



File: maxima.info,  Node: Simetrias,  Next: Grupos,  Prev: Teoria dos Números,  Up: Top

32 Simetrias
************

* Menu:

* Definições para Simetrias::


File: maxima.info,  Node: Definições para Simetrias,  Prev: Simetrias,  Up: Simetrias

32.1 Definições para Simetrias
==============================

32.1.1 Mudando a base do sistema de numeração
---------------------------------------------

 -- Função: comp2pui (<n>, <L>)
     implementa a passagem das funções simétricas completamente
     simétricas fornecidas na lista <L> para as funções simétricas
     elementares de 0 a <n>. Se a lista <L> contiver menos que <n+1>
     elementos, será completada com valores formais do tipo <h1>, <h2>,
     etc. Se o primeiro elemento da lista <L> existir, ele é
     interpretado como sendo o tamanho do alfabeto, de outra forma o
     tamanho é escolhido para <n>.

          (%i1) comp2pui (3, [4, g]);
                                  2                    2
          (%o1)    [4, g, 2 h2 - g , 3 h3 - g h2 + g (g  - 2 h2)]


 -- Função: ele2pui (<m>, <L>)
     vai de funções simétricas elementares para as funções completas.
     Similar a `comp2ele' e `comp2pui'.

     Outras funções para mudanças de base: `comp2ele'.


 -- Função: ele2comp (<m>, <L>)
     Vai de funções simétricas elementares para funções completas.
     Similar a `comp2ele' e a `comp2pui'.

     Outras funções para mudanças de base: `comp2ele'.

 -- Função: elem (<ele>, <sym>, <lvar>)
     ddecompões o polinómio simétrico <sym>, nas variáveis contidas na
     lista <lvar>, em termos de funções elementares simétricas
     fornecidas na lista <ele>.  Se o primeiro elemento de <ele> for
     fornecido, esse primeiro elemento será o tamanho do alfabeto, de
     outra forma o tamanho será o grau do polinómio <sym>.  Se valores
     forem omitidos na lista <ele>, valores formais do tipo <e1>, <e2>,
     etc. serão adicionados.  O polinómio <sym> pode ser fornecido de
     três diferentes formas: contraída (`elem' pode então ser 1, seu
     valor padrão), particionada (`elem' pode ser 3), ou extendida
     (i.e. o polinómio completo, e `elem' pode então ser 2).  A
     função `pui' é usada então da mesma forma.

     sobre um alfabeto de tamanho 3 com <e1>, a primeira funçào
     elementar simétrica, com valor 7, o polinómio simétrico em 3
     variáveis cuja forma contraída (que aqui depende de duas de suas
     variáveis) é <x^4-2*x*y> decomposto como segue em funções
     elementares simétricas:

          (%i1) elem ([3, 7], x^4 - 2*x*y, [x, y]);
          (%o1) 7 (e3 - 7 e2 + 7 (49 - e2)) + 21 e3

                                                   + (- 2 (49 - e2) - 2) e2
          (%i2) ratsimp (%);
                                        2
          (%o2)             28 e3 + 2 e2  - 198 e2 + 2401

     Outras funções para mudanças de base: `comp2ele'.


 -- Function: mon2schur (<L>)
     a lsita <L> representa a função de Schur S_L: temos L = [i_1, i_2,
     ..., i_q], com i_1 <= i_2 <= ... <= i_q.  A função de Schur
     S_[i_1, i_2, ..., i_q] é a menor da matriz infinita h_[i-j], i <=
     1, j <= 1, consistindo das q primeiras linhas e as colunas 1 + i_1,
     +2 + i_2, ..., q + i_q.

     Essa função de Schur pode ser escrita em termos de monômios usando
     `treinat' e `kostka'.  A forma retornada é um polinómio simétrico
     na representação contraída nas variáveis x_1,x_2,\ldots.

          (%i1) mon2schur ([1, 1, 1]);
          (%o1)                       x1 x2 x3
          (%i2) mon2schur ([3]);
                                            2        3
          (%o2)                x1 x2 x3 + x1  x2 + x1
          (%i3) mon2schur ([1, 2]);
                                                2
          (%o3)                  2 x1 x2 x3 + x1  x2

     o qual significa que para 3 variáveis fornece:

             2 x1 x2 x3 + x1^2 x2 + x2^2 x1 + x1^2 x3 + x3^2 x1
              + x2^2 x3 + x3^2 x2
     Outras funções para mudanças de base: `comp2ele'.


 -- Função: multi_elem (<l_elem>, <multi_pc>, <l_var>)
     decompões um polinómio multi-simétrico na forma multi-contraída
     <multi_pc> nos grupos de variáveis contidas na lista de listas
     <l_var> en termos de funções elementares simétricas contidas em
     <l_elem>.

          (%i1) multi_elem ([[2, e1, e2], [2, f1, f2]], a*x + a^2 + x^3, [[x, y], [a, b]]);
                                                            3
          (%o1)         - 2 f2 + f1 (f1 + e1) - 3 e1 e2 + e1
          (%i2) ratsimp (%);
                                   2                       3
          (%o2)         - 2 f2 + f1  + e1 f1 - 3 e1 e2 + e1

     Outras funções para mudanças de base: `comp2ele'.


 -- Função: multi_pui
     é para a função `pui' o que a função `multi_elem' é para a
     função `elem'.

          (%i1) multi_pui ([[2, p1, p2], [2, t1, t2]], a*x + a^2 + x^3, [[x, y], [a, b]]);
                                                      3
                                          3 p1 p2   p1
          (%o1)              t2 + p1 t1 + ------- - ---
                                             2       2


 -- Função: pui (<L>, <sym>, <lvar>)
     decompõe o polinómio simétrico <sym>, nas variáveis na lista
     <lvar>, em termos de funções exponenciais na lista <L>.  Se o
     primeiro elemento de <L> for fornecido, esse primeiro elemento
     será o tamanho do alfabeto, de outra forma o tamanho será o grau
     do polinómio <sym>.  Se valores forem omitidos na lista <L>,
     valores formais do tipo <p1>, <p2> , etc. serão adicionados. O
     polinómio <sym> pode ser fornecido de três diferentes formas:
     contraída (`elem' pode então ser 1, seu valor padrão),
     particionada (`elem' pode ser 3), ou extendida (i.e. o polinómio
     completo, e `elem' pode então ser 2). A função `pui' é usada da
     mesma forma.

          (%i1) pui;
          (%o1)                           1
          (%i2) pui ([3, a, b], u*x*y*z, [x, y, z]);
                                 2
                             a (a  - b) u   (a b - p3) u
          (%o2)              ------------ - ------------
                                  6              3
          (%i3) ratsimp (%);
                                                 3
                                (2 p3 - 3 a b + a ) u
          (%o3)                 ---------------------
                                          6
     Outras funções para mudanças de base: `comp2ele'.


 -- Função: pui2comp (<n>, <lpui>)
     converte a dista das primeiras <n> funções completas (com o
     comprimento em primeiro lugar) em termos de funções exponenciais
     fornecidas na lista <lpui>. se a lista <lpui> for vazia, o
     cardinal é <n>, de outra forma o cardinal será seu primeiro
     elemento (como em `comp2ele' e em `comp2pui').

          (%i1) pui2comp (2, []);
                                                 2
                                          p2 + p1
          (%o1)                   [2, p1, --------]
                                             2
          (%i2) pui2comp (3, [2, a1]);
                                                      2
                                           a1 (p2 + a1 )
                                   2  p3 + ------------- + a1 p2
                            p2 + a1              2
          (%o2)     [2, a1, --------, --------------------------]
                               2                  3
          (%i3) ratsimp (%);
                                      2                     3
                               p2 + a1   2 p3 + 3 a1 p2 + a1
          (%o3)        [2, a1, --------, --------------------]
                                  2               6
     Outras funções para mudanças de base: `comp2ele'.


 -- Função: pui2ele (<n>, <lpui>)
     efectiva a passagem de funções exponenciais para as funções
     elementares simétricas.  Se o sinalizador `pui2ele' for `girard',
     `pui2ele' irá retornar a lista de funções elementares simétricas
     de 1 a <n>, e se o sinalizador for `close', `pui2ele' retornará a
     <n>-ésima função simétrica elementar.

     Outras funções para mudanças de base: `comp2ele'.

 -- Função: puireduc (<n>, <lpui>)
     <lpui> é uma lista cujo primeiro elemento é um inteiro <m>.
     `puireduc' fornece as primeiras <n> funções exponenciais em termos
     das primeiras <m> funções.

          (%i1) puireduc (3, [2]);
                                                   2
                                             p1 (p1  - p2)
          (%o1)          [2, p1, p2, p1 p2 - -------------]
                                                   2
          (%i2) ratsimp (%);
                                                     3
                                         3 p1 p2 - p1
          (%o2)              [2, p1, p2, -------------]
                                               2

 -- Função: schur2comp (<P>, <l_var>)
     <P> é um polinómio nas variáveis da lista <l_var>.  Cada uma
     dessas variáveis represetna uma função simétrica completa.  Na
     lista <l_var> o <i>-ésima função simétrica completa é representada
     através da concatenação da letra `h' com o inteiro <i>: `h<i>'.
     Essa função expressa <P> em termos de funções de Schur.

          (%i1) schur2comp (h1*h2 - h3, [h1, h2, h3]);
          (%o1)                         s
                                         1, 2
          (%i2) schur2comp (a*h3, [h3]);
          (%o2)                         s  a
                                         3

32.1.2 Modificando represetnações
---------------------------------

 -- Função: cont2part (<pc>, <lvar>)
     Retorna o polinómio particionado associado à forma contraída <pc>
     cujas variáveis estão em <lvar>.

          (%i1) pc: 2*a^3*b*x^4*y + x^5;
                                     3    4      5
          (%o1)                   2 a  b x  y + x
          (%i2) cont2part (pc, [x, y]);
                                             3
          (%o2)              [[1, 5, 0], [2 a  b, 4, 1]]

 -- Função: contract (<psym>, <lvar>)
     retorna uma forma contraída (i.e. um monômio de grupo ssimétrico)
     do polinómio <psym> nas variáveis contidas na lista <lvar>.  A
     função `explose' executa a operação inversa.  A função `tcontract'
     testa a simétria do polinómio.

          (%i1) psym: explose (2*a^3*b*x^4*y, [x, y, z]);
                   3      4      3      4      3    4        3    4
          (%o1) 2 a  b y z  + 2 a  b x z  + 2 a  b y  z + 2 a  b x  z

                                                     3      4      3    4
                                                + 2 a  b x y  + 2 a  b x  y
          (%i2) contract (psym, [x, y, z]);
                                        3    4
          (%o2)                      2 a  b x  y

 -- Função: explose (<pc>, <lvar>)
     retorna o polinómio simétrico associado com a forma contraída
     <pc>. A lista <lvar> conté as variáveis.

          (%i1) explose (a*x + 1, [x, y, z]);
          (%o1)                  a z + a y + a x + 1

 -- Função: part2cont (<ppart>, <lvar>)
     vai da forma particionada para a forma contraída de um polinómio
     simétrico.  A forma contraída é convertida com as variáveis em
     <lvar>.

          (%i1) part2cont ([[2*a^3*b, 4, 1]], [x, y]);
                                        3    4
          (%o1)                      2 a  b x  y

 -- Função: partpol (<psym>, <lvar>)
     <psym> é um polinómio simétrico nas variáveis da lista <lvar>.
     Essa função retorna sua represetnação particionada.

          (%i1) partpol (-a*(x + y) + 3*x*y, [x, y]);
          (%o1)               [[3, 1, 1], [- a, 1, 0]]


 -- Função: tcontract (<pol>, <lvar>)
     testa se o polinómio <pol> é simétrico nas variáveis da lista
     <lvar>.  Se for, `tcontract' retorna uma representação contraída
     como o faz a função `contract'.


 -- Função: tpartpol (<pol>, <lvar>)
     testa se o polinómio <pol> é simétrico nas variáveis da lista
     <lvar>.  Se for, `tpartpol' retorna sua represetnação particionada
     como o faz a função `partpol'.


 -- Função: direct ([<p_1>, ..., <p_n>], <y>, <f>, [<lvar_1>, ...,
          <lvar_n>])
     calcula a imagem directa (see M. Giusti, D. Lazard et A. Valibouze,
     ISSAC 1988, Rome) associada à função <f>, na lista de variáveis
     <lvar_1>, ..., <lvar_n>, e nos polinómios <p_1>, ..., <p_n> na
     variável <y>.  A quantidade de argumetnos que a funçào <f> pode
     receber é importante para o cálculo.  Dessa forma, se a expressão
     para <f> não depende de alguma variável, é inútil incluir essa
     variável, e não incluir essa variável irá também reduzir
     consideravelmente o montante cálculos efetuados.

          (%i1) direct ([z^2  - e1* z + e2, z^2  - f1* z + f2],
                        z, b*v + a*u, [[u, v], [a, b]]);
                 2
          (%o1) y  - e1 f1 y

                                           2            2             2   2
                            - 4 e2 f2 - (e1  - 2 e2) (f1  - 2 f2) + e1  f1
                          + -----------------------------------------------
                                                   2
          (%i2) ratsimp (%);
                        2                2                   2
          (%o2)        y  - e1 f1 y + (e1  - 4 e2) f2 + e2 f1
          (%i3) ratsimp (direct ([z^3-e1*z^2+e2*z-e3,z^2  - f1* z + f2],
                        z, b*v + a*u, [[u, v], [a, b]]));
                 6            5         2                        2    2   4
          (%o3) y  - 2 e1 f1 y  + ((2 e1  - 6 e2) f2 + (2 e2 + e1 ) f1 ) y

                                    3                               3   3
           + ((9 e3 + 5 e1 e2 - 2 e1 ) f1 f2 + (- 2 e3 - 2 e1 e2) f1 ) y

                   2       2        4    2
           + ((9 e2  - 6 e1  e2 + e1 ) f2

                              2       2       2                   2    4
           + (- 9 e1 e3 - 6 e2  + 3 e1  e2) f1  f2 + (2 e1 e3 + e2 ) f1 )

            2          2                      2     3          2
           y  + (((9 e1  - 27 e2) e3 + 3 e1 e2  - e1  e2) f1 f2

                           2            2    3                5
           + ((15 e2 - 2 e1 ) e3 - e1 e2 ) f1  f2 - 2 e2 e3 f1 ) y

                     2                   3           3     2   2    3
           + (- 27 e3  + (18 e1 e2 - 4 e1 ) e3 - 4 e2  + e1  e2 ) f2

                   2      3                   3    2   2
           + (27 e3  + (e1  - 9 e1 e2) e3 + e2 ) f1  f2

                             2    4        2   6
           + (e1 e2 e3 - 9 e3 ) f1  f2 + e3  f1

     Encontrando um polinómio cujas raízes são somatórios a+u onde a é
     uma raíz de z^2 - e_1 z + e_2 e u é uma raíz de z^2 - +f_1 z + f_2.

          (%i1) ratsimp (direct ([z^2 - e1* z + e2, z^2 - f1* z + f2],
                                    z, a + u, [[u], [a]]));
                 4                    3             2
          (%o1) y  + (- 2 f1 - 2 e1) y  + (2 f2 + f1  + 3 e1 f1 + 2 e2

               2   2                              2               2
           + e1 ) y  + ((- 2 f1 - 2 e1) f2 - e1 f1  + (- 2 e2 - e1 ) f1

                            2                     2            2
           - 2 e1 e2) y + f2  + (e1 f1 - 2 e2 + e1 ) f2 + e2 f1  + e1 e2 f1

               2
           + e2

     `direct' aceita dois sinalizadores: `elementaires' (elementares) e
     `puissances' (exponenciais - valor padrão) que permitem a
     decomposição de polinómios simétricos que aparecerem nesses
     cálculos em funções simétricas elementares ou em funções
     exponenciais respectivamente.

     Funções de `sym' utilizadas nesta função :

     `multi_orbit' (portanto `orbit'), `pui_direct', `multi_elem'
     (portanto `elem'), `multi_pui' (portanto `pui'), `pui2ele',
     `ele2pui' (se o sinalizador `direct' for escolhido para
     `puissances').


 -- Função: multi_orbit (<P>, [<lvar_1>, <lvar_2>,..., <lvar_p>])
     <P> é um polinómio no conjunto de variáveis contidas nas lista
     <lvar_1>, <lvar_2>, ..., <lvar_p>. Essa função retorna a órbita do
     polinómio <P> sob a ação do produto dos grupos simétricos dos
     conjuntos de variáveis represetnadas nas <p> listas.

          (%i1) multi_orbit (a*x + b*y, [[x, y], [a, b]]);
          (%o1)                [b y + a x, a y + b x]
          (%i2) multi_orbit (x + y + 2*a, [[x, y], [a, b, c]]);
          (%o2)        [y + x + 2 c, y + x + 2 b, y + x + 2 a]
     Veja também: `orbit' para a ação de um grupo simétrico simples.

 -- Função: multsym (<ppart_1>, <ppart_2>, <n>)
     retorna oproduto de dois polinómios simétricos em <n> varieis
     trabalhando somente módulo a ação do grupo simétrico de ordem <n>.
     O polinómios estão em sua forma particionada.

     Dados 2 polinómio simétricos em <x>, <y>:  `3*(x + y) + 2*x*y' e
     `5*(x^2 + y^2)' cujas formas particionadas são `[[3, 1], [2, 1,
     1]]' e `[[5, 2]]', seu produto irá ser

          (%i1) multsym ([[3, 1], [2, 1, 1]], [[5, 2]], 2);
          (%o1)         [[10, 3, 1], [15, 3, 0], [15, 2, 1]]
     isso é `10*(x^3*y + y^3*x) + 15*(x^2*y + y^2*x) + 15*(x^3 + y^3)'.

     Funções para mudar as representacões de um polinómio simétrico:

     `contract', `cont2part', `explose', `part2cont', `partpol',
     `tcontract', `tpartpol'.

 -- Função: orbit (<P>, <lvar>)
     calcula a órbita do polinómio <P> nas variáveis na lista <lvar>
     sob a ação do grupo simétrico do conjunto das variáveis na lista
     <lvar>.

          (%i1) orbit (a*x + b*y, [x, y]);
          (%o1)                [a y + b x, b y + a x]
          (%i2) orbit (2*x + x^2, [x, y]);
                                  2         2
          (%o2)                 [y  + 2 y, x  + 2 x]
     Veja também `multi_orbit' para a ação de um produto de grupos
     simétricos sobre um polinómio.

 -- Função: pui_direct (<orbite>, [<lvar_1>, ..., <lvar_n>], [<d_1>,
          <d_2>, ..., <d_n>])
     Tomemos <f> para ser um polinómio em <n> blocos de variáveis
     <lvar_1>, ..., <lvar_n>.  Façamos <c_i> ser o n;umero de variáveis
     em <lvar_i>, e <SC> ser o produto de <n> grupos simétricos de grau
     <c_1>, ..., <c_n>. Essas ações dos grupos naturalmente sobre <f>.
     A lista <orbite> é a órbita, denotada `<SC>(<f>)', da função <f>
     sob a ação de <SC>. (Essa lista pode ser obtida através da
     função `multi_orbit'.)  Os <di> são inteiros de forma que c_1 \le
     d_1, c_2 \le d_2, \ldots, c_n \le d_n.

     Tomemos <SD> para ser o produto dos grupos simétricos S_[d_1] x
     S_[d_2] x ... x S_[d_n].  A função `pui_direct' retorna as
     primeiras <n> funções exponenciais de `<SD>(<f>)' deduzidas das
     funções exponenciais de `<SC>(<f>)', onde <n> é o tamanho de
     `<SD>(<f>)'.

     O resultado está na multi-forma contraída com relação a <SD>, i.e.
     somente um elemento é mantido por órbita, sob a ação de <SD>.

          (%i1) l: [[x, y], [a, b]];
          (%o1)                   [[x, y], [a, b]]
          (%i2) pui_direct (multi_orbit (a*x + b*y, l), l, [2, 2]);
                                                 2  2
          (%o2)               [a x, 4 a b x y + a  x ]
          (%i3) pui_direct (multi_orbit (a*x + b*y, l), l, [3, 2]);
                                       2  2     2    2        3  3
          (%o3) [2 a x, 4 a b x y + 2 a  x , 3 a  b x  y + 2 a  x ,

              2  2  2  2      3    3        4  4
          12 a  b  x  y  + 4 a  b x  y + 2 a  x ,

              3  2  3  2      4    4        5  5
          10 a  b  x  y  + 5 a  b x  y + 2 a  x ,

              3  3  3  3       4  2  4  2      5    5        6  6
          40 a  b  x  y  + 15 a  b  x  y  + 6 a  b x  y + 2 a  x ]
          (%i4) pui_direct ([y + x + 2*c, y + x + 2*b, y + x + 2*a], [[x, y], [a, b, c]], [2, 3]);
                                       2              2
          (%o4) [3 x + 2 a, 6 x y + 3 x  + 4 a x + 4 a ,

                           2                   3        2       2        3
                        9 x  y + 12 a x y + 3 x  + 6 a x  + 12 a  x + 8 a ]


32.1.3 Partições
----------------

 -- Função: kostka (<part_1>, <part_2>)
     escrita por P. Esperet, calcula o número de Kostka da partição
     <part_1> e <part_2>.

          (%i1) kostka ([3, 3, 3], [2, 2, 2, 1, 1, 1]);
          (%o1)                           6

 -- Função: lgtreillis (<n>, <m>)
     retorna a lista de partições de peso <n> e comprimento <m>.

          (%i1) lgtreillis (4, 2);
          (%o1)                   [[3, 1], [2, 2]]
     Veja também: `ltreillis', `treillis' e `treinat'.

 -- Função: ltreillis (<n>, <m>)
     retorna a lista de partições de peso <n> e comprimento menor que ou
     igual a <m>.

          (%i1) ltreillis (4, 2);
          (%o1)               [[4, 0], [3, 1], [2, 2]]

     Veja também: `lgtreillis', `treillis' e `treinat'.

 -- Função: treillis (<n>)
     retorna todas as partições de peso <n>.

          (%i1) treillis (4);
          (%o1)    [[4], [3, 1], [2, 2], [2, 1, 1], [1, 1, 1, 1]]

     Veja também: `lgtreillis', `ltreillis' e `treinat'.


 -- Função: treinat (<part>)
     retorna a lista de partições inferiores à partiçào <part> com
     relação à ordem natural.

          (%i1) treinat ([5]);
          (%o1)                         [[5]]
          (%i2) treinat ([1, 1, 1, 1, 1]);
          (%o2) [[5], [4, 1], [3, 2], [3, 1, 1], [2, 2, 1], [2, 1, 1, 1],

                                                           [1, 1, 1, 1, 1]]
          (%i3) treinat ([3, 2]);
          (%o3)                 [[5], [4, 1], [3, 2]]

     Outras funções de mudança de representação :

     Veja também: `lgtreillis', `ltreillis' e `treillis'.


32.1.4 Polinómios e suas raízes
-------------------------------

 -- Função: ele2polynome (<L>, <z>)
     retorna o polinómio em <z> de forma que as funções elementares
     simétricas de suas raízes estejam na lista `<L> = [<n>, <e_1>,
     ..., <e_n>]', onde <n> é o grau dos polinómios e <e_i> é a
     <i>-ésima função simétrica elementar.

          (%i1) ele2polynome ([2, e1, e2], z);
                                    2
          (%o1)                    z  - e1 z + e2
          (%i2) polynome2ele (x^7 - 14*x^5 + 56*x^3  - 56*x + 22, x);
          (%o2)          [7, 0, - 14, 0, 56, 0, - 56, - 22]
          (%i3) ele2polynome ([7, 0, -14, 0, 56, 0, -56, -22], x);
                            7       5       3
          (%o3)            x  - 14 x  + 56 x  - 56 x + 22
     o inverso: `polynome2ele (<P>, <z>)'.

     Veja também: `polynome2ele', `pui2polynome'.


 -- Função: polynome2ele (<P>, <x>)
     fornece a lista `<l> = [<n>, <e_1>, ..., <e_n>]' onde <n> é o grau
     do polinómio <P> na variável <x> e <e_i> é a <i>-ésima função
     simétrica elementar das raízes de <P>.

          (%i1) polynome2ele (x^7 - 14*x^5 + 56*x^3 - 56*x + 22, x);
          (%o1)          [7, 0, - 14, 0, 56, 0, - 56, - 22]
          (%i2) ele2polynome ([7, 0, -14, 0, 56, 0, -56, -22], x);
                            7       5       3
          (%o2)            x  - 14 x  + 56 x  - 56 x + 22
     A inversa: `ele2polynome (<l>, <x>)'


 -- Função: prodrac (<L>, <k>)
     <L> é uma lista contendo as funções simétricas elementares sobre
     um conjunto <A>. `prodrac' retorna o polinómio cujas raízes são os
     produtos <k> por <k> dos elementos de <A>.

     Veja também `somrac'.

 -- Função: pui2polynome (<x>, <lpui>)
     calcula o polinómio em <x> cujas funções exponenciais das raízes
     são dadas na lista <lpui>.

          (%i1) pui;
          (%o1)                           1
          (%i2) kill(labels);
          (%o0)                         done
          (%i1) polynome2ele (x^3 - 4*x^2 + 5*x - 1, x);
          (%o1)                     [3, 4, 5, 1]
          (%i2) ele2pui (3, %);
          (%o2)                     [3, 4, 6, 7]
          (%i3) pui2polynome (x, %);
                                  3      2
          (%o3)                  x  - 4 x  + 5 x - 1
     Veja também: `polynome2ele', `ele2polynome'.

 -- Função: somrac (<L>, <k>)
     A lista <L> contains função simétrica elementars de um polynomial
     <P> . The function computes the polinómio whose roots are the <k>
     by <k> distinct sums of the roots of <P>.

     Also see `prodrac'.

32.1.5 Resolvents
-----------------

 -- Função: resolvante (<P>, <x>, <f>, [<x_1>,..., <x_d>])
     calculates the resolvent of the polinómio <P> in <x> of degree <n>
     >= <d> by the function <f> expressed nas variáveis <x_1>, ...,
     <x_d>.  For efficiency of computation it is important to not
     include in the list `[<x_1>, ..., <x_d>]' variables which do not
     appear in the transformation function <f>.

     Para melhorar a eficiência do cálculo se pode escolher
     sinalizadores em `resolvante' de fora a usar os algoritmos
     apropriados:

     Se a função <f> for unitária :
        * um polinómio em uma variável simples,

        *   linear ,

        *   alternado,

        *   um somatório,

        *   simétrico,

        *   um produto,

        * a função da resolvente de Cayley (utilisável de grau 5 em
          diante)

               (x1*x2 + x2*x3 + x3*x4 + x4*x5 + x5*x1 -
                    (x1*x3 + x3*x5 + x5*x2 + x2*x4 + x4*x1))^2

          geral,
     o sinalizador da `resolvante' poderá ser respectivamente :
        *   unitaire,

        *   lineaire,

        *   alternee,

        *   somme,

        *   produit,

        *   cayley,

        *   generale.

          (%i1) resolvante: unitaire$
          (%i2) resolvante (x^7 - 14*x^5 + 56*x^3 - 56*x + 22, x, x^3 - 1, [x]);

          " resolvante unitaire " [7, 0, 28, 0, 168, 0, 1120, - 154, 7840, - 2772, 56448, - 33880,

          413952, - 352352, 3076668, - 3363360, 23114112, - 30494464,

          175230832, - 267412992, 1338886528, - 2292126760]
            3       6      3       9      6      3
          [x  - 1, x  - 2 x  + 1, x  - 3 x  + 3 x  - 1,

           12      9      6      3       15      12       9       6      3
          x   - 4 x  + 6 x  - 4 x  + 1, x   - 5 x   + 10 x  - 10 x  + 5 x

                 18      15       12       9       6      3
           - 1, x   - 6 x   + 15 x   - 20 x  + 15 x  - 6 x  + 1,

           21      18       15       12       9       6      3
          x   - 7 x   + 21 x   - 35 x   + 35 x  - 21 x  + 7 x  - 1]
          [- 7, 1127, - 6139, 431767, - 5472047, 201692519, - 3603982011]
                 7      6        5         4          3           2
          (%o2) y  + 7 y  - 539 y  - 1841 y  + 51443 y  + 315133 y

                                                        + 376999 y + 125253
          (%i3) resolvante: lineaire$
          (%i4) resolvante (x^4 - 1, x, x1 + 2*x2 + 3*x3, [x1, x2, x3]);

          " resolvante lineaire "
                 24       20         16            12             8
          (%o4) y   + 80 y   + 7520 y   + 1107200 y   + 49475840 y

                                                              4
                                                 + 344489984 y  + 655360000
          (%i5) resolvante: general$
          (%i6) resolvante (x^4 - 1, x, x1 + 2*x2 + 3*x3, [x1, x2, x3]);

          " resolvante generale "
                 24       20         16            12             8
          (%o6) y   + 80 y   + 7520 y   + 1107200 y   + 49475840 y

                                                              4
                                                 + 344489984 y  + 655360000
          (%i7) resolvante (x^4 - 1, x, x1 + 2*x2 + 3*x3, [x1, x2, x3, x4]);

          " resolvante generale "
                 24       20         16            12             8
          (%o7) y   + 80 y   + 7520 y   + 1107200 y   + 49475840 y

                                                              4
                                                 + 344489984 y  + 655360000
          (%i8) direct ([x^4 - 1], x, x1 + 2*x2 + 3*x3, [[x1, x2, x3]]);
                 24       20         16            12             8
          (%o8) y   + 80 y   + 7520 y   + 1107200 y   + 49475840 y

                                                              4
                                                 + 344489984 y  + 655360000
          (%i9) resolvante :lineaire$
          (%i10) resolvante (x^4 - 1, x, x1 + x2 + x3, [x1, x2, x3]);

          " resolvante lineaire "
                                        4
          (%o10)                       y  - 1
          (%i11) resolvante: symetrique$
          (%i12) resolvante (x^4 - 1, x, x1 + x2 + x3, [x1, x2, x3]);

          " resolvante symetrique "
                                        4
          (%o12)                       y  - 1
          (%i13) resolvante (x^4 + x + 1, x, x1 - x2, [x1, x2]);

          " resolvante symetrique "
                                     6      2
          (%o13)                    y  - 4 y  - 1
          (%i14) resolvante: alternee$
          (%i15) resolvante (x^4 + x + 1, x, x1 - x2, [x1, x2]);

          " resolvante alternee "
                      12      8       6        4        2
          (%o15)     y   + 8 y  + 26 y  - 112 y  + 216 y  + 229
          (%i16) resolvante: produit$
          (%i17) resolvante (x^7 - 7*x + 3, x, x1*x2*x3, [x1, x2, x3]);

          " resolvante produit "
                  35      33         29        28         27        26
          (%o17) y   - 7 y   - 1029 y   + 135 y   + 7203 y   - 756 y

                   24           23          22            21           20
           + 1323 y   + 352947 y   - 46305 y   - 2463339 y   + 324135 y

                    19           18             17              15
           - 30618 y   - 453789 y   - 40246444 y   + 282225202 y

                       14              12             11            10
           - 44274492 y   + 155098503 y   + 12252303 y   + 2893401 y

                        9            8            7             6
           - 171532242 y  + 6751269 y  + 2657205 y  - 94517766 y

                      5             3
           - 3720087 y  + 26040609 y  + 14348907
          (%i18) resolvante: symetrique$
          (%i19) resolvante (x^7 - 7*x + 3, x, x1*x2*x3, [x1, x2, x3]);

          " resolvante symetrique "
                  35      33         29        28         27        26
          (%o19) y   - 7 y   - 1029 y   + 135 y   + 7203 y   - 756 y

                   24           23          22            21           20
           + 1323 y   + 352947 y   - 46305 y   - 2463339 y   + 324135 y

                    19           18             17              15
           - 30618 y   - 453789 y   - 40246444 y   + 282225202 y

                       14              12             11            10
           - 44274492 y   + 155098503 y   + 12252303 y   + 2893401 y

                        9            8            7             6
           - 171532242 y  + 6751269 y  + 2657205 y  - 94517766 y

                      5             3
           - 3720087 y  + 26040609 y  + 14348907
          (%i20) resolvante: cayley$
          (%i21) resolvante (x^5 - 4*x^2 + x + 1, x, a, []);

          " resolvente de Cayley "
                  6       5         4          3            2
          (%o21) x  - 40 x  + 4080 x  - 92928 x  + 3772160 x  + 37880832 x

                                                                 + 93392896

     Para a resolvente de Cayley, os 2 últimos argumentos são neutros e
     o polinómio fornecido na entrada deve ser necessáriamente de grau
     5.

     Veja também :

     `resolvante_bipartite', `resolvante_produit_sym',
     `resolvante_unitaire', `resolvante_alternee1', `resolvante_klein',
     `resolvante_klein3', `resolvante_vierer', `resolvante_diedrale'.


 -- Função: resolvante_alternee1 (<P>, <x>)
     calcula a transformação de `<P>(<x>)' de grau <n> pela função
     $\prod_{1\leq i<j\leq n-1} (x_i-x_j)$.  product(x_i - x_j, 1 <= i
     < j <= n - 1).

     Veja também :

     `resolvante_produit_sym', `resolvante_unitaire', `resolvante' ,
     `resolvante_klein', `resolvante_klein3', `resolvante_vierer',
     `resolvante_diedrale', `resolvante_bipartite'.


 -- Função: resolvante_bipartite (<P>, <x>)
     calcula a trasformação de `<P>(<x>)' de mesmo grau <n> através da
     função x_1 x_2 ... x_[n/2] + x_[n/2 + 1] ... x_n.

     Veja também :

     `resolvante_produit_sym', `resolvante_unitaire', `resolvante' ,
     `resolvante_klein', `resolvante_klein3', `resolvante_vierer',
     `resolvante_diedrale', `resolvante_alternee1'.

          (%i1) resolvante_bipartite (x^6 + 108, x);
                        10        8           6             4
          (%o1)        y   - 972 y  + 314928 y  - 34012224 y

     Veja também :

     `resolvante_produit_sym', `resolvante_unitaire', `resolvante',
     `resolvante_klein', `resolvante_klein3', `resolvante_vierer',
     `resolvante_diedrale', `resolvante_alternee1'.


 -- Função: resolvante_diedrale (<P>, <x>)
     +calculates the transformation of `<P>(<x>)' by the function
     +`<x_1> <x_2> + <x_3> <x_4>'.

          (%i1) resolvante_diedrale (x^5 - 3*x^4 + 1, x);
                 15       12       11       10        9         8         7
          (%o1) x   - 21 x   - 81 x   - 21 x   + 207 x  + 1134 x  + 2331 x

                  6         5          4          3          2
           - 945 x  - 4970 x  - 18333 x  - 29079 x  - 20745 x  - 25326 x

           - 697

     Veja também :

     `resolvante_produit_sym', `resolvante_unitaire',
     `resolvante_alternee1', `resolvante_klein', `resolvante_klein3',
     `resolvante_vierer', `resolvante'.


 -- Função: resolvante_klein (<P>, <x>)
     +calculates the transformation of `<P>(<x>)' by the function
     +`<x_1> <x_2> <x_4> + <x_4>'.

     Veja também :

     `resolvante_produit_sym', `resolvante_unitaire',
     `resolvante_alternee1', `resolvante', `resolvante_klein3',
     `resolvante_vierer', `resolvante_diedrale'.


 -- Função: resolvante_klein3 (<P>, <x>)
     calcula a transformação de `<P>(<x>)' através da função `<x_1>
     <x_2> <x_4> + <x_4>'.

     Veja também :

     `resolvante_produit_sym', `resolvante_unitaire',
     `resolvante_alternee1', `resolvante_klein', `resolvante',
     `resolvante_vierer', `resolvante_diedrale'.


 -- Função: resolvante_produit_sym (<P>, <x>)
     calcula a lista de todas as resolventes de produto do polinómio
     `<P>(<x>)'.

          (%i1) resolvante_produit_sym (x^5 + 3*x^4 + 2*x - 1, x);
                  5      4             10      8       7       6       5
          (%o1) [y  + 3 y  + 2 y - 1, y   - 2 y  - 21 y  - 31 y  - 14 y

              4       3      2       10      8       7    6       5       4
           - y  + 14 y  + 3 y  + 1, y   + 3 y  + 14 y  - y  - 14 y  - 31 y

                 3      2       5      4
           - 21 y  - 2 y  + 1, y  - 2 y  - 3 y - 1, y - 1]
          (%i2) resolvante: produit$
          (%i3) resolvante (x^5 + 3*x^4 + 2*x - 1, x, a*b*c, [a, b, c]);

          " resolvente produto "
                 10      8       7    6        5       4       3     2
          (%o3) y   + 3 y  + 14 y  - y  - 14 y  - 31 y  - 21 y  - 2 y  + 1

     Veja também :

     `resolvante', `resolvante_unitaire', `resolvante_alternee1',
     `resolvante_klein', `resolvante_klein3', `resolvante_vierer',
     `resolvante_diedrale'.


 -- Função: resolvante_unitaire (<P>, <Q>, <x>)
     +computes the resolvent of the polinómio `<P>(<x>)' by the
     +polynomial `<Q>(<x>)'.

     Veja também :

     `resolvante_produit_sym', `resolvante', `resolvante_alternee1',
     `resolvante_klein', `resolvante_klein3', `resolvante_vierer',
     `resolvante_diedrale'.


 -- Função: resolvante_vierer (<P>, <x>)
     calcula a transformação de `<P>(<x>)' pela função `<x_1> <x_2> -
     <x_3> <x_4>'.

     Veja também :

     `resolvante_produit_sym', `resolvante_unitaire',
     `resolvante_alternee1', `resolvante_klein', `resolvante_klein3',
     `resolvante', `resolvante_diedrale'.


 -- Função: multinomial (<r>, <part>)
     onde <r> é o peso da partição <part>.  Essa função retorna o
     coefinciente multinomial associado: se as partes de <part> forem
     <i_1>, <i_2>, ..., <i_k>, o resultado é `<r>!/(<i_1>! <i_2>! ...
     <i_k>!)'.

 -- Função: permut (<L>)
     retorna a lista de permutações da lista <L>.

 -- Função: tcontract (<pol>, <lvar>)
     testa se o polinómio <pol> é simétrico nas variáveis contidas na
     lista <lvar>. se for é rtornado uma forma contraída da forma
     retornada pela função `contract'.

     Outras funções de mudança de representação :

     `contract', `cont2part', `explose', `part2cont', `partpol',
     `tpartpol'.


 -- Função: tpartpol (<pol>, <lvar>)
     testa se o polinómio <pol> é simétrico nas variáveis contidas na
     lista <lvar>. Se for simétrico `tpartpol' produz a forma
     particionada como a função `partpol'.

     Outras funções de mudança de representação :

     `contract', `cont2part', `explose', `part2cont', `partpol',
     `tcontract'.


 -- Função: treillis (<n>)
     retorna todas as partições de peso <n>.

          (%i1) treillis (4);
          (%o1)    [[4], [3, 1], [2, 2], [2, 1, 1], [1, 1, 1, 1]]

     Veja também : `lgtreillis', `ltreillis' e `treinat'.


 -- Função: treinat (<part>)
     retorna a lista das partições inferiores à partição <part> pela
     ordem natural.

          (%i1) treinat ([5]);
          (%o1)                         [[5]]
          (%i2) treinat ([1, 1, 1, 1, 1]);
          (%o2) [[5], [4, 1], [3, 2], [3, 1, 1], [2, 2, 1], [2, 1, 1, 1],

                                                           [1, 1, 1, 1, 1]]
          (%i3) treinat ([3, 2]);
          (%o3)                 [[5], [4, 1], [3, 2]]

     Veja também : `lgtreillis', `ltreillis' e `treillis'.



File: maxima.info,  Node: Grupos,  Next: Ambiente em Tempo de Execução,  Prev: Simetrias,  Up: Top

33 Grupos
*********

* Menu:

* Definições para Grupos::


File: maxima.info,  Node: Definições para Grupos,  Prev: Grupos,  Up: Grupos

33.1 Definições para Grupos
===========================

 -- Função: todd_coxeter (<relação>, <subgroupo>)
 -- Função: todd_coxeter (<relação>)
     Acha a ordem de G/H onde G é o módulo do Grupo Livre <relação>, e
     H é o subgroupo de G gerado por <subgroupo>.  <subgroupo> é um
     argumento opcional, cujo valor padrão é [].  Em fazendo isso a
     função produz uma tabela de multiplicação à direita de G sobre
     G/H, onde os co-conjuntos são enumerados [H,Hg2,Hg3,...].  Isso
     pode ser visto internamente no `todd_coxeter_state'.

     Exemplo:

          (%i1) symet(n):=create_list(
                  if (j - i) = 1 then (p(i,j))^^3 else
                      if (not i = j) then (p(i,j))^^2 else
                          p(i,i) , j, 1, n-1, i, 1, j);
                                                                 <3>
          (%o1) symet(n) := create_list(if j - i = 1 then p(i, j)

                                          <2>
           else (if not i = j then p(i, j)    else p(i, i)), j, 1, n - 1,

          i, 1, j)
          (%i2) p(i,j) := concat(x,i).concat(x,j);
          (%o2)        p(i, j) := concat(x, i) . concat(x, j)
          (%i3) symet(5);
                   <2>           <3>    <2>           <2>           <3>
          (%o3) [x1   , (x1 . x2)   , x2   , (x1 . x3)   , (x2 . x3)   ,

                      <2>           <2>           <2>           <3>    <2>
                    x3   , (x1 . x4)   , (x2 . x4)   , (x3 . x4)   , x4   ]
          (%i4) todd_coxeter(%o3);

          Rows tried 426
          (%o4)                          120
          (%i5) todd_coxeter(%o3,[x1]);

          Rows tried 213
          (%o5)                          60
          (%i6) todd_coxeter(%o3,[x1,x2]);

          Rows tried 71
          (%o6)                          20



File: maxima.info,  Node: Ambiente em Tempo de Execução,  Next: Opções Diversas,  Prev: Grupos,  Up: Top

34 Ambiente em Tempo de Execução
********************************

* Menu:

* Introdução a Ambiente em Tempo de Execução::
* Interrupções::
* Definições para Ambiente em Tempo de Execução::


File: maxima.info,  Node: Introdução a Ambiente em Tempo de Execução,  Next: Interrupções,  Prev: Ambiente em Tempo de Execução,  Up: Ambiente em Tempo de Execução

34.1 Introdução a Ambiente em Tempo de Execução
===============================================

`maxima-init.mac' é um ficheiro que é chamado automaticamente quando o
Maxima inicia.  Pode usar `maxima-init.mac' para personalizar o seu
ambiente no Maxima.  `maxima-init.mac', se existir, é tipicamente
colocado no directório chamado por `maxima_userdir', embora possa estar
em qualquer outro directório procurado pela função `file_search'.

   Aqui está um exemplo do ficheiro `maxima-init.mac':

     setup_autoload ("specfun.mac", ultraspherical, assoc_legendre_p);
     showtime:all;

   Nesse Exemplo, `setup_autoload' diz ao Maxima para chamar o ficheiro
especificado (`specfun.mac') se qualquer das funções (`ultraspherical',
`assoc_legendre_p') forem chamadas sem estarem definidas.  Dessa forma,
não precisa de se lembrar de chamar o ficheiro antes das funções.

   A declaração `showtime: all' diz ao Maxima para activar a opção
`showtime'.  O ficheiro `maxima-init.mac' pode conter quaisquer outras
atribuições ou outras declarações do Maxima.


File: maxima.info,  Node: Interrupções,  Next: Definições para Ambiente em Tempo de Execução,  Prev: Introdução a Ambiente em Tempo de Execução,  Up: Ambiente em Tempo de Execução

34.2 Interrupções
=================

O utilizador pode parar uma computação que consome muito tempo com o
caractere ^C (control-C).  A ação padrão é parar a computação e mostrar
outra linha de comando do utilizador.  Nesse caso, não é possível
continuar a computação interrompida.

   Se a variável `*debugger-hook*' é escolhida para `nil', através do
comando

     :lisp (setq *debugger-hook* nil)

então na ocasião do recebimento do ^C, Maxima iniciará o depurador
Lisp, e o utilizador pode usar o depurador para inspecionar o ambiente
Lisp.  A computação interrompida pode ser retomada através do comando
`continue' no depurador Lisp.  O método de retorno para ao Maxima
partindo do depurador Lisp (outro como executando a computação para
complementação) é diferente para cada versão do Lisp.

   Em sistemas Unix, o caratere ^Z (control-Z) faz com que Maxima pare
tudo e aguarde em segundo plano, e o controle é retornado para a linha
de comando do shell.  O comando `fg' faz com que o Maxima retorne ao
primeiro plano e continue a partir do ponto no qual foi interrompido.


File: maxima.info,  Node: Definições para Ambiente em Tempo de Execução,  Prev: Interrupções,  Up: Ambiente em Tempo de Execução

34.3 Definições para Ambiente em Tempo de Execução
==================================================

 -- Declaração: feature
     Maxima compreende dois tipos distintos de recurso, recursos do
     sistema e recursos aplicados a expressões matemáticas.  Veja
     Também `status' para informações sobre recursos do sistema.  Veja
     Também `features' e `featurep' para informações sobre recursos
     matemáticos.

     `feature' por si mesmo não é o nome de uma função ou variável.


 -- Função: featurep (<a>, <f>)
     Tenta determinar se o objecto <a> tem o recurso <f> na base dos
     factos dentro base de dados corrente.  Se possue, é retornado
     `true', de outra forma é retornado `false'.

     Note que `featurep' retorna `false' quando nem <f> nem a
     negação de <f> puderem ser estabelecidas.

     `featurep' avalia seus argumentos.

     Veja também `declare' e `features'.

          (%i1) declare (j, even)$
          (%i2) featurep (j, integer);
          (%o2)                           true


 -- Variável de sistema: maxima_tempdir
     `maxima_tempdir' nomeia o directório no qual Maxima cria alguns
     ficheiros temporários.  Em particular, ficheiros temporários para
     impressão são criados no `maxima_tempdir'.

     O valor inicial de `maxima_tempdir' é o directório do utilizador,
     se o maxima puder localizá-lo; de outra forma Maxima supõe um
     directório adequado.

     A `maxima_tempdir' pode ser atribuído uma sequência de caracteres
     que corresponde a um directório.


 -- Variável de sistema: maxima_userdir
     `maxima_userdir' nomeia um directório no qual Maxima espera
     encontrar seus próprios ficheiros e os do ficheiros do Lisp.
     (Maxima procura em alguns outros directórios também;
     `file_search_maxima' e `file_search_lisp' possuem a lista
     completa.)

     O valor inicial de `maxima_userdir' é um subdirectório do
     directório do utilizador, se Maxima puder localizá-lo; de outra
     forma Maxima supõe um directório adequado.

     A `maxima_userdir' pode ser atribuído uma sequência de caracteres
     que corresponde a um directório.  Todavia, fazendo uma
     atribuição a `maxima_userdir' não muda automaticamente o valor de
     `file_search_maxima' e de `file_search_lisp'; Essas variáveis
     devem ser modificadas separadamente.


 -- Função: room ()
 -- Função: room (true)
 -- Função: room (false)
     Mostra uma descrição do estado de armazenamento e gerenciamento de
     pilha no Maxima. `room' chama a função Lisp de mesmo nome.

        * `room ()' mostra uma descrição moderada.

        * `room (true)' mostra uma descrição detalhada.

        * `room (false)' mostra uma descrição resumida.


 -- Função: status (feature)
 -- Função: status (feature, <recurso_ativo>)
 -- Função: status (status)
     Retorna informações sobre a presença ou ausência de certos
     recursos dependentes do sistema operacional.

        * `status (feature)' retorna uma lista dos recursos do sistema.
          Inclui a versão do Lisp, tipo de sistema operacional, etc.  A
          lista pode variar de um tipo de Lisp para outro.

        * `status (feature, <recurso_ativo>)' retorna `true' se
          <recurso_ativo> está na lista de ítens retornada através de
          `status (feature)' e `false' de outra forma.  `status' não
          avalia o argumento <recurso_ativo>.  O operador
          apóstrofo-apóstrofo, `''', evita a avaliação.  Um recurso
          cujo nome contém um caractere especial, tal como um hífem,
          deve ser fornecido como um argumento em forma de sequência de
          caracteres. Por Exemplo, `status (feature, "ansi-cl")'.

        * `status (status)' retorna uma lista de dois elementos
          `[feature, status]'.  `feature' e `status' são dois
          argumentos aceitos pela função `status'; Não está claro se
          essa lista tem significância adicional.

     A variável `features' contém uma lista de recursos que se aplicam a
     expressões matemáticas. Veja `features' e `featurep' para maiores
     informações.


 -- Função: time (%o1, %o2, %o3, ...)
     Retorna uma lista de tempos, em segundos, usados para calcular as
     linhas de saída `%o1', `%o2', `%o3', .... O tempo retornado é uma
     estimativa do Maxima do tempo interno de computação, não do tempo
     decorrido. `time' pode somente ser aplicado a variáveis(rótulos)
     de saída de linha; para quaisquer outras variáveis, `time' retorna
     `unknown' (tempo desconhecido).

     Escolha `showtime: true' para fazer com que Maxima moste o tempo
     de computação e o tempo decorrido a cada linha de saída.


 -- Função: timedate ()
     Retorna uma sequência de caracteres representando a data e hora
     atuais.  A sequência de caracteres tem o formato `HH:MM:SS Dia,
     mm/dd/aaaa (GMT-n)', Onde os campos são horas, minutos, segundos,
     dia da semana, mês, dia do mês, ano, e horas que diferem da hora
     GMT.

     O valor de retorno é uma sequência de caracteres Lisp.

     Exemplo:

          (%i1) d: timedate ();
          (%o1) 08:05:09 Wed, 11/02/2005 (GMT-7)
          (%i2) print ("timedate mostra o tempo actual", d)$
          timedate reports current time 08:05:09 Wed, 11/02/2005 (GMT-7)



File: maxima.info,  Node: Opções Diversas,  Next: Regras e Modelos,  Prev: Ambiente em Tempo de Execução,  Up: Top

35 Opções Diversas
******************

* Menu:

* Introdução a Opções Diversas::
* Compartilhado::
* Definições para Opções Diversas::


File: maxima.info,  Node: Introdução a Opções Diversas,  Next: Compartilhado,  Prev: Opções Diversas,  Up: Opções Diversas

35.1 Introdução a Opções Diversas
=================================

Nessa secção várias opções são tratadas pelo facto de possuirem um
efeito global sobre a operação do Maxima.   Também várias listas tais
como a lista de todas as funções definidas pelo utilizador, são
discutidas.


File: maxima.info,  Node: Compartilhado,  Next: Definições para Opções Diversas,  Prev: Introdução a Opções Diversas,  Up: Opções Diversas

35.2 Compartilhado
==================

O directório "share" do Maxima contém programas e outros ficheiros de
interesse para os utilizadors do Maxima, mas que não são parte da
implementação do núcleo do Maxima.  Esses programas são tipicamente
chamados via `load' ou `setup_autoload'.

   `:lisp *maxima-sharedir*' mostra a localização do directório
compartilhado dentro do sistema de ficheiros do utilizador.

   `printfile ("share.usg")' imprime uma lista de pacotes
desactualizados dos pacotes compartilhados.  Usuários podem encontrar
isso de forma mais detalhada navegando no directório compartilhado
usando um navegador de sistema de ficheiro.


File: maxima.info,  Node: Definições para Opções Diversas,  Prev: Compartilhado,  Up: Opções Diversas

35.3 Definições para Opções Diversas
====================================

 -- Variável de sistema: aliases
     Valor por omissão: `[]'

     `aliases' é a lista de átomos que possuem um alias definido pelo
     utilizador (escolhido através das funções `alias', `ordergreat',
     `orderless' ou através da declaração do átomo como sendo um `noun'
     (substantivo) com `declare').

 -- Declaração: alphabetic
     `alphabetic' é uma declaração reconhecida por `declare'.  A
     expressão `declare(<s>, alphabetic)' diz ao Maxima para reconhecer
     como alfabético todos os caracteres em <s>, que deve ser uma
     sequência de caracteres.

     Veja também _Identificadores_.

     Exemplo:

          (%i1) xx\~yy\`\@ : 1729;
          (%o1)                         1729
          (%i2) declare ("~`@", alphabetic);
          (%o2)                         done
          (%i3) xx~yy`@ + @yy`xx + `xx@@yy~;
          (%o3)               `xx@@yy~ + @yy`xx + 1729
          (%i4) listofvars (%);
          (%o4)                  [@yy`xx, `xx@@yy~]


 -- Função: apropos (<string>)
     Procura por nomes Maxima que possuem <string> aparecendo em
     qualquer lugar dentro de seu nome.  Dessa forma, `apropos (exp)'
     retorna uma lista de todos os sinalizadores e funções que possuem
     `exp' como parte de seus nomes, tais como `expand', `exp', e
     `exponentialize'.  Dessa forma, se lembrar apenas uma parte do nome
     de alguma coisa, pode usar este comando para achar o restante do
     nome.  Similarmente, pode dizer `apropos (tr_)' para achar uma
     lista de muitos dos comutadores relatando para o tradutor, muitos
     dos quais começam com `tr_'.


 -- Função: args (<expr>)
     Retorna a lista de argumentos de `expr', que pode ser de qualquer
     tipo de expressão outra como um átomo.  Somente os argumentos do
     operador de nível mais alto são extraídos; subexpressões de `expr'
     aparecem como elementos ou subexpressões de elementos da lista de
     argumentos.

     A ordem dos ítens na lista pode depender do sinalizador global
     `inflag'.

     `args (<expr>)' é equivalente a `substpart ("[", <expr>, 0)'.
     Veja também `substpart'.

     Veja também `op'.


 -- Variável de opção: genindex
     Valor por omissão: `i'

     `genindex' é o prefixo usado para gerar a próxima variável do
     somatório quando necessário.


 -- Variável de opção: gensumnum
     Valor por omissão: 0

     `gensumnum' é o sufixo numérico usado para gerar variável seguinte
     do somatório.  Se isso for escolhido para `false' então o índice
     consistirá somente de `genindex' com um sufixo numérico.


 -- Constante: inf
     Infinito positivo real.


 -- Constante: infinity
     Infinito complexo, uma magnitude infinita de ângulo de fase
     arbitrária.  Veja também `inf' e `minf'.


 -- Variável de sistema: infolists
     Valor por omissão: `[]'

     `infolists' é uma lista dos nomes de todas as listas de
     informação no Maxima. São elas:

    `labels'
          Todos associam `%i', `%o', e rótulos `%t'.

    `values'
          Todos associam átomos que são variáveis de utilizador, não
          opções do Maxima ou comutadores, criados através de `:' ou
          `::' ou associando funcionalmente.

    `functions'
          Todas as funções definidas pelo utilizador, criadas através
          de `:=' ou `define'.

    `arrays'
          Todos os arrays declarados e não declarados, criados através
          de `:', `::', ou `:='.

    `macros'
          Todas as macros definidas pelo utilizador.

    `myoptions'
          Todas as opções alguma vez alteradas pelo utilizador (mesmo
          que tenham ou não elas tenham mais tarde retornadas para seus
          valores padrão).

    `rules'
          Todos os modelos definidos pelo utilizador que coincidirem e
          regras de simplificação, criadas através de `tellsimp',
          `tellsimpafter', `defmatch', ou `defrule'.

    `aliases'
          Todos os átomos que possuem um alias definido pelo
          utilizador, criado através das funções `alias', `ordergreat',
          `orderless' ou declarando os átomos como um `noun' com
          `declare'.

    `dependencies'
          Todos os átomos que possuem dependências funcionais, criadas
          através das funções `depends' ou `gradef'.

    `gradefs'
          Todas as funções que possuem derivadas definidas pelo
          utilizador, cridas através da função `gradef'.

    `props'
          Todos os átomos que possuem quaisquer propriedades outras que
          não essas mencionadas acima, tais como propriedades
          estabelecidas por `atvalue' , `matchdeclare', etc., também
          propriedades estabelecidas na função `declare'.

    `let_rule_packages'
          Todos os pacote de régras em uso definidos pelo utilizador
          mais o pacote especial `default_let_rule_package'.
          (`default_let_rule_package' é o nome do pacote de régras
          usado quando um não está explicitamente escolhido pelo
          utilizador.)



 -- Função: integerp (<expr>)
     Retorna `true' se <expr> é um inteiro numérico literal, de outra
     forma retorna `false'.

     `integerp' retorna falso se seu argumento for um símbolo, mesmo se
     o argumento for declarado inteiro.

     Exemplos:

          (%i1) integerp (0);
          (%o1)                         true
          (%i2) integerp (1);
          (%o2)                         true
          (%i3) integerp (-17);
          (%o3)                         true
          (%i4) integerp (0.0);
          (%o4)                         false
          (%i5) integerp (1.0);
          (%o5)                         false
          (%i6) integerp (%pi);
          (%o6)                         false
          (%i7) integerp (n);
          (%o7)                         false
          (%i8) declare (n, integer);
          (%o8)                         done
          (%i9) integerp (n);
          (%o9)                         false


 -- Variável de opção: m1pbranch
     Valor por omissão: `false'

     `m1pbranch' é principal descendente de `-1' a um expoente.
     Quantidades tais como `(-1)^(1/3)' (isto é, um expoente racional
     "ímpar") e `(-1)^(1/4)' (isto é, um expoente racional "par") são
     manuseados como segue:

                        domain:real

          (-1)^(1/3):      -1
          (-1)^(1/4):   (-1)^(1/4)

                       domain:complex
          m1pbranch:false          m1pbranch:true
          (-1)^(1/3)               1/2+%i*sqrt(3)/2
          (-1)^(1/4)              sqrt(2)/2+%i*sqrt(2)/2


 -- Função: numberp (<expr>)
     Retorna `true' se <expr> for um inteiro literal, número racional,
     número em ponto flutuante, ou um grande número em ponto flutuante,
     de outra forma retorna `false'.

     `numberp' retorna falso se seu argumento for um símbolo, mesmo se
     o argumento for um número simbólico tal como `%pi' ou `%i', ou
     declarado ser par, ímpar, inteiro, racional, irracional, real,
     imaginário, ou complexo.

     Exemplos:

          (%i1) numberp (42);
          (%o1)                         true
          (%i2) numberp (-13/19);
          (%o2)                         true
          (%i3) numberp (3.14159);
          (%o3)                         true
          (%i4) numberp (-1729b-4);
          (%o4)                         true
          (%i5) map (numberp, [%e, %pi, %i, %phi, inf, minf]);
          (%o5)      [false, false, false, false, false, false]
          (%i6) declare (a, even, b, odd, c, integer, d, rational,
               e, irrational, f, real, g, imaginary, h, complex);
          (%o6)                         done
          (%i7) map (numberp, [a, b, c, d, e, f, g, h]);
          (%o7) [false, false, false, false, false, false, false, false]


 -- Função: properties (<a>)
     Retorna uma lista de nomes de todas as propriedades associadas com
     o átomo <a>.


 -- Símbolo especial: props
     `props' são átomos que possuem qualquer propriedade outra como
     essas explicitamente mencionadas em `infolists', tais como
     atvalues, matchdeclares, etc., também propriedades especificadas
     na função  `declare'.


 -- Função: propvars (<prop>)
     Retorna uma lista desses átomos sobre a lista `props' que possui a
     propriedade indicada através de <prop>.  Dessa forma `propvars
     (atvalue)' retorna uma lista de átomos que possuem atvalues.


 -- Função: put (<átomo>, <valor>, <indicador>)
     Atribui <valor> para a propriedade (especificada através de
     <indicador>) do <átomo>.  <indicador> pode ser o nome de qualquer
     propriedade, não apenas uma propriedade definida pelo sistema.

     `put' avalia seus argumentos.  `put' retorna <valor>.

     Exemplos:

          (%i1) put (foo, (a+b)^5, expr);
                                             5
          (%o1)                       (b + a)
          (%i2) put (foo, "Hello", str);
          (%o2)                         Hello
          (%i3) properties (foo);
          (%o3)            [[user properties, str, expr]]
          (%i4) get (foo, expr);
                                             5
          (%o4)                       (b + a)
          (%i5) get (foo, str);
          (%o5)                         Hello


 -- Função: qput (<átomo>, <valor>, <indicador>)
     Atribui <valor> para a propriedade (especificada através de
     <indicador>) do <átomo>.  Isso é o mesmo que `put', excepto que os
     argumentos nã são avaliados.

     Exemplo:

          (%i1) foo: aa$
          (%i2) bar: bb$
          (%i3) baz: cc$
          (%i4) put (foo, bar, baz);
          (%o4)                          bb
          (%i5) properties (aa);
          (%o5)                [[user properties, cc]]
          (%i6) get (aa, cc);
          (%o6)                          bb
          (%i7) qput (foo, bar, baz);
          (%o7)                          bar
          (%i8) properties (foo);
          (%o8)            [value, [user properties, baz]]
          (%i9) get ('foo, 'baz);
          (%o9)                          bar


 -- Função: rem (<átomo>, <indicador>)
     Remove a propriedade indicada através de <indicador> do <átomo>.


 -- Função: remove (<a_1>, <p_1>, ..., <a_n>, <p_n>)
 -- Função: remove ([<a_1>, ..., <a_m>], [<p_1>, ..., <p_n>], ...)
 -- Função: remove ("<a>", operator)
 -- Função: remove (<a>, transfun)
 -- Função: remove (all, <p>)
     Remove propriedades associadas a átomos.

     `remove (<a_1>, <p_1>, ..., <a_n>, <p_n>)' remove a propriedade
     `p_k' do átomo `a_k'.

     `remove ([<a_1>, ..., <a_m>], [<p_1>, ..., <p_n>], ...)' remove as
     propriedades `<p_1>, ..., <p_n>' dos átomos <a_1>, ..., <a_m>.
     Pode existir mais que um par de listas.

     `remove (all, <p>)' remove a propriedade <p> de todos os átomos
     que a possuem.

     A propriedade removida pode ser definida pelo sistema tal como
     `function', `macro' ou `mode_declare', ou propriedades definidas
     pelo utilizador.

     uma propriedade pode ser `transfun' para remover a versão
     traduzida Lisp de uma função.  Após executar isso, a versão Maxima
     da função é executada em lugar da versão traduzida.

     `remove ("<a>", operator)' ou, equivalentemente, `remove ("<a>",
     op)' remove de <a> as propriedades `operator' declaradas através de
     `prefix', `infix', `nary', `postfix', `matchfix', ou `nofix'.
     Note que o nome do operador deve ser escrito como uma sequência de
     caracteres com apóstofo.

     `remove' sempre retorna `done' se um átomo possui ou não uma
     propriedade especificada.  Esse comportamento é diferente das
     funções remove mais específicas `remvalue', `remarray',
     `remfunction', e `remrule'.


 -- Função: remvalue (<nome_1>, ..., <nome_n>)
 -- Função: remvalue (all)
     Remove os valores de Variáveis de utilizador <nome_1>, ...,
     <nome_n> (que podem ser subscritas) do sistema.

     `remvalue (all)' remove os valores de todas as variáveis em
     `values', a lista de todas as variáveis nomeadas através do
     utilizador (em oposição a essas que são automaticamente atribuídas
     através do Maxima).

     Veja também `values'.


 -- Função: rncombine (<expr>)
     Transforma <expr> combinando todos os termos de <expr> que possuem
     denominadores idênticos ou denominadores que diferem de cada um
     dos outros apenas por factores numéricos somente.  Isso é
     ligeiramente diferente do comportamento de de `combine', que
     colecta termos que possuem denominadores idênticos.

     Escolhendo `pfeformat: true' e usando `combine' retorna resultados
     similares a esses que podem ser obtidos com `rncombine', mas
     `rncombine' pega o passo adicional de multiplicar cruzado factores
     numérios do denominador.  Esses resultados em forma ideal, e a
     possibilidade de reconhecer alguns cancelamentos.

     Para usar essa função escreva primeiramente `load(rncomb)'.

 -- Função: scalarp (<expr>)
     Retorna `true' se <expr> for um número, constante, ou variável
     declarada `scalar' com `declare', ou composta inteiramente de
     números, constantes, e tais Variáveis, bmas não contendo matrizes
     ou listas.


 -- Função: setup_autoload (<nomeficheiro>, <função_1>, ..., <função_n>)
     Especifica que se qualquer entre <função_1>, ..., <função_n> for
     referenciado e não ainda definido, <nomedeqrquivo> é chamado via
     `load'.  <nomeficheiro> usualmente contém definições para as
     funções especificadas, embora isso não seja obrigatório.

     `setup_autoload' não trabalha para funções array.

     `setup_autoload' não avalia seus argumentos.

     Exemplo:

          (%i1) legendre_p (1, %pi);
          (%o1)                  legendre_p(1, %pi)
          (%i2) setup_autoload ("specfun.mac", legendre_p, ultraspherical);
          (%o2)                         done
          (%i3) ultraspherical (2, 1/2, %pi);
          Warning - you are redefining the Macsyma função ultraspherical
          Warning - you are redefining the Macsyma função legendre_p
                                      2
                           3 (%pi - 1)
          (%o3)            ------------ + 3 (%pi - 1) + 1
                                2
          (%i4) legendre_p (1, %pi);
          (%o4)                          %pi
          (%i5) legendre_q (1, %pi);
                                        %pi + 1
                                %pi log(-------)
                                        1 - %pi
          (%o5)                 ---------------- - 1
                                       2



File: maxima.info,  Node: Regras e Modelos,  Next: Listas,  Prev: Opções Diversas,  Up: Top

36 Regras e Modelos
*******************

* Menu:

* Introdução a Regras e Modelos::
* Definições para Regras e Modelos::


File: maxima.info,  Node: Introdução a Regras e Modelos,  Next: Definições para Regras e Modelos,  Prev: Regras e Modelos,  Up: Regras e Modelos

36.1 Introdução a Regras e Modelos
==================================

Essa secção descreve coincidências de modelos definidos pelo utilizador
e regras de simplificação.  Existem dois grupos de funções que
implementam até certo ponto diferentes esquemas de coincidência de
modelo.  Em um grupo estão `tellsimp', `tellsimpafter', `defmatch',
`defrule', `apply1', `applyb1', e `apply2'.  Em outro grupo estão `let'
e `letsimp'.  Ambos os esquemas definem modelos em termos de variáveis
de modelo declaradas por `matchdeclare'.

   Regras de coincidência de modelos definidas por `tellsimp' e
`tellsimpafter' são aplicadas automaticamente através do simplificador
do Maxima.  Regras definidas através de `defmatch', `defrule', e `let'
são aplicadas através de uma chamada explícita de função.

   Existe mecanismos adicionais para regras aplicadas a polinómios
através de `tellrat', e para álgebra comutativa e não comutativa no
pacote `affine'.


File: maxima.info,  Node: Definições para Regras e Modelos,  Prev: Introdução a Regras e Modelos,  Up: Regras e Modelos

36.2 Definições para Regras e Modelos
=====================================

 -- Função: apply1 (<expr>, <rule_1>, ..., <rule_n>)
     Repetidamente aplica <rule_1> a <expr> até que isso falhe, então
     repetidamente aplica a mesma regra a todas as subexpressões de
     <expr>, da esquerda para a direita, até que <rule_1> tenha falhado
     sobre todas as subexpressões.  Chama o resultado da
     transformação de <expr> dessa maneira de <expr_2>.  Então <rule_2>
     é aplicada no mesmo estilo iniciando no topo de <expr_2>.  Quando
     <rule_n> falhar na subexpressão final, o resultado é retornado.

     `maxapplydepth' é a intensidade de nível mais distante de
     subexpressões processadas por `apply1' e `apply2'.

     Veja também `applyb1', `apply2', e `let'.


 -- Função: apply2 (<expr>, <rule_1>, ..., <rule_n>)
     Se <rule_1> falhar sobre uma dada subexpressão, então <rule_2> é
     repetidamente aplicada, etc.  Somente se todas as regras falharem
     sobre uma dada subexpressão é que o conjunto completo de regras é
     repetidamente aplicada à próxima subexpressão.  Se uma das regras
     obtém sucesso, então a mesma subexpressão é reprocessada,
     iniciando com a primeira regra.

     `maxapplydepth' é a intensidade do nível mais distante de
     subexpressões processadas através de `apply1' e `apply2'.

     Veja também `apply1' e `let'.


 -- Função: applyb1 (<expr>, <rule_1>, ..., <rule_n>)
     Repetidamente aplica <rule_1> para a subexpressão mais distante de
     <expr> até falhar, então repetidamente aplica a mesma regra um
     nível mais acima (i.e., subexpressãos mais larga), até que
     <rule_1> tenha falhado sobre a expressão de nível mais alto.
     Então <rule_2> é aplicada com o mesmo estilo para o resultado de
     <rule_1>.  após <rule_n> ter sido aplicada à expressão de nível
     mais elevado, o resultado é retornado.

     `applyb1' é similar a `apply1' mas trabalha da base para cima em
     lugar de do topo para baixo.

     `maxapplyheight' é o ápice que `applyb1' encontra antes de
     interromper.

     Veja também `apply1', `apply2', e `let'.


 -- Variável de opção: current_let_rule_package
     Valor por omissão: `default_let_rule_package'

     `current_let_rule_package' é o nome do pacote de regras que está
     sendo usado por funções no pacote `let' (`letsimp', etc.) se
     nenhum outro pacote de regras for especificado.  A essa variável
     pode ser atribuído o nome de qualquer pacote de regras definido
     via comando `let'.

     Se uma chamada tal como `letsimp (expr, nome_pct_regras)' for
     feita, o pacote de regras `nome_pct_regras' é usado para aquela
     chamada de função somente, e o valor de `current_let_rule_package'
     não é alterado.


 -- Variável de opção: default_let_rule_package
     Valor por omissão: `default_let_rule_package'

     `default_let_rule_package' é o nome do pacote de regras usado
     quando um não for explicitamente escolhido pelo utilizador com
     `let' ou através de alteração do valor de
     `current_let_rule_package'.


 -- Função: defmatch (<prognome>, <modelo>, <x_1>, ..., <x_n>)
 -- Função: defmatch (<prognome>, <modelo>)
     Define uma função `<prognome>(<expr>, <x_1>, ..., <x_n>)' que
     testa <expr> para ver se essa expressão coincide com <modelo>.

     <modelo> é uma expressão contendo os argumentos modelo <x_1>, ...,
     <x_n> (se existir algum) e alguns modelos de variáveis (se existir
     algum).  os argumentos modelo são fornecidos explicitamente como
     argumentos para `defmatch' enquanto os modelos de variáveis são
     declarados através da função `matchdeclare'.  Qualquer variável
     não declarada como modelo em `matchdeclare' ou como um argumento
     modelo em `defmatch' coincide somente com si mesma.

     O primeiro argumento para a função criada <prognome> é uma
     expressão a serem comparadas contra o modelo  e os outros
     argumentos são os atuais argumetnos que correspondem às variáveis
     respectivas <x_1>, ..., <x_n> no modelo.

     Se a tentativa de coincidência obtiver sucesso, <prognome> retorna
     uma lista de equações cujos lados esquerdos são os argumetnos de
     modelo e variáveis de modelo, e cujo lado direito forem as
     subexpressões cujos argumentos de modelo e as variáveis coincidem.
     Os modelos de variáveis, mas não tos argumentos de modelo, são
     atribuídos às subexpressões que coincidirem.  Se a coincidência
     falhar, <prognome> retorna `false'.

     Um modelo literal (isto é, um modelo que não contiver nem
     argumentos de modelo nem variáveis de modelo) retorna `true' se a
     coincidência ocorrer.

     Veja também `matchdeclare', `defrule', `tellsimp', e
     `tellsimpafter'.

     Exemplos:

     Define uma função `linearp(expr, x)' que testa `expr' para ver se
     essa expressão da forma `a*x + b' tal que `a' e `b' não contenham
     `x' e `a' seja não nulo.  Essa função de coincidência coincide com
     expressões que sejam lineares em qualquer variável, por que o
     argumento de modelo `x' é fornecido para `defmatch'.

          (%i1) matchdeclare (a, lambda ([e], e#0 and freeof(x, e)), b, freeof(x));
          (%o1)                         done
          (%i2) defmatch (linearp, a*x + b, x);
          (%o2)                        linearp
          (%i3) linearp (3*z + (y + 1)*z + y^2, z);
                                   2
          (%o3)              [b = y , a = y + 4, x = z]
          (%i4) a;
          (%o4)                         y + 4
          (%i5) b;
                                          2
          (%o5)                          y
          (%i6) x;
          (%o6)                           x

     Define uma função `linearp(expr)' que testa `expr' para ver se
     essa expressão é da forma `a*x + b' tal que `a' e `b' não
     contenham `x' e `a' seja não nulo.  Essa função de coincidência
     somente coincide com expressões lineares em `x', não em qualquer
     outra variável, porque nenhum argumento de modelo é fornecido a
     `defmatch'.

          (%i1) matchdeclare (a, lambda ([e], e#0 and freeof(x, e)), b, freeof(x));
          (%o1)                         done
          (%i2) defmatch (linearp, a*x + b);
          (%o2)                        linearp
          (%i3) linearp (3*z + (y + 1)*z + y^2);
          (%o3)                         false
          (%i4) linearp (3*x + (y + 1)*x + y^2);
                                       2
          (%o4)                  [b = y , a = y + 4]

     Define uma função `checklimits(expr)' que testa `expr' para ver se
     essa expressão é uma integral definida.

          (%i1) matchdeclare ([a, f], true);
          (%o1)                         done
          (%i2) constinterval (l, h) := constantp (h - l);
          (%o2)        constinterval(l, h) := constantp(h - l)
          (%i3) matchdeclare (b, constinterval (a));
          (%o3)                         done
          (%i4) matchdeclare (x, atom);
          (%o4)                         done
          (%i5) simp : false;
          (%o5)                         false
          (%i6) defmatch (checklimits, 'integrate (f, x, a, b));
          (%o6)                      checklimits
          (%i7) simp : true;
          (%o7)                         true
          (%i8) 'integrate (sin(t), t, %pi + x, 2*%pi + x);
                                 x + 2 %pi
                                /
                                [
          (%o8)                 I          sin(t) dt
                                ]
                                /
                                 x + %pi
          (%i9) checklimits (%);
          (%o9)    [b = x + 2 %pi, a = x + %pi, x = t, f = sin(t)]


 -- Função: defrule (<nomeregra>, <modelo>, <substituição>)
     Define e nomeia uma regra de substituição para o modelo dado.  Se
     a regra nomeada <nomeregra> for aplicada a uma expressão (através
     de `apply1', `applyb1', ou `apply2'), toda subexpressão
     coincidindo com o modelo será substituída por `substituição'.
     Todas as variáveis em `substituição' que tiverem sido atribuidos
     valores pela coincidência com o modelo são atribuidas esses
     valores na `substituição' que é então simplificado.

     As regras por si mesmas podem ser tratadas como funções que
     transforma uma expressão através de uma operação de coincidência
     de modelo e substituição.  Se a coincidência falhar, a função da
     regra retorna `false'.


 -- Função: disprule (<nomeregra_1>, ..., <nomeregra_2>)
 -- Função: disprule (all)
     Mostra regras com os nomes <nomeregra_1>, ..., <nomeregra_n>, como
     retornado por `defrule', `tellsimp', ou `tellsimpafter', ou um
     modelo definido por meio de `defmatch'.

     Cada regra é mostrada com um rótulo de expressão intermédia (`%t').

     `disprule (all)' mostra todas as regras.

     `disprule' não avalia seus argumentos.

     `disprule' retorna a lista de rótulos de expressões intermedáirias
     correspondendo às regras mostradas.

     Veja também `letrules', que mostra regras definidas através de
     `let'.

     Examples:

          (%i1) tellsimpafter (foo (x, y), bar (x) + baz (y));
          (%o1)                   [foorule1, false]
          (%i2) tellsimpafter (x + y, special_add (x, y));
          (%o2)                   [+rule1, simplus]
          (%i3) defmatch (quux, mumble (x));
          (%o3)                         quux
          (%i4) disprule (foorule1, "+rule1", quux);
          (%t4)        foorule1 : foo(x, y) -> baz(y) + bar(x)

          (%t5)          +rule1 : y + x -> special_add(x, y)

          (%t6)                quux : mumble(x) -> []

          (%o6)                    [%t4, %t5, %t6]
          (%i6) ''%;
          (%o6) [foorule1 : foo(x, y) -> baz(y) + bar(x),
          +rule1 : y + x -> special_add(x, y), quux : mumble(x) -> []]


 -- Função: let (<prod>, <repl>, <prednome>, <arg_1>, ..., <arg_n>)
 -- Função: let ([<prod>, <repl>, <prednome>, <arg_1>, ..., <arg_n>],
          <nome_pacote>)
     Define uma regra de substituição para `letsimp' tal que <prod> é
     substituído por <repl>.  <prod> é um produto de expoentes
     positivos ou negativos dos seguintes termos:

        * Atomos que `letsimp' irá procurar literalmente a menos que
          previamente chamando `letsimp' a função `matchdeclare' é
          usada para associar um predicado com o átomo.  Nesse caso
          `letsimp' irá coincidir com o átomo para qualquer termo de um
          produto satisfazendo o predicado.

        * Núcleos tais como `sin(x)', `n!', `f(x,y)', etc.  Como com
          átomos acima `letsimp' irá olhar um literal coincidente a
          menos que `matchdeclare' seja usada para associar um
          predicado com o argumento do núcleo.

     Um termo para um expoente positivo irá somente coincidir com um
     termo tendo ao menos aquele expoente.  Um termo para um expoente
     negativo por outro lado irá somente coincidir com um termo com um
     expoente ao menos já negativo.  o caso de expentes negativos em
     <prod> o comutador `letrat' deve ser escolhido para `true'.  Veja
     também `letrat'.

     Se um predicado for incluído na função `let' seguido por uma lista
     de argumentos, uma tentativa de coincidência (i.e. uma que pode
     ser aceita se o predicado fosse omitido) é aceita somente se
     `prednome (arg_1', ..., arg_n')' avaliar para `true' onde <arg_i'>
     é o valor coincidente com <arg_i>.  O <arg_i> pode ser o nome de
     qualquer átomo ou o argumento de qualquer núcleo aparecendo em
     <prod>.  <repl> pode ser qualquer expressão racional. Se quaisquer
     dos átomos ou argumentos de <prod> aparecer em <repl> a
     substituição é feita.  O sinalizador global `letrat' controla a
     simplificação dos quocientes através de `letsimp'.  Quando
     `letrat' for `false', `letsimp' simplifica o numerador e o
     denominador de <expr> separadamente, e não simplifica o quociente.
     Substituições tais como `n!/n' vão para `(n-1)!' então falham
     quando `letrat' for `false'.  Quando `letrat' for `true', então o
     numerador, o denominador, e o quociente são simplificados nessa
     ordem.

     Essas funções de substituição permitem-lhe trabalhar com muitos
     pacotes de regras.  Cada pacote de regras pode conter qualquer
     número de regras `let' e é referenciado através de um nome
     definido pelo utilizador.  `let ([<prod>, <repl>, <prednome>,
     <arg_1>, ..., <arg_n>], <nome_pacote>)' adiciona a regra
     <prednome> ao pacote de regras <nome_pacote>.  `letsimp (<expr>,
     <nome_pacote>)' aplica as regras em <nome_pacote>.  `letsimp
     (<expr>, <nome_pacote1>, <nome_pacote2>, ...)' é equivalente a
     `letsimp (<expr>, <nome_pacote1>)' seguido por `letsimp (%,
     <nome_pacote2>)', ....

     `current_let_rule_package' é o nome do pacote de regras que está
     actualmente sendo usando.  Essa variável pode receber o nome de
     qualquer pacote de regras definidos via o comando `let'.  Quando
     qualquer das funções compreendidas no pacote `let' são chamadas
     sem o nome do pacote, o pacote nomeado por
     `current_let_rule_package' é usado.  Se uma chamada tal como
     `letsimp (<expr>, <nome_pct_regras>)' é feita, o pacote de regras
     <nome_pct_regras> é usado somente para aquele comando `letsimp', e
     `current_let_rule_package' não é alterada.  Se não especificado de
     outra forma, `current_let_rule_package' avalia de forma
     padronizada para `default_let_rule_package'.

          (%i1) matchdeclare ([a, a1, a2], true)$
          (%i2) oneless (x, y) := is (x = y-1)$
          (%i3) let (a1*a2!, a1!, oneless, a2, a1);
          (%o3)         a1 a2! --> a1! where oneless(a2, a1)
          (%i4) letrat: true$
          (%i5) let (a1!/a1, (a1-1)!);
                                  a1!
          (%o5)                   --- --> (a1 - 1)!
                                  a1
          (%i6) letsimp (n*m!*(n-1)!/m);
          (%o6)                      (m - 1)! n!
          (%i7) let (sin(a)^2, 1 - cos(a)^2);
                                  2               2
          (%o7)                sin (a) --> 1 - cos (a)
          (%i8) letsimp (sin(x)^4);
                                  4           2
          (%o8)                cos (x) - 2 cos (x) + 1


 -- Variável de opção: letrat
     Valor por omissão: `false'

     Quando `letrat' for `false', `letsimp' simplifica o numerador e o
     denominador de uma razão separadamente, e não simplifica o
     quociente.

     Quando `letrat' for `true', o numerador, o denominador, e seu
     quocienten são simplificados nessa ordem.

          (%i1) matchdeclare (n, true)$
          (%i2) let (n!/n, (n-1)!);
                                   n!
          (%o2)                    -- --> (n - 1)!
                                   n
          (%i3) letrat: false$
          (%i4) letsimp (a!/a);
                                         a!
          (%o4)                          --
                                         a
          (%i5) letrat: true$
          (%i6) letsimp (a!/a);
          (%o6)                       (a - 1)!


 -- Função: letrules ()
 -- Função: letrules (<nome_pacote>)
     Mostra as regras em um pacote de regras.  `letrules ()' mostra as
     regras no pacote de regras corrente.  `letrules (<nome_pacote>)'
     mostra as regras em `nome_pacote'.

     O pacote de regras corrente é nomeado por
     `current_let_rule_package'.  Se não especificado de outra forma,
     `current_let_rule_package' avalia de forma padrão para
     `default_let_rule_package'.

     Veja também `disprule', que mostra regras defindas por `tellsimp'
     e `tellsimpafter'.


 -- Função: letsimp (<expr>)
 -- Função: letsimp (<expr>, <nome_pacote>)
 -- Função: letsimp (<expr>, <nome_pacote_1>, ..., <nome_pacote_n>)
     Repetidamente aplica a substituição definida por `let' até que
     nenhuma mudança adicional seja feita para <expr>.

     `letsimp (<expr>)' usa as regras de `current_let_rule_package'.

     `letsimp (<expr>, <nome_pacote>)' usa as regras de <nome_pacote>
     sem alterar `current_let_rule_package'.

     `letsimp (<expr>, <nome_pacote_1>, ..., <nome_pacote_n>)' é
     equivalente a `letsimp (<expr>, <nome_pacote_1>', seguido por
     `letsimp (%, <nome_pacote_2>)', e assim sucessivamente.


 -- Variável de opção: let_rule_packages
     Valor por omissão: `[default_let_rule_package]'

     `let_rule_packages' é uma lista de todos os pacotes de regras
     `let' definidos pelo utilizador mais o pacote padrão
     `default_let_rule_package'.


 -- Função: matchdeclare (<a_1>, <pred_1>, ..., <a_n>, <pred_n>)
     Associa um predicado <pred_k> com uma variável ou lista de
     variáveis <a_k> de forma que <a_k> coincida com expressões para as
     quais o predicado retorne qualquer coisa que não `false'.

     Umpredicado é o nome de uma função, ou de uma expressão lambda, ou
     uma chamada de função ou chamada de função lambda iomitindo o
     úlltimo argumento, ou `true' ou `all'.  Qualquer expressão
     coincide com `true' ou `all'.  Se o predicado for especificado
     como uma chamada de função ou chamada de função lambda, a
     expressão a ser testada é anexada ao final da lista de argumentos;
     os argumentos são avaliados ao mesmo tempo que a coincidência é
     avaliada.  De outra forma, o predicado é especificado como um nome
     de função ou expressão lambda, e a expressão a ser testada é o
     argumento sozinho.  Uma função predicado não precisa ser definida
     quando `matchdeclare' for chamada; o predicado não é avaliado até
     que uma coincidência seja tentada.

     Um predicado pode retornar uma expressão Booleana além de `true'
     ou `false'.  Expressões Booleanas são avaliadas por `is' dentro da
     função da regra construída, de forma que não é necessário chamar
     `is' dentro do predicado.

     Se uma expressão satisfaz uma coincidência de predicado, a
     variável de coincidência é atribuída à expressão, excepto para
     variáveis de coincidência que são operandos de adição `+' ou
     multiplicação `*'.  Somente adição e multiplicação são manuseadas
     de forma especial; outros operadores enários (ambos os definidos
     internamente e os definidos pelo utilizador) são tratados como
     funções comuns.

     No caso de adição e multiplicação, a variável de coincidência pode
     ser atribuida a uma expressão simples que satisfaz o predicado de
     coincidência, ou uma adição ou um produto (respectivamente) de
     tais expressões.  Tal coincidência de termo multiplo é gulosa:
     predicados são avaliados na ordem em que suas variáveis associadas
     aparecem no modelo de coincidência, e o termo que satisfizer mais
     que um predicado é tomado pelo primeiro predicado que satisfizer.
     Cada predicado é testado contra todos os operandos de adição ou
     produto antes que o próximo predicado seja avaliado.
     Adicionalmente, se 0 ou 1 (respectivamente) satisfazem um
     predicado de coincidência, e não existe outros termos que
     satisfaçam o predicado, 0 ou 1 é atribuído para a variável de
     coincidência associada com o predicado.

     O algoritmo para processar modelos contendo adição e
     multiplicação faz alguns resultados de coincidência (por exemplo,
     um modelo no qual uma variável "coincida com qualquer coisa"
     aparecer) dependerem da ordem dos termos no modelo de coincidência
     e na expressão a ser testada a coincidência.  Todavia, se todos os
     predicados de coincidência são mutuamente exclusivos, o resultado
     de coincidência é insensível a ordenação, como um predicado de
     coincidência não pode aceitar termos de coincidência de outro.

     Chamado `matchdeclare' com uma variável <a> como um argumento muda
     a propriedade `matchdeclare' para <a>, se a variável <a> tiver
     sido declarada anteriormente; somente o `matchdeclare' mais
     recente está em efeito quando uma regra é definida, mudanças
     posteriores para a propriedade `matchdeclare' (via `matchdeclare'
     ou `remove') não afectam regras existentes.

     `propvars (matchdeclare)' retorna a lista de todas as variáveis
     para as quais exista uma propriedade `matchdeclare'.  `printprops
     (<a>, matchdeclare)' retorna o predicado para a variável `a'.
     `printprops (all, matchdeclare)' retorna a lista de predicados
     para todas as variáveis `matchdeclare'.  `remove (<a>,
     matchdeclare)' remove a propriedade `matchdeclare' da variável <a>.

     As funções `defmatch', `defrule', `tellsimp', `tellsimpafter', e
     `let' constroem regras que testam expressões contra modelos.

     `matchdeclare' coloca apóstrofo em seus argumentos.
     `matchdeclare' sempre retorna `done'.

     Exemplos:

     Um predicado é o nome de uma função, ou uma expressão lambda, ou
     uma chamada de função ou chamada a função lambda omitindo o último
     argumento, or `true' or `all'.

          (%i1) matchdeclare (aa, integerp);
          (%o1)                         done
          (%i2) matchdeclare (bb, lambda ([x], x > 0));
          (%o2)                         done
          (%i3) matchdeclare (cc, freeof (%e, %pi, %i));
          (%o3)                         done
          (%i4) matchdeclare (dd, lambda ([x, y], gcd (x, y) = 1) (1728));
          (%o4)                         done
          (%i5) matchdeclare (ee, true);
          (%o5)                         done
          (%i6) matchdeclare (ff, all);
          (%o6)                         done

     Se uma expressão satisfaz um predicado de coincidência, a variável
     de coincidência é atribuída à expressão.

          (%i1) matchdeclare (aa, integerp, bb, atom);
          (%o1)                         done
          (%i2) defrule (r1, bb^aa, ["integer" = aa, "atom" = bb]);
                              aa
          (%o2)        r1 : bb   -> [integer = aa, atom = bb]
          (%i3) r1 (%pi^8);
          (%o3)               [integer = 8, atom = %pi]

     No caso de adição e multiplicação, à variável de coincidência pode
     ser atribuída uma expressão simples que satisfaz o predicado de
     coincidência, ou um somatório ou produtório (respectivamente) de
     tais expressões.

          (%i1) matchdeclare (aa, atom, bb, lambda ([x], not atom(x)));
          (%o1)                         done
          (%i2) defrule (r1, aa + bb, ["all atoms" = aa, "all nonatoms" = bb]);
          bb + aa partitions `sum'
          (%o2)  r1 : bb + aa -> [all atoms = aa, all nonatoms = bb]
          (%i3) r1 (8 + a*b + sin(x));
          (%o3)     [all atoms = 8, all nonatoms = sin(x) + a b]
          (%i4) defrule (r2, aa * bb, ["all atoms" = aa, "all nonatoms" = bb]);
          bb aa partitions `product'
          (%o4)   r2 : aa bb -> [all atoms = aa, all nonatoms = bb]
          (%i5) r2 (8 * (a + b) * sin(x));
          (%o5)    [all atoms = 8, all nonatoms = (b + a) sin(x)]

     Quando coincidindo argumentos de `+' e `*', se todos os predicados
     de coincidência forem mutuamente exclusivos, o resultado da
     coincidência é insensíve à ordenação, como um predicado de
     coincidência não pode aceitar termos que coincidiram com outro.

          (%i1) matchdeclare (aa, atom, bb, lambda ([x], not atom(x)));
          (%o1)                         done
          (%i2) defrule (r1, aa + bb, ["all atoms" = aa, "all nonatoms" = bb]);
          bb + aa partitions `sum'
          (%o2)  r1 : bb + aa -> [all atoms = aa, all nonatoms = bb]
          (%i3) r1 (8 + a*b + %pi + sin(x) - c + 2^n);
                                                               n
          (%o3) [all atoms = %pi + 8, all nonatoms = sin(x) + 2  - c + a b]
          (%i4) defrule (r2, aa * bb, ["all atoms" = aa, "all nonatoms" = bb]);
          bb aa partitions `product'
          (%o4)   r2 : aa bb -> [all atoms = aa, all nonatoms = bb]
          (%i5) r2 (8 * (a + b) * %pi * sin(x) / c * 2^n);
                                                            n
                                                   (b + a) 2  sin(x)
          (%o5) [all atoms = 8 %pi, all nonatoms = -----------------]
                                                           c

     As funções `propvars' e `printprops' retornam informações sobre
     variávels de coincidência.

          (%i1) matchdeclare ([aa, bb, cc], atom, [dd, ee], integerp);
          (%o1)                         done
          (%i2) matchdeclare (ff, floatnump, gg, lambda ([x], x > 100));
          (%o2)                         done
          (%i3) propvars (matchdeclare);
          (%o3)             [aa, bb, cc, dd, ee, ff, gg]
          (%i4) printprops (ee, matchdeclare);
          (%o4)                    [integerp(ee)]
          (%i5) printprops (gg, matchdeclare);
          (%o5)              [lambda([x], x > 100, gg)]
          (%i6) printprops (all, matchdeclare);
          (%o6) [lambda([x], x > 100, gg), floatnump(ff), integerp(ee),
                                integerp(dd), atom(cc), atom(bb), atom(aa)]


 -- Função: matchfix (<delimitador_e>, <delimitador_d>)
 -- Função: matchfix (<delimitador_e>, <delimitador_d>, <arg_pos>,
          <pos>)
     Declara um operador `matchfix' com delimitadores esquerdo e
     direito <delimitador_e> e <delimitador_d>.  Os delimitadores são
     especificados como sequêcias de caracteres.

     Um operador "matchfix" é uma função que aceita qualquer número de
     argumentos, tal que os argumentos ocorram entre os delimitadores
     correspondentes esquerdo e direito.  Os delimitadores podem ser
     quaisquer sequêcias de caracteres, contanto que o analisador de
     expressões do Maxima possa distinguir os delimitadores dos
     operandos e de outras expressões e operadores.  Na prática essas
     regras excluem delimitadores não analisáveis tais como `%', `,',
     `$' e `;', e pode ser necessário isolar os delimitadores com
     espaços em branco.  O delimitador da direita pode ser o mesmo ou
     diferente do delimitador da esquerda.

     Um delimitador esquerdo pode ser associado com somente um
     delimitador direito; dois diferentes operadores `matchfix' não
     podem ter o mesmo delimitador esquerdo.

     Um operador existente pode ser redeclarado com um operador
     `matchfix' sem alterar suas outras propriedades.  Particularmente,
     operadores internos tais como adição `+' podem ser declarados
     `matchfix', mas funções operadores não podem ser definidas para
     operadores internos.

     `matchfix (<delimitador_e>, <delimitador_d>, <arg_pos>, <pos>)'
     declara o argumento <arg_pos> como sendo um entre: expressão
     lógica, expressão comum do Maxima mas que não seja do tipo
     anterior, e qualquer outro tipo de expressão que não esteja
     incluída nos dois primeiros tipos.  Essa declaração resulta em
     <pos> sendo um entre: expressão lógica, expressão comum do Maxima
     mas que não seja do tipo anterior, e qualquer outro tipo de
     expressão que não esteja incluída nos dois primeiros tipos e os
     delimitadores <delimitador_e> e <delimitador_d>.

     A função para realizar uma operação `matchfix' é uma função comum
     definida pelo utilizador.  A função operador é definida da forma
     usual com o operador de definição de função `:=' ou `define'.  Os
     argumentos podem ser escritos entre os delimitadores, ou com o
     delimitador esquerdo com uma sequência de caracteres com apóstrofo
     e os argumentos seguindo entre parêntesis.  `dispfun
     (<delimitador_e>)' mostra a definição da função operador.

     O único operador interno `matchfix' é o construtor de listas `[ ]'.
     Parêntesis `( )' e aspas duplas `" "' atuam como operadores
     `matchfix', mas não são tratados como tal pelo analisador do
     Maxima.

     `matchfix' avalia seus argumentos.  `matchfix' retorna seu
     primeiro argumento, <delimitador_e>.

     Exemplos:

        * Delimitadores podem ser quase quaisquer sequência de
          caracteres.

          (%i1) matchfix ("@@", "~");
          (%o1)                          @@
          (%i2) @@ a, b, c ~;
          (%o2)                      @@a, b, c~
          (%i3) matchfix (">>", "<<");
          (%o3)                          >>
          (%i4) >> a, b, c <<;
          (%o4)                      >>a, b, c<<
          (%i5) matchfix ("foo", "oof");
          (%o5)                          foo
          (%i6) foo a, b, c oof;
          (%o6)                     fooa, b, coof
          (%i7) >> w + foo x, y oof + z << / @@ p, q ~;
                               >>z + foox, yoof + w<<
          (%o7)                ----------------------
                                      @@p, q~

        * Operadores `matchfix' são funções comuns definidas pelo
          utilizador.

          (%i1) matchfix ("!-", "-!");
          (%o1)                         "!-"
          (%i2) !- x, y -! := x/y - y/x;
                                              x   y
          (%o2)                   !-x, y-! := - - -
                                              y   x
          (%i3) define (!-x, y-!, x/y - y/x);
                                              x   y
          (%o3)                   !-x, y-! := - - -
                                              y   x
          (%i4) define ("!-" (x, y), x/y - y/x);
                                              x   y
          (%o4)                   !-x, y-! := - - -
                                              y   x
          (%i5) dispfun ("!-");
                                              x   y
          (%t5)                   !-x, y-! := - - -
                                              y   x

          (%o5)                         done
          (%i6) !-3, 5-!;
                                          16
          (%o6)                         - --
                                          15
          (%i7) "!-" (3, 5);
                                          16
          (%o7)                         - --
                                          15


 -- Função: remlet (<prod>, <nome>)
 -- Função: remlet ()
 -- Função: remlet (all)
 -- Função: remlet (all, <nome>)
     Apaga a regra de substituiçao, prod -> repl, mais recentemente
     definida através dea função `let'.  Se `nome' for fornecido a
     regra é apagada do pacote de regras chamado `nome'.

     `remlet()' e `remlet(all)' apagam todas as regras de
     substituição do pacote de regras corrente.  Se o nome de um pacote
     de regras for fornecido, e.g. `remlet (all, <nome>)', o pacote de
     regras <nome> é também apagado.

     Se uma substituição é para ser mudada usando o mesmo produto,
     `remlet' não precisa ser chamada, apenas redefina a
     substituição usando o mesmo produto (literalmente) com a função
     `let' e a nova substituição e/ou nome de predicado.  Pode agora
     `remlet (<prod>)' ser chamada e a regra de substituição original é
     ressuscitada.

     Veja também `remrule', que remove uma regra definida através de
     `tellsimp' ou de `tellsimpafter'.


 -- Função: remrule (<op>, <nomeregra>)
 -- Função: remrule (<op>, all)
     Remove regras definidas por `tellsimp', ou `tellsimpafter'.

     `remrule (<op>, <nomeregra>)' remove a regra com o nome
     `nomeregra' do operador <op>.  Quando <op> for um operador interno
     ou um operador definido pelo utilizador (como definido por
     `infix', `prefix', etc.), <op> e <rulename> devem ser colocados
     entre aspas duplas.

     `remrule (<op>, all)' remove todas as regras para o operador <op>.

     Veja também `remlet', que remove uma regra definida através de
     `let'.

     Examples:

          (%i1) tellsimp (foo (aa, bb), bb - aa);
          (%o1)                   [foorule1, false]
          (%i2) tellsimpafter (aa + bb, special_add (aa, bb));
          (%o2)                   [+rule1, simplus]
          (%i3) infix ("@@");
          (%o3)                          @@
          (%i4) tellsimp (aa @@ bb, bb/aa);
          (%o4)                   [@@rule1, false]
          (%i5) tellsimpafter (quux (%pi, %e), %pi - %e);
          (%o5)                  [quuxrule1, false]
          (%i6) tellsimpafter (quux (%e, %pi), %pi + %e);
          (%o6)             [quuxrule2, quuxrule1, false]
          (%i7) [foo (aa, bb), aa + bb, aa @@ bb, quux (%pi, %e),
                 quux (%e, %pi)];
                                               bb
          (%o7) [bb - aa, special_add(aa, bb), --, %pi - %e, %pi + %e]
                                               aa
          (%i8) remrule (foo, foorule1);
          (%o8)                          foo
          (%i9) remrule ("+", "+rule1");
          (%o9)                           +
          (%i10) remrule ("@@", "@@rule1");
          (%o10)                         @@
          (%i11) remrule (quux, all);
          (%o11)                        quux
          (%i12) [foo (aa, bb), aa + bb, aa @@ bb, quux (%pi, %e),
                  quux (%e, %pi)];
          (%o12) [foo(aa, bb), bb + aa, aa @@ bb, quux(%pi, %e),
                                                   quux(%e, %pi)]


 -- Função: tellsimp (<pattern>, <replacement>)
     é similar a `tellsimpafter' mas coloca nova informação antes da
     antiga de forma que essa nova regra seja aplicada antes das regras
     de simplificação internas.

     `tellsimp' é usada quando for importante modificar a expressão
     antes que o simplificador trabalhe sobre ela, por exemplo se o
     simplificador "sabe" alguma coisa sobre a expressão, mas o que ele
     retorna não é para sua apreciação.  Se o simplificador "sabe"
     alguma coisa sobre o principal operador da expressão, mas está
     simplesmente a escondê-lo, provavelmente querrá usar
     `tellsimpafter'.

     O modelo pode não ser uma adição, um produto, variável simples, ou
     número.

     `rules' é a lista de regras definidas por `defrule', `defmatch',
     `tellsimp', e `tellsimpafter'.

     Exemplos:

          (%i1) matchdeclare (x, freeof (%i));
          (%o1)                         done
          (%i2) %iargs: false$
          (%i3) tellsimp (sin(%i*x), %i*sinh(x));
          (%o3)                 [sinrule1, simp-%sin]
          (%i4) trigexpand (sin (%i*y + x));
          (%o4)         sin(x) cos(%i y) + %i cos(x) sinh(y)
          (%i5) %iargs:true$
          (%i6) errcatch(0^0);
           0
          0  has been generated
          (%o6)                          []
          (%i7) ev (tellsimp (0^0, 1), simp: false);
          (%o7)                  [^rule1, simpexpt]
          (%i8) 0^0;
          (%o8)                           1
          (%i9) remrule ("^", %th(2)[1]);
          (%o9)                           ^
          (%i10) tellsimp (sin(x)^2, 1 - cos(x)^2);
          (%o10)                 [^rule2, simpexpt]
          (%i11) (1 + sin(x))^2;
                                                2
          (%o11)                    (sin(x) + 1)
          (%i12) expand (%);
                                             2
          (%o12)               2 sin(x) - cos (x) + 2
          (%i13) sin(x)^2;
                                            2
          (%o13)                     1 - cos (x)
          (%i14) kill (rules);
          (%o14)                        done
          (%i15) matchdeclare (a, true);
          (%o15)                        done
          (%i16) tellsimp (sin(a)^2, 1 - cos(a)^2);
          (%o16)                 [^rule3, simpexpt]
          (%i17) sin(y)^2;
                                            2
          (%o17)                     1 - cos (y)


 -- Função: tellsimpafter (<modelo>, <substituição>)
     Define a uma regra de simplificação que o simplificador do Maxima
     aplica após as regras de simplificação internas.  <modelo> é uma
     expressão, compreendendo variáveis de modelo (declaradas através
     de `matchdeclare') e outros átomos e operações, considerados
     literais para o propósito de coincidência de modelos.
     <substituição> é substituída para uma expressão actual que
     coincide com <modelo>; variáveis de modelo em <substituição> são
     atribuidas a valores coincidentes na expressão actual.

     <modelo> pode ser qualquer expressão não atômica na qual o
     principal operador não é uma variável de modelo; a regra de
     simplificação está associada com o operador principal.  Os nomes
     de funções (com uma excessão, descrita abaixo), listas, e arrays
     podem aparecer em <modelo> como o principal operador somente como
     literais (não variáveis de modelo); essas regras fornecem
     expressões tais como `aa(x)' e `bb[y]' como modelos, se `aa' e
     `bb' forem variáveis de modelo.  Nomes de funções, listas, e
     arrays que são variáveis de modelo podem aparecer como operadores
     outros que não o operador principal em <modelo>.

     Existe uma excessão para o que foi dito acima com relação a regras
     e nomes de funções.  O nome de uma função subscrita em uma
     expressão tal como `aa[x](y)' pode ser uma variável de modelo,
     porque o operador principal não é `aa' mas ao contrário o átomo
     Lisp `mqapply'.  Isso é uma consequência da representação de
     expressões envolvendo funções subscritas.

     Regras de simplificação são aplicadas após avaliação (se não
     suprimida através de colocação de apóstrofo ou do sinalizador
     `noeval').  Regras estabelecidas por `tellsimpafter' são aplicadas
     na ordem em que forem definidas, e após quaisquer regras internas.
     Regras são aplicadas de baixo para cima, isto é, aplicadas
     primeiro a subexpressões antes de ser aplicada à expressão
     completa.  Isso pode ser necessário para repetidamente simplificar
     um resultado (por exemplo, via o operador apóstrofo-apóstrofo `'''
     ou o sinalizador `infeval') para garantir que todas as regras são
     aplicadas.

     Variáveis de modelo são tratadas como variáveis locais em regras
     de simplificação.  Assim que uma regra é definida, o valor de uma
     variável de modelo não afecta a regra, e não é afectado pela regra.
     Uma atribuição para uma variável de modelo que resulta em uma
     coincidência de regra com sucesso não afecta a atribuição corrente
     (ou necessita disso) da variável de modelo.  Todavia, como com
     todos os átomos no Maxima, as propriedades de variáveis de modelo
     (como declarado por `put' e funções relacionadas) são globais.

     A regra construída por `tellsimpafter' é nomeada após o operador
     principal de `modelo'.  Regras para operadores internos, e
     operadores definidos pelo utilizador definidos por meio de
     `infix', `prefix', `postfix', `matchfix', e `nofix', possuem nomes
     que são sequências de caracteres do Maxima.  Regras para outras
     funções possuem nomes que são identificadores comuns do Maxima.

     O tratamento de substantivos e formas verbais é desprezívelmente
     confuso. Se uma regra é definida para uma forma substantiva (ou
     verbal) e uma regra para o verbo correspondente (ou substantivo)
     já existe, então a nova regra definida aplica-se a ambas as formas
     (substantiva e verbal).  Se uma regra para a correspondente forma
     verbal (ou substantiva) não existe, a nova regra definida
     aplicar-se-á somente para a forma substantiva (ou verbal).

     A regra construída através de `tellsimpafter' é uma função Lisp
     comum.  Se o nome da regra for `$foorule1', a construção `:lisp
     (trace $foorule1)' rastreia a função, e `:lisp (symbol-function
     '$foorule1' mostra sua definição.

     `tellsimpafter' não avalia seus argumentos.  `tellsimpafter'
     retorna a lista de regras para o operador principal de <modelo>,
     incluindo a mais recente regra estabelecia.

     Veja também `matchdeclare', `defmatch', `defrule', `tellsimp',
     `let', `kill', `remrule', e `clear_rules'.

     Exemplos:

     <modelo> pode ser qualquer expressão não atômica na qual o
     principal operador não é uma variável de modelo.

          (%i1) matchdeclare (aa, atom, [ll, mm], listp, xx, true)$
          (%i2) tellsimpafter (sin (ll), map (sin, ll));
          (%o2)                 [sinrule1, simp-%sin]
          (%i3) sin ([1/6, 1/4, 1/3, 1/2, 1]*%pi);
                              1  sqrt(2)  sqrt(3)
          (%o3)              [-, -------, -------, 1, 0]
                              2     2        2
          (%i4) tellsimpafter (ll^mm, map ("^", ll, mm));
          (%o4)                  [^rule1, simpexpt]
          (%i5) [a, b, c]^[1, 2, 3];
                                          2   3
          (%o5)                      [a, b , c ]
          (%i6) tellsimpafter (foo (aa (xx)), aa (foo (xx)));
          (%o6)                   [foorule1, false]
          (%i7) foo (bar (u - v));
          (%o7)                    bar(foo(u - v))

     Regras são aplicadas na ordem em que forem definidas.  Se duas
     regras podem coincidir com uma expressão, a regra que foi primeiro
     definida é a que será aplicada.

          (%i1) matchdeclare (aa, integerp);
          (%o1)                         done
          (%i2) tellsimpafter (foo (aa), bar_1 (aa));
          (%o2)                   [foorule1, false]
          (%i3) tellsimpafter (foo (aa), bar_2 (aa));
          (%o3)              [foorule2, foorule1, false]
          (%i4) foo (42);
          (%o4)                       bar_1(42)

     variáveis de modelo são tratadas como variáveis locais em regras
     de simplificação.  (Compare a `defmatch', que trata variáveis de
     modelo como variáveis globais.)

          (%i1) matchdeclare (aa, integerp, bb, atom);
          (%o1)                         done
          (%i2) tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));
          (%o2)                   [foorule1, false]
          (%i3) bb: 12345;
          (%o3)                         12345
          (%i4) foo (42, %e);
          (%o4)                 bar(aa = 42, bb = %e)
          (%i5) bb;
          (%o5)                         12345

     Como com todos os átomos, propriedades de variáveis de modelo são
     globais embora valores sejam locais.  Nesse exemplo, uma
     propriedade de atribuição é declarada via `define_variable'.  Essa
     é a propriedade do átomo `bb' através de todo o Maxima.

          (%i1) matchdeclare (aa, integerp, bb, atom);
          (%o1)                         done
          (%i2) tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));
          (%o2)                   [foorule1, false]
          (%i3) foo (42, %e);
          (%o3)                 bar(aa = 42, bb = %e)
          (%i4) define_variable (bb, true, boolean);
          (%o4)                         true
          (%i5) foo (42, %e);
          Error: bb was declared mode boolean, has value: %e
           -- an error.  Quitting.  To debug this try debugmode(true);

     Regras são nomeadas após operadores principais.  Nomes de regras
     para operadores internos e operadores definidos pelo utilizador
     são sequências de caracteres, enquanto nomes para outras funções
     são identificadores comuns.

          (%i1) tellsimpafter (foo (%pi + %e), 3*%pi);
          (%o1)                   [foorule1, false]
          (%i2) tellsimpafter (foo (%pi * %e), 17*%e);
          (%o2)              [foorule2, foorule1, false]
          (%i3) tellsimpafter (foo (%i ^ %e), -42*%i);
          (%o3)         [foorule3, foorule2, foorule1, false]
          (%i4) tellsimpafter (foo (9) + foo (13), quux (22));
          (%o4)                   [+rule1, simplus]
          (%i5) tellsimpafter (foo (9) * foo (13), blurf (22));
          (%o5)                  [*rule1, simptimes]
          (%i6) tellsimpafter (foo (9) ^ foo (13), mumble (22));
          (%o6)                  [^rule1, simpexpt]
          (%i7) rules;
          (%o7) [trigrule0, trigrule1, trigrule2, trigrule3, trigrule4,
          htrigrule1, htrigrule2, htrigrule3, htrigrule4, foorule1,
          foorule2, foorule3, +rule1, *rule1, ^rule1]
          (%i8) foorule_name: first (%o1);
          (%o8)                       foorule1
          (%i9) plusrule_name: first (%o4);
          (%o9)                        +rule1
          (%i10) [?mstringp (foorule_name), symbolp (foorule_name)];
          (%o10)                    [false, true]
          (%i11) [?mstringp (plusrule_name), symbolp (plusrule_name)];
          (%o11)                    [true, true]
          (%i12) remrule (foo, foorule1);
          (%o12)                         foo
          (%i13) remrule ("^", "^rule1");
          (%o13)                          ^

     Um exemplo trabalhado: multiplicação anticomutativa.

          (%i1) gt (i, j) := integerp(j) and i < j;
          (%o1)           gt(i, j) := integerp(j) and i < j
          (%i2) matchdeclare (i, integerp, j, gt(i));
          (%o2)                         done
          (%i3) tellsimpafter (s[i]^^2, 1);
          (%o3)                 [^^rule1, simpncexpt]
          (%i4) tellsimpafter (s[i] . s[j], -s[j] . s[i]);
          (%o4)                   [.rule1, simpnct]
          (%i5) s[1] . (s[1] + s[2]);
          (%o5)                    s  . (s  + s )
                                    1     2    1
          (%i6) expand (%);
          (%o6)                      1 - s  . s
                                          2    1
          (%i7) factor (expand (sum (s[i], i, 0, 9)^^5));
          (%o7) 100 (s  + s  + s  + s  + s  + s  + s  + s  + s  + s )
                      9    8    7    6    5    4    3    2    1    0


 -- Função: clear_rules ()
     Executa `kill (rules)' e então re-escolhe o próximo número de
     regra para 1 para adição `+', multiplicação `*', e
     exponenciação `^'.



File: maxima.info,  Node: Listas,  Next: Conjuntos,  Prev: Regras e Modelos,  Up: Top

37 Listas
*********

* Menu:

* Introdução a Listas::
* Definições para Listas::


File: maxima.info,  Node: Introdução a Listas,  Next: Definições para Listas,  Prev: Listas,  Up: Listas

37.1 Introdução a Listas
========================

Listas são o bloco básico de construção para Maxima e Lisp.**Todos os
outros tipos de dado como arrays, tabelas desordenadas, números são
representados como listas Lisp.  Essas listas Lisp possuem a forma

     ((MPLUS) $A 2)

para indicar a expressão `a+2'.**No nível um do Maxima poderemos ver a
notação infixa `a+2'.**Maxima também tem listas que foram impressas como

     [1, 2, 7, x+y]

para uma lista com 4 elementos.**Internamente isso corresponde a uma
lista Lisp da forma

     ((MLIST) 1  2  7  ((MPLUS)  $X $Y ))

O sinalizador que denota o tipo campo de uma expressão Maxima é uma
lista em si mesmo, após ter sido adicionado o simplificador a lista
poderá transforma-se

     ((MLIST SIMP) 1 2 7 ((MPLUS SIMP) $X $Y))


File: maxima.info,  Node: Definições para Listas,  Prev: Introdução a Listas,  Up: Listas

37.2 Definições para Listas
===========================

 -- Função: append (<list_1>, ..., <list_n>)
     Retorna uma lista simples dos elementos de <list_1> seguidos pelos
     elementos de <list_2>, ....  `append' também trabalha sobre
     expressões gerais, e.g. `append (f(a,b), f(c,d,e));' retorna
     `f(a,b,c,d,e)'.

     Faça `example(append);' para um exemplo.


 -- Função: assoc (<key>, <list>, <default>)
 -- Função: assoc (<key>, <list>)
     Essa função procura pela chave <key> do lado esquerdo da entrada
     <list> que é da forma `[x,y,z,...]' onde cada elemento de <list> é
     uma expressão de um operando binário e 2 elementos.  Por exemplo
     `x=1', `2^3', `[a,b]' etc.  A chave <key> é verificada contra o
     primeiro operando.  `assoc' retorna o segundo operando se `key'
     for achada.  Se a chave `key' não for achada isso retorna o valor
     padrão <default>.  <default> é opcional e o padrão é `false'.


 -- Função: atom (<expr>)
     Retorna `true' se <expr> for atomica (i.e. um número, nome ou
     sequência de caracteres) de outra forma retorna `false'.  Desse
     modo `atom(5)' é `true' enquanto `atom(a[1])' e `atom(sin(x))' São
     `false' (assumindo `a[1]' e `x' não estão associados).


 -- Função: cons (<expr>, <list>)
     Retorna uma nova lista construída do elemento <expr> como seu
     primeiro elemento, seguido por elementos de <list>.  `cons' também
     trabalha sobre outras expressões, e.g. `cons(x, f(a,b,c));'  ->
     `f(x,a,b,c)'.


 -- Função: copylist (<list>)
     Retorna uma cópia da lista <list>.


 -- Função: create_list (<form>, <x_1>, <list_1>, ..., <x_n>, <list_n>)
     Cria uma lista por avaliação de <form> com <x_1> associando a cada
     elemento <list_1>, e para cada tal associação anexa <x_2> para
     cada elemento de <list_2>, ....  O número de elementos no
     resultado será o produto do número de elementos de cada lista.
     Cada variável <x_i> pode actualmente ser um síbolo -o qual não
     pode ser avaliado.  A lista de argumentos será avaliada uma única
     vez no início do bloco de repetição.

          (%i82) create_list1(x^i,i,[1,3,7]);
          (%o82) [x,x^3,x^7]

     Com um bloco de repetição duplo:

          (%i79) create_list([i,j],i,[a,b],j,[e,f,h]);
          (%o79) [[a,e],[a,f],[a,h],[b,e],[b,f],[b,h]]

     Em lugar de <list_i> dois argumentos podem ser fornecidos cada um
     dos quais será avaliado como um número.   Esses podem vir a ser
     inclusive o limite inferior e superior do bloco de repetição.

          (%i81) create_list([i,j],i,[1,2,3],j,1,i);
          (%o81) [[1,1],[2,1],[2,2],[3,1],[3,2],[3,3]]

     Note que os limites ou lista para a variável <j> podem depender do
     valor corrente de <i>.


 -- Função: delete (<expr_1>, <expr_2>)
 -- Função: delete (<expr_1>, <expr_2>, <n>)
     Remove todas as ocorrências de <expr_1> em <expr_2>. <expr_1> pode
     ser uma parcela de <expr_2> (se isso for uma adição) ou um factor
     de <expr_2> (se isso for um produto).

          (%i1) delete(sin(x), x+sin(x)+y);
          (%o1)                         y + x

     `delete(<expr_1>, <expr_2>, <n>)' remove as primeiras <n>
     ocorrências de <expr_1> em <expr_2>.  Se houver menos que <n>
     ocorrências de <expr_1> em <expr_2> então todas as corrências
     seram excluídas.

          (%i1) delete(a, f(a,b,c,d,a));
          (%o1)                      f(b, c, d)
          (%i2) delete(a, f(a,b,a,c,d,a), 2);
          (%o2)                     f(b, c, d, a)


 -- Função: eighth (<expr>)
     Retorna o oitavo item de uma expressão ou lista <expr>.  Veja
     `first' para maiores detalhes.


 -- Função: endcons (<expr>, <list>)
     Retorna uma nova lista consistindo de elementos de `list' seguidos
     por <expr>.  `endcons' também trabalha  sobre expressões gerais,
     e.g.  `endcons(x, f(a,b,c));'  ->  `f(a,b,c,x)'.


 -- Função: fifth (<expr>)
     Retorna o quinto item da expressão ou lista <expr>.  Veja `first'
     para maiores detalhes.


 -- Função: first (<expr>)
     Retorna a primeira parte de <expr> que pode resultar no primeiro
     elemento de uma lista, a primeira linha de uma matriz, a primeira
     parcela de uma adição, etc.  Note que `first' e suas funções
     relacionadas, `rest' e `last', trabalham sobre a forma de <expr>
     que é mostrada não da forma que é digitada na entrada.  Se a
     variável `inflag' é escolhida para `true' todavia, essa funções
     olharão  na forma interna de <expr>.  Note que o simplificador
     re-ordena expressões.  Desse modo `first(x+y)' será `x' se `inflag'
     for `true' e `y' se `inflag' for `false' (`first(y+x)' fornece os
     mesmos resultados).  As funções `second' .. `tenth' retornam da
     segunda até a décima parte do seu argumento.


 -- Função: fourth (<expr>)
     Retorna o quarto item da expressõ ou lista <expr>.  Veja `first'
     para maiores detalhes.


 -- Função: get (<a>, <i>)
     Recupera a propriedade de utilizador indicada por <i> associada com
     o átomo <a> ou retorna `false' se "a" não tem a propriedade <i>.

     `get' avalia seus argumentos.

          (%i1) put (%e, 'transcendental, 'type);
          (%o1)                    transcendental
          (%i2) put (%pi, 'transcendental, 'type)$
          (%i3) put (%i, 'algebraic, 'type)$
          (%i4) typeof (expr) := block ([q],
                  if numberp (expr)
                  then return ('algebraic),
                  if not atom (expr)
                  then return (maplist ('typeof, expr)),
                  q: get (expr, 'type),
                  if q=false
                  then errcatch (error(expr,"is not numeric.")) else q)$
          (%i5) typeof (2*%e + x*%pi);
          x is not numeric.
          (%o5)  [[transcendental, []], [algebraic, transcendental]]
          (%i6) typeof (2*%e + %pi);
          (%o6)     [transcendental, [algebraic, transcendental]]


 -- Função: join (<l>, <m>)
     Cria uma nova lista contendo os elementos das lista <l> e <m>,
     intercaladas.  O resultado tem os elementos `[<l>[1], <m>[1],
     <l>[2], <m>[2], ...]'.  As listas <l> e <m> podem conter qualquer
     tipo de elementos.

     Se as listas forem de diferentes comprimentos, `join' ignora
     elementos da lista mais longa.

     Maxima reclama se <L_1> ou <L_2> não for uma lista.

     Exemplos:

          (%i1) L1: [a, sin(b), c!, d - 1];
          (%o1)                [a, sin(b), c!, d - 1]
          (%i2) join (L1, [1, 2, 3, 4]);
          (%o2)          [a, 1, sin(b), 2, c!, 3, d - 1, 4]
          (%i3) join (L1, [aa, bb, cc, dd, ee, ff]);
          (%o3)        [a, aa, sin(b), bb, c!, cc, d - 1, dd]


 -- Função: last (<expr>)
     Retorna a última parte (parcela, linha, elemento, etc.) de <expr>.


 -- Função: length (<expr>)
     Retorna (por padrão) o número de partes na forma externa
     (mostrada) de <expr>.  Para listas isso é o número de elementos,
     para matrizes isso é o número de linhas, e para adições isso é o
     número de parcelas (veja `dispform').

     O comando `length' é afectado pelo comutador `inflag'.  Então,
     e.g. `length(a/(b*c));' retorna 2 se `inflag' for `false'
     (Assumindo `exptdispflag' sendo `true'), mas 3 se `inflag' for
     `true' (A representação interna é essencialmente `a*b^-1*c^-1').


 -- Variável de opção: listarith
     Valor por omissão: `true' - se `false' faz com que quaisquer
     operações aritméticas com listas sejam suprimidas; quando `true',
     operações lista-matriz são contagiosas fazendo com que listas
     sejam convertidas para matrizes retornando um resultado que é
     sempre uma matriz.  Todavia, operações lista-lista podem retornar
     listas.


 -- Função: listp (<expr>)
     Retorna `true' se <expr> for uma lista de outra forma retorna
     `false'.


 -- Função: makelist (<expr>, <i>, <i_0>, <i_1>)
 -- Função: makelist (<expr>, <x>, <list>)
     Constrói e retorna uma lista, cada elemento dessa lista é gerado
     usando <expr>.

     `makelist (<expr>, <i>, <i_0>, <i_1>)' retorna uma lista, o
     `j''ésimo elemento dessa lista é igual a `ev (<expr>, <i>=j)' para
     `j' variando de <i_0> até <i_1>.

     `makelist (<expr>, <x>, <list>)' retorna uma lista, o `j''ésimo
     elemento é igual a `ev (<expr>, <x>=<list>[j])' para `j' variando
     de 1 até `length (<list>)'.

     Exemplos:

          (%i1) makelist(concat(x,i),i,1,6);
          (%o1)               [x1, x2, x3, x4, x5, x6]
          (%i2) makelist(x=y,y,[a,b,c]);
          (%o2)                 [x = a, x = b, x = c]


 -- Função: member (<expr_1>, <expr_2>)
     Retorna `true' se `is(<expr_1> = <a>)' para algum elemento <a> em
     `args(<expr_2>)', de outra forma retorna `false'.

     `expr_2' é tipicamente uma lista, nesse caso `args(<expr_2>) =
     <expr_2>' e `is(<expr_1> = <a>)' para algum elemento <a> em
     `expr_2' é o teste.

     `member' não inspeciona partes dos argumentos de `expr_2', então
     `member' pode retornar `false' mesmo se `expr_1' for uma parte de
     algum argumento de `expr_2'.

     Veja também `elementp'.

     Exemplos:

          (%i1) member (8, [8, 8.0, 8b0]);
          (%o1)                         true
          (%i2) member (8, [8.0, 8b0]);
          (%o2)                         false
          (%i3) member (b, [a, b, c]);
          (%o3)                         true
          (%i4) member (b, [[a, b], [b, c]]);
          (%o4)                         false
          (%i5) member ([b, c], [[a, b], [b, c]]);
          (%o5)                         true
          (%i6) F (1, 1/2, 1/4, 1/8);
                                         1  1  1
          (%o6)                     F(1, -, -, -)
                                         2  4  8
          (%i7) member (1/8, %);
          (%o7)                         true
          (%i8) member ("ab", ["aa", "ab", sin(1), a + b]);
          (%o8)                         true


 -- Função: ninth (<expr>)
     Retorna o nono item da expressão ou lista <expr>.  Veja `first'
     para maiores detalhes.


 -- Função: rest (<expr>, <n>)
 -- Função: rest (<expr>)
     Retorna <expr> com seus primeiros <n> elementos removidos se <n>
     for positivo e seus últimos `- <n>' elementos removidos se <n> for
     negativo.  Se <n> for 1 isso pode ser omitido.  <expr> pode ser
     uma lista, matriz, ou outra expressão.


 -- Função: reverse (<list>)
     Ordem reversa para os membros de <list> (não os membros em si
     mesmos).  `reverse' também trabalha sobre expressões gerais, e.g.
     `reverse(a=b);' fornece `b=a'.


 -- Função: second (<expr>)
     Retorna o segundo item da expressão ou lista <expr>.  Veja `first'
     para maiores detalhes.


 -- Função: seventh (<expr>)
     Retorna o sétimo item da expressão ou lista <expr>.  Veja `first'
     para maiores detalhes.


 -- Função: sixth (<expr>)
     Retorna o sexto item da expressão ou lista <expr>.  Veja `first'
     para maiores detalhes.


 -- Função: sublist_indices (<L>, <P>)
     Retorna os índices dos elementos `x' da lista <L> para os quais o
     predicado `maybe(<P>(x))' retornar `true'; isso inclui `unknown'
     bem como `false'.  <P> pode ser um nome de função ou uma expressão
     lambda.  <L> deve ser uma lista literal.

     Exemplos:

          (%i1) sublist_indices ('[a, b, b, c, 1, 2, b, 3, b], lambda ([x], x='b));
          (%o1)                     [2, 3, 7, 9]
          (%i2) sublist_indices ('[a, b, b, c, 1, 2, b, 3, b], symbolp);
          (%o2)                  [1, 2, 3, 4, 7, 9]
          (%i3) sublist_indices ([1 > 0, 1 < 0, 2 < 1, 2 > 1, 2 > 0], identity);
          (%o3)                       [1, 4, 5]
          (%i4) assume (x < -1);
          (%o4)                       [x < - 1]
          (%i5) map (maybe, [x > 0, x < 0, x < -2]);
          (%o5)                [false, true, unknown]
          (%i6) sublist_indices ([x > 0, x < 0, x < -2], identity);
          (%o6)                          [2]


 -- Função: tenth (<expr>)
     Retorna o décimo item da expressão ou lista <expr>.  Veja `first'
     para maiores detalhes.


 -- Função: third (<expr>)
     Retorna o terceiro item da expressão ou lista <expr>.  Veja
     `first' para maiores detalhes.



File: maxima.info,  Node: Conjuntos,  Next: Definição de Função,  Prev: Listas,  Up: Top

38 Conjuntos
************

* Menu:

* Introdução a Conjuntos::
* Definições para Conjuntos::


File: maxima.info,  Node: Introdução a Conjuntos,  Next: Definições para Conjuntos,  Prev: Conjuntos,  Up: Conjuntos

38.1 Introdução a Conjuntos
===========================

Maxima fornece funções de conjunto, tais como intersecção e união, para
conjuntos finitos que são definidos por enumeração explícita.  Maxima
trata listas e conjuntos como objectos distintos. Este recurso torna
possível trabalhar com conjuntos que possuem elementos que são ou
listas ou conjuntos.

   Adicionalmente, para funções de conjuntos finitos, Maxima fornece
algumas funções relacionadas com análise combinatória: números de
Stirling de primeiro e de segundo tipo, números de Bell, coeficientes
multinomiais e partições de inteiros não negativos, entre outras.
Maxima também define a função delta de Kronecker.

38.1.1 Utilização
-----------------

Para construir um conjunto com elementos `a_1, ..., a_n', escreva
`set(a_1, ..., a_n)' ou `{a_1, ..., a_n}'; para construir o conjunto
vazio, escreva `set()' ou `{}'.  Para inserção de dados, `set(...)' e
`{ ... }' são equivalentes. Os conjuntos são sempre mostrados entre
chaves (`{ ... }').

   Se um elemento é listado mais de uma vez, o simplificador do Maxima
elimina o elemento redundante.

     (%i1) set();
     (%o1)                          {}
     (%i2) set(a, b, a);
     (%o2)                        {a, b}
     (%i3) set(a, set(b));
     (%o3)                       {a, {b}}
     (%i4) set(a, [b]);
     (%o4)                       {a, [b]}
     (%i5) {};
     (%o5)                          {}
     (%i6) {a, b, a};
     (%o6)                        {a, b}
     (%i7) {a, {b}};
     (%o7)                       {a, {b}}
     (%i8) {a, [b]};
     (%o8)                       {a, [b]}

   Dois elementos <x> e <y> são redundantes (nomeadamente, considerados
o mesmo para propósito de construção de conjuntos) se e somente se
`is(<x> = <y>)' retornar `true'.  Note que `is(equal(<x>, <y>))' pode
retornar `true' enquanto `is(<x> = <y>)' retorna `false'; nesse caso os
elementos <x> e <y> são considerados distintos.

     (%i1) x: a/c + b/c;
                                   b   a
     (%o1)                         - + -
                                   c   c
     (%i2) y: a/c + b/c;
                                   b   a
     (%o2)                         - + -
                                   c   c
     (%i3) z: (a + b)/c;
                                   b + a
     (%o3)                         -----
                                     c
     (%i4) is (x = y);
     (%o4)                         true
     (%i5) is (y = z);
     (%o5)                         false
     (%i6) is (equal (y, z));
     (%o6)                         true
     (%i7) y - z;
                                b + a   b   a
     (%o7)                    - ----- + - + -
                                  c     c   c
     (%i8) ratsimp (%);
     (%o8)                           0
     (%i9) {x, y, z};
                               b + a  b   a
     (%o9)                    {-----, - + -}
                                 c    c   c

   Para construir um conjunto dos elementos de uma lista, use `setify'.

     (%i1) setify ([b, a]);
     (%o1)                        {a, b}

   Os elementos de conjunto `x' e `y' serão considerados iguais se
`is(x = y)' for avaliando para `true'. Dessa forma, `rat(x)' e `x' são
iguais como elementos de conjunto; consequentemente,

     (%i1) {x, rat(x)};
     (%o1)                          {x}

   Adicionalmente, uma vez que `is((x - 1)*(x + 1) = x^2 - 1)' avalia
para `false', `(x - 1)*(x + 1)' e `x^2 - 1' são considerados elementos
de conjunto diferentes; dessa forma

     (%i1) {(x - 1)*(x + 1), x^2 - 1};
                                            2
     (%o1)               {(x - 1) (x + 1), x  - 1}

   Para reduzir esse conjunto a um conjunto simples, apliquemos `rat' a
cada elemento do conjunto

     (%i1) {(x - 1)*(x + 1), x^2 - 1};
                                            2
     (%o1)               {(x - 1) (x + 1), x  - 1}
     (%i2) map (rat, %);
                                   2
     (%o2)/R/                    {x  - 1}

   Para remover redundâncias em outros conjuntos, poderá ter que usar
outras funções de simplificação. Aqui está um exemplo que usa
`trigsimp':

     (%i1) {1, cos(x)^2 + sin(x)^2};
                                 2         2
     (%o1)                {1, sin (x) + cos (x)}
     (%i2) map (trigsimp, %);
     (%o2)                          {1}

   Um conjunto está simplificado quando os seus elementos não são
redundantes e o conjunto está ordenado. A versão actual das funções de
conjunto usam a função `orderlessp' do Maxima para ordenar conjuntos;
contudo, _versões futuras das funções de conjunto poderão vir a usar
uma função de ordenação diferente_.

   Algumas operações sobre conjuntos, tais como substituições,
forçam automaticamente a uma re-simplificação; por exemplo,

     (%i1) s: {a, b, c}$
     (%i2) subst (c=a, s);
     (%o2)                        {a, b}
     (%i3) subst ([a=x, b=x, c=x], s);
     (%o3)                          {x}
     (%i4) map (lambda ([x], x^2), set (-1, 0, 1));
     (%o4)                        {0, 1}

   Maxima trata listas e conjuntos como objectos distintos; funções
tais como `union' e `intersection' produzem um erro se qualquer
argumento não for um conjunto. se precisar aplicar uma função de
conjunto a uma lista, use a função `setify' para converter essa lista
num conjunto. Dessa forma

     (%i1) union ([1, 2], {a, b});
     Function union expects a set, instead found [1,2]
      -- an error.  Quitting.  To debug this try debugmode(true);
     (%i2) union (setify ([1, 2]), {a, b});
     (%o2)                     {1, 2, a, b}

   Para extrair todos os elementos de um conjunto `s' que satisfazem um
predicado `f', use `subset(s, f)'. (Um predicado é um uma função que
avalia para os valores booleanos `true'/`false'.) Por exemplo, para
encontrar as equações num dado conjunto que não depende de uma variável
`z', use

     (%i1) subset ({x + y + z, x - y + 4, x + y - 5}, lambda ([e], freeof (z, e)));
     (%o1)               {- y + x + 4, y + x - 5}

   A secção _Definições para Conjuntos_ possui uma lista completa das
funções de conjunto no Maxima.

38.1.2 Iterações entre Elementos de Conjuntos
---------------------------------------------

Existem duas formas de fazer iterações sobre elementos de conjuntos.
Uma forma é usar `map'; por exemplo:

     (%i1) map (f, {a, b, c});
     (%o1)                  {f(a), f(b), f(c)}

   A outra forma consiste em usar `for <x> in <s> do'

     (%i1) s: {a, b, c};
     (%o1)                       {a, b, c}
     (%i2) for si in s do print (concat (si, 1));
     a1
     b1
     c1
     (%o2)                         done

   As funções `first' e `rest' do Maxima trabalham actualmente sobre
conjuntos. Aplicada a um conjunto, `first' retorna o primeiro elemento
mostrado de um conjunto; qual o élemento que será mostrado dependerá da
implementação. Se `s' for um conjunto, então `rest(s)' é equivalente a
`disjoin(first(s), s)'.  Actualmente, existem outras funções do Maxima
que trabalham correctamente sobre conjuntos. Em versões futuras das
funções de conjunto, `first' e `rest' podem vir a funcionar
diferentemente ou deixar de funcionar.

38.1.3 Erros
------------

As funções de conjunto usam a função `orderlessp' do Maxima para
organizar os elementos dum conjunto e a função (a nível do Lisp) `like'
para testar a igualdade entre elementos de conjuntos. Ambas essas
funções possuem falhas conhecidas que podem se manifestar quando tentar
usar conjuntos com elementos que são listas ou matrizes que contenham
expressões na forma racional canónica (CRE). Um exemplo é

     (%i1) {[x], [rat (x)]};
     Maxima encountered a Lisp error:

       The value #:X1440 is not of type LIST.

     Automatically continuing.
     To reenable the Lisp debugger set *debugger-hook* to nil.

   Essa expressão faz com que o Maxima produza um erro (a mensagem de
erro dependerá da versão do Lisp que o Maxima estiver a utilizar).
Outro exemplo é

     (%i1) setify ([[rat(a)], [rat(b)]]);
     Maxima encountered a Lisp error:

       The value #:A1440 is not of type LIST.

     Automatically continuing.
     To reenable the Lisp debugger set *debugger-hook* to nil.

   Essas falhas são causadas por falhas em `orderlessp' e `like', e não
por falhas nas funções de conjunto. Para ilustrar, experimente as
expressões

     (%i1) orderlessp ([rat(a)], [rat(b)]);
     Maxima encountered a Lisp error:

       The value #:B1441 is not of type LIST.

     Automatically continuing.
     To reenable the Lisp debugger set *debugger-hook* to nil.
     (%i2) is ([rat(a)] = [rat(a)]);
     (%o2)                         false

   Até que essas falhas forem corrigidas, não construa conjuntos com
elementos que sejam listas ou matrizes contendo expressões na forma
racional canónica (CRE); um conjunto com um elemento na forma CRE,
contudo, pode não ser um problema:

     (%i1) {x, rat (x)};
     (%o1)                          {x}

   A `orderlessp' do Maxima possui outra falha que pode causar
problemas com funções de conjunto; nomeadamente, o predicado de
ordenação `orderlessp' não é transitivo. O mais simples exemplo
conhecido que mostra isso é

     (%i1) q: x^2$
     (%i2) r: (x + 1)^2$
     (%i3) s: x*(x + 2)$
     (%i4) orderlessp (q, r);
     (%o4)                         true
     (%i5) orderlessp (r, s);
     (%o5)                         true
     (%i6) orderlessp (q, s);
     (%o6)                         false

   Essa falha pode causar problemas com todas as funções de conjunto
bem como com funções do Maxima em geral. É provável, mas não certo, que
essa falha possa ser evitada se todos os elementos do conjunto
estiverem ou na forma CRE ou tiverem sido simplificados usando
`ratsimp'.

   Os mecanismos `orderless' e `ordergreat' do Maxima são incompatíveis
com as funções de conjunto. Se precisar usar `orderless' ou
`ordergrreat', chame todas essas funções antes de construir quaisquer
conjuntos, e não use `unorder'.

   Se encontrar alguma coisa que pense ser uma falha em alguma
funçõ de conjunto, por favor relate isso para a base de dados de falhas
do Maxima. Veja `bug_report'.

38.1.4 Autores
--------------

Stavros Macrakis de Cambridge, Massachusetts e Barton Willis da
Universidade de Nebraska e Kearney (UNK) escreveram as fnções de
conjunto do Maxima e sua documentação.


File: maxima.info,  Node: Definições para Conjuntos,  Prev: Introdução a Conjuntos,  Up: Conjuntos

38.2 Definições para Conjuntos
==============================

 -- Função: adjoin (<x>, <a>)
     Calcula a união do conjunto <a> com `{<x>}'.

     `adjoin' falha se <a> não for um conjunto literal.

     `adjoin(<x>, <a>)' e `union(set(<x>), <a>)' são equivalentes;
     contudo, `adjoin' pode ser um pouco mais rápida que `union'.

     Veja também `disjoin'.

     Exemplos:

          (%i1) adjoin (c, {a, b});
          (%o1)                       {a, b, c}
          (%i2) adjoin (a, {a, b});
          (%o2)                        {a, b}


 -- Função: belln (<n>)
     Representa o n-ésimo número de Bell.  `belln(n)' é o número de
     partições de um conjunto de <n> elementos.

     Para inteiros não negativos <n>, `belln(<n>)' simplifica para o
     n-ésimo número de Bell.  `belln' não simplifica para qualquer
     outro tipo de argumento.

     `belln', aplicada a equações, listas, matrizes e conjuntos, é
     calculada em forma distributiva.

     Exemplos:

     `belln' aplicado a inteiros não negativos.

          (%i1) makelist (belln (i), i, 0, 6);
          (%o1)               [1, 1, 2, 5, 15, 52, 203]
          (%i2) is (cardinality (set_partitions ({})) = belln (0));
          (%o2)                         true
          (%i3) is (cardinality (set_partitions ({1, 2, 3, 4, 5, 6})) = belln (6));
          (%o3)                         true

     `belln' aplicado a argumentos que não são inteiros não negativos.

          (%i1) [belln (x), belln (sqrt(3)), belln (-9)];
          (%o1)        [belln(x), belln(sqrt(3)), belln(- 9)]


 -- Função: cardinality (<a>)
     Calcula o número de elementos distintos do conjunto <a>.

     `cardinality' ignora elementos redundantes mesmo quando a
     simplificação não estiver habilitada.

     Exemplos:

          (%i1) cardinality ({});
          (%o1)                           0
          (%i2) cardinality ({a, a, b, c});
          (%o2)                           3
          (%i3) simp : false;
          (%o3)                         false
          (%i4) cardinality ({a, a, b, c});
          (%o4)                           3


 -- Função: cartesian_product (<b_1>, ... , <b_n>)
     Retorna um conjunto de listas da forma `[<x_1>, ..., <x_n>]', onde
     <x_1>, ..., <x_n> são elementos dos conjuntos <b_1>, ... , <b_n>,
     respectivamente.

     `cartesian_product' falha se qualquer argumento não for um
     conjunto literal.

     Exemplos:

          (%i1) cartesian_product ({0, 1});
          (%o1)                      {[0], [1]}
          (%i2) cartesian_product ({0, 1}, {0, 1});
          (%o2)           {[0, 0], [0, 1], [1, 0], [1, 1]}
          (%i3) cartesian_product ({x}, {y}, {z});
          (%o3)                      {[x, y, z]}
          (%i4) cartesian_product ({x}, {-1, 0, 1});
          (%o4)              {[x, - 1], [x, 0], [x, 1]}

 -- Função: disjoin (<x>, <a>)
     Retorna o conjunto <a> sem o elemento <x>.  Se <x> não for um
     elemento de <a>, retorna <a> sem modificações.

     `disjoin' reclama se <a> não for um conjunto literal.

     `disjoin(<x>, <a>)', `delete(<x>, <a>)', e `setdifference(<a>,
     set(<x>))' são todos equivalentes.  Desses, `disjoin' é geralmente
     mais rápido que os outros.

     Exemplos:

          (%i1) disjoin (a, {a, b, c, d});
          (%o1)                       {b, c, d}
          (%i2) disjoin (a + b, {5, z, a + b, %pi});
          (%o2)                      {5, %pi, z}
          (%i3) disjoin (a - b, {5, z, a + b, %pi});
          (%o3)                  {5, %pi, b + a, z}


 -- Função: disjointp (<a>, <b>)
     Retorna `true' se e somente se os conjuntos <a> e <b> forem
     disjuntos.

     `disjointp' falha se ou <a> ou <b> não forem conjuntos literais.

     Exemplos:

          (%i1) disjointp ({a, b, c}, {1, 2, 3});
          (%o1)                         true
          (%i2) disjointp ({a, b, 3}, {1, 2, 3});
          (%o2)                         false


 -- Função: divisors (<n>)
     Representa o conjunto dos divisores de <n>.

     `divisors(<n>)' produz um conjunto de divisores inteiros quando
     <n> for um inteiro não nulo. O conjunto dos divisores inclui os
     elementos 1 e <n>. Os divisores de um inteiro negativo são os
     divisores do seu valor absoluto.

     `divisors', aplicada a equações, listas, matrizes e conjuntos, é
     calculada em forma distributiva.

     Exemplos:

     Podemos verificar que 28 é um número perfeito: a adição dos seus
     divisores (excepto o próprio 28) é 28.

          (%i1) s: divisors(28);
          (%o1)                 {1, 2, 4, 7, 14, 28}
          (%i2) lreduce ("+", args(s)) - 28;
          (%o2)                          28

     `divisors' é uma função de simplificação.  Substituindo 8 por `a'
     em `divisors(a)' calcula os divisores sem ser preciso pedir que
     `divisors(8)' seja reavaliada.

          (%i1) divisors (a);
          (%o1)                      divisors(a)
          (%i2) subst (8, a, %);
          (%o2)                     {1, 2, 4, 8}

     `divisors', aplicada a equações, listas, matrizes e conjuntos, é
     calculada em forma distributiva.

          (%i1) divisors (a = b);
          (%o1)               divisors(a) = divisors(b)
          (%i2) divisors ([a, b, c]);
          (%o2)        [divisors(a), divisors(b), divisors(c)]
          (%i3) divisors (matrix ([a, b], [c, d]));
                            [ divisors(a)  divisors(b) ]
          (%o3)             [                          ]
                            [ divisors(c)  divisors(d) ]
          (%i4) divisors ({a, b, c});
          (%o4)        {divisors(a), divisors(b), divisors(c)}

 -- Função: elementp (<x>, <a>)
     Retorna `true' se e somente se <x> for um elemento do conjunto <a>.

     `elementp' falha se <a> não for um conjunto literal.

     Exemplos:

          (%i1) elementp (sin(1), {sin(1), sin(2), sin(3)});
          (%o1)                         true
          (%i2) elementp (sin(1), {cos(1), cos(2), cos(3)});
          (%o2)                         false


 -- Função: emptyp (<a>)
     Retorna `true' se e somente se <a> for o conjunto vazio ou uma
     lista vazia.

     Exemplos:

          (%i1) map (emptyp, [{}, []]);
          (%o1)                     [true, true]
          (%i2) map (emptyp, [a + b, {{}}, %pi]);
          (%o2)                 [false, false, false]

 -- Função: equiv_classes (<s>, <F>)
     Retorna um conjunto das classes de equivalências do conjunto <s>
     com relação à relação de equivalência <F>.

     <F> é uma função de duas variáveis definida sobre o produto
     cartesiano <s> por <s>.  O valor de retorno de <F> é ou `true' ou
     `false', ou uma expressão <expr> tal que `is(<expr>)' é ou `true'
     ou `false'.

     Quando <F> nõ for uma relação de equivalência, `equiv_classes'
     aceita-a sem reclamação, mas o resultado é geralmente incorrecto
     nesse caso.

     Exemplos:

     A relação de equivalência é uma expressão lambda a qual retorna
     `true' ou `false'.

          (%i1) equiv_classes ({1, 1.0, 2, 2.0, 3, 3.0}, lambda ([x, y], is (equal (x, y))));
          (%o1)            {{1, 1.0}, {2, 2.0}, {3, 3.0}}

     A relação de equivalência é o nome de uma função relacional que
     avalia para `true' ou `false'.

          (%i1) equiv_classes ({1, 1.0, 2, 2.0, 3, 3.0}, equal);
          (%o1)            {{1, 1.0}, {2, 2.0}, {3, 3.0}}

     As classes de equivalência são números que diferem por um múltiplo
     de 3.

          (%i1) equiv_classes ({1, 2, 3, 4, 5, 6, 7}, lambda ([x, y], remainder (x - y, 3) = 0));
          (%o1)              {{1, 4, 7}, {2, 5}, {3, 6}}

 -- Função: every (<f>, <s>)
 -- Função: every (<f>, <L_1>, ..., <L_n>)
     Retorna `true' se o predicado <f> for `true' para todos os
     argumentos fornecidos.

     Dado um conjunto como segundo argumento, `every(<f>, <s>)' retorna
     `true' se `is(<f>(<a_i>))' retornar `true' para todos os <a_i> em
     <s>.  `every' pode ou não avaliar <f> para todos os <a_i> em <s>.
     Uma vez que os conjuntos são desordenados, `every' pode avaliar
     `<f>(<a_i>)' em qualquer ordem.

     Dada uma ou mais listas como argumentos, `every(<f>, <L_1>, ...,
     <L_n>)' retorna `true' se `is(<f>(<x_1>, ..., <x_n>))' retornar
     `true' para todos os <x_1>, ..., <x_n> em <L_1>, ..., <L_n>,
     respectivamente. `every' pode ou não avaliar <f> para toda
     combinação <x_1>, ..., <x_n>.  `every' avalia listas na ordem de
     incremento do índice.

     Dado um conjunto vazio `{}' ou uma lista vazia `[]' como
     argumentos, `every' retorna `false'.

     Quando o sinalizador global `maperror' for `true', todas as listas
     <L_1>, ..., <L_n> deverão ter o mesmo comprimento.  Quando
     `maperror' for falso, as listas dadas como argumentos serão
     efectivamente truncadas para o comprimento da menor lista.

     Os resultados do predicado <f> que avaliarem (via `is') para algo
     diferente de `true' ou `false' são governados através da variável
     global `prederror'. Quando `prederror' for `true', tais valores
     são tratados como `false', e o valor de retorno de `every' é
     `false'.  Quando `prederror' for `false', tais valores são
     tratados como `unknown', e o valor de retorno de `every' é
     `unknown'.

     Exemplos:

     `every' aplicada a um conjunto simples. O predicado é uma
     função de um argumento.

          (%i1) every (integerp, {1, 2, 3, 4, 5, 6});
          (%o1)                         true
          (%i2) every (atom, {1, 2, sin(3), 4, 5 + y, 6});
          (%o2)                         false

     `every' aplicada a duas listas. O predicado é uma função de dois
     argumentos.

          (%i1) every ("=", [a, b, c], [a, b, c]);
          (%o1)                         true
          (%i2) every ("#", [a, b, c], [a, b, c]);
          (%o2)                         false

     Predicado <f> que produz resultados diferentes de `true' ou
     `false', governados por meio da variável global `prederror'.

          (%i1) prederror : false;
          (%o1)                         false
          (%i2) map (lambda ([a, b], is (a < b)), [x, y, z], [x^2, y^2, z^2]);
          (%o2)              [unknown, unknown, unknown]
          (%i3) every ("<", [x, y, z], [x^2, y^2, z^2]);
          (%o3)                        unknown
          (%i4) prederror : true;
          (%o4)                         true
          (%i5) every ("<", [x, y, z], [x^2, y^2, z^2]);
          (%o5)                         false


 -- Função: extremal_subset (<s>, <f>, max)
 -- Função: extremal_subset (<s>, <f>, min)
     Encontra o subconjunto de <s> para o qual a função <f> toma
     valores máximos ou mínimos.

     `extremal_subset(<s>, <f>, max)' encontra o subconjunto do
     conjunto ou lista <s> para os quais a função real <f> assume um
     valor máximo.

     `extremal_subset(<s>, <f>, min)' encontra o subconjunto do
     conjunto ou lista <s> para a qual a função real <f> assume um
     valor mínimo.

     Exemplos:

          (%i1) extremal_subset ({-2, -1, 0, 1, 2}, abs, max);
          (%o1)                       {- 2, 2}
          (%i2) extremal_subset ({sqrt(2), 1.57, %pi/2}, sin, min);
          (%o2)                       {sqrt(2)}

 -- Função: flatten (<expr>)
     Colecta argumentos de subexpressões que possuem o mesmo operador
     que <expr> e constrói uma expressão a partir desses argumentos
     colectados.

     Subexpressões nas quais o operador é diferente do operador
     principal de `expr' são copiadas sem modificação, mesmo se tiverem
     subexpressões com o mesmo operador que `expr'.

     É possível que `flatten' construia expressões nas quais o número
     de argumentos difira dos argumentos declarados para um operador;
     isso pode provocar uma mensagem de erro do simplificador ou do
     avaliador.  `flatten' não tenta detectar tais situações.

     Expressões com representações especiais, por exemplo, expressões
     racionais canónicas (CRE), não podem usar a função `flatten';
     nesses casos, `flatten' retorna os seus argumentos sem
     modificação.

     Exemplos:

     Aplicado a uma lista, `flatten' reúne todos os elementos da lista
     que sejam listas.

          (%i1) flatten ([a, b, [c, [d, e], f], [[g, h]], i, j]);
          (%o1)            [a, b, c, d, e, f, g, h, i, j]

     Aplicado a um conjunto, `flatten' reúne todos os elementos do
     conjunto que sejam conjuntos.

          (%i1) flatten ({a, {b}, {{c}}});
          (%o1)                       {a, b, c}
          (%i2) flatten ({a, {[a], {a}}});
          (%o2)                       {a, [a]}

     o efeito de `flatten' é similar a declarar o operador principal
     para ser enário. No entanto, `flatten' não faz efeito sobre
     subexpressões que possuem um operador diferente do operador
     principal, enquanto uma declaração enária faz efeito.

          (%i1) expr: flatten (f (g (f (f (x)))));
          (%o1)                     f(g(f(f(x))))
          (%i2) declare (f, nary);
          (%o2)                         done
          (%i3) ev (expr);
          (%o3)                      f(g(f(x)))

     `flatten' trata funções subscritas da mesma forma que qualquer
     outro operador.

          (%i1) flatten (f[5] (f[5] (x, y), z));
          (%o1)                      f (x, y, z)
                                      5

     É possível que `flatten' construa expressões nas quais o número de
     argumentos difira dos argumentos declarados para um operador;

          (%i1) 'mod (5, 'mod (7, 4));
          (%o1)                   mod(5, mod(7, 4))
          (%i2) flatten (%);
          (%o2)                     mod(5, 7, 4)
          (%i3) ''%, nouns;
          Wrong number of arguments to mod
           -- an error.  Quitting.  To debug this try debugmode(true);

 -- Função: full_listify (<a>)
     Substitui todo operador de conjunto em <a> por um operador de
     lista, e retorna o resultado. `fullt_listify' substitui operadores
     de conjunto em subexpressões aninhadas, mesmo se o operador
     principal não for (`set').

     `listify' substitui unicamente o operador principal.

     Exemplos:

          (%i1) full_listify ({a, b, {c, {d, e, f}, g}});
          (%o1)               [a, b, [c, [d, e, f], g]]
          (%i2) full_listify (F (G ({a, b, H({c, d, e})})));
          (%o2)              F(G([a, b, H([c, d, e])]))


 -- Função: fullsetify (<a>)
     Quando <a> for uma lista, substitui o operador de lista por um
     operador de conjunto, e aplica `fullsetify' a cada elemento que for
     um conjunto.  Quando <a> não for uma lista, o resultado é <a> na
     sua forma original e sem modificações.

     `setify' substitui unicamente o operador principal.

     Exemplos:

     Na linha (%o2), o argumento de `f' não é convertido para um
     conjunto porque o operador principal de `f([b])' não é uma lista.

          (%i1) fullsetify ([a, [a]]);
          (%o1)                       {a, {a}}
          (%i2) fullsetify ([a, f([b])]);
          (%o2)                      {a, f([b])}


 -- Função: identity (<x>)
     Retorna <x> para qualquer argumento <x>.

     Exemplos:

     `identity' pode ser usado como um predicado quando os argumentos
     forem valores Booleanos.

          (%i1) every (identity, [true, true]);
          (%o1)                         true

 -- Função: integer_partitions (<n>)
 -- Função: integer_partitions (<n>, <len>)
     Calcula partições inteiras de <n>, isto é, listas de inteiros cuja
     soma dos elementos de cada lista é <n>.

     `integer_partitions(<n>)' encontra o conjunto de todas as
     partições do inteiro <n>. Cada partição é uma lista ordenada do
     maior para o menor.

     `integer_partitions(<n>, <len>)' encontra todas as partições com
     comprimento <len> ou menor; nesse caso, serão adicionados zeros ao
     final de cada partição de comprimento menor que <len>, para fazer
     com que todas as partições tenham exactamente <len> termos.  Cada
     partição é uma lista ordenada do maior para o menor.

     Uma lista [a_1, ..., a_m] é uma partição de um inteiro não
     negativo n quando: (1) cada a_i é um inteiro não nulo, e (2) a_1 +
     ... + a_m = n. Dessa forma, 0 não tem partições.

     Exemplos:

          (%i1) integer_partitions (3);
          (%o1)               {[1, 1, 1], [2, 1], [3]}
          (%i2) s: integer_partitions (25)$
          (%i3) cardinality (s);
          (%o3)                         1958
          (%i4) map (lambda ([x], apply ("+", x)), s);
          (%o4)                         {25}
          (%i5) integer_partitions (5, 3);
          (%o5) {[2, 2, 1], [3, 1, 1], [3, 2, 0], [4, 1, 0], [5, 0, 0]}
          (%i6) integer_partitions (5, 2);
          (%o6)               {[3, 2], [4, 1], [5, 0]}

     Para encontrar todas as partições que satisfazem uma condição, use
     a função `subset'; aqui está um exemplo que encontra todas as
     partições de 10 cujos elementos da lista são números primos.

          (%i1) s: integer_partitions (10)$
          (%i2) cardinality (s);
          (%o2)                          42
          (%i3) xprimep(x) := integerp(x) and (x > 1) and primep(x)$
          (%i4) subset (s, lambda ([x], every (xprimep, x)));
          (%o4) {[2, 2, 2, 2, 2], [3, 3, 2, 2], [5, 3, 2], [5, 5], [7, 3]}


 -- Função: intersect (<a_1>, ..., <a_n>)
     `intersect' é o mesmo que `intersection', como veremos.


 -- Função: intersection (<a_1>, ..., <a_n>)
     Retorna um conjunto contendo os elementos que são comuns aos
     conjuntos <a_1> até <a_n>.

     `intersection' falha se qualquer dos argumentos não for um
     conjunto literal.

     Exemplos:

          (%i1) S_1 : {a, b, c, d};
          (%o1)                     {a, b, c, d}
          (%i2) S_2 : {d, e, f, g};
          (%o2)                     {d, e, f, g}
          (%i3) S_3 : {c, d, e, f};
          (%o3)                     {c, d, e, f}
          (%i4) S_4 : {u, v, w};
          (%o4)                       {u, v, w}
          (%i5) intersection (S_1, S_2);
          (%o5)                          {d}
          (%i6) intersection (S_2, S_3);
          (%o6)                       {d, e, f}
          (%i7) intersection (S_1, S_2, S_3);
          (%o7)                          {d}
          (%i8) intersection (S_1, S_2, S_3, S_4);
          (%o8)                          {}


 -- Função: kron_delta (<x>, <y>)
     Representa a função delta de Kronecker.

     `kron_delta' simplifica para 1 quando <x> e <y> forem idênticos ou
     equivalentes, e simplifica para 0 quando <x> e <y> não forem
     equivalentes. De outra forma, se não for certo que <x> e <y> são
     equivalentes, `kron_delta' simplificará para uma expressão
     substantiva. `kron_delta' implementa uma política de segurança
     para expressões em ponto flutuante: se a diferença `<x> - <y>' for
     um número em ponto flutuante, `kron_delta' simplifica para uma
     expressão substantiva quando <x> for aparentemente equivalente a
     <y>.

     Especificamente, `kron_delta(<x>, <y>)' simplifica para 1 quando
     `is(x = y)' for `true'. `kron_delta' também simplifica para 1
     quando `sign(abs(<x> - <y>))' for `zero' e `<x> - <y>' não for um
     número em ponto flutuante (e também não for um número de precisão
     simples em ponto flutuante nem um número de precisão dupla em poto
     flutuante, isto é, não for um bigfloat). `kron_delta' simplifica
     para 0 quando `sign(abs(<x> - <y>))' for `pos'.

     Caso contrário, `sign(abs(<x> - <y>))' é diferente de `pos' ou
     `zero', ou é `zero' e `<x> - <y>' é um número em ponto flutuante.
     Nesses casos, `kron_delta' retorna um expressão substantiva.

     `kron_delta' é declarada como sendo simétrica. Isto é,
     `kron_delta(<x>, <y>)' é igual a `kron_delta(<y>, <x>)'.

     Exemplos:

     Os argumentos de `kron_delta' são idênticos. `kron_delta'
     simplifica para 1.

          (%i1) kron_delta (a, a);
          (%o1)                           1
          (%i2) kron_delta (x^2 - y^2, x^2 - y^2);
          (%o2)                           1
          (%i3) float (kron_delta (1/10, 0.1));
          (%o3)                           1

     Os argumentos de `kron_delta' são equivalentes, e a diferença
     entre eles não é um número em ponto flutuante.  `kron_delta'
     simplifica para 1.

          (%i1) assume (equal (x, y));
          (%o1)                     [equal(x, y)]
          (%i2) kron_delta (x, y);
          (%o2)                           1

     Os argumentos de `kron_delta' não são equivalentes.  `kron_delta'
     simplifica para 0.

          (%i1) kron_delta (a + 1, a);
          (%o1)                           0
          (%i2) assume (a > b)$
          (%i3) kron_delta (a, b);
          (%o3)                           0
          (%i4) kron_delta (1/5, 0.7);
          (%o4)                           0

     Os argumentos de `kron_delta' podem ou não ser equivalentes.
     `kron_delta' simplifica para uma expressão substantiva.

          (%i1) kron_delta (a, b);
          (%o1)                   kron_delta(a, b)
          (%i2) assume(x >= y)$
          (%i3) kron_delta (x, y);
          (%o3)                   kron_delta(x, y)

     Os argumentos de `kron_delta' são equivalentes, mas a
     diferença entre eles é um número em ponto flutuante.  `kron_delta'
     simplifica para uma expressão substantiva.

          (%i1) 1/4 - 0.25;
          (%o1)                          0.0
          (%i2) 1/10 - 0.1;
          (%o2)                          0.0
          (%i3) 0.25 - 0.25b0;
          Warning:  Float to bigfloat conversion of 0.25
          (%o3)                         0.0b0
          (%i4) kron_delta (1/4, 0.25);
                                            1
          (%o4)                  kron_delta(-, 0.25)
                                            4
          (%i5) kron_delta (1/10, 0.1);
                                            1
          (%o5)                  kron_delta(--, 0.1)
                                            10
          (%i6) kron_delta (0.25, 0.25b0);
          Warning:  Float to bigfloat conversion of 0.25
          (%o6)               kron_delta(0.25, 2.5b-1)

     `kron_delta' é simétrica.

          (%i1) kron_delta (x, y);
          (%o1)                   kron_delta(x, y)
          (%i2) kron_delta (y, x);
          (%o2)                   kron_delta(x, y)
          (%i3) kron_delta (x, y) - kron_delta (y, x);
          (%o3)                           0
          (%i4) is (equal (kron_delta (x, y), kron_delta (y, x)));
          (%o4)                         true
          (%i5) is (kron_delta (x, y) = kron_delta (y, x));
          (%o5)                         true


 -- Função: listify (<a>)
     Retorna uma lista contendo os elementos de <a> quando <a> for um
     conjunto. De outra forma, `listify' retorna <a>.

     `full_listify' substitui todos os operadores de conjunto em <a>
     por operadores de lista.

     Exemplos:

          (%i1) listify ({a, b, c, d});
          (%o1)                     [a, b, c, d]
          (%i2) listify (F ({a, b, c, d}));
          (%o2)                    F({a, b, c, d})


 -- Função: lreduce (<F>, <s>)
 -- Função: lreduce (<F>, <s>, <s_0>)
     Extende a função de dois argumentos <F> para uma função de `n'
     argumentos, usando composição, onde <s> é uma lista.

     `lreduce(<F>, <s>)' retorna `F(... F(F(s_1, s_2), s_3), ... s_n)'.
     Quando o argumento opcional <s_0> estiver presente, o resultado é
     equivalente a `lreduce(<F>, cons(<s_0>, <s>))'.

     A função <F> é aplicada primeiro aos elementos mais à _esquerda_
     de lista; daí o nome "lreduce".

     Veja também `rreduce', `xreduce', e `tree_reduce'.

     Exemplos:

     `lreduce' sem o argumento opcional.

          (%i1) lreduce (f, [1, 2, 3]);
          (%o1)                     f(f(1, 2), 3)
          (%i2) lreduce (f, [1, 2, 3, 4]);
          (%o2)                  f(f(f(1, 2), 3), 4)

     `lreduce' com o argumento opcional.

          (%i1) lreduce (f, [1, 2, 3], 4);
          (%o1)                  f(f(f(4, 1), 2), 3)

     `lreduce' aplicada a operadores binários internos do Maxima `/' é
     o operador de divisão.

          (%i1) lreduce ("^", args ({a, b, c, d}));
                                         b c d
          (%o1)                       ((a ) )
          (%i2) lreduce ("/", args ({a, b, c, d}));
                                          a
          (%o2)                         -----
                                        b c d


 -- Função: makeset (<expr>, <x>, <s>)
     Retorna um conjunto com elementos gerados a partir da expressão
     <expr>, onde <x> é uma lista de variáveis em <expr>, e <s>é um
     conjunto ou lista de listas.  Para gerar cada elemento do
     conjunto, <expr> é avaliada com as variáveis <x> substituídas, em
     paralelo, por elementos de <s>.

     Cada elemento de <s> deve ter o mesmo comprimento que <x>.  A
     lista de variáveis <x> deve ser uma lista de símbolos, sem
     índices.  Mesmo se existir somente um símbolo, <x> deve ser uma
     lista de um elemento, e cada elemento de <s> deve ser uma lista de
     um elemento.

     Veja também `makelist'.

     Exemplos:

          (%i1) makeset (i/j, [i, j], [[1, a], [2, b], [3, c], [4, d]]);
                                     1  2  3  4
          (%o1)                     {-, -, -, -}
                                     a  b  c  d
          (%i2) S : {x, y, z}$
          (%i3) S3 : cartesian_product (S, S, S);
          (%o3) {[x, x, x], [x, x, y], [x, x, z], [x, y, x], [x, y, y],
          [x, y, z], [x, z, x], [x, z, y], [x, z, z], [y, x, x],
          [y, x, y], [y, x, z], [y, y, x], [y, y, y], [y, y, z],
          [y, z, x], [y, z, y], [y, z, z], [z, x, x], [z, x, y],
          [z, x, z], [z, y, x], [z, y, y], [z, y, z], [z, z, x],
          [z, z, y], [z, z, z]}
          (%i4) makeset (i + j + k, [i, j, k], S3);
          (%o4) {3 x, 3 y, y + 2 x, 2 y + x, 3 z, z + 2 x, z + y + x,
                                                 z + 2 y, 2 z + x, 2 z + y}
          (%i5) makeset (sin(x), [x], {[1], [2], [3]});
          (%o5)               {sin(1), sin(2), sin(3)}

 -- Função: moebius (<n>)
     Representa a função de Moebius.

     Quando <n> for o produto de k primos distintos, `moebius(<n>)'
     simplifica para (-1)^k; quando <n> = 1, simplifica para 1; e
     simplifica para 0 para todos os outros inteiros positivos.

     `moebius', aplicada a equações, listas, matrizes e conjuntos, é
     calculada em forma distributiva.

     Exemplos:

          (%i1) moebius (1);
          (%o1)                           1
          (%i2) moebius (2 * 3 * 5);
          (%o2)                          - 1
          (%i3) moebius (11 * 17 * 29 * 31);
          (%o3)                           1
          (%i4) moebius (2^32);
          (%o4)                           0
          (%i5) moebius (n);
          (%o5)                      moebius(n)
          (%i6) moebius (n = 12);
          (%o6)                    moebius(n) = 0
          (%i7) moebius ([11, 11 * 13, 11 * 13 * 15]);
          (%o7)                      [- 1, 1, 1]
          (%i8) moebius (matrix ([11, 12], [13, 14]));
                                     [ - 1  0 ]
          (%o8)                      [        ]
                                     [ - 1  1 ]
          (%i9) moebius ({21, 22, 23, 24});
          (%o9)                      {- 1, 0, 1}


 -- Função: multinomial_coeff (<a_1>, ..., <a_n>)
 -- Função: multinomial_coeff ()
     Calcula o coeficiente multinomial.

     Quando cada <a_k> for um inteiro não negativo, o coeficiente
     multinomial indica o número de formas possíveis de colocar `<a_1>
     + ... + <a_n>' objectos distintos em n caixas com <a_k> elementos
     na k'ésima caixa. Em geral, `multinomial_coeff (<a_1>, ...,
     <a_n>)' calcula `(<a_1> + ... + <a_n>)!/(<a_1>! ... <a_n>!)'.

     `multinomial_coeff()' (sem argumentos) produz 1.

     `minfactorial' poderá conseguir simplificar o valor calculado por
     `multinomial_coeff'.

     Exemplos:

          (%i1) multinomial_coeff (1, 2, x);
                                      (x + 3)!
          (%o1)                       --------
                                        2 x!
          (%i2) minfactorial (%);
                               (x + 1) (x + 2) (x + 3)
          (%o2)                -----------------------
                                          2
          (%i3) multinomial_coeff (-6, 2);
                                       (- 4)!
          (%o3)                       --------
                                      2 (- 6)!
          (%i4) minfactorial (%);
          (%o4)                          10

 -- Função: num_distinct_partitions (<n>)
 -- Função: num_distinct_partitions (<n>, list)
     Calcula o n;umero de partições de inteiros distintos de <n> quando
     <n> for um inteiro não negativo.  De outra forma,
     `num_distinct_partitions' retorna uma expressão substantiva.

     `num_distinct_partitions(<n>, list)' retorna uma lista do número
     de partições distintas de 1, 2, 3, ..., <n>.

     Uma partição distinta de <n> é uma lista de inteiros positivos
     distintos k_1, ..., k_m tais que <n> = k_1 + ... + k_m.

     Exemplos:

          (%i1) num_distinct_partitions (12);
          (%o1)                          15
          (%i2) num_distinct_partitions (12, list);
          (%o2)      [1, 1, 1, 2, 2, 3, 4, 5, 6, 8, 10, 12, 15]
          (%i3) num_distinct_partitions (n);
          (%o3)              num_distinct_partitions(n)


 -- Função: num_partitions (<n>)
 -- Função: num_partitions (<n>, list)
     Calcula o número das partições inteiras de <n> quando <n> for um
     inteiro não negativo.  De outra forma, `num_partitions' retorna
     uma expressão substantiva.

     `num_partitions(<n>, list)' retorna uma lista do número de
     partições inteiras de 1, 2, 3, ..., <n>.

     Para um inteiro não negativo <n>, `num_partitions(<n>)' é igual a
     `cardinality(integer_partitions(<n>))'; todavia, `num_partitions'
     não constrói actualmente o conjunto das partições, nesse sentido
     `num_partitions' é mais rápida.

     Exemplos:

          (%i1) num_partitions (5) = cardinality (integer_partitions (5));
          (%o1)                         7 = 7
          (%i2) num_partitions (8, list);
          (%o2)            [1, 1, 2, 3, 5, 7, 11, 15, 22]
          (%i3) num_partitions (n);
          (%o3)                   num_partitions(n)


 -- Função: partition_set (<a>, <f>)
     Partições do conjunto <a> que satisfazem o predicado <f>.

     `partition_set' retorna uma lista de dois conjuntos.  O primeiro
     conjunto compreende os elementos de <a> para os quais <f> avalia
     para `false', e o segundo conjunto compreende quaisquer outros
     elementos de <a>.  `partition_set' não aplica `is' ao valor de
     retorno de <f>.

     `partition_set' reclama se <a> não for um conjunto literal.

     Veja também `subset'.

     Exemplos:

          (%i1) partition_set ({2, 7, 1, 8, 2, 8}, evenp);
          (%o1)                   [{1, 7}, {2, 8}]
          (%i2) partition_set ({x, rat(y), rat(y) + z, 1}, lambda ([x], ratp(x)));
          (%o2)/R/              [{1, x}, {y, y + z}]

 -- Função: permutations (<a>)
     Retorna um conjunto todas as permutações distintas dos elementos da
     lista ou do conjunto <a>. Cada permutação é uma lista, não um
     conjunto.

     Quando <a> for uma lista, elementos duplicados de <a> são incluídos
     nas permutações.

     `permutations' reclama se <a> não for um conjunto literal ou uma
     lista literal.

     Exemplos:

          (%i1) permutations ([a, a]);
          (%o1)                       {[a, a]}
          (%i2) permutations ([a, a, b]);
          (%o2)           {[a, a, b], [a, b, a], [b, a, a]}


 -- Função: powerset (<a>)
 -- Função: powerset (<a>, <n>)
     Retorna o conjunto de todos os dubconjuntos de <a>, ou um
     subconjunto de <a>.

     `powerset(<a>)' retorna o conjunto de todos os subconjuntos do
     conjunto <a>.  `powerset(<a>)' tem `2^cardinality(<a>)' elementos.

     `powerset(<a>, <n>)' retorna o conjunto de todos os subconjuntos
     de <a> que possuem cardinalidade <n>.

     `powerset' reclama se <a> não for um conjunto literal, ou se <n>
     não for um inteiro não negativo.

     Exemplos:

          (%i1) powerset ({a, b, c});
          (%o1) {{}, {a}, {a, b}, {a, b, c}, {a, c}, {b}, {b, c}, {c}}
          (%i2) powerset ({w, x, y, z}, 4);
          (%o2)                    {{w, x, y, z}}
          (%i3) powerset ({w, x, y, z}, 3);
          (%o3)     {{w, x, y}, {w, x, z}, {w, y, z}, {x, y, z}}
          (%i4) powerset ({w, x, y, z}, 2);
          (%o4)   {{w, x}, {w, y}, {w, z}, {x, y}, {x, z}, {y, z}}
          (%i5) powerset ({w, x, y, z}, 1);
          (%o5)                 {{w}, {x}, {y}, {z}}
          (%i6) powerset ({w, x, y, z}, 0);
          (%o6)                         {{}}


 -- Função: rreduce (<F>, <s>)
 -- Função: rreduce (<F>, <s>, <s_{n + 1}>)
     Extende a função de dois argumentos <F> para uma função de <n>
     argumentos usando composição de funções, onde <s> é uma lista.

     `rreduce(<F>, <s>)' retorna `F(s_1, ... F(s_{n - 2}, F(s_{n - 1},
     s_n)))'.  Quando o argumento opcional <s_{n + 1}> estiver presente,
     o resultado é equivalente a `rreduce(<F>, endcons(<s_{n + 1}>,
     <s>))'.

     A função <F> é primeiro aplicada à lista de elementos mais à
     direita - rightmost, daí o nome "rreduce".

     Veja também `lreduce', `tree_reduce', e `xreduce'.

     Exemplos:

     `rreduce' sem o argumento opcional.

          (%i1) rreduce (f, [1, 2, 3]);
          (%o1)                     f(1, f(2, 3))
          (%i2) rreduce (f, [1, 2, 3, 4]);
          (%o2)                  f(1, f(2, f(3, 4)))

     `rreduce' com o argumento opcional.

          (%i1) rreduce (f, [1, 2, 3], 4);
          (%o1)                  f(1, f(2, f(3, 4)))

     `rreduce' aplicada a operadores de dois argumentos internos (
     definidos por padrão) ao Maxima.  `/' é o operadro de divisão.

          (%i1) rreduce ("^", args ({a, b, c, d}));
                                           d
                                          c
                                         b
          (%o1)                         a
          (%i2) rreduce ("/", args ({a, b, c, d}));
                                         a c
          (%o2)                          ---
                                         b d


 -- Função: setdifference (<a>, <b>)
     Retorna um conjunto contendo os elementos no conjunto <a> que não
     estãono conjunto <b>.

     `setdifference' reclama se ou <a> ou <b> não for um conjunto
     literal.

     Exemplos:

          (%i1) S_1 : {a, b, c, x, y, z};
          (%o1)                  {a, b, c, x, y, z}
          (%i2) S_2 : {aa, bb, c, x, y, zz};
          (%o2)                 {aa, bb, c, x, y, zz}
          (%i3) setdifference (S_1, S_2);
          (%o3)                       {a, b, z}
          (%i4) setdifference (S_2, S_1);
          (%o4)                     {aa, bb, zz}
          (%i5) setdifference (S_1, S_1);
          (%o5)                          {}
          (%i6) setdifference (S_1, {});
          (%o6)                  {a, b, c, x, y, z}
          (%i7) setdifference ({}, S_1);
          (%o7)                          {}


 -- Função: setequalp (<a>, <b>)
     Retorna `true' se os conjuntos <a> e <b> possuirem o mesmo número
     de elementos e `is(<x> = <y>)' for `true' para `x' nos elementos
     de <a> e `y' nos elementos de <b>, considerados na ordem
     determinada por `listify'.  De outra forma, `setequalp' retorna
     `false'.

     Exemplos:

          (%i1) setequalp ({1, 2, 3}, {1, 2, 3});
          (%o1)                         true
          (%i2) setequalp ({a, b, c}, {1, 2, 3});
          (%o2)                         false
          (%i3) setequalp ({x^2 - y^2}, {(x + y) * (x - y)});
          (%o3)                         false


 -- Função: setify (<a>)
     Constrói um conjunto de elementos a partir da lista <a>. Elementos
     duplicados da lista <a> são apagados e os elementos são ordenados
     de acordo com o predicado `orderlessp'.

     `setify' reclama se <a> não for uma lista literal.

     Exemplos:

          (%i1) setify ([1, 2, 3, a, b, c]);
          (%o1)                  {1, 2, 3, a, b, c}
          (%i2) setify ([a, b, c, a, b, c]);
          (%o2)                       {a, b, c}
          (%i3) setify ([7, 13, 11, 1, 3, 9, 5]);
          (%o3)                {1, 3, 5, 7, 9, 11, 13}


 -- Função: setp (<a>)
     Retorna `true' se e somente se <a> for um conjunto na
     interpretação do Maxima.

     `setp' retorna `true' para conjuntos não simplificados (isto é,
     conjuntos com elementos redundantes) e também para conjuntos
     simplificados.

     `setp' é equivalente à função do Maxima `setp(a) := not atom(a)
     and op(a) = 'set'.

     Exemplos:

          (%i1) simp : false;
          (%o1)                         false
          (%i2) {a, a, a};
          (%o2)                       {a, a, a}
          (%i3) setp (%);
          (%o3)                         true


 -- Função: set_partitions (<a>)
 -- Função: set_partitions (<a>, <n>)
     Retorna o conjunto de todas as partições de <a>, ou um subconjunto
     daquele conjunto de partições.

     `set_partitions(<a>, <n>)' retorna um conjunto de todas as
     decomposições de <a> em <n> subconjutnos disjuntos não vazios.

     `set_partitions(<a>)' retorna o conjunto de todas as partições.

     `stirling2' retorna a cardinalidade de um conjuntode partições de
     um conjunto.

     Um conjunto de conjuntos P é uma partição de um conjunto S quando

       1. cada elemento de P é um conjunto não vazio,

       2. elementos distintos de P são disjuntos,

       3. a união dos elementos de P é igual a S.

     Exemplos:

     O conjunto vazio é uma partição de si mesmo, as ondições 1 e 2 são
     "vaziamente" verdadeiras.

          (%i1) set_partitions ({});
          (%o1)                         {{}}

     A cardinalidade do conjunto de partições de um conjunto pode ser
     encontrada usando `stirling2'.

          (%i1) s: {0, 1, 2, 3, 4, 5}$
          (%i2) p: set_partitions (s, 3)$
          (%i3) cardinality(p) = stirling2 (6, 3);
          (%o3)                        90 = 90

     Cada elemento de `p' pode ter <n> = 3 elementos; vamos verificar.

          (%i1) s: {0, 1, 2, 3, 4, 5}$
          (%i2) p: set_partitions (s, 3)$
          (%i3) map (cardinality, p);
          (%o3)                          {3}

     Finalmente, para cada elementos de `p', a união de seus elementos
     possivelmente será igua a `s'; novamente vamos comprovar.

          (%i1) s: {0, 1, 2, 3, 4, 5}$
          (%i2) p: set_partitions (s, 3)$
          (%i3) map (lambda ([x], apply (union, listify (x))), p);
          (%o3)                 {{0, 1, 2, 3, 4, 5}}

 -- Função: some (<f>, <a>)
 -- Função: some (<f>, <L_1>, ..., <L_n>)
     Retorna `true' se o predicado <f> for `true' para um ou mais
     argumentos dados.

     Given one set as the second argument, `some(<f>, <s>)' returns
     `true' if `is(<f>(<a_i>))' returns `true' for one or more <a_i> in
     <s>.  `some' may or may not evaluate <f> for all <a_i> in <s>.
     Since sets are unordered, `some' may evaluate `<f>(<a_i>)' in any
     order.

     Dadas uma ou mais listas como argumentos, `some(<f>, <L_1>, ...,
     <L_n>)' retorna `true' se `is(<f>(<x_1>, ..., <x_n>))' retornar
     `true' para um ou mais <x_1>, ..., <x_n> em <L_1>, ..., <L_n>,
     respectivamente.  `some' pode ou não avaliar <f> para algumas
     combinações <x_1>, ..., <x_n>.  `some' avalia listas na ordem do
     índice de incremento.

     Dado um conjunto vazio `{}' ou uma lista vazia `[]' como
     argumentos, `some' retorna `false'.

     Quando o sinalizador global `maperror' for `true', todas as listas
     <L_1>, ..., <L_n> devem ter obrigatóriamente comprimentos iguais.
     Quando `maperror' for `false', argumentos do tipo lista são
     efectivamente truncados para o comprimento da menor lista.

     Retorna o valor de um predicado <f> o qual avalia (por meio de
     `is') para alguma coisa outra que não `true' ou `false' e são
     governados pelo sinalizador global `prederror'.  Quando
     `prederror' for `true', tais valores são tratados como `false'.
     Quando `prederror' for `false', tais valores são tratados como
     `unknown' (desconhecidos).

     Exemplos:

     `some' aplicado a um conjunto simples.  O predicado é uma
     função de um argumento.

          (%i1) some (integerp, {1, 2, 3, 4, 5, 6});
          (%o1)                         true
          (%i2) some (atom, {1, 2, sin(3), 4, 5 + y, 6});
          (%o2)                         true

     `some' aplicada a duas listas.  O predicado é uma função de dois
     argumentos.

          (%i1) some ("=", [a, b, c], [a, b, c]);
          (%o1)                         true
          (%i2) some ("#", [a, b, c], [a, b, c]);
          (%o2)                         false

     Retorna o valor do predicado <f> o qual avalia para alguma coisa
     que não `true' ou `false' e são governados através do sinalizador
     global `prederror'.

          (%i1) prederror : false;
          (%o1)                         false
          (%i2) map (lambda ([a, b], is (a < b)), [x, y, z], [x^2, y^2, z^2]);
          (%o2)              [unknown, unknown, unknown]
          (%i3) some ("<", [x, y, z], [x^2, y^2, z^2]);
          (%o3)                        unknown
          (%i4) some ("<", [x, y, z], [x^2, y^2, z + 1]);
          (%o4)                         true
          (%i5) prederror : true;
          (%o5)                         true
          (%i6) some ("<", [x, y, z], [x^2, y^2, z^2]);
          (%o6)                         false
          (%i7) some ("<", [x, y, z], [x^2, y^2, z + 1]);
          (%o7)                         true

 -- Função: stirling1 (<n>, <m>)
     Representa o número de Stirling de primeiro tipo.

     Quando <n> e <m> forem não negativos inteiros, a magnitude de
     `stirling1 (<n>, <m>)' é o número de permutações de um conjunto
     com <n> elementos que possui <m> ciclos.  Para detalhes, veja
     Graham, Knuth e Patashnik Concrete Mathematics.  Maxima utiliza
     uma relação recursiva para definir `stirling1 (<n>, <m>)' para <m>
     menor que 0; `stirling1' não é definida para <n> menor que 0 e
     para argumentos não inteiros.

     `stirling1' é uma função de simplificação.  Maxima conhece as
     seguintes identidades:

       1. stirling1(0, n) = kron_delta(0, n) (Ref. [1])

       2. stirling1(n, n) = 1 (Ref. [1])

       3. stirling1(n, n - 1) = binomial(n, 2) (Ref. [1])

       4. stirling1(n + 1, 0) = 0 (Ref. [1])

       5. stirling1(n + 1, 1) = n! (Ref. [1])

       6. stirling1(n + 1, 2) = 2^n  - 1 (Ref. [1])

     Essas identidades são aplicadas quando os argumentos forem
     inteiros literais ou símbolos declarados como inteiros, e o
     primeiro argumento for não negativo.  `stirling1' não simplififca
     para argumentos não inteiros.

     Referências:

     [1] Donald Knuth, The Art of Computer Programming, terceira
     edição, Volume 1, Seção 1.2.6, Equações 48, 49, e 50.

     Exemplos:

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling1 (n, n);
          (%o3)                           1

     `stirling1' não simplifica para argumentos não inteiros.

          (%i1) stirling1 (sqrt(2), sqrt(2));
          (%o1)              stirling1(sqrt(2), sqrt(2))

     Maxima aplica identidades a `stirling1'.

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling1 (n + 1, n);
                                      n (n + 1)
          (%o3)                       ---------
                                          2
          (%i4) stirling1 (n + 1, 1);
          (%o4)                          n!

 -- Função: stirling2 (<n>, <m>)
     Representa o número de Stirling de segundo tipo.

     Quando <n> e <m> forem inteiros não negativos, `stirling2 (<n>,
     <m>)' é o número de maneiras através dos quais um conjunto com
     cardinalidade <n> pode ser particionado em <m> subconjuntos
     disjuntos.  Maxima utiliza uma relação recursiva para definir
     `stirling2 (<n>, <m>)' para <m> menor que 0; `stirling2' é
     indefinida para <n> menor que 0 e para argumentos não inteiros.

     `stirling2' é uma função de simplificação.  Maxima conhece as
     seguintes identidades.

       1. stirling2(0, n) = kron_delta(0, n) (Ref. [1])

       2. stirling2(n, n) = 1 (Ref. [1])

       3. stirling2(n, n - 1) = binomial(n, 2) (Ref. [1])

       4. stirling2(n + 1, 1) = 1 (Ref. [1])

       5. stirling2(n + 1, 2) = 2^n  - 1 (Ref. [1])

       6. stirling2(n, 0) = kron_delta(n, 0) (Ref. [2])

       7. stirling2(n, m) = 0 when m > n (Ref. [2])

       8. stirling2(n, m) = sum((-1)^(m - k) binomial(m k) k^n,i,1,m) /
          m!  onde m e n são inteiros, e n é não negativo. (Ref. [3])

     Essas identidades são aplicadas quando os argumentos forem
     inteiros literais ou símbolos declarados como inteiros, e o
     primeiro argumento for não negativo.  `stirling2' não simplifica
     para argumentos não inteiros.

     Referências:

     [1] Donald Knuth. The Art of Computer Programming, terceira
     edição, Volume 1, Seção 1.2.6, Equações 48, 49, e 50.

     [2] Graham, Knuth, e Patashnik. Concrete Mathematics, Tabela 264.

     [3] Abramowitz e Stegun. Handbook of Mathematical Functions,
     Seção 24.1.4.

     Exemplos:

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling2 (n, n);
          (%o3)                           1

     `stirling2' não simplifica para argumentos não inteiros.

          (%i1) stirling2 (%pi, %pi);
          (%o1)                  stirling2(%pi, %pi)

     Maxima aplica identidades a `stirling2'.

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling2 (n + 9, n + 8);
                                   (n + 8) (n + 9)
          (%o3)                    ---------------
                                          2
          (%i4) stirling2 (n + 1, 2);
                                        n
          (%o4)                        2  - 1

 -- Função: subset (<a>, <f>)
     Retorna o subconjuntode um conjunto <a> que satisfaz o predicado
     <f>.

     `subset' returns um conjunto which comprises the elements of <a>
     for which <f> returns anything other than `false'.  `subset' does
     not apply `is' to the return value of <f>.

     `subset' reclama se <a> não for um conjunto literal.

     See also `partition_set'.

     Exemplos:

          (%i1) subset ({1, 2, x, x + y, z, x + y + z}, atom);
          (%o1)                     {1, 2, x, z}
          (%i2) subset ({1, 2, 7, 8, 9, 14}, evenp);
          (%o2)                      {2, 8, 14}


 -- Função: subsetp (<a>, <b>)
     Retorna `true' se e somente se o conjunto <a> for um subconjunto
     de <b>.

     `subsetp' reclama se ou <a> ou <b> não forem um conjunto literal.

     Exemplos:

          (%i1) subsetp ({1, 2, 3}, {a, 1, b, 2, c, 3});
          (%o1)                         true
          (%i2) subsetp ({a, 1, b, 2, c, 3}, {1, 2, 3});
          (%o2)                         false


 -- Função: symmdifference (<a_1>, ..., <a_n>)
     Retorna a diferença simétrica, isto é, o conjunto dos elemetnos
     que ocorrem em exactamente um conjunto <a_k>.

     Given two arguments, `symmdifference(<a>, <b>)' is the same as
     `union(setdifference(<a>, <b>), setdifference(<b>, <a>))'.

     `symmdifference' reclama se any argument não for um conjunto
     literal.

     Exemplos:

          (%i1) S_1 : {a, b, c};
          (%o1)                       {a, b, c}
          (%i2) S_2 : {1, b, c};
          (%o2)                       {1, b, c}
          (%i3) S_3 : {a, b, z};
          (%o3)                       {a, b, z}
          (%i4) symmdifference ();
          (%o4)                          {}
          (%i5) symmdifference (S_1);
          (%o5)                       {a, b, c}
          (%i6) symmdifference (S_1, S_2);
          (%o6)                        {1, a}
          (%i7) symmdifference (S_1, S_2, S_3);
          (%o7)                        {1, z}
          (%i8) symmdifference ({}, S_1, S_2, S_3);
          (%o8)                        {1, z}


 -- Função: tree_reduce (<F>, <s>)
 -- Função: tree_reduce (<F>, <s>, <s_0>)
     Extende a função binária <F> a uma função enária através de
     composição, onde <s> é um conjunto ou uma lista.

     `tree_reduce' é equivalente ao seguinte: Aplicar <F> a sucessivos
     pares de elementos para formar uma nova lista `[<F>(<s_1>, <s_2>),
     <F>(<s_3>, <s_4>), ...]', mantendo o elemento final inalterado
     caso haja um número ímpar de elementos.  Repetindo então o
     processo até que a lista esteja reduzida a um elemento simples, o
     qual é o valor de retorno da função.

     Quando o argumento opcional <s_0> estiver presente, o resultado é
     equivalente a `tree_reduce(<F>, cons(<s_0>, <s>)'.

     Para adições em ponto flutuante, `tree_reduce' pode retornar uma
     soma que possui um menor ero de arredondamento que `rreduce' ou
     `lreduce'.

     Os elementos da lista <s> e os resultados parciais podem ser
     arranjados em uma árvore binária de profundidade mínima, daí o
     nome "tree_reduce".

     Exemplos:

     `tree_reduce' aplicada a uma lista com um número par de elementos.

          (%i1) tree_reduce (f, [a, b, c, d]);
          (%o1)                  f(f(a, b), f(c, d))

     `tree_reduce' aplicada a uma lista com um número ímpar de
     elementos.

          (%i1) tree_reduce (f, [a, b, c, d, e]);
          (%o1)               f(f(f(a, b), f(c, d)), e)


 -- Função: union (<a_1>, ..., <a_n>)
     Retorna a união dos conjuntos de <a_1> a <a_n>.

     `union()' (sem argumentos) retorna o conjunto vazio.

     `union' reclama se qualquer argumento não for um conjunto literal.

     Exemplos:

          (%i1) S_1 : {a, b, c + d, %e};
          (%o1)                   {%e, a, b, d + c}
          (%i2) S_2 : {%pi, %i, %e, c + d};
          (%o2)                 {%e, %i, %pi, d + c}
          (%i3) S_3 : {17, 29, 1729, %pi, %i};
          (%o3)                {17, 29, 1729, %i, %pi}
          (%i4) union ();
          (%o4)                          {}
          (%i5) union (S_1);
          (%o5)                   {%e, a, b, d + c}
          (%i6) union (S_1, S_2);
          (%o6)              {%e, %i, %pi, a, b, d + c}
          (%i7) union (S_1, S_2, S_3);
          (%o7)       {17, 29, 1729, %e, %i, %pi, a, b, d + c}
          (%i8) union ({}, S_1, S_2, S_3);
          (%o8)       {17, 29, 1729, %e, %i, %pi, a, b, d + c}


 -- Função: xreduce (<F>, <s>)
 -- Função: xreduce (<F>, <s>, <s_0>)
     Extendendo a função <F> para uma função enária por composição, ou,
     se <F> já for enária, aplica-se <F> a <s>.  Quando <F> não for
     enária, `xreduce' funciona da mesma forma que `lreduce'.  O
     argumento <s> é uma lista.

     Funções sabidamente enárias inclui adição `+', multiplicação `*',
     `and', `or', `max', `min', e `append'.  Funções podem também serem
     declaradas enárias por meio de `declare(<F>, nary)'.  Para essas
     funções, é esperado que `xreduce' seja mais rápida que ou
     `rreduce' ou `lreduce'.

     Quando o argumento opcional <s_0> estiver presente, o resultado é
     equivalente a `xreduce(<s>, cons(<s_0>, <s>))'.

     Adições em ponto flutuante não são exactamente associativas;
     quando a associatividade ocorrer, `xreduce' aplica a adição enária
     do Maxima quando <s> contiver números em ponto flutuante.

     Exemplos:

     `xreduce' aplicada a uma função sabidamente enária.  `F' é chamada
     uma vez, com todos os argumentos.

          (%i1) declare (F, nary);
          (%o1)                         done
          (%i2) F ([L]) := L;
          (%o2)                      F([L]) := L
          (%i3) xreduce (F, [a, b, c, d, e]);
          (%o3)         [[[[[("[", simp), a], b], c], d], e]

     `xreduce' aplicada a uma função não sabidamente enária.  `G' é
     chamada muitas vezes, com dois argumentos de cada vez.

          (%i1) G ([L]) := L;
          (%o1)                      G([L]) := L
          (%i2) xreduce (G, [a, b, c, d, e]);
          (%o2)         [[[[[("[", simp), a], b], c], d], e]
          (%i3) lreduce (G, [a, b, c, d, e]);
          (%o3)                 [[[[a, b], c], d], e]



File: maxima.info,  Node: Definição de Função,  Next: Fluxo de Programa,  Prev: Conjuntos,  Up: Top

39 Definição de Função
**********************

* Menu:

* Introdução a Definição de Função::
* Função::
* Macros::
* Definições para Definição de Função::


File: maxima.info,  Node: Introdução a Definição de Função,  Next: Função,  Prev: Definição de Função,  Up: Definição de Função

39.1 Introdução a Definição de Função
=====================================


File: maxima.info,  Node: Função,  Next: Macros,  Prev: Introdução a Definição de Função,  Up: Definição de Função

39.2 Função
===========

39.2.1 Ordinary functions
-------------------------

Para definir uma função no Maxima usa-se o operador :=.  Por exemplo,

     f(x) := sin(x)

define uma função `f'.  Funções anônimas podem também serem criadas
usando `lambda'.  Por exemplo

     lambda ([i, j], ...)

pode ser usada em lugar de `f' onde

     f(i,j) := block ([], ...);
     map (lambda ([i], i+1), l)

retornará uma lista com 1 adicionado a cada termo.

   Pode também definir uma função com um número variável de argumentos,
usando um argumento final que seja uma lista, na qual serão inseridos
todos os argumentos adicionais:

     (%i1) f ([u]) := u;
     (%o1)                      f([u]) := u
     (%i2) f (1, 2, 3, 4);
     (%o2)                     [1, 2, 3, 4]
     (%i3) f (a, b, [u]) := [a, b, u];
     (%o3)               f(a, b, [u]) := [a, b, u]
     (%i4) f (1, 2, 3, 4, 5, 6);
     (%o4)                 [1, 2, [3, 4, 5, 6]]

   O lado direito na definição de uma função é uma expressão. Assim,
quando quiser que a definição seja uma sequência de expressões, poderá
usar a forma
     f(x) := (expr1, expr2, ...., exprn);

   e o valor de <exprn> é que é retornado pela função.

   Se quiser introduzir um ponto de `retorno' em alguma expressão
dentro da função, deverá usar `block' e `return'.

     block ([], expr1, ..., if (a > 10) then return(a), ..., exprn)

   é em si mesma uma expressão, e então poderá ocupar o lugar do lado
direito de uma definição de função.  Aqui pode acontecer que o retorno
aconteça mais facilmente que no exemplo anterior a essa última
expressão.

   O primeiro `[]' no bloco, pode conter uma lista de variáveis e
atribuições de variáveis, tais como `[a: 3, b, c: []]', que farão com
que as três variáveis `a',`b',e `c' não se refiram a seus valores
globais, mas ao contrário tenham esses valores especiais enquanto o
código estiver executando a parte dentro do bloco `block', ou dentro da
funções chamadas de dentro do bloco `block'.  Isso é chamado
associação dynamic, uma vez que as variáveis permanecem do início do
bloco pelo tempo que ele existir. Quando regressar do bloco `block', ou
o descartar, os valores antigos (quaisquer que sejam) das variáveis
serão restaurados.  É certamente uma boa idéia para proteger as suas
variáveis nesse caminho.  Note que as atribuições em variáveis do
bloco, são realizadas em paralelo.  Isso significa, que se tivesse
usado `c: a' acima, o valor de `c' seria o valor que `a' tinha antes do
bloco, antes de ter obtido o seu novo valor atribuído no bloco.  Dessa
forma fazendo alguma coisa como

     block ([a: a], expr1, ...  a: a+3, ..., exprn)

   protegerá o valor externo de `a' de ser alterado, mas impedirá
aceder ao valor antigo. Assim, o lado direito de atribuições, é
avaliado no contexto inserido, antes que qualquer avaliação ocorra.
Usando apenas `block ([x], ...' faremos com que o `x' tenho como valor
a si próprio; esse é o mesmo valor que teria no início de uma sessão do
Maxima.

   Os actuais argumentos para uma função são tratados exactamente da
mesma que as variáveis em um bloco.  Dessa forma em

     f(x) := (expr1, ..., exprn);

   e

     f(1);

   teremos um contexto similar para avaliação de expressões como se
tivéssemos concluído

     block ([x: 1], expr1, ..., exprn)

   Dentro de funções, quando o lado direito de uma definição, pode ser
calculado em tempo de execução, isso é úti para usar `define' e
possivelmente `buildq'.

39.2.2 Função de Array
----------------------

Uma função de Array armazena o valor da função na primeira vez que ela
for chamada com um argumento dado, e retorna o valor armazenado, sem
recalcular esse valor, quando o mesmo argumento for fornecido.  De modo
que uma função é muitas vezes chamada uma função de memorização.

   Nomes de funções de Array são anexados ao final da lista global
`arrays' (não na lista global `functions').  O comando `arrayinfo'
retorna a lista de argumentos para os quais exite valores armazenados,
e `listarray' retorna os valores armazenados.  Os comandos `dispfun' e
`fundef' retornam a definição da função de array.

   O comando `arraymake' contrói uma chamada de função de array,
análogamente a `funmake' para funções comuns.  O comando `arrayapply'
aplica uma função de array a seus argmentos, análogamente a `apply'
para funções comuns.  Não existe nada exactamente análogo a `map' para
funções de array, embora `map(lambda([<x>], <a>[<x>]), <L>)' ou
`makelist(<a>[<x>], <x>, <L>)', onde <L> é uma lista, não estejam tão
longe disso.

   O comando `remarray' remove uma definição de função de array
(incluindo qualquer valor armazenado pela função removida), análogo a
`remfunction' para funções comuns.

   o comando `kill(<a>[<x>])' remove o valor da função de array <a>
armazenado para o argumento <x>; a próxima vez que <a> foor chamada com
o argumento <x>, o valor da função é recomputado.  Todavia, não exite
caminho para remover todos os valores armazenados de uma vez, excepto
para `kill(<a>)' ou `remarray(<a>)', o qual remove também remove a
definição da função de array.


File: maxima.info,  Node: Macros,  Next: Definições para Definição de Função,  Prev: Função,  Up: Definição de Função

39.3 Macros
===========

 -- Função: buildq (<L>, <expr>)
     Substitue variáveis nomeadas pela lista <L> dentro da expressão
     <expr>, paralelamente, sem avaliar <expr>.  A expressão resultante
     é simplificada, mas não avaliada, após `buildq' realizar a
     substituição.

     Os elementos de <L> são símbolos ou expressões de atribuição
     `<símbolo>: <valor>', avaliadas paralelamente.  Isto é, a
     associação de uma variável sobre o lado direito de uma
     atribuição é a associação daquela variável no contexto do qual
     `buildq' for chamada, não a associação daquela variável na lista
     <L> de variáveis.  Se alguma variável em <L> não dada como uma
     atribuição explícita, sua associação em `buildq' é a mesma que no
     contexto no qual `buildq' for chamada.

     Então as variáveis nomeadas em <L> são substituidas em <expr>
     paralelamente.  Isto é, a substituição para cada variável é
     determinada antes que qualquer substituição seja feita, então a
     substituição para uma variável não tem efeito sobre qualquer outra.

     Se qualquer variável <x> aparecer como `splice (<x>)' em <expr>,
     então <x> deve estar associada para uma lista, e a lista recebe
     uma aplicação da função `splice' (é interpolada) na <expr> em
     lugar de substituída.

     Quaisquer variáveis em <expr> não aparecendo em <L> são levados no
     resultado tal como foram escritos, mesmo se elas tiverem
     associações no contexto do qual `buildq' tiver sido chamada.

     Exemplos

     `a' é explicitamente associada a `x', enquanto `b' tem a mesma
     associação (nomeadamente 29) como no contexto chamado, e `c' é
     levada do começo ao fim da forma como foi escrita.  A expressão
     resultante não é avaliada até a avaliação explícita ( com duplo
     apóstrofo - não com aspas - `''%'.

          (%i1) (a: 17, b: 29, c: 1729)$
          (%i2) buildq ([a: x, b], a + b + c);
          (%o2)                      x + c + 29
          (%i3) ''%;
          (%o3)                       x + 1758

     `e' está associado a uma lista, a qual aparece também como tal nos
     argumentos de `foo', e interpolada nos argumentos de `bar'.

          (%i1) buildq ([e: [a, b, c]], foo (x, e, y));
          (%o1)                 foo(x, [a, b, c], y)
          (%i2) buildq ([e: [a, b, c]], bar (x, splice (e), y));
          (%o2)                  bar(x, a, b, c, y)

     O resultado é simplificado após substituição.  Se a
     simplificação for aplicada antes da substituição, esses dois
     resultados podem ser iguais.
          (%i1) buildq ([e: [a, b, c]], splice (e) + splice (e));
          (%o1)                    2 c + 2 b + 2 a
          (%i2) buildq ([e: [a, b, c]], 2 * splice (e));
          (%o2)                        2 a b c

     As variáveis em <L> são associadas em paralelo; se associadas
     sequêncialmente, o primeiro resultado pode ser `foo (b, b)'.
     Substituições são realizadas em paralelo; compare o segundo
     resultado com o resultado de `subst', que realiza substituições
     sequêncialmente.

          (%i1) buildq ([a: b, b: a], foo (a, b));
          (%o1)                       foo(b, a)
          (%i2) buildq ([u: v, v: w, w: x, x: y, y: z, z: u], bar (u, v, w, x, y, z));
          (%o2)                 bar(v, w, x, y, z, u)
          (%i3) subst ([u=v, v=w, w=x, x=y, y=z, z=u], bar (u, v, w, x, y, z));
          (%o3)                 bar(u, u, u, u, u, u)

     Constrói uma lista de euqções com algumas variáveis ou expressões
     sobre o lado esquerdo e seus valores sobre o lado direito.
     `macroexpand' mostra a expressão retornada por `show_values'.

          (%i1) show_values ([L]) ::= buildq ([L], map ("=", 'L, L));
          (%o1)   show_values([L]) ::= buildq([L], map("=", 'L, L))
          (%i2) (a: 17, b: 29, c: 1729)$
          (%i3) show_values (a, b, c - a - b);
          (%o3)              [a = 17, b = 29, c = 1729]


 -- Função: macroexpand (<expr>)
     Retorna a expansão da macro de <expr> sem avaliar a expressão,
     quando `expr' for uma chamada de função de macro.  De outra forma,
     `macroexpand' retorna <expr>.

     Se a expansão de <expr> retorna outra chamada de função de macro,
     aquela chamada de função de macro é também expandida.

     `macroexpand' coloca apóstrofo em seus argumentos, isto é, não os
     avalia.  Todavia, se a expansão de uma chamada de função de macro
     tiver algum efeito, esse efeito colateral é executado.

     Veja também `::=', `macros', e `macroexpand1'.

     Exemplos

          (%i1) g (x) ::= x / 99;
                                              x
          (%o1)                      g(x) ::= --
                                              99
          (%i2) h (x) ::= buildq ([x], g (x - a));
          (%o2)            h(x) ::= buildq([x], g(x - a))
          (%i3) a: 1234;
          (%o3)                         1234
          (%i4) macroexpand (h (y));
                                        y - a
          (%o4)                         -----
                                         99
          (%i5) h (y);
                                      y - 1234
          (%o5)                       --------
                                         99


 -- Função: macroexpand1 (<expr>)
     Retorna a expansão de macro de <expr> sem avaliar a expressão,
     quando `expr' for uma chamada de função de macro.  De outra forma,
     `macroexpand1' retorna <expr>.

     `macroexpand1' não avalia seus argumentos.  Todavia, se a expansão
     de uma chamada de função de macro tiver algum efeito, esse efeito
     colateral é executado.

     Se a expansão de <expr> retornar outra chamada de função de macro,
     aquela chamada de função de macro não é expandida.

     Veja também `::=', `macros', e `macroexpand'.

     Examples

          (%i1) g (x) ::= x / 99;
                                              x
          (%o1)                      g(x) ::= --
                                              99
          (%i2) h (x) ::= buildq ([x], g (x - a));
          (%o2)            h(x) ::= buildq([x], g(x - a))
          (%i3) a: 1234;
          (%o3)                         1234
          (%i4) macroexpand1 (h (y));
          (%o4)                       g(y - a)
          (%i5) h (y);
                                      y - 1234
          (%o5)                       --------
                                         99


 -- Global variable: macros
     Default value: `[]'

     `macros' é a lista de funções de macro definidas pelo utilizador.
     O operador de definição de função de macro `::=' coloca uma nova
     função de macro nessa lista, e `kill', `remove', e `remfunction'
     removem funções de macro da lista.

     Veja também `infolists'.


 -- Função: splice (<a>)
     Une como se fosse um elo de ligação (interpola) a lista nomeada
     através do átomo <a> em uma expressão, mas somente se `splice'
     aparecer dentro de `buildq'; de outra forma, `splice' é tratada
     como uma função indefinida.  Se aparecer dentro de `buildq' com
     <a> sozinho (sem `splice'), <a> é substituido (não interpolado)
     como uma lista no resultado.  O argumento de `splice' pode somente
     ser um átomo; não pode ser uma lista lateral ou uma expressão que
     retorna uma lista.

     Tipicamente `splice' fornece os argumentos para uma função ou
     operador.  Para uma função `f', a expressão `f (splice (<a>))'
     dentro de `buildq' expande para `f (<a>[1], <a>[2], <a>[3], ...)'.
     Para um operador `o', a expressão `"o" (splice (<a>)' dentro de
     `buildq' expande para `"o" (<a>[1], <a>[2], <a>[3], ...)', onde
     `o' pode ser qualquer tipo de operador (tipicamente um que toma
     múltiplos argumentos).  Note que o operador deve ser contido
     dentro de aspas duplas `"'.

     Exemplos

          (%i1) buildq ([x: [1, %pi, z - y]], foo (splice (x)) / length (x));
                                 foo(1, %pi, z - y)
          (%o1)                -----------------------
                               length([1, %pi, z - y])
          (%i2) buildq ([x: [1, %pi]], "/" (splice (x)));
                                          1
          (%o2)                          ---
                                         %pi
          (%i3) matchfix ("<>", "<>");
          (%o3)                          <>
          (%i4) buildq ([x: [1, %pi, z - y]], "<>" (splice (x)));
          (%o4)                   <>1, %pi, z - y<>



File: maxima.info,  Node: Definições para Definição de Função,  Prev: Macros,  Up: Definição de Função

39.4 Definições para Definição de Função
========================================

 -- Função: apply (<F>, [<x_1>, ..., <x_n>])
     Constrói e avalia uma expressãp `<F>(<arg_1>, ..., <arg_n>)'.

     `apply' não tenta distinguir funções de array de funções comuns;
     quando <F> for o nome de uma função de array, `apply' avalia
     `<F>(...)' (isto é, uma chamada de função com parêntesis em lugar
     de colchêtes).  `arrayapply' avalia uma chamada de função com
     colchêtes nesse caso.

     Exemplos:

     `apply' avalia seus argumentos.  Nesse exemplo, `min' é aplicado a
     `L'.

          (%i1) L : [1, 5, -10.2, 4, 3];
          (%o1)                 [1, 5, - 10.2, 4, 3]
          (%i2) apply (min, L);
          (%o2)                        - 10.2

     `apply' avalia argumentos, mesmo se a função <F> disser que os
     argumentos não devem ser avaliados.

          (%i1) F (x) := x / 1729;
                                             x
          (%o1)                     F(x) := ----
                                            1729
          (%i2) fname : F;
          (%o2)                           F
          (%i3) dispfun (F);
                                             x
          (%t3)                     F(x) := ----
                                            1729

          (%o3)                         [%t3]
          (%i4) dispfun (fname);
          fname is not the name of a user function.
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i5) apply (dispfun, [fname]);
                                             x
          (%t5)                     F(x) := ----
                                            1729

          (%o5)                         [%t5]

     `apply' avalia o nome de função <F>.  Apóstrofo `'' evita
     avaliação.  `demoivre' é o nome de uma variável global e também de
     uma função.

          (%i1) demoivre;
          (%o1)                         false
          (%i2) demoivre (exp (%i * x));
          (%o2)                  %i sin(x) + cos(x)
          (%i3) apply (demoivre, [exp (%i * x)]);
          demoivre evaluates to false
          Improper name or value in functional position.
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) apply ('demoivre, [exp (%i * x)]);
          (%o4)                  %i sin(x) + cos(x)


 -- Função: block ([<v_1>, ..., <v_m>], <expr_1>, ..., <expr_n>)
 -- Função: block (<expr_1>, ..., <expr_n>)
     `block' avalia <expr_1>, ..., <expr_n> em sequência e retorna o
     valor da última expressão avaliada.  A sequência pode ser
     modificada pelas funções `go', `throw', e `return'.  A última
     expressão é <expr_n> a menos que `return' ou uma expressão
     contendo `throw' seja avaliada.  Algumas variáveis <v_1>, ...,
     <v_m> podem ser declaradas locais para o bloco; essas são
     distinguidas das variáveis globais dos mesmos nomes.  Se variáveis
     não forem declaradas locais então a lista pode ser omitida.
     Dentro do bloco, qualquer variável que não <v_1>, ..., <v_m> é uma
     variável global.

     `block' salva os valores correntes das variáveis <v_1>, ..., <v_m>
     (quaisquer valores) na hora da entrada para o bloco, então libera
     as variáveis dessa forma eles avaliam para si mesmos.  As
     variáveis locais podem ser associadas a valores arbitrários dentro
     do bloco mas quando o bloco é encerrado o valores salvos são
     restaurados, e os valores atribuídos dentro do bloco são perdidos.

     `block' pode aparecer dentro de outro `block'.  Variáveis locais
     são estabelecidas cada vez que um novo `block' é avaliado.
     Variáveis locais parecem ser globais para quaisquer blocos
     fechados.  Se uma variável é não local em um bloco, seu valor é o
     valor mais recentemente atribuído por um bloco fechado, quaisquer
     que sejam, de outra forma, seu valor é o valor da variável no
     ambiente global.  Essa política pode coincidir com o entendimento
     usual de "escopo dinâmico".

     Se isso for desejado para salvar e restaurar outras propriedades
     locais ao lado de `value', por exemplo `array' (excepto para
     arrays completos), `function', `dependencies', `atvalue',
     `matchdeclare', `atomgrad', `constant', e `nonscalar' então a
     função `local' pode ser usada dentro do bloco com argumentos sendo
     o nome das variáveis.

     O valor do bloco é o valor da última declaração ou o valor do
     argumento para a função `return' que pode ser usada para sair
     explicitamente do bloco.  A função `go' pode ser usada para
     transferir o controle para a declaração do bloco que é
     identificada com o argumento para `go'.  Para identificar uma
     declaração, coloca-se antes dela um argumento atômico como outra
     declaração no bloco.  Por exemplo: `block ([x], x:1, loop, x: x+1,
     ..., go(loop), ...)'.  O argumento para `go' deve ser o nome de um
     identificador que aparece dentro do bloco.  Não se deve usar `go'
     para transferir para um identificador em um outro bloco a não ser
     esse que contém o `go'.

     Blocos tipicamente aparecem do lado direito de uma definição de
     função mas podem ser usados em outros lugares também.


 -- Função: break (<expr_1>, ..., <expr_n>)
     Avalia e imprime <expr_1>, ..., <expr_n> e então causa uma parada
     do Maxima nesse ponto e o utilizador pode examinar e alterar seu
     ambiente.  Nessa situação digite `exit;' para que o cálculo seja
     retomado.


 -- Função: catch (<expr_1>, ..., <expr_n>)
     Avalia <expr_1>, ..., <expr_n> uma por uma; se qualquer
     avaliação levar a uma avaliação de uma expressão da forma `throw
     (arg)', então o valor de `catch' é o valor de `throw (arg)', e
     expressões adicionais não são avaliadas.  Esse "retorno não local"
     atravessa assim qualquer profundidade de aninhar para o mais
     próximo contendo `catch'.  Se não existe nenhum `catch' contendo
     um `throw', uma mensagem de erro é impressa.

     Se a avaliação de argumentos não leva para a avaliação de qualquer
     `throw' então o valor de `catch' é o valor de <expr_n>.

          (%i1) lambda ([x], if x < 0 then throw(x) else f(x))$
          (%i2) g(l) := catch (map (''%, l))$
          (%i3) g ([1, 2, 3, 7]);
          (%o3)               [f(1), f(2), f(3), f(7)]
          (%i4) g ([1, 2, -3, 7]);
          (%o4)                          - 3

     A função `g' retorna uma lista de `f' de cada elemento de `l' se
     `l' consiste somente de números não negativos; de outra forma, `g'
     "captura" o primeiro elemento negativo de `l' e "arremessa-o".


 -- Função: compfile (<nomeficheiro>, <f_1>, ..., <f_n>)
 -- Função: compfile (<nomeficheiro>, funç ~oes)
 -- Função: compfile (<nomeficheiro>, all)
     Traduz fuções Maxima para Lisp e escreve o código traduzido no
     ficheiro <nomeficheiro>.

     `compfile(<nomeficheiro>, <f_1>, ..., <f_n>)' traduz as funções
     especificadas.  `compfile(<nomeficheiro>, functions)' e
     `compfile(<nomeficheiro>, all)' traduz todas as funções definidas
     pelo utilizador.

     As traduções Lisp não são avaliadas, nem é o ficheiro de saída
     processado pelo compilador Lisp.  `translate' cria e avalia
     traduções Lisp.  `compile_file' traduz Maxima para Lisp, e então
     executa o compilador Lisp.

     Veja também `translate', `translate_file', e `compile_file'.


 -- Função: compile (<f_1>, ..., <f_n>)
 -- Função: compile (funç ~oes)
 -- Função: compile (all)
     Traduz funções Maxima <f_1>, ..., <f_n> para Lisp, avalia a
     tradução Lisp, e chama a função Lisp `COMPILE' sobre cada
     função traduzida.  `compile' retorna uma lista de nomes de
     funções compiladas.

     `compile (all)' ou `compile (funções)' compila todas as funções
     definidas pelo utilizador.

     `compile' não avalia seus argumentos; o operador
     apóstrofo-apóstrofo `''' faz com que ocorra avaliação
     sobrepondo-se ao apóstrofo.


 -- Função: define (<f>(<x_1>, ..., <x_n>), <expr>)
 -- Função: define (<f>[<x_1>, ..., <x_n>], <expr>)
 -- Função: define (funmake (<f>, [<x_1>, ..., <x_n>]), <expr>)
 -- Função: define (arraymake (<f>, [<x_1>, ..., <x_n>]), <expr>)
 -- Função: define (ev (<expr_1>), <expr_2>)
     Define uma função chamada <f> com argumentos <x_1>, ..., <x_n> e
     corpo da função <expr>.  `define' sempre avalia seu segundo
     argumento (a menos que explícitamente receba um apostrofo de forma
     a evitar a avaliação).  A função então definida pode ser uma
     função comum do Maxima (com argumentos contidos entre parêtesis)
     ou uma função de array (com argumentos contidos entre colchêtes).

     Quando o último ou único argumento da função <x_n> for uma lista
     de um elemento, a função definida por `define' aceita um número
     variável de argumentos.  Os argumentos actuais são atribuídos um a
     um a argumentos formais <x_1>, ..., <x_(n - 1)>, e quaisquer
     argumentos adicionais actuais, se estiverem presentes, são
     atribuídos a <x_n> como uma lista.

     Quando o primeiro argumento de `define' for uma expressão da forma
     `<f>(<x_1>, ..., <x_n>)' or `<f>[<x_1>, ..., <x_n>]', os
     argumentos são avaliados mas <f> não é avaliada, mesmo se já
     existe anteriormente uma função ou variável com aquele nome.
     Quando o primeiro argumento for uma expressão com operador
     `funmake', `arraymake', ou `ev', o primeiro argumento será
     avaliado; isso permite para o nome da função seja calculado,
     também como o corpo.

     Todas as definições de função aparecem no mesmo nível de escopo e
     visibilidade; definindo uma função `f' dentro de outra função `g'
     não limita o escopo de `f' a `g'.

     Se algum argumento formal <x_k> for um símbolo com apóstrofo (após
     ter sido feita uma avaliação), a função definida por `define' não
     avalia o correspondente actual argumento.  de outra forma todos os
     argumentos actuais são avaliados.

     Veja também `:=' and `::='.

     Exemplos:

     `define' sempre avalia seu segundo argumento (a menos que
     explícitamente receba um apostrofo de forma a evitar a
     avaliação).

          (%i1) expr : cos(y) - sin(x);
          (%o1)                    cos(y) - sin(x)
          (%i2) define (F1 (x, y), expr);
          (%o2)              F1(x, y) := cos(y) - sin(x)
          (%i3) F1 (a, b);
          (%o3)                    cos(b) - sin(a)
          (%i4) F2 (x, y) := expr;
          (%o4)                   F2(x, y) := expr
          (%i5) F2 (a, b);
          (%o5)                    cos(y) - sin(x)

     A função definida por `define' pode ser uma função comum do Maxima
     ou uma função de array.

          (%i1) define (G1 (x, y), x.y - y.x);
          (%o1)               G1(x, y) := x . y - y . x
          (%i2) define (G2 [x, y], x.y - y.x);
          (%o2)                G2     := x . y - y . x
                                 x, y

     Quando o último ou único argumento da função <x_n> for uma lista
     de um único elemento, a função definida por `define' aceita um
     número variável de argumentos.

          (%i1) define (H ([L]), '(apply ("+", L)));
          (%o1)                H([L]) := apply("+", L)
          (%i2) H (a, b, c);
          (%o2)                       c + b + a

     When the first argument is an expression with operator `funmake',
     `arraymake', or `ev', the first argument is evaluated.

          (%i1) [F : I, u : x];
          (%o1)                        [I, x]
          (%i2) funmake (F, [u]);
          (%o2)                         I(x)
          (%i3) define (funmake (F, [u]), cos(u) + 1);
          (%o3)                  I(x) := cos(x) + 1
          (%i4) define (arraymake (F, [u]), cos(u) + 1);
          (%o4)                   I  := cos(x) + 1
                                   x
          (%i5) define (foo (x, y), bar (y, x));
          (%o5)                foo(x, y) := bar(y, x)
          (%i6) define (ev (foo (x, y)), sin(x) - cos(y));
          (%o6)             bar(y, x) := sin(x) - cos(y)


 -- Função: define_variable (<name>, <default_value>, <mode>)
     Introduz uma variável global dentro do ambiente Maxima.
     `define_variable' é útil em pacotes escritos pelo utilizador, que
     são muitas vezes traduzidos ou compilados.

     `define_variable' realiza os seguintes passos:

       1. `mode_declare (<name>, <mode>)' declara o modo de <name> para
          o tradutor.  Veja `mode_declare' para uma lista dos modos
          possíveis.

       2. Se a variável é não associada, <default_value> é atribuído
          para <name>.

       3. `declare (<name>, special)' declara essa variável especial.

       4. Associa <name> com uma função de teste para garantir que a
          <name> seja somente atribuído valores do modo declarado.

     A propriedade `value_check' pode ser atribuída a qualquer variável
     que tenha sido definida via `define_variable' com um outro modo
     que não `any'.  A propriedade `value_check' é uma expressão lambda
     ou o nome de uma função de uma variável, que é chamada quando uma
     tentativa é feita para atribuir um valor a uma variável.  O
     argumento da  função `value_check' é o valor que será atribuído.

     `define_variable' avalia `default_value', e não avalia `name' e
     `mode'.  `define_variable' retorna o valor corrente de `name', que
     é `default_value' se `name' não tiver sido associada antes, e de
     outra forma isso é o valor prévio de `name'.

     Exemplos:

     `foo' é uma variável Booleana, com o valor inicial `true'.

          (%i1) define_variable (foo, true, boolean);
          (%o1)                         true
          (%i2) foo;
          (%o2)                         true
          (%i3) foo: false;
          (%o3)                         false
          (%i4) foo: %pi;
          Error: foo was declared mode boolean, has value: %pi
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i5) foo;
          (%o5)                         false

     `bar' é uma variável inteira, que deve ser um número primo.

          (%i1) define_variable (bar, 2, integer);
          (%o1)                           2
          (%i2) qput (bar, prime_test, value_check);
          (%o2)                      prime_test
          (%i3) prime_test (y) := if not primep(y) then error (y, "is not prime.");
          (%o3) prime_test(y) := if not primep(y)

                                             then error(y, "is not prime.")
          (%i4) bar: 1439;
          (%o4)                         1439
          (%i5) bar: 1440;
          1440 é not prime.
          #0: prime_test(y=1440)
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i6) bar;
          (%o6)                         1439

     `baz_quux' é uma variável que não pode receber a atribuição de um
     valor.  O modo `any_check' é como `any', mas `any_check' habilita
     o mecanismo `value_check', e `any' não habilita.

          (%i1) define_variable (baz_quux, 'baz_quux, any_check);
          (%o1)                       baz_quux
          (%i2) F: lambda ([y], if y # 'baz_quux then error ("Cannot assign to `baz_quux'."));
          (%o2) lambda([y], if y # 'baz_quux

                                  then error(Cannot assign to `baz_quux'.))
          (%i3) qput (baz_quux, ''F, value_check);
          (%o3) lambda([y], if y # 'baz_quux

                                  then error(Cannot assign to `baz_quux'.))
          (%i4) baz_quux: 'baz_quux;
          (%o4)                       baz_quux
          (%i5) baz_quux: sqrt(2);
          Cannot assign to `baz_quux'.
          #0: lambda([y],if y # 'baz_quux then error("Cannot assign to `baz_quux'."))(y=sqrt(2))
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i6) baz_quux;
          (%o6)                       baz_quux


 -- Função: dispfun (<f_1>, ..., <f_n>)
 -- Função: dispfun (all)
     Mostra a definição de funções definidas pelo utilizador <f_1>,
     ..., <f_n>.  Cada argumento pode ser o nome de uma macro (definida
     com `::='), uma função comum (definida com `:=' ou `define'), uma
     função array (definida com `:=' ou com `define', mas contendo
     argumentos entre colchêtes `[ ]'), uma função subscrita, (definida
     com `:=' ou `define', mas contendo alguns argumentos entre
     colchêtes e outros entre parêntesis `( )') uma da família de
     funções subscritas seleccionadas por um valor subscrito particular,
     ou uma função subscrita definida com uma constante subscrita.

     `dispfun (all)' mostra todas as funções definidas pelo utilizador
     como dadas pelas `functions', `arrays', e listas de `macros',
     omitindo funções subscritas definidas com constantes subscritas.

     `dispfun' cria um Rótulo de expressão intermédia (`%t1', `%t2',
     etc.)  para cada função mostrada, e atribui a definição de
     função para o rótulo.  Em contraste, `fundef' retorna a
     definição de função.

     `dispfun' não avalia seus argumentos; O operador
     apóstrofo-apóstrofo `''' faz com que ocorra avaliação.

     `dispfun' retorna a lista de rótulos de expressões intermédias
     correspondendo às funções mostradas.

     Exemplos:

          (%i1) m(x, y) ::= x^(-y);
                                               - y
          (%o1)                   m(x, y) ::= x
          (%i2) f(x, y) :=  x^(-y);
                                               - y
          (%o2)                    f(x, y) := x
          (%i3) g[x, y] :=  x^(-y);
                                              - y
          (%o3)                     g     := x
                                     x, y
          (%i4) h[x](y) :=  x^(-y);
                                              - y
          (%o4)                     h (y) := x
                                     x
          (%i5) i[8](y) :=  8^(-y);
                                              - y
          (%o5)                     i (y) := 8
                                     8
          (%i6) dispfun (m, f, g, h, h[5], h[10], i[8]);
                                               - y
          (%t6)                   m(x, y) ::= x

                                               - y
          (%t7)                    f(x, y) := x

                                              - y
          (%t8)                     g     := x
                                     x, y

                                              - y
          (%t9)                     h (y) := x
                                     x

                                              1
          (%t10)                     h (y) := --
                                      5        y
                                              5

                                               1
          (%t11)                    h  (y) := ---
                                     10         y
                                              10

                                              - y
          (%t12)                    i (y) := 8
                                     8

          (%o12)       [%t6, %t7, %t8, %t9, %t10, %t11, %t12]
          (%i12) ''%;
                               - y              - y            - y
          (%o12) [m(x, y) ::= x   , f(x, y) := x   , g     := x   ,
                                                      x, y
                            - y           1              1             - y
                  h (y) := x   , h (y) := --, h  (y) := ---, i (y) := 8   ]
                   x              5        y   10         y   8
                                          5             10


 -- Variável de sistema: functions
     Valor por omissão: `[]'

     `functions' é uma lista de todas as funções comuns do Maxima na
     sessão corrente.  Uma função comum é uma função construída através
     de `define' ou de `:=' e chamada com parêntesis `()'.  Uma
     função pode ser definida pela linha de comando do Maxima de forma
     interativa com o utilizador ou em um ficheiro Maxima chamado por
     `load' ou `batch'.

     Funções de array (chamadas com colchêtes, e.g., `F[x]') e
     funções com subscritos (chamadas com colchêtes e parêntesis, e.g.,
     `F[x](y)') são lsitados através da variável global `arrays', e não
     por meio de `functions'.

     Funções Lisp não são mantidas em nenhuma lista.

     Exemplos:

          (%i1) F_1 (x) := x - 100;
          (%o1)                   F_1(x) := x - 100
          (%i2) F_2 (x, y) := x / y;
                                                x
          (%o2)                    F_2(x, y) := -
                                                y
          (%i3) define (F_3 (x), sqrt (x));
          (%o3)                   F_3(x) := sqrt(x)
          (%i4) G_1 [x] := x - 100;
          (%o4)                    G_1  := x - 100
                                      x
          (%i5) G_2 [x, y] := x / y;
                                               x
          (%o5)                     G_2     := -
                                       x, y    y
          (%i6) define (G_3 [x], sqrt (x));
          (%o6)                    G_3  := sqrt(x)
                                      x
          (%i7) H_1 [x] (y) := x^y;
                                                y
          (%o7)                     H_1 (y) := x
                                       x
          (%i8) functions;
          (%o8)              [F_1(x), F_2(x, y), F_3(x)]
          (%i9) arrays;
          (%o9)                 [G_1, G_2, G_3, H_1]


 -- Função: fundef (<f>)
     Retorna a definição da função <f>.

     O argumento pode ser o nome de uma macro (definida com `::='), uma
     função comum (definida com `:=' ou `define'), uma função array
     (definida com `:=' ou `define', mas contendo argumentos entre
     colchêtes `[ ]'), Uma função subscrita, (definida com `:=' ou
     `define', mas contendo alguns argumentos entre colchêtes e
     parêntesis `( )') uma da família de funções subscritas
     seleccionada por um valor particular subscrito, ou uma função
     subscrita definida com uma constante subscrita.

     `fundef' não avalia seu argumento; o operador apóstrofo-apóstrofo
     `''' faz com que ocorra avaliação.

     `fundef (<f>)' retorna a definição de <f>.  Em contraste, `dispfun
     (<f>)' cria um rótulo de expressão intermédia e atribui a
     definição para o rótulo.


 -- Função: funmake (<F>, [<arg_1>, ..., <arg_n>])
     Retorna uma expressão `<F>(<arg_1>, ..., <arg_n>)'.  O valor de
     retorno é simplificado, mas não avaliado, então a função <F> não é
     chamada, mesmo se essa função <F> existir.

     `funmake' não tenta distinguir funções de array de funções comuns;
     quando <F> for o nome de uma função de array, `funmake' retorna
     `<F>(...)' (isto é, uma chamada de função com parêntesis em lugar
     de colchêtes).  `arraymake' retorna uma chamada de função com
     colchêtes nesse caso.

     `funmake' avalia seus argumentos.

     Exemplos:

     `funmake' aplicada a uma função comum do Maxima.

          (%i1) F (x, y) := y^2 - x^2;
                                             2    2
          (%o1)                  F(x, y) := y  - x
          (%i2) funmake (F, [a + 1, b + 1]);
          (%o2)                    F(a + 1, b + 1)
          (%i3) ''%;
                                        2          2
          (%o3)                  (b + 1)  - (a + 1)

     `funmake' aplicada a uma macro.

          (%i1) G (x) ::= (x - 1)/2;
                                            x - 1
          (%o1)                    G(x) ::= -----
                                              2
          (%i2) funmake (G, [u]);
          (%o2)                         G(u)
          (%i3) ''%;
                                        u - 1
          (%o3)                         -----
                                          2

     `funmake' aplicada a uma função subscrita.

          (%i1) H [a] (x) := (x - 1)^a;
                                                  a
          (%o1)                   H (x) := (x - 1)
                                   a
          (%i2) funmake (H [n], [%e]);
                                                 n
          (%o2)               lambda([x], (x - 1) )(%e)
          (%i3) ''%;
                                              n
          (%o3)                       (%e - 1)
          (%i4) funmake ('(H [n]), [%e]);
          (%o4)                        H (%e)
                                        n
          (%i5) ''%;
                                              n
          (%o5)                       (%e - 1)

     `funmake' aplicada a um símbolo que não é uma função definida de
     qualquer tipo.

          (%i1) funmake (A, [u]);
          (%o1)                         A(u)
          (%i2) ''%;
          (%o2)                         A(u)

     `funmake' avalia seus argumentos, mas não o valor de retorno.

          (%i1) det(a,b,c) := b^2 -4*a*c;
                                              2
          (%o1)              det(a, b, c) := b  - 4 a c
          (%i2) (x : 8, y : 10, z : 12);
          (%o2)                          12
          (%i3) f : det;
          (%o3)                          det
          (%i4) funmake (f, [x, y, z]);
          (%o4)                    det(8, 10, 12)
          (%i5) ''%;
          (%o5)                         - 284
     Maxima simplifica o valor de retorno de `funmake'.

          (%i1) funmake (sin, [%pi / 2]);
          (%o1)                           1


 -- Função: lambda ([<x_1>, ..., <x_m>], <expr_1>, ..., <expr_n>)
 -- Função: lambda ([[<L>]], <expr_1>, ..., <expr_n>)
 -- Função: lambda ([<x_1>, ..., <x_m>, [<L>]], <expr_1>, ..., <expr_n>)
     Define e retorna uma expressão lambda (que é, uma função anônima)
     A função pode ter argumentos que sejam necessários <x_1>, ...,
     <x_m> e/ou argumentos opcionais <L>, os quais aparecem dentro do
     corpo da função como uma lista.  O valor de retorno da função é
     <expr_n>.  Uma expressão lambda pode ser atribuída para uma
     variável e avaliada como uma função comum.  Uma expressão lambda
     pode aparecer em alguns contextos nos quais um nome de função é
     esperado.

     Quando a função é avaliada, variáveis locais não associadas <x_1>,
     ..., <x_m> são criadas.  `lambda' pode aparecer dentro de `block'
     ou outra função `lambda'; variáveis locais são estabelecidas cada
     vez que outro `block' ou função `lambda' é avaliada.  Variáveis
     locais parecem ser globais para qualquer coisa contendo `block' ou
     `lambda'.  Se uma variável é não local, seu valor é o valor mais
     recentemente atribuído em alguma coisa contendo `block' ou
     `lambda', qualquer que seja, de outra forma, seu valor é o valor
     da variável no ambiente global.  Essa política pode coincidir com
     o entendimento usual de "escopo dinâmico".

     Após variáveis locais serem estabelecidas, <expr_1> até <expr_n>
     são avaliadas novamente.  a variável especial `%%', representando
     o valor da expressão precedente, é reconhecida.  `throw' e `catch'
     pode também aparecer na lista de expressões.

     `return' não pode aparecer em uma expressão lambda a menos que
     contendo `block', nesse caso `return' define o valor de retorno do
     bloco e não da expressão lambda, a menos que o bloco seja <expr_n>.
     Da mesma forma, `go' não pode aparecer em uma expressão lambda a
     menos que contendo `block'.

     `lambda' não avalia seus argumentos; o operador
     apóstrofo-apóstrofo `''' faz com que ocorra avaliação.

     Exemplos:

        * A expressão lambda pode ser atribuída para uma variável e
          avaliada como uma função comum.

          (%i1) f: lambda ([x], x^2);
                                                2
          (%o1)                    lambda([x], x )
          (%i2) f(a);
                                          2
          (%o2)                          a

        * Uma expressão lambda pode aparecer em contextos nos quais uma
          avaliação de função é esperada como resposta.

          (%i3) lambda ([x], x^2) (a);
                                          2
          (%o3)                          a
          (%i4) apply (lambda ([x], x^2), [a]);
                                          2
          (%o4)                          a
          (%i5) map (lambda ([x], x^2), [a, b, c, d, e]);
                                  2   2   2   2   2
          (%o5)                 [a , b , c , d , e ]

        * Variáveis argumento são variáveis locais.  Outras variáveis
          aparecem para serem variáveis globais.  Variáveis globais são
          avaliadas ao mesmo tempo em que a expressão lambda é avaliada,
          a menos que alguma avaliação especial seja forçada por alguns
          meios, tais como `'''.

          (%i6) a: %pi$
          (%i7) b: %e$
          (%i8) g: lambda ([a], a*b);
          (%o8)                   lambda([a], a b)
          (%i9) b: %gamma$
          (%i10) g(1/2);
                                       %gamma
          (%o10)                       ------
                                         2
          (%i11) g2: lambda ([a], a*''b);
          (%o11)                lambda([a], a %gamma)
          (%i12) b: %e$
          (%i13) g2(1/2);
                                       %gamma
          (%o13)                       ------
                                         2

        * Expressões lambda podem ser aninhadas.  Variáveis locais
          dentro de outra expressão lambda parece ser global para a
          expressão interna a menos que mascarada por variáveis locais
          de mesmos nomes.

          (%i14) h: lambda ([a, b], h2: lambda ([a], a*b), h2(1/2));
                                                             1
          (%o14)    lambda([a, b], h2 : lambda([a], a b), h2(-))
                                                             2
          (%i15) h(%pi, %gamma);
                                       %gamma
          (%o15)                       ------
                                         2

        * Uma vez que `lambda' não avalia seus argumentos, a expressão
          lambda `i' abaixo não define uma função "multiplicação por
          `a'".  Tanto uma função pode ser definida via `buildq', como
          na expressão lambda `i2' abaixo.

          (%i16) i: lambda ([a], lambda ([x], a*x));
          (%o16)            lambda([a], lambda([x], a x))
          (%i17) i(1/2);
          (%o17)                  lambda([x], a x)
          (%i18) i2: lambda([a], buildq([a: a], lambda([x], a*x)));
          (%o18)    lambda([a], buildq([a : a], lambda([x], a x)))
          (%i19) i2(1/2);
                                               x
          (%o19)                   lambda([x], -)
                                               2
          (%i20) i2(1/2)(%pi);
                                         %pi
          (%o20)                         ---
                                          2

        * Uma expressão lambda pode receber um número variável de
          argumentos, os quais são indicados por meio de `[<L>]' como o
          argumento único ou argumento final.  Os argumentos aparecem
          dentro do corpo da função como uma lista.

          (%i1) f : lambda ([aa, bb, [cc]], aa * cc + bb);
          (%o1)          lambda([aa, bb, [cc]], aa cc + bb)
          (%i2) f (foo, %i, 17, 29, 256);
          (%o2)       [17 foo + %i, 29 foo + %i, 256 foo + %i]
          (%i3) g : lambda ([[aa]], apply ("+", aa));
          (%o3)             lambda([[aa]], apply(+, aa))
          (%i4) g (17, 29, x, y, z, %e);
          (%o4)                  z + y + x + %e + 46

 -- Função: local (<v_1>, ..., <v_n>)
     Declara as variáveis <v_1>, ..., <v_n> para serem locais com
     relação a todas as propriedades na declaração na qual essa
     função é usada.

     `local' não avalia seus argumentos.  `local' retorna `done'.

     `local' pode somente ser usada em `block', no corpo de
     definições de função ou expressões `lambda', ou na função `ev', e
     somente uma ocorrêcia é permitida em cada.

     `local' é independente de `context'.


 -- Variável de opção: macroexpansion
     Valor por omissão: `false'

     `macroexpansion' controla recursos avançados que afectam a
     eficiência de macros.  Escolhas possíveis:

        * `false' - Macros expandem normalmente cada vez que são
          chamadas.

        * `expand' - A primeira vez de uma chamada particular é
          avaliada, a expansão é lembrada internamente, dessa forma não
          tem como ser recalculada em chamadas subsequênte rapidamente.
          A macro chama ainda chamadas `grind' e `display' normalmente.
          Todavia, memória extra é requerida para lembrar todas as
          expansões.

        * `displace' - A primeira vez de uma chamada particular é
          avaliada, a expansão é substituída pela chamada.  Isso requer
          levemente menos armazenagem que quando `macroexpansion' é
          escolhida para `expand' e é razoávelmente rápido, mas tem a
          desvantagem de a macro original ser lentamente lembrada e daí
          a expansão será vista se `display' ou `grind' for chamada.
          Veja a documentação para `translate' e `macros' para maiores
          detalhes.


 -- Variável de opção: mode_checkp
     Valor por omissão: `true'

     Quando `mode_checkp' é `true', `mode_declare' verifica os modos de
     associação de variáveis.


 -- Variável de opção: mode_check_errorp
     Valor por omissão: `false'

     Quando `mode_check_errorp' é `true', `mode_declare' chama a
     função "error".


 -- Variável de opção: mode_check_warnp
     Valor por omissão: `true'

     Quando `mode_check_warnp' é `true', modo "errors" são descritos.


 -- Função: mode_declare (<y_1>, <mode_1>, ..., <y_n>, <mode_n>)
     `mode_declare' é usado para declarar os modos de variáveis e
     funções para subsequênte tradução ou compilação das funções.
     `mode_declare' é tipicamente colocada no início de uma
     definição de função, no início de um script Maxima, ou executado
     através da linha de comando de forma interativa.

     Os argumentos de `mode_declare' são pares consistindo de  uma
     variável e o modo que é um de `boolean', `fixnum', `number',
     `rational', ou `float'.  Cada variável pode também ser uma lista
     de variáveis todas as quais são declaradas para ter o mesmo modo.

     Se uma variável é um array, e se todo elemento do array que é
     referenciado tiver um valor então `array (yi, complete, dim1,
     dim2, ...)' em lugar de
          array(yi, dim1, dim2, ...)
     deverá ser usado primeiro declarando as associações do array.  Se
     todos os elementos do array estão no modo `fixnum' (`float'), use
     `fixnum' (`float') em lugar de `complete'.  Também se todo
     elemento do array está no mesmo modo, digamos `m', então

          mode_declare (completearray (yi), m))

     deverá ser usado para uma tradução eficiente.

     Código numéricos usando arrays podem rodar mais rápidamente se for
     decladado o tamanho esperado do array, como em:

          mode_declare (completearray (a [10, 10]), float)

     para um array numérico em ponto flutuante que é 10 x 10.

     Pode-se declarar o modo do resultado de uma função usando
     `function (f_1, f_2, ...)' como um argumento; aqui `f_1', `f_2',
     ...  são nomes de funções.  Por exemplo a expressão,

          mode_declare ([function (f_1, f_2, ...)], fixnum)

     declara que os valores retornados por `f_1', `f_2', ...  são
     inteiros palavra simples.

     `modedeclare' é um sinônimo para `mode_declare'.


 -- Função: mode_identity (<arg_1>, <arg_2>)
     Uma forma especial usada com `mode_declare' e `macros' para
     declarar, e.g., uma lista de listas de números em ponto flutuante
     ou outros objectos de dados.  O primeiro argumento para
     `mode_identity' é um valor primitivo nome de modo como dado para
     `mode_declare' (i.e., um de `float', `fixnum', `number', `list',
     ou `any'), e o segundo argumento é uma expressão que é avaliada e
     retornada com o valor de `mode_identity'. No entanto, se o valor
     de retorno não é permitido pelo modo declarado no primeiro
     argumento, um erro ou alerta é sinalizado.  Um ponto importante é
     que o modo da expressão como determinado pelo Maxima para o
     tradutor Lisp, será aquele dado como o primeiro argumento,
     independente de qualquer coisa que vá no segundo argumento.  E.g.,
     `x: 3.3; mode_identity (fixnum, x);' retorna um erro.
     `mode_identity (flonum, x)' returns 3.3 .  Isto tem númerosas
     utilidades, por exemplo, se souber que `first (l)' retornou um
     número então poderá escrever `mode_identity (number, first (l))'.
     No entanto, um caminho mais eficiente para fazer a mesma coisa é
     definir uma nova primitiva,

          firstnumb (x) ::= buildq ([x], mode_identity (number, x));

     e usar `firstnumb' sempre que obtiver o primeiro de uma lista de
     números.


 -- Variável de opção: transcompile
     Valor por omissão: `true'

     Quando `transcompile' é `true', `translate' e `translate_file'
     geram declarações para fazer o código traduzido mais adequado para
     compilação.

     `compfile' escolhe `transcompile: true' para a duração.


 -- Função: translate (<f_1>, ..., <f_n>)
 -- Função: translate (funç ~oes)
 -- Função: translate (all)
     Traduz funções definidas pelo utilizador <f_1>, ..., <f_n> da
     linguagem de Maxima para Lisp e avalia a tradução Lisp.
     Tipicamente as funções traduzidas executam mais rápido que as
     originais.

     `translate (all)' ou `translate (funções)' traduz todas as
     funções definidas pelo utilizador.

     Funções a serem traduzidas incluir~ao uma chamada para
     `mode_declare' no início quando possível com o objectivo de
     produzir um código mais eficiente.  Por exemplo:

          f (x_1, x_2, ...) := block ([v_1, v_2, ...],
              mode_declare (v_1, mode_1, v_2, mode_2, ...), ...)

     quando <x_1>, <x_2>, ...  são parâmetros para a função e <v_1>,
     <v_2>, ...  são variáveis locais.

     Os nomes de funções traduzidas são removidos da lista `functions'
     se `savedef' é `false' (veja abaixo) e são adicionados nas listas
     `props'.

     Funções não poderão ser traduzidas a menos que elas sejam
     totalmente depuradas.

     Expressões são assumidas simplificadas; se não forem, um código
     correcto será gerado mas não será um código óptimo.  Dessa forma,
     o utilizador não poderá escolher o comutador `simp' para `false' o
     qual inibe simplificação de expressões a serem traduzidas.

     O comutador `translate', se `true', causa tradução automatica de
     uma função de utilizador para Lisp.

     Note que funções traduzidas podem não executar identicamente para
     o caminho que elas faziam antes da tradução como certas
     incompatabilidades podem existir entre o Lisp e versões do Maxima.
     Principalmente, a função  `rat' com mais de um argumento e a
     função `ratvars' não poderá ser usada se quaisquer variáveis são
     declaradas com `mode_declare' como sendo expressões rotacionais
     canónicas(CRE).  Também a escolha `prederror: false' não traduzirá.

     `savedef' - se `true' fará com que a versão Maxima de uma
     função  utilizador permaneça quando a função é traduzida com
     `translate'.  Isso permite a que definição seja mostrada por
     `dispfun' e autoriza a função a ser editada.

     `transrun' - se `false' fará com que a versão interpretada de
     todas as funções sejam executadas (desde que estejam ainda
     disponíveis) em lugar da versão traduzida.

     O resultado retornado por `translate' é uma lista de nomes de
     funções traduzidas.


 -- Função: translate_file (<maxima_nomeficheiro>)
 -- Função: translate_file (<maxima_nomeficheiro>, <lisp_nomeficheiro>)
     Traduz um ficheiro com código Maxima para um ficheiro com código
     Lisp.  `translate_file' retorna uma lista de três nomes de
     ficheiro: O nome do ficheiro Maxima, o nome do ficheiro Lisp, e o
     nome do ficheiro contendo informações adicionais sobre a
     tradução.  `translate_file' avalia seus argumentos.

     `translate_file ("foo.mac"); load("foo.LISP")' é o mesmo que
     `batch ("foo.mac")' excepto por certas restrições, o uso de `''' e
     `%', por exemplo.

     `translate_file (<maxima_nomeficheiro>)' traduz um ficheiro Maxima
     <maxima_nomeficheiro> para um similarmente chamado ficheiro Lisp.
     Por exemplo, `foo.mac' é traduzido em `foo.LISP'.  O nome de
     ficheiro Maxima pod incluir nome ou nomes de directório(s), nesse
     caso o ficheiro de saída Lisp é escrito para o mesmo directório
     que a entrada Maxima.

     `translate_file (<maxima_nomeficheiro>, <lisp_nomeficheiro>)'
     traduz um ficheiro Maxima <maxima_nomeficheiro> em um ficheiro
     Lisp <lisp_nomeficheiro>.  `translate_file' ignora a extensão do
     nome do ficheiro, se qualquer, de `lisp_nomeficheiro'; a extensão
     do ficheiro de saída Lisp é sempre `LISP'.  O nome de ficheiro
     Lisp pode incluir um nome ou nomes de directórios), nesse caso o
     ficheiro de saída Lisp é escrito para o directório especificado.

     `translate_file' também escreve um ficheiro de mensagens de alerta
     do tradutor em vários graus de severidade.  A extensão do nome de
     ficheiro desse ficheiro é `UNLISP'.  Esse ficheiro pode conter
     informação valiosa, apesar de possivelmente obscura, para rastrear
     erros no código traduzido.  O ficheiro `UNLISP' é sempre escrito
     para o mesmo directório que a entrada Maxima.

     `translate_file' emite código Lisp o qual faz com que algumas
     definições tenham efeito tão logo o código Lisp é compilado.  Veja
     `compile_file' para mais sobre esse tópico.

     Veja também `tr_array_as_ref', `tr_bound_function_applyp',
     `tr_exponent', `tr_file_tty_messagesp',
     `tr_float_can_branch_complex', `tr_function_call_default',
     `tr_numer', `tr_optimize_max_loop', `tr_semicompile',
     `tr_state_vars', `tr_warnings_get', `tr_warn_bad_function_calls',
     `tr_warn_fexpr', `tr_warn_meval', `tr_warn_mode',
     `tr_warn_undeclared', e `tr_warn_undefined_variable'.


 -- Variável de opção: transrun
     Valor por omissão: `true'

     Quando `transrun' é `false' fará com que a versão interpretada de
     todas as funções sejam executadas (desde que estejam ainda
     disponíveis) em lugar de versão traduzidas.


 -- Variável de opção: tr_array_as_ref
     Valor por omissão: `true'

     Se `translate_fast_arrays' for `false', referências a arrays no
     Código Lisp emitidas por `translate_file' são afectadas por
     `tr_array_as_ref'.  Quando `tr_array_as_ref' é `true', nomes de
     arrays são avaliados, de outra forma nomes de arrays aparecem como
     símbolos literais no código traduzido.

     `tr_array_as_ref' não terão efeito se `translate_fast_arrays' for
     `true'.


 -- Variável de opção: tr_bound_function_applyp
     Valor por omissão: `true'

     Quando `tr_bound_function_applyp' for `true', Maxima emite um
     alerta se uma associação de variável (tal como um argumento de
     função) é achada sendo usada como uma função.
     `tr_bound_function_applyp' não afecta o código gerado em tais
     casos.

     Por exemplo, uma expressão tal como `g (f, x) := f (x+1)' irá
     disparar a mensagem de alerta.


 -- Variável de opção: tr_file_tty_messagesp
     Valor por omissão: `false'

     Quando `tr_file_tty_messagesp' é `true', messagens geradas por
     `translate_file' durante a tradução de um ficheiro são mostradas
     sobre o console e inseridas dentro do ficheiro UNLISP.  Quando
     `false', messagens sobre traduções de ficheiros são somente
     inseridas dentro do ficheiro UNLISP.


 -- Variável de opção: tr_float_can_branch_complex
     Valor por omissão: `true'

     Diz ao tradutor Maxima-para-Lisp assumir que as funções `acos',
     `asin', `asec', e `acsc' podem retornar resultados complexos.

     O efeito ostensivo de `tr_float_can_branch_complex' é mostrado
     adiante.  Todavia, parece que esse sinalizador não tem efeito
     sobre a saída do tradutor.

     Quando isso for `true' então `acos(x)' será do modo `any' sempre
     que `x' for do modo `float' (como escolhido por `mode_declare').
     Quando `false' então `acos(x)' será do modo `float' se e somente
     se `x' for do modo `float'.


 -- Variável de opção: tr_function_call_default
     Valor por omissão: `general'

     `false' significa abandonando e chamando `meval', `expr' significa
     que Lisp assume função de argumento fixado.  `general', o código
     padrão dado como sendo bom para `mexprs' e `mlexprs' mas não
     `macros'.  `general' garante que associações de variável são
     correctas em códigos compilados.  No modo `general', quando
     traduzindo F(X), se F for uma variável associada, então isso
     assumirá que `apply (f, [x])' é significativo, e traduz como tal,
     com o alerta apropriado.  Não é necessário desabilitar isso.  Com
     as escolhas padrão, sem mensagens de alerta implica
     compatibilidade total do código traduzido e compilado com o
     interpretador Maxima.


 -- Variável de opção: tr_numer
     Valor por omissão: `false'

     Quando `tr_numer' for `true' propriedades `numer' são usadas para
     átomos que possuem essa propriedade, e.g. `%pi'.


 -- Variável de opção: tr_optimize_max_loop
     Valor por omissão: 100

     `tr_optimize_max_loop' é número máximo de vezes do passo de
     macro-expansão e optimização que o tradutor irá executar
     considerando uma forma.  Isso é para capturar erros de expansão de
     macro, e propriedades de optimização não terminadas.


 -- Variável de opção: tr_semicompile
     Valor por omissão: `false'

     Quando `tr_semicompile' for `true', as formas de saída de
     `translate_file' e `compfile' serão macroexpandidas mas não
     compiladas em código de máquina pelo compilador Lisp.


 -- Variável de sistema: tr_state_vars
     Valor por omissão:
          [transcompile, tr_semicompile, tr_warn_undeclared, tr_warn_meval,
          tr_warn_fexpr, tr_warn_mode, tr_warn_undefined_variable,
          tr_function_call_default, tr_array_as_ref,tr_numer]

     A lista de comutadores que afectam a forma de saída da tradução.
     Essa informação é útil para sistemas populares quando tentam
     depurar o tradutor.  Comparando o produto traduzido para o qual
     pode ter sido produzido por um dado estado, isso é possível para
     rastrear erros.


 -- Função: tr_warnings_get ()
     Imprime uma lista de alertas que podem ter sido dadas pelo
     tradutor durante a tradução corrente.


 -- Variável de opção: tr_warn_bad_function_calls
     Valor por omissão: `true'

     - Emite um alerta quando chamadas de função estão sendo feitas por
     um caminho que pode não ser correcto devido a declarações
     impróprias que foram feitas em tempo de tradução.


 -- Variável de opção: tr_warn_fexpr
     Valor por omissão: `compfile'

     - Emite um alerta se quaisquer FEXPRs forem encontradas.  FEXPRs
     não poderão normalmente ser saída em código traduzido, todas as
     formas de programa especial legítimo são traduzidas.


 -- Variável: tr_warn_meval
     Valor por omissão: `compfile'

     - Emite um alerta se a função `meval' recebe chamadas.  Se `meval'
     é chamada isso indica problemas na tradução.


 -- Variável: tr_warn_mode
     Valor por omissão: `all'

     - Emite um alerta quando a variáveis forem atribuídos valores
     inapropriados para seu modo.


 -- Variável de opção: tr_warn_undeclared
     Valor por omissão: `compile'

     - Determina quando enviar alertas sobre variáveis não declaradas
     para o TTY.


 -- Variável de opção: tr_warn_undefined_variable
     Valor por omissão: `all'

     - Emite um alerta quando variáveis globais indefinidas forem
     vistas.


 -- Função: compile_file (<nomeficheiro>)
 -- Função: compile_file (<nomeficheiro>, <nomeficheiro_compilado>)
 -- Função: compile_file (<nomeficheiro>, <nomeficheiro_compilado>,
          <lisp_nomeficheiro>)
     Traduz o ficheiro Maxima <nomeficheiro> para Lisp, executa o
     compilador Lisp, e, se a tradução e a compilação obtiverem
     sucesso, chama o código compilado dentro do Maxima.

     `compile_file' retorna uma lista dos nomes de quatro ficheiros: o
     ficheiro original do Maxima, o nome da tradução Lisp, uma ficheiro
     de notas sobre a tradução, e o nome do ficheiro que contém o
     código compilado.  Se a compilação falhar, o quarto item é `false'.

     Algumas declarações e definições passam a ter efeito tão logo o
     código Lisp seja compilado (sem que seja necessário chamar o
     código compilado).  Isso inclui funções definidas com o operador
     `:=', macros definidas com o operador `::=', `alias', `declare',
     `define_variable',  `mode_declare', e `infix', `matchfix',
     `nofix', `postfix', `prefix', e `compfile'.

     Atribuições e chamadas de função não serão avaliadas até que o
     código compilado seja carregado.  Em particular, dentro do
     ficheiro Maxima, atribuições para sinalizadores traduzidos
     (`tr_numer', etc.) não têm efeito sobre a tradução.

     <nomeficheiro> pode não conter declarações `:lisp'.

     `compile_file' avalia seus argumentos.


 -- Função: declare_translated (<f_1>, <f_2>, ...)
     Quando traduzindo um ficheiro do código Maxima para Lisp, é
     importante para o programa tradutor saber quais funções no
     ficheiro são para serem chamadas como funções traduzidas ou
     compiladas, e quais outras são apenas funções Maxima ou
     indefinidas.  Colocando essa declaração no topo do ficheiro,
     faremos conhecido que embora um símbolo diga que não temos ainda
     um valor de função Lisp, teremos uma em tempo de chamada.
     `(MFUNCTION-CALL fn arg1 arg2 ...)' é gerado quando o tradutor
     n~ao sabe que `fn' está sendo compilada para ser uma função Lisp.



File: maxima.info,  Node: Fluxo de Programa,  Next: Depuração,  Prev: Definição de Função,  Up: Top

40 Fluxo de Programa
********************

* Menu:

* Introdução a Fluxo de Programa::
* Definições para Fluxo de Programa::


File: maxima.info,  Node: Introdução a Fluxo de Programa,  Next: Definições para Fluxo de Programa,  Prev: Fluxo de Programa,  Up: Fluxo de Programa

40.1 Introdução a Fluxo de Programa
===================================

Maxima fornece um `do' para ciclos iterativos, também contruções mais
primitivas tais como `go'.


File: maxima.info,  Node: Definições para Fluxo de Programa,  Prev: Introdução a Fluxo de Programa,  Up: Fluxo de Programa

40.2 Definições para Fluxo de Programa
======================================

 -- Função: backtrace ()
 -- Função: backtrace (<n>)
     Imprime a pilha de chamadas, que é, a lista de funções que foram
     chamadas pela função correntemente activa.

     `backtrace()' imprime toda a pilha de chamadas.

     `backtrace (<n>)' imprime as <n> mais recentes chamadas a
     funções, incluindo a função correntemente activa.

     `backtrace' pode ser chamada por um script, uma função, ou a
     partir da linha de comando interativa (não somente em um contexto
     de depuração).

     Exemplos:

        * `backtrace()' imprime toda a pilha de chamadas.

               (%i1) h(x) := g(x/7)$
               (%i2) g(x) := f(x-11)$
               (%i3) f(x) := e(x^2)$
               (%i4) e(x) := (backtrace(), 2*x + 13)$
               (%i5) h(10);
               #0: e(x=4489/49)
               #1: f(x=-67/7)
               #2: g(x=10/7)
               #3: h(x=10)
                                             9615
               (%o5)                         ----
                                              49

        * `backtrace (<n>)' imprime as <n> mais recentes chamadas a
          funções, incluindo a função correntemente activa.

               (%i1) h(x) := (backtrace(1), g(x/7))$
               (%i2) g(x) := (backtrace(1), f(x-11))$
               (%i3) f(x) := (backtrace(1), e(x^2))$
               (%i4) e(x) := (backtrace(1), 2*x + 13)$
               (%i5) h(10);
               #0: h(x=10)
               #0: g(x=10/7)
               #0: f(x=-67/7)
               #0: e(x=4489/49)
                                             9615
               (%o5)                         ----
                                              49


 -- Operador especial: do
     A declaração `do' é usada para executar iteração.  Devido à sua
     grande generalidade a declaração `do' será  descrita em duas
     partes.  Primeiro a forma usual será dada que é análoga à forma
     que é usada em muitas outras linguagens de programação (Fortran,
     Algol, PL/I, etc.); em segundo lugar os outros recursos serão
     mencionados.

     Existem três variantes do operador especial `do' que diferem
     somente por suas condições de encerramento.  São elas:

        * `for <Variável>: <valor_inicial> step <incremento>       thru
          <limite> do <corpo>'

        * `for <Variável>: <valor_inicial> step <incremento>
          while <condition> do <corpo>'

        * `for <Variável>: <valor_inicial> step <incremento>
          unless <condition> do <corpo>'

     (Alternativamente, o `step' pode ser dado após a condição de
     encerramento ou limite.)

     <valor_inicial>, <incremento>, <limite>, e <corpo> podem ser
     quaisquer expressões.  Se o incremento for 1 então "`step 1'" pode
     ser omitido.

     A execução da declaração `do' processa-se primeiro atribuindo o
     valor_inicial para a variável (daqui em diante chamada a variável
     de controle).  Então: (1) Se a variável de controle excede o
     limite de uma especificação `thru', ou se a condição de `unless'
     for `true', ou se a condição de `while' for `false' então o `do'
     será encerrado.  (2) O corpo é avaliado.  (3) O incremento é
     adicionado à variável de controle.  O processo de (1) a (3) é
     executado repetidamente até que a condição de encerramento seja
     satisfeita.  Pode-se também dar muitas condições de encerramento e
     nesse caso o `do' termina quando qualquer delas for satisfeita.

     Em geral o teste `thru' é satisfeito quando a variável de controle
     for maior que o limite se o incremento for não negativo, ou quando
     a variável de controle for menor que o limite se o incremento for
     negativo.  O incremento e o limite podem ser expressões não
     numéricas enquanto essa desigualdade puder ser determinada.
     Todavia, a menos que o incremento seja sintaticamente negativo
     (e.g. for um número negativo) na hora em que a declaração `do' for
     iniciada, Maxima assume que o incremento e o limite serão
     positivos quando o `do' for executado.  Se o limite e o incremento
     não forem positivos, então o `do' pode não terminar propriamente.

     Note que o limite, incremento, e condição de encerramento são
     avaliados cada vez que ocorre um ciclo.  Dessa forma se qualquer
     desses for responsável por muitos cálculos, e retornar um
     resultado que não muda durante todas as execuções do corpo, então
     é mais eficiente escolher uma variável para seu valor anterior
     para o `do' e usar essa variável na forma `do'.

     O valor normalmente retornado por uma declaração `do' é o átomo
     `done'.  Todavia, a função `return' pode ser usada dentro do corpo
     para sair da delcaração `do' prematuramente e dar a isso qualquer
     valor desejado.  Note todavia que um `return' dentro de um `do' que
     ocorre em um `block' encerrará somente o `do' e não o `block'.
     Note também que a função `go' não pode ser usada para sair de
     dentro de um `do' dentro de um `block' que o envolve.

     A variável de controle é sempre local para o `do' e dessa forma
     qualquer variável pode ser usada sem afectar o valor de uma
     variável com o mesmo nome fora da declaração `do'.  A variável de
     controle é liberada após o encerramento da declaração `do'.

          (%i1) for a:-3 thru 26 step 7 do display(a)$
                                       a = - 3

                                        a = 4

                                       a = 11

                                       a = 18

                                       a = 25

          (%i1) s: 0$
          (%i2) for i: 1 while i <= 10 do s: s+i;
          (%o2)                         done
          (%i3) s;
          (%o3)                          55

     Note que a condição `while i <= 10' é equivalente a `unless i >
     10' e também `thru 10'.

          (%i1) series: 1$
          (%i2) term: exp (sin (x))$
          (%i3) for p: 1 unless p > 7 do
                    (term: diff (term, x)/p,
                     series: series + subst (x=0, term)*x^p)$
          (%i4) series;
                            7    6     5    4    2
                           x    x     x    x    x
          (%o4)            -- - --- - -- - -- + -- + x + 1
                           90   240   15   8    2

     que fornece 8 termos da série de Taylor para `e^sin(x)'.

          (%i1) poly: 0$
          (%i2) for i: 1 thru 5 do
                    for j: i step -1 thru 1 do
                        poly: poly + i*x^j$
          (%i3) poly;
                            5      4       3       2
          (%o3)          5 x  + 9 x  + 12 x  + 14 x  + 15 x
          (%i4) guess: -3.0$
          (%i5) for i: 1 thru 10 do
                    (guess: subst (guess, x, 0.5*(x + 10/x)),
                     if abs (guess^2 - 10) < 0.00005 then return (guess));
          (%o5)                  - 3.162280701754386

     Esse exemplo calcula a raíz quadrada negativa de 10 usando a
     iteração de Newton- Raphson um maximum de 10 vezes.  Caso o
     critério de convergêcia não tenha sido encontrado o valor
     retornado pode ser `done'.  Em lugar de sempre adicionar uma
     quantidade à variável de controle pode-se algumas vezes desejar
     alterar isso de alguma outra forma para cada iteração.  Nesse caso
     pode-se usar `next <expressão>' em lugar de `step <incremento>'.
     Isso fará com que a variável de controle seja escolhida para o
     resultado da expressão de avaliação cada vez que o ciclo de
     repetição for executado.

          (%i6) for count: 2 next 3*count thru 20 do display (count)$
                                      count = 2

                                      count = 6

                                     count = 18

     Como uma alternativa para `for <Variável>: <valor> ...do...' a
     sintaxe `for <Variável> from <valor> ...do...'  pode ser usada.
     Isso permite o `from <valor>' ser colocado após o `step' ou
     proximo valor ou após a condição de encerramento.  Se `from
     <valor>' for omitido então 1 é usado como o valor inicial.

     Algumas vezes se pode estar interessado em executar uma
     iteração onde a variável de controle nunca seja usada.  Isso é
     permissível para dar somente as condições de encerramento omitindo
     a inicialização e a informação de actualização como no exemplo
     seguinte para para calcular a raíz quadrada de 5 usando uma fraca
     suposição inicial.

          (%i1) x: 1000$
          (%i2) thru 20 do x: 0.5*(x + 5.0/x)$
          (%i3) x;
          (%o3)                   2.23606797749979
          (%i4) sqrt(5), numer;
          (%o4)                   2.23606797749979

     Se isso for desejado pode-se sempre omitir as condições de
     encerramento inteiramente e apenas dar o corpo `do <corpo>' que
     continuará a ser avaliado indefinidamente.  Nesse caso a função
     `return' será usada para encerrar a execução da declaração `do'.

          (%i1) newton (f, x):= ([y, df, dfx], df: diff (f ('x), 'x),
                    do (y: ev(df), x: x - f(x)/y,
                        if abs (f (x)) < 5e-6 then return (x)))$
          (%i2) sqr (x) := x^2 - 5.0$
          (%i3) newton (sqr, 1000);
          (%o3)                   2.236068027062195

     (Note que `return', quando executado, faz com que o valor corrente
     de `x' seja retornado como o valor da declaração `do'.  O `block'
     é encerrado e esse valor da declaração `do' é retornado como o
     valor do `block' porque o `do' é a última declaração do `block'.)

     Uma outra forma de `do' é disponível no Maxima.  A sintaxe é:

          for <Variável> in <list> <end_tests> do <corpo>

     Os elementos de <list> são quaisquer expressões que irão
     sucessivamente ser atribuídas para a variável a cada iteração do
     corpo.  O teste opcional <end_tests> pode ser usado para encerrar
     a execução da declaração `do'; de outra forma o `do' terminará
     quando a lista for exaurida ou quando um `return' for executado no
     corpo.  (De facto, a lista pode ser qualquer expressão não
     atômica, e partes sucessivas são usadas.)

          (%i1)  for f in [log, rho, atan] do ldisp(f(1))$
          (%t1)                                  0
          (%t2)                                rho(1)
                                               %pi
          (%t3)                                 ---
                                                4
          (%i4) ev(%t3,numer);
          (%o4)                             0.78539816


 -- Função: errcatch (<expr_1>, ..., <expr_n>)
     Avalia <expr_1>, ..., <expr_n> uma por uma e retorna `[<expr_n>]'
     (uma lista) se nenhum erro ocorrer.  Se um erro ocorrer na
     avaliação de qualquer argumento, `errcatch' evita que o erro se
     propague e retorna a lista vazia `[]' sem avaliar quaisquer mais
     argumentos.

     `errcatch' é útil em ficheiros `batch' onde se suspeita que um
     erro possa estar ocorrendo o `errcatch' terminará o `batch' se o
     erro não for detectado.


 -- Função: error (<expr_1>, ..., <expr_n>)
 -- Variável de sistema: error
     Avalia e imprime <expr_1>, ..., <expr_n>, e então causa um retorno
     de erro para o nível mais alto do Maxima ou para o mais próximo
     contendo `errcatch'.

     A variável `error' é escolhida para uma lista descrevendo o erro.
     O primeiro elemento de `error' é uma sequência de caracteres de
     formato, que junta todas as sequências de caracteres entre os
     argumentos <expr_1>, ..., <expr_n>, e os elementos restantes são
     os valores de quaisquer argumentos que não são sequências de
     caracteres.

     `errormsg()' formata e imprime `error'.  Isso efectivamente
     reimprime a mais recente mensagem de erro.


 -- Função: errormsg ()
     Reimprime a mais recente mensagem de erro.  A variável `error'
     recebe a mensagem, e `errormsg' formata e imprime essa mensagem.


 -- Operador especial: for
     Usado em iterações.  Veja `do' para uma descrição das facilidades
     de iteração do Maxima.


 -- Função: go (<tag>)
     é usada dentro de um `block' para transferir o controle para a
     declaração do bloco que for identificada com o argumento para
     `go'.  Para identificar uma declaração, coloque antes dessa
     declaração um argumento atômico como outra declaração no `block'.
     Por exemplo:

          block ([x], x:1, loop, x+1, ..., go(loop), ...)

     O argumento para `go' deve ser o nome de um identificardor
     aparecendo no mesmo `block'.  Não se pode usar `go' para
     transferir para um identificador em um outro `block' que não seja
     o próprio contendo o `go'.


 -- Operador especial: if
     Representa avaliação condicional. Várias formas de expressões `if'
     são reconhecidas.  `if <cond_1> then <expr_1> else <expr_0>'
     avalia para <expr_1> se <cond_1> avaliar para `true', de outra
     forma a expressão avalia para `expr_0'.

     `if <cond_1> then <expr_1> elseif <cond_2> then <expr_2> elseif
     ... else <expr_0>' avalia para <expr_k> se <cond_k> for `true' e
     todas as condições precedentes forem `false'.  Se nenhuma das
     condições forem `true', a expressão avalia para `expr_0'.

     O comportamento `else false' é assumido se `else' for omitido.
     Isso é, `if <cond_1> then <expr_1>' é equivalente a `if <cond_1>
     then <expr_1> else false', e `if <cond_1> then <expr_1> elseif ...
     elseif <cond_n> then <expr_n>' é equivalente a `if <cond_1> then
     <expr_1> elseif ... elseif <cond_n> then <expr_n> else false'.

     As alternativas <expr_0>, ..., <expr_n> podem ser quaisquer
     expressões do Maxima, incluíndo expressões `if' aninhadas ( if
     dentro de if).  As alternativas não são nem simplificadas nem
     avaliadas a menos que a correspondente condição seja `true'.

     As condições <cond_1>, ..., <cond_n> são expressões tais que
     `is(<cond_k>)' avaliem para `true' ou para `false'; de outra forma
     é um erro.  Entre outros elementos, condições podem compreender
     operadores lógicos e relacionais como segue.

          Operação             Símbolo      Tipo

          menor que            <           infixo relacional
          menor que            <=
            ou igual a                     infixo relacional
          igualdade            =
            (sintática)                    infixo relacional
          negação de =         #           infixo relacional
          igualdade (valor)    equal       função relacional
          negação de           notequal
            igualdade                      função relacional
          maior que            >=
            ou igual a                     infixo relacional
          maior que            >           infixo relacional
          e                    and         infixo lógico
          ou                   or          infixo lógico
          não                  not         prefixo lógico


 -- Função: map (<f>, <expr_1>, ..., <expr_n>)
     Retorna uma expressão cujo operador principal é o mesmo que o das
     expressões <expr_1>, ..., <expr_n> mas cujas subpartes são os
     resultados da aplicação de <f> nas correspondentes subpartes das
     expressões.  <f> é ainda o nome de uma função de n argumentos ou é
     uma forma `lambda' de n argumentos.

     `maperror' - se `false' fará com que todas as funções mapeadas (1)
     parem quando elas terminarem retornando a menor expi se não forem
     todas as expi do mesmo comprimento e (2) aplique fn a [exp1,
     exp2,...]  se expi não forem todas do mesmo tipo de objecto.  Se
     `maperror' for `true' então uma mensagem de erro será dada nas
     duas instâncias acima.

     Um dos usos dessa função é para mapear (`map') uma função (e.g.
     `partfrac') sobre cada termo de uma expressão muito larga onde
     isso comumente não poderia ser possível usar a função sobre a
     expressão inteira devido a uma exaustão de espaço da lista de
     armazenamento no decorrer da computação.

          (%i1) map(f,x+a*y+b*z);
          (%o1)                        f(b z) + f(a y) + f(x)
          (%i2) map(lambda([u],partfrac(u,x)),x+1/(x^3+4*x^2+5*x+2));
                                     1       1        1
          (%o2)                     ----- - ----- + -------- + x
                                   x + 2   x + 1          2
                                                   (x + 1)
          (%i3) map(ratsimp, x/(x^2+x)+(y^2+y)/y);
                                                1
          (%o3)                            y + ----- + 1
                                              x + 1
          (%i4) map("=",[a,b],[-0.5,3]);
          (%o4)                          [a = - 0.5, b = 3]

 -- Função: mapatom (<expr>)
     Retorna `true' se e somente se <expr> for tratada pelas rotinas de
     mapeamento como um átomo.  "Mapatoms" são átomos, números
     (incluíndo números racioanais), e variáveis subscritas.


 -- Variável de opção: maperror
     Valor por omissão: `true'

     Quando `maperror' é `false', faz com que todas as funções
     mapeadas, por exemplo

          map (f, expr_1, expr_2, ...))

     (1) parem quando elas terminarem retornando a menor expi se não
     forem todas as expi do mesmo comprimento e (2) aplique `f' a
     `[expr_1, expr_2, ...]' se `expr_i' não forem todas do mesmo tipo
     de objecto.

     Se `maperror' for `true' então uma ,mensagem de erro é mostrada
     nas duas instâncias acima.


 -- Função: maplist (<f>, <expr_1>, ..., <expr_n>)
     Retorna uma lista de aplicações de <f> em todas as partes das
     expressões <expr_1>, ..., <expr_n>.  <f> é o nome de uma função,
     ou uma expressão lambda.

     `maplist' difere de `map (<f>, <expr_1>, ..., <expr_n>)' que
     retorna uma expressão com o mesmo operador principal que <expr_i>
     tem (excepto para simplificações  e o caso onde `map' faz um
     `apply').


 -- Variável de opção: prederror
     Valor por omissão: `true'

     Quando `prederror' for `true', uma mensagem de erro é mostrada
     sempre que o predicado de uma declaração `if' ou uma função `is'
     falha em avaliar ou para `true' ou para  `false'.

     Se `false', `unknown' é retornado no lugar nesse caso.  O modo
     `prederror: false' não é suportado no código traduzido; todavia,
     `maybe' é suportado no código traduzido.

     Veja também `is' e `maybe'.


 -- Função: return (valor)
     Pode ser usada para sair explicitamente de um bloco, levando seu
     argumento.  Veja `block' para mais informação.


 -- Função: scanmap (<f>, <expr>)
 -- Função: scanmap (<f>, <expr>, bottomup)
     Recursivamente aplica <f> a <expr>, de cima para baixo.  Isso é
     muito útil quando uma factoração completa é desejada, por exemplo:

          (%i1) exp:(a^2+2*a+1)*y + x^2$
          (%i2) scanmap(factor,exp);
                                              2      2
          (%o2)                         (a + 1)  y + x

     Note o caminho através do qual `scanmap' aplica a dada função
     `factor' para as subexpressões constituintes de <expr>; se outra
     forma de <expr> é apresentada para `scanmap' então o resultado
     pode ser diferente.  Dessa forma, `%o2' não é recuperada quando
     `scanmap' é aplicada para a forma expandida de exp:

          (%i3) scanmap(factor,expand(exp));
                                     2                  2
          (%o3)                      a  y + 2 a y + y + x

     Aqui está um outro exemplo do caminho no qual `scanmap' aplica
     recursivamente uma função dada para todas as subexpressões,
     incluindo expoentes:

          (%i4) expr : u*v^(a*x+b) + c$
          (%i5) scanmap('f, expr);
                              f(f(f(a) f(x)) + f(b))
          (%o5) f(f(f(u) f(f(v)                      )) + f(c))

     `scanmap (<f>, <expr>, bottomup)' aplica <f> a <expr> de baixo
     para cima.  E.g., para `f' indefinida,

          scanmap(f,a*x+b) ->
             f(a*x+b) -> f(f(a*x)+f(b)) -> f(f(f(a)*f(x))+f(b))
          scanmap(f,a*x+b,bottomup) -> f(a)*f(x)+f(b)
              -> f(f(a)*f(x))+f(b) ->
               f(f(f(a)*f(x))+f(b))

     Neste caso, obtém-se a mesma resposta pelos dois métodos.


 -- Função: throw (<expr>)
     Avalia <expr> e descarta o valor retornado para o mais recente
     `catch'.  `throw' é usada com `catch' como um mecanismo de retorno
     não local.


 -- Operador especial: while
     Veja `do'.


 -- Função: outermap (<f>, <a_1>, ..., <a_n>)
     Aplica a função <f> para cada um dos elementos do produto externo
     <a_1> vezes <a_2> ... vezes <a_n>.

     <f> é o nome de uma função de n argumentos ou uma expressão lambda
     de n argumentos.  Cada argumento <a_k> pode ser uma lista simples
     ou lista aninhada ( lista contendo listas como elementos ), ou uma
     matrz, ou qualquer outro tip de expressão.

     O valor de retorno de `outermap' é uma estrutura aninhada.
     Tomemos <x> como sendo o valor de retorno.  Então <x> tem a mesma
     estrutura da primeira lista, lista aninhada, ou argumento matriz,
     `<x>[i_1]...[i_m]' tem a mesma estrutura que a segunda lista,
     lista aninhada, ou argumento matriz,
     `<x>[i_1]...[i_m][j_1]...[j_n]' tem a mesma estrutura que a
     terceira lista, lista aninhada, ou argumento matriz, e assim por
     diante, onde <m>, <n>, ... são os números dos índices requeridos
     para acessar os elementos de cada argumento (um para uma lista,
     dois para uma matriz, um ou mais para uma lista aninhada).
     Argumentos que não forem listas ou matrizes não afectam a
     estrutura do valor de retorno.

     Note que o efeito de `outermap' é diferente daquele de aplicar <f>
     a cada um dos elementos do produto externo retornado por
     `cartesian_product'.  `outermap' preserva a estrutura dos
     argumentos no valor de retorno, enquanto `cartesian_product' não
     reserva essa mesma estrutura.

     `outermap' avalia seus argumentos.

     Veja também `map', `maplist', e `apply'.

     Exemplos: Exemplos elementares de `outermap'.  Para mostrar a a
     combinação de argumentos mais claramente, `F' está indefinida à
     esquerda.

          (%i1) outermap (F, [a, b, c], [1, 2, 3]);
          (%o1) [[F(a, 1), F(a, 2), F(a, 3)], [F(b, 1), F(b, 2), F(b, 3)],
                                               [F(c, 1), F(c, 2), F(c, 3)]]
          (%i2) outermap (F, matrix ([a, b], [c, d]), matrix ([1, 2], [3, 4]));
                   [ [ F(a, 1)  F(a, 2) ]  [ F(b, 1)  F(b, 2) ] ]
                   [ [                  ]  [                  ] ]
                   [ [ F(a, 3)  F(a, 4) ]  [ F(b, 3)  F(b, 4) ] ]
          (%o2)    [                                            ]
                   [ [ F(c, 1)  F(c, 2) ]  [ F(d, 1)  F(d, 2) ] ]
                   [ [                  ]  [                  ] ]
                   [ [ F(c, 3)  F(c, 4) ]  [ F(d, 3)  F(d, 4) ] ]
          (%i3) outermap (F, [a, b], x, matrix ([1, 2], [3, 4]));
                 [ F(a, x, 1)  F(a, x, 2) ]  [ F(b, x, 1)  F(b, x, 2) ]
          (%o3) [[                        ], [                        ]]
                 [ F(a, x, 3)  F(a, x, 4) ]  [ F(b, x, 3)  F(b, x, 4) ]
          (%i4) outermap (F, [a, b], matrix ([1, 2]), matrix ([x], [y]));
                 [ [ F(a, 1, x) ]  [ F(a, 2, x) ] ]
          (%o4) [[ [            ]  [            ] ],
                 [ [ F(a, 1, y) ]  [ F(a, 2, y) ] ]
                                        [ [ F(b, 1, x) ]  [ F(b, 2, x) ] ]
                                        [ [            ]  [            ] ]]
                                        [ [ F(b, 1, y) ]  [ F(b, 2, y) ] ]
          (%i5) outermap ("+", [a, b, c], [1, 2, 3]);
          (%o5) [[a + 1, a + 2, a + 3], [b + 1, b + 2, b + 3],
                                                     [c + 1, c + 2, c + 3]]

     Uma explanação final do valor de retorno de `outermap'.  Os
     argumentos primeiro, segundo, e terceiro são matriz, lista, e
     matriz, respectivamente.  O valor de retorno é uma matriz.  Cada
     elementos daquela matriz é uma lista, e cada elemento de cada
     lista é uma matriz.

          (%i1) arg_1 :  matrix ([a, b], [c, d]);
                                      [ a  b ]
          (%o1)                       [      ]
                                      [ c  d ]
          (%i2) arg_2 : [11, 22];
          (%o2)                       [11, 22]
          (%i3) arg_3 : matrix ([xx, yy]);
          (%o3)                      [ xx  yy ]
          (%i4) xx_0 : outermap (lambda ([x, y, z], x / y + z), arg_1, arg_2, arg_3);
                         [  [      a        a  ]  [      a        a  ]  ]
                         [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                         [  [      11       11 ]  [      22       22 ]  ]
          (%o4)  Col 1 = [                                              ]
                         [  [      c        c  ]  [      c        c  ]  ]
                         [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                         [  [      11       11 ]  [      22       22 ]  ]
                           [  [      b        b  ]  [      b        b  ]  ]
                           [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                           [  [      11       11 ]  [      22       22 ]  ]
                   Col 2 = [                                              ]
                           [  [      d        d  ]  [      d        d  ]  ]
                           [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                           [  [      11       11 ]  [      22       22 ]  ]
          (%i5) xx_1 : xx_0 [1][1];
                     [      a        a  ]  [      a        a  ]
          (%o5)     [[ xx + --  yy + -- ], [ xx + --  yy + -- ]]
                     [      11       11 ]  [      22       22 ]
          (%i6) xx_2 : xx_0 [1][1] [1];
                                [      a        a  ]
          (%o6)                 [ xx + --  yy + -- ]
                                [      11       11 ]
          (%i7) xx_3 : xx_0 [1][1] [1] [1][1];
                                            a
          (%o7)                        xx + --
                                            11
          (%i8) [op (arg_1), op (arg_2), op (arg_3)];
          (%o8)                  [matrix, [, matrix]
          (%i9) [op (xx_0), op (xx_1), op (xx_2)];
          (%o9)                  [matrix, [, matrix]

     `outermap' preserves the structure of the arguments in the return
     value, while `cartesian_product' does not.

          (%i1) outermap (F, [a, b, c], [1, 2, 3]);
          (%o1) [[F(a, 1), F(a, 2), F(a, 3)], [F(b, 1), F(b, 2), F(b, 3)],
                                               [F(c, 1), F(c, 2), F(c, 3)]]
          (%i2) setify (flatten (%));
          (%o2) {F(a, 1), F(a, 2), F(a, 3), F(b, 1), F(b, 2), F(b, 3),
                                                 F(c, 1), F(c, 2), F(c, 3)}
          (%i3) map (lambda ([L], apply (F, L)), cartesian_product ({a, b, c}, {1, 2, 3}));
          (%o3) {F(a, 1), F(a, 2), F(a, 3), F(b, 1), F(b, 2), F(b, 3),
                                                 F(c, 1), F(c, 2), F(c, 3)}
          (%i4) is (equal (%, %th (2)));
          (%o4)                         true



File: maxima.info,  Node: Depuração,  Next: augmented_lagrangian,  Prev: Fluxo de Programa,  Up: Top

41 Depuração
************

* Menu:

* Depuração do Código Fonte::
* Comandos Palavra Chave::
* Definições para Depuração::



Local Variables:
coding: iso-8859-1
End:
