This is maxima.info, produced by makeinfo version 4.13 from maxima.texi.

Ver. 5.30 Este es el Manual de Maxima en versión Texinfo

   Copyright 1994, 2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).  Un sistema de cálculo simbólico
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Funciones y variables para draw,  Next: Funciones y variables para picture,  Prev: Introducción a draw,  Up: draw

47.2 Funciones y variables para draw
====================================

47.2.1 Escenas
--------------

 -- Constructor de escena: gr2d (<Opción gráfica>, ...,
          <graphic_object>, ...)
     La función `gr2d' construye un objeto que describe una escena 2d.
     Los argumentos son opciones gráficas y objetos gráficos o listas
     que contengan elementos de ambos tipos. Esta escena se interpreta
     secuencialmente: las opciones gráficas afectan a aquellos objetos
     gráficos colocados a su derecha. Algunas opciones gráficas afectan
     al aspecto global de la escena.

     La lista de objetos gráficos disponibles para escenas en dos
     dimensiones: `bars', `ellipse', `explicit', `image', `implicit',
     `label', `parametric', `points', `polar', `polygon',
     `quadrilateral', `rectangle', `triangle', `vector' y `geomap'
     (este último definido en el paquete `worldmap').

     Véanse también `draw' y `draw2d'.

     Para utilizar este objecto, ejecútese primero `load(draw)'.

 -- Constructor de escena: gr3d (<Opción gráfica>, ...,
          <graphic_object>, ...)
     La función `gr3d' construye un objeto que describe una escena 3d.
     Los argumentos son opciones gráficas y objetos gráficos o listas
     que contengan elementos de ambos tipos. Esta escena se interpreta
     secuencialmente: las opciones gráficas afectan a aquellos objetos
     gráficos colocados a su derecha. Algunas opciones gráficas afectan
     al aspecto global de la escena.

     La lista de objetos gráficos disponibles para escenas en tres
     dimensiones: `cylindrical', `elevation_grid', `explicit',
     `implicit', `label', `mesh', `parametric', `parametric_surface',
     `points', `quadrilateral', `spherical', `triangle', `tube',
     `vector' y `geomap' (este último definido en el paquete
     `worldmap').

     Véanse también `draw' y `draw3d'.

     Para utilizar este objeto, ejecútese primero `load(draw)'.

47.2.2 Funciones
----------------

 -- Función: draw (<gr2d>, ..., <gr3d>, ..., <options>, ...)
     Representa gráficamente una serie de escenas; sus argumentos son
     objetos `gr2d' y/o `gr3d', junto con algunas opciones, o listas de
     escenas y opciones.  Por defecto, las escenas se representan en
     una columna.

     La función `draw' acepta las siguientes opciones globales:
     `terminal', `columns', `dimensions', `file_name' y `delay'.

     Las funciones `draw2d' y `draw3d' son atajos a utilizar cuando se
     quiere representar una única escena en dos o tres dimensiones,
     respectivamente.

     Véanse también `gr2d' y `gr3d'.

     Para utilizar esta función, ejecútese primero `load(draw)'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) scene1: gr2d(title="Ellipse",
                             nticks=30,
                             parametric(2*cos(t),5*sin(t),t,0,2*%pi))$
          (%i3) scene2: gr2d(title="Triangle",
                             polygon([4,5,7],[6,4,2]))$
          (%i4) draw(scene1, scene2, columns = 2)$

     Las dos sentencias gráficas siguientes son equivalentes:
          (%i1) load(draw)$
          (%i2) draw(gr3d(explicit(x^2+y^2,x,-1,1,y,-1,1)));
          (%o2)                          [gr3d(explicit)]
          (%i3) draw3d(explicit(x^2+y^2,x,-1,1,y,-1,1));
          (%o3)                          [gr3d(explicit)]

     Un fichero gif animado:
          (%i1) load(draw)$
          (%i2) draw(
                  delay     = 100,
                  file_name = "zzz",
                  terminal  = 'animated_gif,
                  gr2d(explicit(x^2,x,-1,1)),
                  gr2d(explicit(x^3,x,-1,1)),
                  gr2d(explicit(x^4,x,-1,1)));
          End of animation sequence
          (%o2)          [gr2d(explicit), gr2d(explicit), gr2d(explicit)]

     Véanse también `gr2d', `gr3d', `draw2d' y `draw3d'.

 -- Función: draw2d (<option>, <graphic_object>, ...)
     Esta función es un atajo para `draw(gr2d(<options>, ...,
     <graphic_object>, ...))'.

     Puede utilizarse para representar una única escena en 2d.

     Para utilizar esta función, ejecútese primero `load(draw)'.

     Véanse también `draw' y `gr2d'.

 -- Función: draw3d (<option>, <graphic_object>, ...)
     Esta función es un atajo para `draw(gr3d(<options>, ...,
     <graphic_object>, ...))'.

     Puede utilizarse para representar una única escena en 3d.

     Para utilizar esta función, ejecútese primero `load(draw)'.

     Véanse también `draw' y `gr3d'.

 -- Función: draw_file (<Opción gráfica>, ..., <Opción gráfica>, ...)
     Almacena el gráfico actual en un fichero. Las opciones gráficas que
     acepta son: `terminal', `dimensions', `file_name' y
     `background_color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) /* dibujo en pantalla */
                draw(gr3d(explicit(x^2+y^2,x,-1,1,y,-1,1)))$
          (%i3) /* same plot in eps format */
                draw_file(terminal  = eps,
                          dimensions = [5,5]) $

 -- Función: multiplot_mode (<term>)
     Esta función permite a Maxima trabajar en modo de gráficos
     múltiples en una sola ventana del terminal <term>; argumentos
     válidos para esta función son `screen', `wxt', `aquaterm' y `none'.

     Cuando el modo de gráficos múltiples está activo, cada llamada a
     `draw' envía un nuevo gr'afico a la misma ventana, sin borrar los
     anteriores.  Para desactivar el modo de gráficos múltiples
     escríbase `multiplot_mode(none)'.

     Cuando el modo de gráficos múltiples está activo, la opción global
     `terminal' se bloquea; para desbloquearla y cambiar de terminal es
     necesario desactivar previamente el modo de gráficos múltiples.

     Este modo de trabajo no funciona en plataformas Windows.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) set_draw_defaults(
                   xrange = [-1,1],
                   yrange = [-1,1],
                   grid   = true,
                   title  = "Step by step plot" )$
          (%i3) multiplot_mode(screen)$
          (%i4) draw2d(color=blue,  explicit(x^2,x,-1,1))$
          (%i5) draw2d(color=red,   explicit(x^3,x,-1,1))$
          (%i6) draw2d(color=brown, explicit(x^4,x,-1,1))$
          (%i7) multiplot_mode(none)$

 -- Función: set_draw_defaults (<Opción gráfica>, ..., <Opción
          gráfica>, ...)
     Establece las opciones gráficas de usuario. Esta función es útil
     para dibujar varios gráficos con las mismas opciones. Llamando a
     la función sin argumentos se borran las opciones de usuario por
     defecto.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) set_draw_defaults(
                   xrange = [-10,10],
                   yrange = [-2, 2],
                   color  = blue,
                   grid   = true)$
          (%i3) /* dibujo con opciones de usuario */
                draw2d(explicit(((1+x)**2/(1+x*x))-1,x,-10,10))$
          (%i4) set_draw_defaults()$
          (%i5) /* dibujo con opciones por defecto */
                draw2d(explicit(((1+x)**2/(1+x*x))-1,x,-10,10))$

     Para utilizar esta función, ejecútese primero `load(draw)'.

47.2.3 Opciones gráficas
------------------------

 -- Opción gráfica: adapt_depth
     Valor por defecto: 10

     `adapt_depth' es el número máximo de particiones utilizadas por la
     rutina gráfica adaptativa.

     Esta opción sólo es relevante para funciones de tipo `explicit' en
     2d.

 -- Opción gráfica: allocation
     Valor por defecto: `false'

     Con la opción `allocation' es posible colocar a voluntad una
     escena en la ventana de salida, lo cual resulta de utilidad en el
     caso de gráficos múltiples. Cuando la opción toma el valor
     `false', la escena se coloca de forma automática, dependiendo del
     valor asignado a la opción `columns'.  En cualquier otro caso, a
     `allocation' se le debe asignar una lista con dos pares de
     números; el primero se corresponde con la posición de la esquina
     inferior izquierda del gráfico y el segundo par hace referencia al
     ancho y alto de la escena. Todas las cantidades deben darse en
     coordenadas relativas, entre 0 y 1.

     Ejemplos:

     Gráficos internos.

          (%i1) load(draw)$
          (%i2) draw(
                  gr2d(
                    explicit(x^2,x,-1,1)),
                  gr2d(
                    allocation = [[1/4, 1/4],[1/2, 1/2]],
                    explicit(x^3,x,-1,1),
                    grid = true) ) $

     Multiplot con dimensiones establecidas por el usuario.

          (%i1) load(draw)$
          (%i2) draw(
                  terminal = wxt,
                  gr2d(
                    allocation = [[0, 0],[1, 1/4]],
                    explicit(x^2,x,-1,1)),
                  gr3d(
                    allocation = [[0, 1/4],[1, 3/4]],
                    explicit(x^2+y^2,x,-1,1,y,-1,1) ))$

     Véase también la opción `columns'.

 -- Opción gráfica: axis_3d
     Valor por defecto: `true'

     Cuando `axis_3d' vale `true', los ejes <x>, <y> y <z> permanecen
     visibles en las escenas 3d.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(axis_3d = false,
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2) )$

     Véanse también `axis_bottom',  `axis_left', `axis_top' y
     `axis_right' for axis in 2d.

 -- Opción gráfica: axis_bottom
     Valor por defecto: `true'

     Cuando `axis_bottom' vale `true', el eje inferior permanece
     visible en las escenas 2d.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(axis_bottom = false,
                       explicit(x^3,x,-1,1))$

     Véanse también `axis_left',  `axis_top', `axis_right' y `axis_3d'.

 -- Opción gráfica: axis_left
     Valor por defecto: `true'

     Cuando `axis_left' vale `true', el eje izquierdo permanece visible
     en las escenas 2d.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(axis_left = false,
                       explicit(x^3,x,-1,1))$

     Véanse también `axis_bottom',  `axis_top', `axis_right' y
     `axis_3d'.

 -- Opción gráfica: axis_right
     Valor por defecto: `true'

     Cuando `axis_right' vale `true', el eje derecho permanece visible
     en las escenas 2d.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(axis_right = false,
                       explicit(x^3,x,-1,1))$

     Véanse también `axis_bottom',  `axis_left', `axis_top' y `axis_3d'.

 -- Opción gráfica: axis_top
     Valor por defecto: `true'

     Cuando `axis_top' vale `true', el eje superior permanece visible
     en las escenas 2d.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(axis_top = false,
                       explicit(x^3,x,-1,1))$

     Véanse también `axis_bottom',  `axis_left', `axis_right' y
     `axis_3d'.

 -- Opción gráfica: background_color
     Valor por defecto: `white'

     Establece el color de fondo en los terminales `gif', `png', `jpg'
     y `gif'. El color de fondo por defecto es blanco.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Esta opción no es compatible con los terminales `epslatex' y
     `epslatex_standalone'.

     Véase también `color'.

 -- Opción gráfica: border
     Valor por defecto: `true'

     Cuando `border' vale `true', los bordes de los polígonos se
     dibujan de acuerdo con `line_type' y `line_width'.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr2d': `polygon', `rectangle' y `ellipse'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(color       = brown,
                       line_width  = 8,
                       polygon([[3,2],[7,2],[5,5]]),
                       border      = false,
                       fill_color  = blue,
                       polygon([[5,2],[9,2],[7,5]]) )$

 -- Opción gráfica: cbrange
     Valor por defecto: `auto'

     Cuando `cbrange' vale `auto', el rango de los valores que se
     colorean cuando `enhanced3d' es diferente de `false' se calcula
     automáticamente. Valores fuera del rango utilizan el color del
     valor extremo más cercano.

     Cuando `enhanced3d' o `colorbox' vale `false', la opción `cbrange'
     no tiene efecto alguno.

     Si el usuario quiere especificar un intervalo para los valores a
     colorear, éste debe expresarse como una lista de Maxima, como en
     `cbrange=[-2, 3]'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d (
                  enhanced3d     = true,
                  color          = green,
                  cbrange = [-3,10],
                  explicit(x^2+y^2, x,-2,2,y,-2,2)) $

     Véanse también `enhanced3d' y `cbtics'.

 -- Opción gráfica: cbtics
     Valor por defecto: `auto'

     Esta opción gráfica controla la forma en la que se dibujarán las
     marcas en la escala de color cuando la opción `enhanced3d' sea
     diferente de `false'.

     Cuando `enhanced3d' o `colorbox' vale `false', la opción `cbtics'
     no tiene efecto alguno.

     Véase `xtics' para una descripción completa.

     Ejemplo :

          (%i1) load(draw)$
          (%i2) draw3d (
                  enhanced3d = true,
                  color      = green,
                  cbtics  = {["High",10],["Medium",05],["Low",0]},
                  cbrange = [0, 10],
                  explicit(x^2+y^2, x,-2,2,y,-2,2)) $

     See also `enhanced3d', `colorbox' and `cbrange'.

 -- Opción gráfica: color
     Valor por defecto: `blue'

     `color' especifica el color para dibujar líneas, puntos, bordes de
     polígonos y etiquetas.

     Los colores se pueden dar a partir de sus nombres o en código
     hexadecimal rgb.

     Los nombres de colores disponibles son: `white', `black', `gray0',
     `grey0', `gray10', `grey10', `gray20', `grey20', `gray30',
     `grey30', `gray40', `grey40', `gray50', `grey50', `gray60',
     `grey60', `gray70', `grey70', `gray80', `grey80', `gray90',
     `grey90', `gray100', `grey100', `gray', `grey', `light_gray',
     `light_grey', `dark_gray', `dark_grey', `red', `light_red',
     `dark_red', `yellow', `light_yellow', `dark_yellow', `green',
     `light_green', `dark_green', `spring_green', `forest_green',
     `sea_green', `blue', `light_blue', `dark_blue', `midnight_blue',
     `navy', `medium_blue', `royalblue', `skyblue', `cyan',
     `light_cyan', `dark_cyan', `magenta', `light_magenta',
     `dark_magenta', `turquoise', `light_turquoise', `dark_turquoise',
     `pink', `light_pink', `dark_pink', `coral', `light_coral',
     `orange_red', `salmon', `light_salmon', `dark_salmon',
     `aquamarine', `khaki', `dark_khaki', `goldenrod',
     `light_goldenrod', `dark_goldenrod', `gold', `beige', `brown',
     `orange', `dark_orange', `violet', `dark_violet', `plum' y
     `purple'.

     Las componentes cromáticas en código hexadecimal se introducen en
     el formato `"#rrggbb"'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^2,x,-1,1), /* default is black */
                       color = red,
                       explicit(0.5 + x^2,x,-1,1),
                       color = blue,
                       explicit(1 + x^2,x,-1,1),
                       color = light_blue,
                       explicit(1.5 + x^2,x,-1,1),
                       color = "#23ab0f",
                       label(["This is a label",0,1.2])  )$

     Véase también `fill_color'.

 -- Opción gráfica: colorbox
     Valor por defecto: `true'

     Cuando `colorbox' vale `true', se dibuja una escala de colores sin
     título al lado de los objetos `image' en 2D o de objetos
     coloreados en 3D. Cuando `colorbox' vale `false', no se presenta
     la escala de colores. Cuando `colorbox' es una cadena de
     caracteres, se mostrará la escala de colores con un título.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

     Escala de colores e imágenes.

          (%i1) load(draw)$
          (%i2) im: apply('matrix,
                           makelist(makelist(random(200),i,1,30),i,1,30))$
          (%i3) draw2d(image(im,0,0,30,30))$
          (%i4) draw2d(colorbox = false, image(im,0,0,30,30))$

     Escala de colores y objeto 3D coloreado.

          (%i1) load(draw)$
          (%i2) draw3d(
                  colorbox   = "Magnitude",
                  enhanced3d = true,
                  explicit(x^2+y^2,x,-1,1,y,-1,1))$

     Véase también `palette'.

 -- Opción gráfica: columns
     Valor por defecto: 1

     `columns' es el número de columnas en gráficos múltiples.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia. También puede
     usarse como argumento de la función `draw'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) scene1: gr2d(title="Ellipse",
                             nticks=30,
                             parametric(2*cos(t),5*sin(t),t,0,2*%pi))$
          (%i3) scene2: gr2d(title="Triangle",
                             polygon([4,5,7],[6,4,2]))$
          (%i4) draw(scene1, scene2, columns = 2)$


 -- Opción gráfica: contour
     Valor por defecto: `none'

     La opción `contour' permite al usuario decidir dónde colocar las
     líneas de nivel.  Valores posibles son:

        * `none': no se dibujan líneas de nivel.

        * `base': las líneas de nivel se proyectan sobre el plano xy.

        * `surface': las líneas de nivel se dibujan sobre la propia
          superficie.

        * `both': se dibujan dos conjuntos de líneas de nivel: sobre la
          superficie y las que se proyectan sobre el plano xy.

        * `map': las líneas de nivel se proyectan sobre el plano xy y
          el punto de vista del observador se coloca perpendicularmente
          a él.


     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(20*exp(-x^2-y^2)-10,x,0,2,y,-3,3),
                       contour_levels = 15,
                       contour        = both,
                       surface_hide   = true) $

     Véase también `contour_levels'.

 -- Opción gráfica: contour_levels
     Valor por defecto: 5

     Esta opción gráfica controla cómo se dibujarán las líneas de
     nivel. A `contour_levels' se le puede asignar un número entero
     positivo, una lista de tres números o un conjunto numérico
     arbitrario:

        * Si a `contour_levels' se le asigna un entero positivo <n>,
          entonces se dibujarán <n> líneas de nivel a intervalos
          iguales. Por defecto, se dibujaán cinco isolíneas.

        * Si a `contour_levels' se le asigna una lista de tres números
          de la forma `[inf,p,sup]', las isolíneas se dibujarán desde
          `inf' hasta `sup' en pasos de amplitud `p'.

        * Si a `contour_levels' se le asigna un conjunto de números de
          la forma `{n1, n2, ...}', entonces se dibujarán las isolíneas
          correspondientes a los niveles `n1', `n2', ...

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplos:

     Diez isolíneas igualmente espaciadas. El número real puede
     ajustarse a fin de poder conseguir etiquetas más sencillas.
          (%i1) load(draw)$
          (%i2) draw3d(color = green,
                       explicit(20*exp(-x^2-y^2)-10,x,0,2,y,-3,3),
                       contour_levels = 10,
                       contour        = both,
                       surface_hide   = true) $

     Desde -8 hasta 8 en pasos de amplitud 4.
          (%i1) load(draw)$
          (%i2) draw3d(color = green,
                       explicit(20*exp(-x^2-y^2)-10,x,0,2,y,-3,3),
                       contour_levels = [-8,4,8],
                       contour        = both,
                       surface_hide   = true) $

     Líneas correspondientes a los niveles -7, -6, 0.8 y 5.
          (%i1) load(draw)$
          (%i2) draw3d(color = green,
                       explicit(20*exp(-x^2-y^2)-10,x,0,2,y,-3,3),
                       contour_levels = {-7, -6, 0.8, 5},
                       contour        = both,
                       surface_hide   = true) $

     Véase también `contour'.

 -- Opción gráfica: data_file_name
     Valor por defecto: `"data.gnuplot"'

     `data_file_name' es el nombre del fichero que almacena la
     información numérica que necesita Gnuplot para crear el gráfico
     solicitado.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia. También puede
     usarse como argumento de la función `draw'.

     Véase ejemplo en `gnuplot_file_name'.


 -- Opción gráfica: delay
     Valor por defecto: 5

     Este es el retraso en centésimas de segundo entre imágenes en los
     ficheros gif animados.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia. También puede
     usarse como argumento de la función `draw'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw(
                  delay     = 100,
                  file_name = "zzz",
                  terminal  = 'animated_gif,
                  gr2d(explicit(x^2,x,-1,1)),
                  gr2d(explicit(x^3,x,-1,1)),
                  gr2d(explicit(x^4,x,-1,1)));
          End of animation sequence
          (%o2)          [gr2d(explicit), gr2d(explicit), gr2d(explicit)]

     La opciób `delay' sólo se activa en caso de gifs animados; se
     ignora en cualquier otro caso.

     Véanse también `terminal', `dimensions'.

 -- Opción gráfica: dimensions
     Valor por defecto: `[600,500]'

     Dimensiones del terminal de salida. Su valor es una lista formada
     por el ancho y el alto. El significado de estos dos números
     depende del terminal con el que se esté trabajando.

     Con los terminales `gif', `animated_gif', `png', `jpg', `svg',
     `screen', `wxt' y `aquaterm', los enteros representan números de
     puntos en cada dirección. Si no son enteros se redondean.

     Con los terminales `eps', `eps_color', `pdf' y `pdfcairo', los
     números representan centésimas de cm, lo que significa que, por
     defecto, las imágenes en estos formatos tienen 6 cm de ancho por 5
     cm de alto.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia. También puede
     usarse como argumento de la función `draw'.

     Ejemplos:

     La opción `dimensions' aplicada a un fichero de salida y al lienzo
     wxt.

          (%i1) load(draw)$
          (%i2) draw2d(
                  dimensions = [300,300],
                  terminal   = 'png,
                  explicit(x^4,x,-1,1)) $
          (%i3) draw2d(
                  dimensions = [300,300],
                  terminal   = 'wxt,
                  explicit(x^4,x,-1,1)) $

     La opción `dimensions' aplicada a una salida eps.  En este caso
     queremos un fichero eps con dimensiones A4.

          (%i1) load(draw)$
          (%i2) A4portrait: 100*[21, 29.7]$
          (%i3) draw3d(
                  dimensions = A4portrait,
                  terminal   = 'eps,
                  explicit(x^2-y^2,x,-2,2,y,-2,2)) $

 -- Opción gráfica: draw_realpart
     Valor por defecto: `true'

     Cuando vale `true', las funciones a dibujar se consideran
     funciones complejas cuyas partes reales se deben dibujar; cuando
     la opción vale `false', no se dibujará nada en caso de que la
     función no devuelve valores reales.

     Esta opción afecta a los objetos `explicit' y `parametric' en 2D y
     3D, y al objeto `parametric_surface'.

     Ejemplo:

     La opción `draw_realpart' afecta a los objetos `explicit' y
     `parametric'.

          (%i1) load(draw)$
          (%i2) draw2d(
                  draw_realpart = false,
                  explicit(sqrt(x^2  - 4*x) - x, x, -1, 5),
                  color         = red,
                  draw_realpart = true,
                  parametric(x,sqrt(x^2  - 4*x) - x + 1, x, -1, 5) );


 -- Opción gráfica: enhanced3d
     Valor por defecto: `none'

     Cuando `enhanced3d' vale `none', las superficies no se colorean en
     escenas 3D.  Para obtener una superficie coloreada se debe asignar
     una lista a la opción `enhanced3d', en la que el primer elemento
     es una expresión y el resto son los nombres de las variables o
     parámetros utilizados en la expresión.  Una lista tal como
     `[f(x,y,z), x, y, z]' significa que al punto `[x,y,z]' de la
     superficie se le asigna el número `f(x,y,z)', el cual será
     coloreado de acuerdo con el valor actual de `palette'.  Para
     aquellos objetos gráficos 3D definidos en términos de parámetros,
     es posible definir el número de color en términos de dichos
     parámetros, como en `[f(u), u]', para los objetos `parametric' y
     `tube', o `[f(u,v), u, v]', para el objeto `parametric_surface'.
     Mientras que todos los objetos 3D admiten el modelo basado en
     coordenadas absolutas, `[f(x,y,z), x, y, z]', solamente dos de
     ellos, esto es `explicit' y `elevation_grid', aceptan también el
     modelo basado en las coordenadas `[x,y]', `[f(x,y), x, y]'. El
     objeto 3D `implicit' acepta solamente el modelo `[f(x,y,z), x, y,
     z]'. El objeto `points' también acepta el modelo `[f(x,y,z), x, y,
     z]', pero cuando los puntos tienen naturaleza cronológica también
     admite el modelo `[f(k), k]', siendo `k' un parámetro de orden.

     Cuando a `enhanced3d' se le asigna algo diferente de `none', se
     ignoran las opciones `color' y `surface_hide'.

     Los nombres de las variables definidas en las listas pueden ser
     diferentes de aquellas utilizadas en las definiciones de los
     objetos gráficos.

     A fin de mantener compatibilidad con versiones anteriores,
     `enhanced3d = false' es equivalente a `enhanced3d = none' y
     `enhanced3d = true' es equivalente a `enhanced3d = [z, x, y, z]'.
     Si a `enhanced3d' se le asigna una expresión, sus variables deben
     ser las mismas utilizadas en la definición de la superficie. Esto
     no es necesario cuando se utilizan listas.

     Sobre la definición de paletas, véase `palette'.

     Ejemplos:

     Objeto `explicit' con coloreado definido por el modelo `[f(x,y,z),
     x, y, z]'.

          (%i1) load(draw)$
          (%i2) draw3d(
                   enhanced3d = [x-z/10,x,y,z],
                   palette    = gray,
                   explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3))$

     Objeto `explicit' con coloreado definido por el modelo `[f(x,y),
     x, y]'.  Los nombres de las variables definidas en las listas
     pueden ser diferentes de aquellas utilizadas en las definiciones
     de los objetos gráficos 3D; en este caso, `r' corresponde a `x' y
     `s' a `y'.

          (%i1) load(draw)$
          (%i2) draw3d(
                   enhanced3d = [sin(r*s),r,s],
                   explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3))$

     Objeto `parametric' con coloreado definido por el modelo
     `[f(x,y,z), x, y, z]'.

          (%i1) load(draw)$
          (%i2) draw3d(
                   nticks = 100,
                   line_width = 2,
                   enhanced3d = [if y>= 0 then 1 else 0, x, y, z],
                   parametric(sin(u)^2,cos(u),u,u,0,4*%pi)) $

     Objeto `parametric' con coloreado definido por el modelo `[f(u),
     u]'.  En este caso, `(u-1)^2' es una simplificación de
     `[(u-1)^2,u]'.

          (%i1) load(draw)$
          (%i2) draw3d(
                   nticks = 60,
                   line_width = 3,
                   enhanced3d = (u-1)^2,
                   parametric(cos(5*u)^2,sin(7*u),u-2,u,0,2))$

     Objeto `elevation_grid' con coloreado definido por el modelo
     `[f(x,y), x, y]'.

          (%i1) load(draw)$
          (%i2) m: apply(
                     matrix,
                     makelist(makelist(cos(i^2/80-k/30),k,1,30),i,1,20)) $
          (%i3) draw3d(
                   enhanced3d = [cos(x*y*10),x,y],
                   elevation_grid(m,-1,-1,2,2),
                   xlabel = "x",
                   ylabel = "y");

     Objeto `tube' con coloreado definido por el modelo `[f(x,y,z), x,
     y, z]'.

          (%i1) load(draw)$
          (%i2) draw3d(
                   enhanced3d = [cos(x-y),x,y,z],
                   palette = gray,
                   xu_grid = 50,
                   tube(cos(a), a, 0, 1, a, 0, 4*%pi) )$

     Objeto `tube' con coloreado definido por el modelo `[f(u), u]'.
     En este caso, `enhanced3d = -a' puede ser una simplificación de
     `enhanced3d = [-foo,foo]'.

          (%i1) load(draw)$
          (%i2) draw3d(
                   tube_extremes = [open, closed],
                   palette = [26,15,-2],
                   enhanced3d = [-foo, foo],
                   tube(a, a, a^2, 1, a, -2, 2) )$

     Objetos `implicit' y `points' con coloreado definido por el modelo
     `[f(x,y,z), x, y, z]'.

          (%i1) load(draw)$
          (%i2) draw3d(
                   enhanced3d = [x-y,x,y,z],
                   implicit((x^2+y^2+z^2-1)*(x^2+(y-1.5)^2+z^2-0.5)=0.015,
                            x,-1,1,y,-1.2,2.3,z,-1,1)) $
          (%i3) m: makelist([random(1.0),random(1.0),random(1.0)],k,1,2000)$
          (%i4) draw3d(
                   point_type = filled_circle,
                   point_size = 2,
                   enhanced3d = [u+v-w,u,v,w],
                   points(m) ) $

     cuando los puntos tienen naturaleza cronológica también se admite
     el modelo `[f(k), k]', siendo `k' un parámetro de orden.

          (%i1) load(draw)$
          (%i2) m:makelist([random(1.0), random(1.0), random(1.0)],k,1,5)$
          (%i3) draw3d(
                   enhanced3d = [sin(j), j],
                   point_size = 3,
                   point_type = filled_circle,
                   points_joined = true,
                   points(m)) $

 -- Opción gráfica: error_type
     Valor por defecto: `y'

     Dependiendo de su valor, el cual puede ser `x', `y' o `xy', el
     objeto gráfico `errors' dibujará puntos con barras de error
     horizontales, verticales, o ambas. Si `error_type=boxes', se
     dibujarán cajas en lugar de cruces.

     Véase también `errors'.

 -- Opción gráfica: file_name
     Valor por defecto: `"maxima_out"'

     `file_name' es el nombre del fichero en el que los terminales
     `png', `jpg', `gif', `eps', `eps_color', `pdf', `pdfcairo' y `svg'
     guardarán el gráfico.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia. También puede
     usarse como argumento de la función `draw'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(file_name = "myfile",
                       explicit(x^2,x,-1,1),
                       terminal  = 'png)$

     Véanse también `terminal', `dimensions'.

 -- Opción gráfica: fill_color
     Valor por defecto: `"red"'

     `fill_color' especifica el color para rellenar polígonos y
     funciones explícitas bidimensionales.

     Véase `color' para más información sobre cómo definir colores.

 -- Opción gráfica: fill_density
     Valor por defecto: 0

     `fill_density' es un número entre 0 y 1 que especifica la
     intensidad del color de relleno (dado por `fill_color') en los
     objetos `bars'.

     Véase `bars' para ejemplos.

 -- Opción gráfica: filled_func
     Valor por defecto: `false'

     La opción `filled_func' establece cómo se van a rellenar las
     regiones limitadas por funciones. Si `filled_func' vale `true', la
     región limitada por la función definida en el objeto `explicit' y
     el borde inferior del la ventana gráfica se rellena con
     `fill_color'.  Si `filled_func' guarda la expresión de una
     función, entonces la región limitada por esta función y la
     definida en el objeto `explicit' será la que se rellene. Por
     defecto, las funciones explícitas no se rellenan.

     Esta opción sólo afecta al objeto gráfico bidimensional `explicit'.

     Ejemplo:

     Región limitada por un objeto `explicit' y el borde inferior de la
     ventana gráfica.
          (%i1) load(draw)$
          (%i2) draw2d(fill_color  = red,
                       filled_func = true,
                       explicit(sin(x),x,0,10) )$

     Región limitada por un objeto `explicit' y la función definida en
     la opción `filled_func'. Nótese que la variable en `filled_func'
     debe ser la misma que la utilizada en `explicit'.
          (%i1) load(draw)$
          (%i2) draw2d(fill_color  = grey,
                       filled_func = sin(x),
                       explicit(-sin(x),x,0,%pi));

     Véanse también `fill_color' y `explicit'.

 -- Opción gráfica: font
     Valor por defecto: `""' (cadena vacía)

     Esta opción permite seleccionar el tipo de fuente a utilizar por el
     terminal. Sólo se puede utilizar un tipo de fuente y tamaño por
     gráfico.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Véase también `font_size'.

     Gnuplot no puede gestionar por sí mismo las fuentes, dejando esta
     tarea a las librerías que dan soporte a los diferentes terminales,
     cada uno con su propia manera de controlar la tipografía. A
     continuación un breve resumen:

        * x11: Utiliza el mecanismo habitual para suministrar las
          fuentes en x11.

          Ejemplo:
               (%i1) load(draw)$
               (%i2) draw2d(font      = "Arial",
                            font_size = 20,
                            label(["Arial font, size 20",1,1]))$

        * windows: El terminal de windows no permite cambiar fuentes
          desde dentro del gráfico. Una vez se ha creado el gráfico, se
          pueden cambiar las fuentes haciendo clic derecho en el menú
          de la ventana gráfica.

        * png, jpeg, gif: La librería libgd utiliza la ruta a las
          fuentes almacenada en la variable de entorno `GDFONTPATH'; en
          tal caso sólo es necesario darle a la opción `font' el nombre
          de la fuente. También es posible darle la ruta completa al
          fichero de la fuente.

          Ejemplos:

          A la opción `font' se le puede dar la ruta completa al
          fichero de la fuente:
               (%i1) load(draw)$
               (%i2) path: "/usr/share/fonts/truetype/freefont/" $
               (%i3) file: "FreeSerifBoldItalic.ttf" $
               (%i4) draw2d(
                       font      = concat(path, file),
                       font_size = 20,
                       color     = red,
                       label(["FreeSerifBoldItalic font, size 20",1,1]),
                       terminal  = png)$

          Si la variable de entorno `GDFONTPATH' almacena la ruta a la
          carpeta donde se alojan las fuentes, es posible darle a la
          opción `font' sólo el nombre de la fuente:
               (%i1) load(draw)$
               (%i2) draw2d(
                       font      = "FreeSerifBoldItalic",
                       font_size = 20,
                       color     = red,
                       label(["FreeSerifBoldItalic font, size 20",1,1]),
                       terminal  = png)$

        * Postscript: Las fuentes estándar de Postscript son:
          `"Times-Roman"', `"Times-Italic"', `"Times-Bold"',
          `"Times-BoldItalic"', `"Helvetica"', `"Helvetica-Oblique"',
          `"Helvetica-Bold"', `"Helvetic-BoldOblique"', `"Courier"',
          `"Courier-Oblique"', `"Courier-Bold"' y
          `"Courier-BoldOblique"'.

          Ejemplo:
               (%i1) load(draw)$
               (%i2) draw2d(
                       font      = "Courier-Oblique",
                       font_size = 15,
                       label(["Courier-Oblique font, size 15",1,1]),
                       terminal = eps)$

        * pdf: Utiliza las mismas fuentes que Postscript.

        * pdfcairo: Utiliza las mismas fuentes que wxt.

        * wxt: La librería pango encuentra las fuentes por medio de la
          utilidad `fontconfig'.

        * aqua: La fuente por defecto es `"Times-Roman"'.

     La documentación de gnuplot es una importante fuente de
     información sobre terminales y fuentes.

 -- Opción gráfica: font_size
     Valor por defecto: 10

     Esta opción permite seleccionar el tamaño de la fuente a utilizar
     por el terminal. Sólo se puede utilizar un tipo de fuente y tamaño
     por gráfico. `font_size' sólo se activa cuando la opción `font'
     tiene un valor diferente de la cadena vacía.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Véase también `font'.

 -- Opción gráfica: gnuplot_file_name
     Valor por defecto: `"maxout.gnuplot"'

     `gnuplot_file_name' es el nombre del fichero que almacena las
     instrucciones a ser procesadas por Gnuplot.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia. También puede
     usarse como argumento de la función `draw'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(
                 file_name = "my_file",
                 gnuplot_file_name = "my_commands_for_gnuplot",
                 data_file_name    = "my_data_for_gnuplot",
                 terminal          = png,
                 explicit(x^2,x,-1,1)) $

     Véase también `data_file_name'.


 -- Opción gráfica: grid
     Valor por defecto: `false'

     Cuando `grid' vale `true', se dibujará una rejilla sobre el plano
     <xy>.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(grid = true,
                       explicit(exp(u),u,-2,2))$

 -- Opción gráfica: head_angle
     Valor por defecto: 45

     `head_angle' indica el ángulo, en grados, entre la flecha y el
     segmento del vector.

     Esta opción sólo es relevante para objetos de tipo `vector'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,10],
                       yrange      = [0,9],
                       head_length = 0.7,
                       head_angle  = 10,
                       vector([1,1],[0,6]),
                       head_angle  = 20,
                       vector([2,1],[0,6]),
                       head_angle  = 30,
                       vector([3,1],[0,6]),
                       head_angle  = 40,
                       vector([4,1],[0,6]),
                       head_angle  = 60,
                       vector([5,1],[0,6]),
                       head_angle  = 90,
                       vector([6,1],[0,6]),
                       head_angle  = 120,
                       vector([7,1],[0,6]),
                       head_angle  = 160,
                       vector([8,1],[0,6]),
                       head_angle  = 180,
                       vector([9,1],[0,6]) )$

     Véanse también `head_both', `head_length' y `head_type'.

 -- Opción gráfica: head_both
     Valor por defecto: `false'

     Cuando `head_both' vale `true', los vectores se dibujan
     bidireccionales.  Si vale `false', se dibujan unidireccionales.

     Esta opción sólo es relevante para objetos de tipo `vector'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,8],
                       yrange      = [0,8],
                       head_length = 0.7,
                       vector([1,1],[6,0]),
                       head_both   = true,
                       vector([1,7],[6,0]) )$

     Véanse también `head_length', `head_angle' y `head_type'.

 -- Opción gráfica: head_length
     Valor por defecto: 2

     `head_length' indica, en las unidades del eje <x>, la longitud de
     las flechas de los vectores.

     Esta opción sólo es relevante para objetos de tipo `vector'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,12],
                       yrange      = [0,8],
                       vector([0,1],[5,5]),
                       head_length = 1,
                       vector([2,1],[5,5]),
                       head_length = 0.5,
                       vector([4,1],[5,5]),
                       head_length = 0.25,
                       vector([6,1],[5,5]))$

     Véanse también `head_both', `head_angle' y `head_type'.

 -- Opción gráfica: head_type
     Valor por defecto: `filled'

     `head_type' se utiliza para especificar cómo se habrán de dibujar
     las flechas de los vectores. Los valores posibles para esta opción
     son: `filled' (flechas cerradas y rellenas), `empty' (flechas
     cerradas pero no rellenas) y `nofilled' (flechas abiertas).

     Esta opción sólo es relevante para objetos de tipo `vector'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,12],
                       yrange      = [0,10],
                       head_length = 1,
                       vector([0,1],[5,5]), /* default type */
                       head_type = 'empty,
                       vector([3,1],[5,5]),
                       head_type = 'nofilled,
                       vector([6,1],[5,5]))$

     Véanse también `head_both', `head_angle' y `head_length'.

 -- Opción gráfica: ip_grid
     Valor por defecto: `[50, 50]'

     `ip_grid' establece la rejilla del primer muestreo para los
     gráficos de funciones implícitas.

     Esta opción sólo es relevante para funciones de tipo `implicit'.

 -- Opción gráfica: ip_grid_in
     Valor por defecto: `[5, 5]'

     `ip_grid_in' establece la rejilla del segundo muestreo para los
     gráficos de funciones implícitas.

     Esta opción sólo es relevante para funciones de tipo `implicit'.

 -- Opción gráfica: key
     Valor por defecto: `""' (cadena vacía)

     `key' es la clave de una función en la leyenda. Si `key' es una
     cadena vacía, las funciones no tendrán clave asociada en la
     leyenda.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr2d': `points', `polygon', `rectangle', `ellipse',
          `vector', `explicit', `implicit', `parametric' y `polar'.

        * `gr3d': `points', `explicit', `parametric', y
          `parametric_surface'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(key   = "Sinus",
                       explicit(sin(x),x,0,10),
                       key   = "Cosinus",
                       color = red,
                       explicit(cos(x),x,0,10) )$

 -- Opción gráfica: label_alignment
     Valor por defecto: `center'

     `label_alignment' se utiliza para especificar dónde se escribirán
     las etiquetas con respecto a las coordenadas de referencia. Los
     valores posibles para esta opción son: `center', `left' y `right'.

     Esta opción sólo es relevante para objetos de tipo `label'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange          = [0,10],
                       yrange          = [0,10],
                       points_joined   = true,
                       points([[5,0],[5,10]]),
                       color           = blue,
                       label(["Centered alignment (default)",5,2]),
                       label_alignment = 'left,
                       label(["Left alignment",5,5]),
                       label_alignment = 'right,
                       label(["Right alignment",5,8]))$

     Véanse también `label_orientation' y `color'.

 -- Opción gráfica: label_orientation
     Valor por defecto: `horizontal'

     `label_orientation' se utiliza para especificar la orientación de
     las etiquetas. Los valores posibles para esta opción son:
     `horizontal' y `vertical'.

     Esta opción sólo es relevante para objetos de tipo `label'.

     Ejemplo:

     En este ejemplo, el punto ficticio que se añade sirve para obtener
     la imagen, ya que el paquete `draw' necesita siempre de datos para
     construir la escena.
          (%i1) load(draw)$
          (%i2) draw2d(xrange     = [0,10],
                       yrange     = [0,10],
                       point_size = 0,
                       points([[5,5]]),
                       color      = navy,
                       label(["Horizontal orientation (default)",5,2]),
                       label_orientation = 'vertical,
                       color             = "#654321",
                       label(["Vertical orientation",1,5]))$

     Véanse también `label_alignment' y `color'.

 -- Opción gráfica: line_type
     Valor por defecto: `solid'

     `line_type' indica cómo se van a dibujar las líneas; valores
     posibles son `solid' y `dots'.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr2d': `points', `polygon', `rectangle', `ellipse',
          `vector', `explicit', `implicit', `parametric' y `polar'.

        * `gr3d': `points', `explicit', `parametric' y
          `parametric_surface'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(line_type = dots,
                       explicit(1 + x^2,x,-1,1),
                       line_type = solid, /* default */
                       explicit(2 + x^2,x,-1,1))$

     Véase también `line_width'.

 -- Opción gráfica: line_width
     Valor por defecto: 1

     `line_width' es el ancho de las líneas a dibujar.  Su valor debe
     ser un número positivo.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr2d': `points', `polygon', `rectangle', `ellipse',
          `vector', `explicit', `implicit', `parametric' y `polar'.

        * `gr3d': `points' y `parametric'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^2,x,-1,1), /* default width */
                       line_width = 5.5,
                       explicit(1 + x^2,x,-1,1),
                       line_width = 10,
                       explicit(2 + x^2,x,-1,1))$

     Véase también `line_type'.

 -- Opción gráfica: logcb
     Valor por defecto: `false'

     Cuando `logcb' vale `true', la escala de colores se dibuja
     logarítmicamente.

     Cuando `enhanced3d' o `colorbox' vale `false', la opción `logcb'
     no tiene efecto alguno.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d (
                  enhanced3d = true,
                  color      = green,
                  logcb = true,
                  logz  = true,
                  palette = [-15,24,-9],
                  explicit(exp(x^2-y^2), x,-2,2,y,-2,2)) $

     Véanse también `enhanced3d', `colorbox' y `cbrange'.

 -- Opción gráfica: logx
     Valor por defecto: `false'

     Cuando `logx' vale `true', el eje <x> se dibuja en la escala
     logarítmica.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(log(x),x,0.01,5),
                       logx = true)$

     Véanse también `logy' y `logz'.

 -- Opción gráfica: logy
     Valor por defecto: `false'

     Cuando `logy' vale `true', el eje <y> se dibuja en la escala
     logarítmica.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(logy = true,
                       explicit(exp(x),x,0,5))$

     Véanse también `logx' y `logz'.

 -- Opción gráfica: logz
     Valor por defecto: `false'

     Cuando `logz' vale `true', el eje <z> se dibuja en la escala
     logarítmica.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(logz = true,
                       explicit(exp(u^2+v^2),u,-2,2,v,-2,2))$

     Véanse también `logx' y `logy'.

 -- Opción gráfica: nticks
     Valor por defecto: 29

     En 2d, `nticks' es el número de puntos a utilizar por el programa
     adaptativo que genera las funciones explícitas. También es el
     número de puntos que se representan en las curvas paramétricas y
     polares.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr2d': `ellipse', `explicit', `parametric' y `polar'.

        * `gr3d': `parametric'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(transparent = true,
                       ellipse(0,0,4,2,0,180),
                       nticks = 5,
                       ellipse(0,0,4,2,180,180) )$

 -- Opción gráfica: palette
     Valor por defecto: `color'

     `palette' indica cómo transformar niveles de gris en componentes
     cromáticas.  Trabaja conjuntamente con la opción `enhanced3d' en
     gráficos 3D, la cual asocia cada punto de una superficie con un
     número real o nivel de gris. También trabaja con imágenes grises.
     Con `palette', estos niveles se transforman en colores.

     Hay dos formas de definir estas transformaciones.

     En primer lugar, `palette' puede ser un vector de longitud tres
     con sus componentes tomando valores enteros en el rango desde -36
     a +36; cada valor es un índice para seleccionar una fórmula que
     transforma los niveles numéricos en las componentes cromáticas
     rojo, verde y azul:
           0: 0               1: 0.5           2: 1
           3: x               4: x^2           5: x^3
           6: x^4             7: sqrt(x)       8: sqrt(sqrt(x))
           9: sin(90x)       10: cos(90x)     11: |x-0.5|
          12: (2x-1)^2       13: sin(180x)    14: |cos(180x)|
          15: sin(360x)      16: cos(360x)    17: |sin(360x)|
          18: |cos(360x)|    19: |sin(720x)|  20: |cos(720x)|
          21: 3x             22: 3x-1         23: 3x-2
          24: |3x-1|         25: |3x-2|       26: (3x-1)/2
          27: (3x-2)/2       28: |(3x-1)/2|   29: |(3x-2)/2|
          30: x/0.32-0.78125 31: 2*x-0.84     32: 4x;1;-2x+1.84;x/0.08-11.5
          33: |2*x - 0.5|    34: 2*x          35: 2*x - 0.5
          36: 2*x - 1
     los números negativos se interpretan como colores invertidos de
     las componentes cromáticas.  `palette = gray' y `palette = color'
     son atajos para `palette = [3,3,3]' y `palette = [7,5,15]',
     respectivamente.

     En segundo lugar, `palette' puede ser una paleta de colores
     definida por el usuario. En este caso, el formato para crear una
     paleta de longitud `n' es `palette=[color_1, color_2, ...,
     color_n]', donde `color_i' es un color correctamente definido
     (véase la opción `color'), de tal manera que `color_1' se asigna
     al valor más bajo del nivel y `color_n' al más alto. El resto de
     colores se interpolan.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplos:

     Trabaja conjuntamente con la opción `enhanced3d' en gráficos 3D.

          (%i1) load(draw)$
          (%i2) draw3d(
                  enhanced3d = [z-x+2*y,x,y,z],
                  palette = [32, -8, 17],
                  explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3))$

     También trabaja con imágenes grises.

          (%i1) load(draw)$
          (%i2) im: apply(
                     'matrix,
                      makelist(makelist(random(200),i,1,30),i,1,30))$
          (%i3) /* palette = color, default */
                draw2d(image(im,0,0,30,30))$
          (%i4) draw2d(palette = gray, image(im,0,0,30,30))$
          (%i5) draw2d(palette = [15,20,-4],
                       colorbox=false,
                       image(im,0,0,30,30))$

     `palette' puede ser una paleta de colores definida por el usuario.
     En este ejemplo, valores bajos de `x' se colorean en rojo y altos
     en amarillo.

          (%i1) load(draw)$
          (%i2) draw3d(
                   palette = [red, blue, yellow],
                   enhanced3d = x,
                   explicit(x^2+y^2,x,-1,1,y,-1,1)) $

     Véase también `colorbox' y `enhanced3d'.

 -- Opción gráfica: point_size
     Valor por defecto: 1

     `point_size' establece el tamaño de los puntos dibujados. Debe ser
     un número no negativo.

     Esta opción no tiene efecto alguno cuando a la opción gráfica
     `point_type' se le ha dado el valor `dot'.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr2d': `points'.

        * `gr3d': `points'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(
                  points(makelist([random(20),random(50)],k,1,10)),
                  point_size = 5,
                  points(makelist(k,k,1,20),makelist(random(30),k,1,20)))$

 -- Opción gráfica: point_type
     Valor por defecto: 1

     `point_type' indica cómo se van a dibujar los puntos aislados. Los
     valores para esta opción pueden ser índices enteros mayores o
     iguales que -1, o también nombres de estilos: `$none' (-1), `dot'
     (0), `plus' (1), `multiply' (2), `asterisk' (3), `square' (4),
     `filled_square' (5), `circle' (6), `filled_circle' (7),
     `up_triangle' (8), `filled_up_triangle' (9), `down_triangle' (10),
     `filled_down_triangle' (11), `diamant' (12) y `filled_diamant'
     (13).

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr2d': `points'.

        * `gr3d': `points'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange = [0,10],
                       yrange = [0,10],
                       point_size = 3,
                       point_type = diamant,
                       points([[1,1],[5,1],[9,1]]),
                       point_type = filled_down_triangle,
                       points([[1,2],[5,2],[9,2]]),
                       point_type = asterisk,
                       points([[1,3],[5,3],[9,3]]),
                       point_type = filled_diamant,
                       points([[1,4],[5,4],[9,4]]),
                       point_type = 5,
                       points([[1,5],[5,5],[9,5]]),
                       point_type = 6,
                       points([[1,6],[5,6],[9,6]]),
                       point_type = filled_circle,
                       points([[1,7],[5,7],[9,7]]),
                       point_type = 8,
                       points([[1,8],[5,8],[9,8]]),
                       point_type = filled_diamant,
                       points([[1,9],[5,9],[9,9]]) )$

 -- Opción gráfica: points_joined
     Valor por defecto: `false'

     Cuando `points_joined' vale `true', los puntos se unen con
     segmentos; si vale `false', se dibujarán puntos aislados. Un
     tercer valor posible para esta opción gráfica es `impulses'; en
     tal caso, se dibujarán segmentos verticales desde los puntos hasta
     el eje-x (2D) o hasta el plano-xy (3D).

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr2d': `points'.

        * `gr3d': `points'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange        = [0,10],
                       yrange        = [0,4],
                       point_size    = 3,
                       point_type    = up_triangle,
                       color         = blue,
                       points([[1,1],[5,1],[9,1]]),
                       points_joined = true,
                       point_type    = square,
                       line_type     = dots,
                       points([[1,2],[5,2],[9,2]]),
                       point_type    = circle,
                       color         = red,
                       line_width    = 7,
                       points([[1,3],[5,3],[9,3]]) )$

 -- Opción gráfica: proportional_axes
     Valor por defecto: `none'

     Cuando `proportional_axes' es igual a `xy' o `xy', una escena 2D o
     3D se dibujará con los ejes proporcionales a sus longitudes
     relativas.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Esta opción sólo funciona con Gnuplot versión 4.2.6 o superior.

     Ejemplos:

     Gráfico en 2D.

          (%i1) load(draw)$
          (%i2) draw2d(
                  ellipse(0,0,1,1,0,360),
                  transparent=true,
                  color = blue,
                  line_width = 4,
                  ellipse(0,0,2,1/2,0,360),
                  proportional_axes = xy) $

     Multiplot.

          (%i1) load(draw)$
          (%i2) draw(
                  terminal = wxt,
                  gr2d(proportional_axes = xy,
                       explicit(x^2,x,0,1)),
                  gr2d(explicit(x^2,x,0,1),
                       xrange = [0,1],
                       yrange = [0,2],
                       proportional_axes=xy),
                  gr2d(explicit(x^2,x,0,1))


 -- Opción gráfica: surface_hide
     Valor por defecto: `false'

     Cuando `surface_hide' vale `true', las partes ocultas no se
     muestran en las superficies de las escenas 3d.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw(columns=2,
                     gr3d(explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3)),
                     gr3d(surface_hide = true,
                          explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3)) )$

 -- Opción gráfica: terminal
     Valor por defecto: `screen'

     Selecciona el terminal a utilizar por Gnuplot; valores posibles
     son: `screen' (por defecto), `png', `pngcairo', `jpg', `gif',
     `eps', `eps_color', `epslatex', `epslatex_standalone', `svg',
     `dumb', `dumb_file', `pdf', `pdfcairo', `wxt', `animated_gif',
     `multipage_pdfcairo', `multipage_pdf', `multipage_eps',
     `multipage_eps_color' y `aquaterm'.

     Los terminales `screen', `wxt' y `aquaterm' también se pueden
     definir como una lista de dos elementos: el propio nombre del
     terminal y un número entero no negativo. De esta forma se pueden
     abrir varias ventanas al mismo tiempo, cada una de ellas con su
     número correspondiente. Esta modalidad no funciona en plataformas
     Windows.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia. También puede
     usarse como argumento de la función `draw'.

     pdfcairo necesita Gnuplot 4.3.  `pdf' necesita que Gnuplot haya
     sido compilado con la opción `--enable-pdf' y libpdf debe estar
     instalado
     (`http://www.pdflib.com/en/download/pdflib-family/pdflib-lite/').

     Ejemplos:

          (%i1) load(draw)$
          (%i2) /* screen terminal (default) */
                draw2d(explicit(x^2,x,-1,1))$
          (%i3) /* png file */
                draw2d(terminal  = 'png,
                       explicit(x^2,x,-1,1))$
          (%i4) /* jpg file */
                draw2d(terminal   = 'jpg,
                       dimensions = [300,300],
                       explicit(x^2,x,-1,1))$
          (%i5) /* eps file */
                draw2d(file_name = "myfile",
                       explicit(x^2,x,-1,1),
                       terminal  = 'eps)$
          (%i6) /* pdf file */
                draw2d(file_name = "mypdf",
                       dimensions = 100*[12.0,8.0],
                       explicit(x^2,x,-1,1),
                       terminal  = 'pdf)$
          (%i7) /* wxwidgets window */
                draw2d(explicit(x^2,x,-1,1),
                       terminal  = 'wxt)$

     Ventanas múltiples.
          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^5,x,-2,2), terminal=[screen, 3])$
          (%i3) draw2d(explicit(x^2,x,-2,2), terminal=[screen, 0])$

     Un fichero gif animado.
          (%i1) load(draw)$
          (%i2) draw(
                  delay     = 100,
                  file_name = "zzz",
                  terminal  = 'animated_gif,
                  gr2d(explicit(x^2,x,-1,1)),
                  gr2d(explicit(x^3,x,-1,1)),
                  gr2d(explicit(x^4,x,-1,1)));
          End of animation sequence
          (%o2)          [gr2d(explicit), gr2d(explicit), gr2d(explicit)]

     La opción `delay' sólo se activa en caso de gifs animados; se
     ignora en cualquier otro caso.

     Salida multipágina en formato eps.
          (%i1) load(draw)$
          (%i2) draw(
                  file_name = "parabol",
                  terminal  = multipage_eps,
                  dimensions = 100*[10,10],
                  gr2d(explicit(x^2,x,-1,1)),
                  gr3d(explicit(x^2+y^2,x,-1,1,y,-1,1))) $

     Véanse también `file_name', `pic_width', `pic_height' y `delay'.

 -- Opción gráfica: title
     Valor por defecto: `""' (cadena vacía)

     La opción `title' almacena una cadena con el título de la escena.
     Por defecto, no se escribe título alguno.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(exp(u),u,-2,2),
                       title = "Exponential function")$

 -- Opción gráfica: transform
     Valor por defecto: `none'

     Si `transform' vale `none', el espacio no sufre transformación
     alguna y los objetos gráficos se representan tal cual se definen.
     Si es necesario transformar el espacio, se debe asignar una lista
     a la opción `transform'. En caso de una escena 2D, la lista toma
     la forma `[f1(x,y), f2(x,y), x, y]'.  En caso de una escena 3D, la
     lista debe ser de la forma `[f1(x,y,z), f2(x,y,z), f3(x,y,z), x,
     y, z]'.

     Los nombres de las variables definidas en las listas pueden ser
     diferentes de aquellas utilizadas en las definiciones de los
     objetos gráficos.

     Ejemplos:

     Rotación en 2D.

          (%i1) load(draw)$
          (%i2) th : %pi / 4$
          (%i3) draw2d(
                  color = "#e245f0",
                  proportional_axes = 'xy,
                  line_width = 8,
                  triangle([3,2],[7,2],[5,5]),
                  border     = false,
                  fill_color = yellow,
                  transform  = [cos(th)*x - sin(th)*y,
                                sin(th)*x + cos(th)*y, x, y],
                  triangle([3,2],[7,2],[5,5]) )$

     Traslación en 3D.

          (%i1) load(draw)$
          (%i2) draw3d(
                  color     = "#a02c00",
                  explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3),
                  transform = [x+10,y+10,z+10,x,y,z],
                  color     = blue,
                  explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3) )$

 -- Opción gráfica: transparent
     Valor por defecto: `false'

     Cuando `transparent' vale `true', las regiones internas de los
     polígonos se rellenan de acuerdo con `fill_color'.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr2d': `polygon', `rectangle' y `ellipse'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(polygon([[3,2],[7,2],[5,5]]),
                       transparent = true,
                       color       = blue,
                       polygon([[5,2],[9,2],[7,5]]) )$

 -- Opción gráfica: tube_extremes
     Valor por defecto: `[open, open]'

     Una lista de dos elementos, `open' y `closed', indicando si los
     extremos de un objeto gráfico `tube' permanece abiertos o si deben
     ser cerrados. Por defecto, ambos extremos se dejan abiertos.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(
                  tube_extremes = [open, closed],
                  tube(0, 0, a, 1,
                       a, 0, 8) )$


 -- Opción gráfica: unit_vectors
     Valor por defecto: `false'

     Cuando `unit_vectors' vale `true', los vectores se dibujan con
     módulo unidad.  Esta opción es útil para representar campos
     vectoriales. Cuando `unit_vectors' vale `false', los vectores se
     dibujan con su longitud original.

     Esta opción sólo es relevante para objetos de tipo `vector'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [-1,6],
                       yrange      = [-1,6],
                       head_length = 0.1,
                       vector([0,0],[5,2]),
                       unit_vectors = true,
                       color        = red,
                       vector([0,3],[5,2]))$

 -- Opción gráfica: user_preamble
     Valor por defecto: `""' (cadena vacía)

     Usuarios expertos en Gnuplot pueden hacer uso de esta opción para
     afinar el comportamiento de Gnuplot escribiendo código que será
     enviado justo antes de la instrucción `plot' o `splot'.

     El valor dado a esta opción debe ser una cadena alfanumérica o una
     lista de cadenas (una por línea).

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

     El terminal dumb no está soportado por el paquete `draw', pero es
     posible activarlo haciendo uso de la opción `user_preamble',
          (%i1) load(draw)$
          (%i2) draw2d(explicit(exp(x)-1,x,-1,1),
                       parametric(cos(u),sin(u),u,0,2*%pi),
                       user_preamble="set terminal dumb")$

 -- Opción gráfica: view
     Valor por defecto: `[60,30]'

     Un par de ángulos, medidos en grados, indicando la direcciÃ³n del
     observador en una escena 3D. El primer ángulo es la rotación
     vertical alrededor del eje <x>, dentro del intervalo [0, 360].  El
     segundo es la rotación horizontal alrededor del eje <z>, dentro
     del intervalo [0, 360].

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(view = [170, 360],
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2) )$

 -- Opción gráfica: wired_surface
     Valor por defecto: `false'

     Indica si las superficies en 3D en modo `enhanced3d' deben mostrar
     o no la malla que unen los puntos.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(
                  enhanced3d    = [sin(x),x,y],
                  wired_surface = true,
                  explicit(x^2+y^2,x,-1,1,y,-1,1)) $


 -- Opción gráfica: x_voxel
     Valor por defecto: 10

     `x_voxel' es el número de voxels en la dirección x a utilizar por
     el algoritmo marching cubes implementado por el objeto `implicit'
     tridimensional. También se utiliza como opción del objeto gráfico
     `region'.

 -- Opción gráfica: xaxis
     Valor por defecto: `false'

     Si `xaxis' vale `true', se dibujará el eje <x>.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       xaxis       = true,
                       xaxis_color = blue)$

     Véanse también `xaxis_width', `xaxis_type' y `xaxis_color'.

 -- Opción gráfica: xaxis_color
     Valor por defecto: `"black"'

     `xaxis_color' especifica el color para el eje <x>. Véase `color'
     para ver cómo se definen los colores.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       xaxis       = true,
                       xaxis_color = red)$

     Véanse también `xaxis', `xaxis_width' y `xaxis_type'.

 -- Opción gráfica: xaxis_secondary
     Valor por defecto: `false'

     Si `xaxis_secondary' vale `true', los valores de las funciones se
     pueden representar respecto del eje <x> secundario, el cual se
     dibuja en la parte superior de la escena.

     Nótese que esta es una opción gráfica local que sólo afecta a
     objetos 2d.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(
                   key   = "Bottom x-axis",
                   explicit(x+1,x,1,2),
                   color = red,
                   key   = "Above x-axis",
                   xtics_secondary = true,
                   xaxis_secondary = true,
                   explicit(x^2,x,-1,1)) $

     Véanse también `xrange_secondary', `xtics_secondary',
     `xtics_rotate_secondary', `xtics_axis_secondary' y
     `xaxis_secondary'.


 -- Opción gráfica: xaxis_type
     Valor por defecto: `dots'

     `xaxis_type' indica cómo se debe dibujar el eje <x>; valores
     admisibles son `solid' y `dots'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       xaxis       = true,
                       xaxis_type  = solid)$

     Véanse también `xaxis', `xaxis_width' y `xaxis_color'.

 -- Opción gráfica: xaxis_width
     Valor por defecto: 1

     `xaxis_width' es el ancho del eje <x>.  Su valor debe ser un
     número positivo.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       xaxis       = true,
                       xaxis_width = 3)$

     Véanse también `xaxis', `xaxis_type' y `xaxis_color'.

 -- Opción gráfica: xlabel
     Valor por defecto: `""' (cadena vacía)

     La opción `xlabel' almacena una cadena con la etiqueta del eje
     <x>. Por defecto, el eje no tiene etiqueta.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xlabel = "Time",
                       explicit(exp(u),u,-2,2),
                       ylabel = "Population")$

     Véanse también `ylabel' y `zlabel'.

 -- Opción gráfica: xrange
     Valor por defecto: `auto'

     Cuando `xrange' vale `auto', el rango de la coordenada <x> se
     calcula de forma automática.

     Si el usuario quiere especificar un intervalo para <x>, éste debe
     expresarse como una lista de Maxima, como en `xrange=[-2, 3]'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange = [-3,5],
                       explicit(x^2,x,-1,1))$

     Véanse también `yrange' y `zrange'.

 -- Opción gráfica: xrange_secondary
     Valor por defecto: `auto'

     Cuando `xrange_secondary' vale `auto', el rango del eje <x>
     secundario se calcula de forma automática.

     Si el usuario quiere especificar un intervalo para el eje <x>
     secundario, éste debe expresarse como una lista de Maxima, como en
     `xrange_secondary=[-2, 3]'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Véanse también `xrange', `yrange', `zrange' y `yrange_secondary'.

 -- Opción gráfica: xtics
     Valor por defecto: `auto'

     Esta opción gráfica controla la forma en la que se dibujarán las
     marcas del eje <x>.

        * Cuando a `xtics' se le da el valor <auto>, las marcas se
          dibujarán de forma automática.

        * Cuando a `xtics' se le da el valor <none>, no habrá marcas en
          los ejes.

        * Cuando a `xtics' se le da un valor numérico positivo, se
          interpretará como la distancia entre dos marcas consecutivas.

        * Cuando a `xtics' se le da una lista de longitud tres de la
          forma `[start,incr,end]', las marcas se dibujarán desde
          `start' hasta `end' a intervalos de longitud `incr'.

        * Cuando a `xtics' se le da un conjunto de números de la forma
          `{n1, n2, ...}', las marcas se dibujarán exactamente en los
          valores `n1', `n2', ...

        * Cuando a `xtics' se le da un conjunto de pares de la forma
          `{["label1", n1], ["label2", n2], ...}', las marcas
          correspondientes a los valores `n1', `n2', ... se etiquetarán
          con `"label1"', `"label2"', ..., respectivamente.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplos:

     Marcas desactivadas.
          (%i1) load(draw)$
          (%i2) draw2d(xtics = 'none,
                       explicit(x^3,x,-1,1)  )$

     Marcas cada 1/4 unidades.
          (%i1) load(draw)$
          (%i2) draw2d(xtics = 1/4,
                       explicit(x^3,x,-1,1)  )$

     Marcas desde -3/4 hasta 3/4 en saltos de 1/8.
          (%i1) load(draw)$
          (%i2) draw2d(xtics = [-3/4,1/8,3/4],
                       explicit(x^3,x,-1,1)  )$

     Marcas en los puntos -1/2, -1/4 y 3/4.
          (%i1) load(draw)$
          (%i2) draw2d(xtics = {-1/2,-1/4,3/4},
                       explicit(x^3,x,-1,1)  )$

     Marcas etiquetadas.
          (%i1) load(draw)$
          (%i2) draw2d(xtics = {["High",0.75],["Medium",0],["Low",-0.75]},
                       explicit(x^3,x,-1,1)  )$

 -- Opción gráfica: xtics_axis
     Valor por defecto: `false'

     Si `xtics_axis' vale `true', las marcas y sus etiquetas se dibujan
     sobre el propio eje <x>, si vale `false' las marcas se colocan a
     lo largo del borde del gráfico.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: xtics_rotate
     Valor por defecto: `false'

     Si `xtics_rotate' vale `true', las marcas del eje <x> se giran 90
     grados.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: xtics_rotate_secondary
     Valor por defecto: `false'

     Si `xtics_rotate_secondary' vale `true', las marcas del eje <x>
     secundario se giran 90 grados.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: xtics_secondary
     Valor por defecto: `auto'

     Esta opción gráfica controla la forma en la que se dibujarán las
     marcas del eje <x> secundario.

     Véase `xtics' para una descripción completa.

 -- Opción gráfica: xtics_secondary_axis
     Valor por defecto: `false'

     Si `xtics_secondary_axis' vale `true', las marcas y sus etiquetas
     se dibujan sobre el propio eje <x> secundario, si vale `false' las
     marcas se colocan a lo largo del borde del gráfico.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: xu_grid
     Valor por defecto: 30

     `xu_grid' es el número de coordenadas de la primera variable (`x'
     en superficies explcítas y `u' en las paramétricas) para formar la
     rejilla de puntos muestrales.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr3d': `explicit' y `parametric_surface'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(xu_grid = 10,
                       yv_grid = 50,
                       explicit(x^2+y^2,x,-3,3,y,-3,3) )$

     Véase también `yv_grid'.

 -- Opción gráfica: xy_file
     Valor por defecto: `""' (cadena vacía)

     `xy_file' es el nombre del fichero donde se almacenarán las
     coordenadas después de hacer clic con el botón del ratón en un
     punto de la imagen y pulsado la tecla 'x'. Por defecto, las
     coordenadas no se almacenan.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Graphic option: xyplane
     Valor por defecto: `false'

     Coloca el plano-xy en escenas 3D. Si `xyplane' vale `false', el
     plano-xy se coloca automáticamente; en cambio, si toma un valor
     real, el plano-xy intersectará con el eje <z> a ese nivel.  Esta
     opción no tiene efecto alguno en escenas 2D.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(xyplane = %e-2,
                       explicit(x^2+y^2,x,-1,1,y,-1,1))$

 -- Opción gráfica: y_voxel
     Valor por defecto: 10

     `y_voxel' es el número de voxels en la dirección y a utilizar por
     el algoritmo marching cubes implementado por el objeto `implicit'
     tridimensional. También se utiliza como opción del objeto gráfico
     `region'.

 -- Opción gráfica: yaxis
     Valor por defecto: `false'

     Si `yaxis' vale `true', se dibujará el eje <y>.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       yaxis       = true,
                       yaxis_color = blue)$

     Véanse también `yaxis_width', `yaxis_type' y `yaxis_color'.

 -- Opción gráfica: yaxis_color
     Valor por defecto: `"black"'

     `yaxis_color' especifica el color para el eje <y>. Véase `color'
     para ver cómo se definen los colores.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       yaxis       = true,
                       yaxis_color = red)$

     Véanse también `yaxis', `yaxis_width' y `yaxis_type'.

 -- Opción gráfica: yaxis_secondary
     Valor por defecto: `false'

     Si `yaxis_secondary' vale `true', los valores de las funciones se
     pueden representar respecto del eje <y> secundario, el cual se
     dibuja al lado derecho de la escena.

     Nótese que esta es una opción gráfica local que sólo afecta a
     objetos 2d.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(
                   explicit(sin(x),x,0,10),
                   yaxis_secondary = true,
                   ytics_secondary = true,
                   color = blue,
                   explicit(100*sin(x+0.1)+2,x,0,10));

     Véanse también `yrange_secondary', `ytics_secondary',
     `ytics_rotate_secondary' y `ytics_axis_secondary'.


 -- Opción gráfica: yaxis_type
     Valor por defecto: `dots'

     `yaxis_type' indica cómo se debe dibujar el eje <y>; valores
     admisibles son `solid' y `dots'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       yaxis       = true,
                       yaxis_type  = solid)$

     Véanse también `yaxis', `yaxis_width' y `yaxis_color'.

 -- Opción gráfica: yaxis_width
     Valor por defecto: 1

     `yaxis_width' es el ancho del eje <y>.  Su valor debe ser un
     número positivo.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       yaxis       = true,
                       yaxis_width = 3)$

     Véanse también `yaxis', `yaxis_type' y `yaxis_color'.

 -- Opción gráfica: ylabel
     Valor por defecto: `""' (cadena vacía)

     La opción `ylabel' almacena una cadena con la etiqueta del eje
     <y>. Por defecto, el eje no tiene etiqueta.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xlabel = "Time",
                       ylabel = "Population",
                       explicit(exp(u),u,-2,2) )$

     Véanse también `xlabel' y `zlabel'.

 -- Opción gráfica: yrange
     Valor por defecto: `auto'

     Cuando `yrange' vale `auto', el rango de la coordenada <y> se
     calcula de forma automática.

     Si el usuario quiere especificar un intervalo para <y>, éste debe
     expresarse como una lista de Maxima, como en `yrange=[-2, 3]'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(yrange = [-2,3],
                       explicit(x^2,x,-1,1),
                       xrange = [-3,3])$

     Véanse también `xrange' y `zrange'.

 -- Opción gráfica: yrange_secondary
     Valor por defecto: `auto'

     Cuando `yrange_secondary' vale `auto', el rango del eje <y>
     secundario se calcula de forma automática.

     Si el usuario quiere especificar un intervalo para el eje <y>
     secundario, éste debe expresarse como una lista de Maxima, como en
     `yrange_secondary=[-2, 3]'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(
                   explicit(sin(x),x,0,10),
                   yaxis_secondary = true,
                   ytics_secondary = true,
                   yrange = [-3, 3],
                   yrange_secondary = [-20, 20],
                   color = blue,
                   explicit(100*sin(x+0.1)+2,x,0,10)) $

     Véanse también `xrange', `yrange' y `zrange'.

 -- Opción gráfica: ytics
     Valor por defecto: `auto'

     Esta opción gráfica controla la forma en la que se dibujarán las
     marcas del eje <y>.

     Véase `xtics' para una descripción completa.

 -- Opción gráfica: ytics_axis
     Valor por defecto: `false'

     Si `ytics_axis' vale `true', las marcas y sus etiquetas se dibujan
     sobre el propio eje <y>, si vale `false' las marcas se colocan a
     lo largo del borde del gráfico.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: ytics_rotate
     Valor por defecto: `false'

     Si `ytics_rotate' vale `true', las marcas del eje <y> se giran 90
     grados.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: ytics_rotate_secondary
     Valor por defecto: `false'

     Si `ytics_rotate_secondary' vale `true', las marcas del eje <y>
     secundario se giran 90 grados.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: ytics_secondary
     Valor por defecto: `auto'

     Esta opción gráfica controla la forma en la que se dibujarán las
     marcas del eje <y> secundario.

     Véase `xtics' para una descripción completa.

 -- Opción gráfica: ytics_secondary_axis
     Valor por defecto: `false'

     Si `ytics_secondary_axis' vale `true', las marcas y sus etiquetas
     se dibujan sobre el propio eje <y> secundario, si vale `false' las
     marcas se colocan a lo largo del borde del gráfico.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: yv_grid
     Valor por defecto: 30

     `yv_grid' es el número de coordenadas de la segunda variable (`y'
     en superficies explcítas y `v' en las paramétricas) para formar la
     rejilla de puntos muestrales.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr3d': `explicit' y `parametric_surface'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(xu_grid = 10,
                       yv_grid = 50,
                       explicit(x^2+y^2,x,-3,3,y,-3,3) )$

     Véase también `xu_grid'.

 -- Opción gráfica: z_voxel
     Valor por defecto: 10

     `z_voxel' es el número de voxels en la dirección z a utilizar por
     el algoritmo marching cubes implementado por el objeto `implicit'
     tridimensional.

 -- Opción gráfica: zaxis
     Valor por defecto: `false'

     Si `zaxis' vale `true', se dibujará el eje <z> en escenas 3D. Esta
     opción no tiene efecto alguno en escenas 2D.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(x^2+y^2,x,-1,1,y,-1,1),
                       zaxis       = true,
                       zaxis_type  = solid,
                       zaxis_color = blue)$

     Véanse también `zaxis_width', `zaxis_type' y `zaxis_color'.

 -- Opción gráfica: zaxis_color
     Valor por defecto: `"black"'

     `zaxis_color' especifica el color para el eje <z>. Véase `color'
     para ver cómo se definen los colores.  Esta opción no tiene efecto
     alguno en escenas 2D.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(x^2+y^2,x,-1,1,y,-1,1),
                       zaxis       = true,
                       zaxis_type  = solid,
                       zaxis_color = red)$

     Véanse también `zaxis', `zaxis_width' y `zaxis_type'.

 -- Opción gráfica: zaxis_type
     Valor por defecto: `dots'

     `zaxis_type' indica cómo se debe dibujar el eje <z>; valores
     admisibles son `solid' y `dots'.  Esta opción no tiene efecto
     alguno en escenas 2D.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(x^2+y^2,x,-1,1,y,-1,1),
                       zaxis       = true,
                       zaxis_type  = solid)$

     Véanse también `zaxis', `zaxis_width' y `zaxis_color'.

 -- Opción gráfica: zaxis_width
     Valor por defecto: 1

     `zaxis_width' es el ancho del eje <z>.  Su valor debe ser un
     número positivo. Esta opción no tiene efecto alguno en escenas 2D.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(x^2+y^2,x,-1,1,y,-1,1),
                       zaxis       = true,
                       zaxis_type  = solid,
                       zaxis_width = 3)$

     Véanse también `zaxis', `zaxis_type' y `zaxis_color'.

 -- Opción gráfica: zlabel
     Valor por defecto: `""' (cadena vacía)

     La opción `zlabel' almacena una cadena con la etiqueta del eje
     <z>. Por defecto, el eje no tiene etiqueta.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(zlabel = "Z variable",
                       ylabel = "Y variable",
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2),
                       xlabel = "X variable" )$

     Véanse también `xlabel' y `ylabel'.

 -- Opción gráfica: zrange
     Valor por defecto: `auto'

     Cuando `zrange' vale `auto', el rango de la coordenada <z> se
     calcula de forma automática.

     Si el usuario quiere especificar un intervalo para <z>, éste debe
     expresarse como una lista de Maxima, como en `zrange=[-2, 3]'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(yrange = [-3,3],
                       zrange = [-2,5],
                       explicit(x^2+y^2,x,-1,1,y,-1,1),
                       xrange = [-3,3])$

     Véanse también `xrange' y `yrange'.

 -- Opción gráfica: ztics
     Valor por defecto: `auto'

     Esta opción gráfica controla la forma en la que se dibujarán las
     marcas del eje <z>.

     Véase `xtics' para una descripción completa.

 -- Opción gráfica: ztics_axis
     Valor por defecto: `false'

     Si `ztics_axis' vale `true', las marcas y sus etiquetas se dibujan
     sobre el propio eje <z>, si vale `false' las marcas se colocan a
     lo largo del borde del gráfico.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: ztics_rotate
     Valor por defecto: `false'

     Si `ztics_rotate' vale `true', las marcas del eje <z> se giran 90
     grados.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

47.2.4 Objetos gráficos
-----------------------

 -- Objeto gráfico: bars ([<x1>,<h1>,<w1>], [<x2>,<h2>,<w2>, ...])
     Dibuja barras verticales en 2D.

     2D

     `bars ([<x1>,<h1>,<w1>], [<x2>,<h2>,<w2>, ...])' dibuja barras
     centradas en los valores <x1>, <x2>, ... de alturas <h1>, <h2>, ...
     y anchos <w1>, <w2>, ...

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `key', `fill_color', `fill_density' y `line_width'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(
                 key          = "Grupo A",
                 fill_color   = blue,
                 fill_density = 0.2,
                 bars([0.8,5,0.4],[1.8,7,0.4],[2.8,-4,0.4]),
                 key          = "Grupo B",
                 fill_color   = red,
                 fill_density = 0.6,
                 line_width   = 4,
                 bars([1.2,4,0.4],[2.2,-2,0.4],[3.2,5,0.4]),
                 xaxis = true);

 -- Objeto gráfico: cylindrical
          (<radius>,<z>,<minz>,<maxz>,<azi>,<minazi>,<maxazi>)
     Dibuja funciones 3D definidas en coordenadas cilíndricas.

     3D

     `cylindrical (<radius>,<z>,<minz>,<maxz>,<azi>,<minazi>,<maxazi>)'
     dibuja la función `<radius>(<z>,<azi>)' definida en coordenadas
     cilíndricas, con la variable <z> tomando valores desde <minz>
     hasta <maxz> y el azimut <azi> tomando valores desde <minazi>
     hasta <maxazi>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `xu_grid', `yv_grid', `line_type', `key', `wired_surface',
     `enhanced3d' y `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(cylindrical(1,z,-2,2,az,0,2*%pi))$

 -- Objeto gráfico: elevation_grid (<mat>,<x0>,<y0>,<width>,<height>)
     Dibuja la matriz <mat> en 3D. Los valores <z> se toman de <mat>,
     las abscisas van desde <x0> hasta <x0> + <width> y las ordenadas
     desde <y0> hasta <y0> + <height>. El elemento a(1,1) se proyecta
     sobre el punto (x0,y0+height), a(1,n) sobre (x0+width,y0+height),
     a(m,1) sobre (x0,y0) y a(m,n) sobre (x0+width,y0).

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `line_type', `line_width', `key', `wired_surface', `enhanced3d' y
     `color'.

     En versiones antiguas de Maxima, `elevation_grid' se llamaba
     `mesh'.  Véase también `mesh'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) m: apply(
                      matrix,
                      makelist(makelist(random(10.0),k,1,30),i,1,20)) $
          (%i3) draw3d(
                   color = blue,
                   elevation_grid(m,0,0,3,2),
                   xlabel = "x",
                   ylabel = "y",
                   surface_hide = true);


 -- Objeto gráfico: ellipse (<xc>, <yc>, <a>, <b>, <ang1>, <ang2>)
     Dibuja elipses y círculos en 2D.

     2D

     `ellipse (<xc>, <yc>, <a>, <b>, <ang1>, <ang2>)' dibuja una elipse
     de centro `[<xc>, <yc>]' con semiejes horizontal y vertical <a> y
     <b>, respectivamente, comenzando en el ángulo <ang1> y trazando un
     arco de amplitud igual al ángulo <ang2>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `nticks', `transparent', `fill_color', `border', `line_width',
     `line_type', `key' y `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(transparent = false,
                       fill_color  = red,
                       color       = gray30,
                       transparent = false,
                       line_width  = 5,
                       ellipse(0,6,3,2,270,-270),
                       /* center (x,y), a, b, start & end in degrees */
                       transparent = true,
                       color       = blue,
                       line_width  = 3,
                       ellipse(2.5,6,2,3,30,-90),
                       xrange      = [-3,6],
                       yrange      = [2,9] )$

 -- Objeto gráfico: errors ([<x1>,<x2>,...], [<y1>,<y2>,...])
     Dibuja puntos con barras de error asociadas horizontales,
     verticales o de ambos tipos, según sea el valor de la opción
     `error_type'.

     2D

     Si `error_type=x', los argumentos a `errors' deben ser de la forma
     `[x,y,xdelta]' o `[x,y,xlow,xhigh]'. Si `error_type=y', los
     argumentos deben ser del tipo `[x,y,ydelta]' o `[x,y,ylow,yhigh]'.
     Si `error_type=xy' o `error_type=boxes', los argumentos deben ser
     de la forma `[x,y,xdelta,ydelta]' o `[x,y,xlow,xhigh,ylow,yhigh]'.

     Véase también `error_type'.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `error_type', `points_joined', `line_width', `key', `line_type',
     `color', `fill_density', `xaxis_secondary' y `yaxis_secondary'.

     La opción `fill_density' solo es relevante cuando
     `error_type=boxes'.

     Ejemplos:

     Barras de error horizontales.

          (%i1) load(draw)$
          (%i2) draw2d(
                  error_type = y,
                  errors([[1,2,1], [3,5,3], [10,3,1], [17,6,2]]))$

     Barras de error horizontales y verticales.

          (%i1) load(draw)$
          (%i2) draw2d(
                  error_type = xy,
                  points_joined = true,
                  color = blue,
                  errors([[1,2,1,2], [3,5,2,1], [10,3,1,1], [17,6,1/2,2]]));


 -- Objeto gráfico: explicit (<fcn>,<var>,<minval>,<maxval>)
 -- Objeto gráfico: explicit
          (<fcn>,<var1>,<minval1>,<maxval1>,<var2>,<minval2>,<maxval2>)
     Dibuja funciones explícitas en 2D y 3D.

     2D

     `explicit (<fcn>,<var>,<minval>,<maxval>)' dibuja la función
     explícita <fcn>, con la variable <var> tomando valores desde
     <minval> hasta <maxval>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `nticks', `adapt_depth', `draw_realpart', `line_width',
     `line_type', `key', `filled_func', `fill_color' y `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(line_width = 3,
                       color      = blue,
                       explicit(x^2,x,-3,3) )$
          (%i3) draw2d(fill_color  = brown,
                       filled_func = true,
                       explicit(x^2,x,-3,3) )$

     3D

     `explicit
     (<fcn>,<var1>,<minval1>,<maxval1>,<var2>,<minval2>,<maxval2>)'
     dibuja la función explícita <fcn>, con la variable `var1' tomando
     valores desde <minval1> hasta <maxval1> y la variable <var2>
     tomando valores desde <minval2> hasta <maxval2>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `draw_realpart', `xu_grid', `yv_grid', `line_type', `line_width',
     `key', `wired_surface', `enhanced3d' y `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(key   = "Gauss",
                       color = "#a02c00",
                       explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3),
                       yv_grid     = 10,
                       color = blue,
                       key   = "Plane",
                       explicit(x+y,x,-5,5,y,-5,5),
                       surface_hide = true)$

     Véase también `filled_func' para el relleno de curvas.

 -- Objeto gráfico: image (<im>,<x0>,<y0>,<width>,<height>)
     Reproduce una imagen en 2D.

     2D

     `image (<im>,<x0>,<y0>,<width>,<height>)': dibuja la imagen <im>
     en la región rectangular desde el vértice <(X0,Y0)> hasta el
     `(x0+<width>,y0+<height>)' del plano real. El argumento <im> debe
     ser una matriz de números reales, una matriz de vectores de
     longitud tres o un objeto de tipo `picture'.

     Si <im> es una matriz de números reales, los valores de los
     píxeles se interpretan según indique la opción gráfica `palette',
     que es un vector de longitud tres con sus componentes tomando
     valores enteros en el rango desde -36 a +36; cada valor es un
     índice para seleccionar una fórmula que transforma los niveles
     numéricos en las componentes cromáticas rojo, verde y azul:
           0: 0               1: 0.5           2: 1
           3: x               4: x^2           5: x^3
           6: x^4             7: sqrt(x)       8: sqrt(sqrt(x))
           9: sin(90x)       10: cos(90x)     11: |x-0.5|
          12: (2x-1)^2       13: sin(180x)    14: |cos(180x)|
          15: sin(360x)      16: cos(360x)    17: |sin(360x)|
          18: |cos(360x)|    19: |sin(720x)|  20: |cos(720x)|
          21: 3x             22: 3x-1         23: 3x-2
          24: |3x-1|         25: |3x-2|       26: (3x-1)/2
          27: (3x-2)/2       28: |(3x-1)/2|   29: |(3x-2)/2|
          30: x/0.32-0.78125 31: 2*x-0.84
          32: 4x;1;-2x+1.84;x/0.08-11.5
          33: |2*x - 0.5|    34: 2*x          35: 2*x - 0.5
          36: 2*x - 1
     los números negativos se interpretan como colores invertidos de
     las componentes cromáticas.

     `palette = gray' y `palette = color' son atajos para `palette =
     [3,3,3]' y `palette = [7,5,15]', respectivamente.

     Si <im> es una matriz de vectores de longitud tres, éstos se
     interpretarán como las componentes cromáticas rojo, verde y azul.

     Ejemplos:

     Si <im> es una matriz de números reales, los valores de los
     píxeles se interpretan según indique la opción gráfica `palette'.
          (%i1) load(draw)$
          (%i2) im: apply(
                     'matrix,
                      makelist(makelist(random(200),i,1,30),i,1,30))$
          (%i3) /* palette = color, default */
                draw2d(image(im,0,0,30,30))$
          (%i4) draw2d(palette = gray, image(im,0,0,30,30))$
          (%i5) draw2d(palette = [15,20,-4],
                       colorbox=false,
                       image(im,0,0,30,30))$

     Véase también `colorbox'.

     Si <im> es una matriz de vectores de longitud tres, éstos se
     interpretarán como las componentes cromáticas rojo, verde y azul.
          (%i1) load(draw)$
          (%i2) im: apply(
                      'matrix,
                       makelist(
                         makelist([random(300),
                                   random(300),
                                   random(300)],i,1,30),i,1,30))$
          (%i3) draw2d(image(im,0,0,30,30))$

     El paquete `draw' carga automáticamente el paquete `picture'.  En
     este ejemplo, una imagen de niveles se define a mano,
     reproduciéndola a continuación.
          (%i1) load(draw)$
          (%i2) im: make_level_picture([45,87,2,134,204,16],3,2);
          (%o2)       picture(level, 3, 2, {Array:  #(45 87 2 134 204 16)})
          (%i3) /* default color palette */
                draw2d(image(im,0,0,30,30))$
          (%i4) /* gray palette */
                draw2d(palette = gray,
                       image(im,0,0,30,30))$

     Se lee un fichero xpm y se reproduce.
          (%i1) load(draw)$
          (%i2) im: read_xpm("myfile.xpm")$
          (%i3) draw2d(image(im,0,0,10,7))$

     Véanse también `make_level_picture', `make_rgb_picture' y
     `read_xpm'.

     En `http://www.telefonica.net/web2/biomates/maxima/gpdraw/image'
     se encuentran ejemplos más elaborados.

 -- Objeto gráfico: implicit (<fcn>,<x>,<xmin>,<xmax>,<y>,<ymin>,<ymax>)
 -- Objeto gráfico: implicit
          (<fcn>,<x>,<xmin>,<xmax>,<y>,<ymin>,<ymax>,<z>,<zmin>,<zmax>)
     Dibuja funciones implícitas en 2D y 3D.

     2D

     `implicit (<fcn>,<x>,<xmin>,<xmax>,<y>,<ymin>,<ymax>)' dibuja la
     función implícita <fcn>, con la variable `x' tomando valores desde
     <xmin> hasta <xmax>, y la variable <y> tomando valores desde
     <ymin> hasta <ymax>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `ip_grid', `ip_grid_in', `line_width', `line_type', `key' y
     `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(terminal  = eps,
                       grid      = true,
                       line_type = solid,
                       key       = "y^2=x^3-2*x+1",
                       implicit(y^2=x^3-2*x+1, x, -4,4, y, -4,4),
                       line_type = dots,
                       key       = "x^3+y^3 = 3*x*y^2-x-1",
                       implicit(x^3+y^3 = 3*x*y^2-x-1, x,-4,4, y,-4,4),
                       title     = "Two implicit functions" )$

     3D

     `implicit (<fcn>,<x>,<xmin>,<xmax>, <y>,<ymin>,<ymax>,
     <z>,<zmin>,<zmax>)' dibuja la función implícita <fcn>, con la
     variable <x> tomando valores desde <xmin> hasta <xmax>, la
     variable <y> tomando valores desde <ymin> hasta <ymax> y la
     variable <z> tomando valores desde <zmin> hasta <zmax>. Este
     objeto está programado con el algoritmo marching cubes.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `x_voxel', `y_voxel', `z_voxel', `line_width', `line_type', `key',
     `wired_surface', `enhanced3d' y `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(
                  color=blue,
                  implicit((x^2+y^2+z^2-1)*(x^2+(y-1.5)^2+z^2-0.5)=0.015,
                           x,-1,1,y,-1.2,2.3,z,-1,1),
                  surface_hide=true);

 -- Objeto gráfico: label ([<string>,<x>,<y>],...)
 -- Objeto gráfico: label ([<string>,<x>,<y>,<z>],...)
     Escribe etiquetas en 2D y 3D.

     Las etiquetas coloreadas sólo trabajan con Gnuplot 4.3. Este es un
     fallo conocido del paquete `draw'.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `label_alignment', `label_orientation' y `color'.

     2D

     `label([<string>,<x>,<y>])' escribe la cadena de caracteres
     <string> en el punto `[<x>,<y>]'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(yrange = [0.1,1.4],
                       color = red,
                       label(["Label in red",0,0.3]),
                       color = "#0000ff",
                       label(["Label in blue",0,0.6]),
                       color = light_blue,
                       label(["Label in light-blue",0,0.9],
                             ["Another light-blue",0,1.2])  )$

     3D

     `label([<string>,<x>,<y>,<z>])' escribe la cadena de caracteres
     <string> en el punto `[<x>,<y>,<z>]'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3),
                       color = red,
                       label(["UP 1",-2,0,3], ["UP 2",1.5,0,4]),
                       color = blue,
                       label(["DOWN 1",2,0,-3]) )$

 -- Objeto gráfico: mesh (<fila_1>,<fila_2>,...)
     Dibuja un enrejado cuadrangular en 3D.

     3D

     El argumento <fila_i> es una lista de <n> puntos en 3D de la forma
     `[[x_i1,y_i1,z_i1], ...,[x_in,y_in,z_in]]', siendo todas las filas
     de igual longitud. Todos estos puntos definen una superficie
     arbitraria en 3D.  En cierto sentido, se trata de una
     generalización del objeto `elevation_grid'.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `line_type', `line_width', `color', `key', `wired_surface',
     `enhanced3d' y `transform'.

     Ejemplos:

     Un sencillo ejemplo.

          (%i1) load(draw)$
          (%i2) draw3d(
                   mesh([[1,1,3],   [7,3,1],[12,-2,4],[15,0,5]],
                        [[2,7,8],   [4,3,1],[10,5,8], [12,7,1]],
                        [[-2,11,10],[6,9,5],[6,15,1], [20,15,2]])) $

     Dibujando un triángulo en 3D.

          (%i1) load(draw)$
          (%i2) draw3d(
                  line_width = 2,
                  mesh([[1,0,0],[0,1,0]],
                       [[0,0,1],[0,0,1]])) $

     Dos cuadriláteros.

          (%i1) load(draw)$
          (%i2) draw3d(
                  surface_hide = true,
                  line_width   = 3,
                  color = red,
                  mesh([[0,0,0], [0,1,0]],
                       [[2,0,2], [2,2,2]]),
                  color = blue,
                  mesh([[0,0,2], [0,1,2]],
                       [[2,0,4], [2,2,4]])) $

 -- Objeto gráfico: parametric (<xfun>,<yfun>,<par>,<parmin>,<parmax>)
 -- Objeto gráfico: parametric
          (<xfun>,<yfun>,<zfun>,<par>,<parmin>,<parmax>)
     Dibuja funciones paramétricas en 2D y 3D.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `nticks', `line_width', `line_type', `key', `color' y `enhanced3d'.

     2D

     `parametric (<xfun>,<yfun>,<par>,<parmin>,<parmax>)' dibuja la
     función paramétrica `[<xfun>,<yfun>]', con el parámetro <par>
     tomando valores desde <parmin> hasta <parmax>.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(exp(x),x,-1,3),
                       color = red,
                       key   = "This is the parametric one!!",
                       parametric(2*cos(rrr),rrr^2,rrr,0,2*%pi))$

     3D

     `parametric (<xfun>,<yfun>,<zfun>,<par>,<parmin>,<parmax>)' dibuja
     la curva paramétrica `[<xfun>,<yfun>,<zfun>]', con el parámetro
     <par> tomando valores desde <parmin> hasta <parmax>.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3),
                       color = royalblue,
                       parametric(cos(5*u)^2,sin(7*u),u-2,u,0,2),
                       color      = turquoise,
                       line_width = 2,
                       parametric(t^2,sin(t),2+t,t,0,2),
                       surface_hide = true,
                       title = "Surface & curves" )$

 -- Objeto gráfico: parametric_surface
          (<xfun>,<yfun>,<zfun>,<par1>,<par1min>,<par1max>,<par2>,<par2min>,<par2max>)
     Dibuja superficies paramétricas en 3D.

     3D

     `parametric_surface
     (<xfun>,<yfun>,<zfun>,<par1>,<par1min>,<par1max>,<par2>,<par2min>,<par2max>)'
     dibuja la superficie paramétrica `[<xfun>,<yfun>,<zfun>]', con el
     parámetro <par1> tomando valores desde <par1min> hasta <par1max> y
     el parámetro <par2> tomando valores desde <par2min> hasta
     <par2max>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `draw_realpart', `xu_grid', `yv_grid', `line_type', `line_width',
     `key', `wired_surface', `enhanced3d' y `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(title          = "Sea shell",
                       xu_grid        = 100,
                       yv_grid        = 25,
                       view           = [100,20],
                       surface_hide   = true,
                       parametric_surface(0.5*u*cos(u)*(cos(v)+1),
                                     0.5*u*sin(u)*(cos(v)+1),
                                     u*sin(v) - ((u+3)/8*%pi)^2 - 20,
                                     u, 0, 13*%pi, v, -%pi, %pi) )$

 -- Objeto gráfico: points ([[<x1>,<y1>], [<x2>,<y2>],...])
 -- Objeto gráfico: points ([<x1>,<x2>,...], [<y1>,<y2>,...])
 -- Objeto gráfico: points ([<y1>,<y2>,...])
 -- Objeto gráfico: points ([[<x1>,<y1>,<z1>], [<x2>,<y2>,<z2>],...])
 -- Objeto gráfico: points ([<x1>,<x2>,...], [<y1>,<y2>,...],
          [<z1>,<z2>,...])
 -- Objeto gráfico: points (<matrix>)
 -- Objeto gráfico: points (<1d_y_array>)
 -- Objeto gráfico: points (<1d_x_array>, <1d_y_array>)
 -- Objeto gráfico: points (<1d_x_array>, <1d_y_array>, <1d_z_array>)
 -- Objeto gráfico: points (<2d_xy_array>)
 -- Objeto gráfico: points (<2d_xyz_array>)
     Dibuja puntos en 2D y 3D.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `point_size', `point_type', `points_joined', `line_width', `key',
     `line_type' y `color'. En modo 3D también se ve afectado por
     `enhanced3d'.

     2D

     `points ([[<x1>,<y1>], [<x2>,<y2>],...])' o `points
     ([<x1>,<x2>,...], [<y1>,<y2>,...])' dibuja los puntos
     `[<x1>,<y1>]', `[<x2>,<y2>]', etc. Si no se dan las abscisas,
     éstas se asignan automáticamente a enteros positivos consecutivos,
     de forma que `points([<y1>,<y2>,...])' dibuja los puntos
     `[1,<y1>]', `[2,<y2>]', etc.  Si <matrix> es una matriz de dos
     columnas o de dos filas, `points (<matrix>)' dibuja los puntos
     asociados.

     Si <1d_y_array> es un array lisp de números en 1D, `points
     (<1d_y_array>)' los dibujará asignando las abscisas a números
     enteros consecutivos.  `points (<1d_x_array>, <1d_y_array>)'
     dibuja los puntos cuyas coordenadas se toman de los dos arrays
     pasados como argumentos. Si <2d_xy_array> es un array lisp 2D de
     dos filas, o de dos columnas, `points (<2d_xy_array>)' dibuja los
     correspondientes puntos del plano.

     Ejemplos:

     Dos tipos de argumentos para `points', una lista de pares ordenados
     y dos listas con las coordenadas separadas.
          (%i1) load(draw)$
          (%i2) draw2d(
                  key = "Small points",
                  points(makelist([random(20),random(50)],k,1,10)),
                  point_type    = circle,
                  point_size    = 3,
                  points_joined = true,
                  key           = "Great points",
                  points(makelist(k,k,1,20),makelist(random(30),k,1,20)),
                  point_type    = filled_down_triangle,
                  key           = "Automatic abscissas",
                  color         = red,
                  points([2,12,8]))$

     Dibujando impulsos.
          (%i1) load(draw)$
          (%i2) draw2d(
                  points_joined = impulses,
                  line_width    = 2,
                  color         = red,
                  points(makelist([random(20),random(50)],k,1,10)))$

     Array con ordenadas.
          (%i1) load(draw)$
          (%i2) a: make_array (flonum, 100) $
          (%i3) for i:0 thru 99 do a[i]: random(1.0) $
          (%i4) draw2d(points(a)) $

     Dos arrays con coordenadas separadas.
          (%i1) load(draw)$
          (%i2) x: make_array (flonum, 100) $
          (%i3) y: make_array (fixnum, 100) $
          (%i4) for i:0 thru 99 do (
                  x[i]: float(i/100),
                  y[i]: random(10) ) $
          (%i5) draw2d(points(x, y)) $

     Un array 2D de dos columnas.
          (%i1) load(draw)$
          (%i2) xy: make_array(flonum, 100, 2) $
          (%i3) for i:0 thru 99 do (
                  xy[i, 0]: float(i/100),
                  xy[i, 1]: random(10) ) $
          (%i4) draw2d(points(xy)) $

     Dibujando un array rellenado con la función `read_array'.
          (%i1) load(draw)$
          (%i2) a: make_array(flonum,100) $
          (%i3) read_array (file_search ("pidigits.data"), a) $
          (%i4) draw2d(points(a)) $

     3D

     `points ([[<x1>,<y1>,<z1>], [<x2>,<y2>,<z2>],...])' o `points
     ([<x1>,<x2>,...], [<y1>,<y2>,...], [<z1>,<z2>,...])' dibuja los
     puntos `[<x1>,<y1>,<z1>]', `[<x2>,<y2>,<z2>]', etc.  Si <matrix>
     es una matriz de tres columnas o de tres filas, `points (<matrix>)'
     dibuja los puntos asociados. Si <matrix> es una matriz columna o
     fila, las abscisas se asignan automáticamente.

     En caso de que los argumentos sean arrays lisp, `points
     (<1d_x_array>, <1d_y_array>, <1d_z_array>)' toma las coordenadas
     de los tres arrays unidimensionales. Si <2d_xyz_array> es un array
     2D de tres columnas, o de tres filas, entonces `points
     (<2d_xyz_array>)' dibuja los puntos correspondientes.

     Ejemplos:

     Una muestra tridimensional,
          (%i1) load(draw)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) draw3d(title = "Daily average wind speeds",
                       point_size = 2,
                       points(args(submatrix (s2, 4, 5))) )$

     Dos muestras tridimensionales,
          (%i1) load(draw)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) draw3d(
                   title = "Daily average wind speeds. Two data sets",
                   point_size = 2,
                   key        = "Sample from stations 1, 2 and 3",
                   points(args(submatrix (s2, 4, 5))),
                   point_type = 4,
                   key        = "Sample from stations 1, 4 and 5",
                   points(args(submatrix (s2, 2, 3))) )$

     Arrays unidimensionales,
          (%i1) load(draw)$
          (%i2) x: make_array (fixnum, 10) $
          (%i3) y: make_array (fixnum, 10) $
          (%i4) z: make_array (fixnum, 10) $
          (%i5) for i:0 thru 9 do (
                  x[i]: random(10),
                  y[i]: random(10),
                  z[i]: random(10) ) $
          (%i6) draw3d(points(x,y,z)) $

     Array bidimensional coloreado,
          (%i1) load(draw)$
          (%i2) xyz: make_array(fixnum, 10, 3) $
          (%i3) for i:0 thru 9 do (
                  xyz[i, 0]: random(10),
                  xyz[i, 1]: random(10),
                  xyz[i, 2]: random(10) ) $
          (%i4) draw3d(
                   enhanced3d = true,
                   points_joined = true,
                   points(xyz)) $

     Números de colores especificados explícitamente por el usuario.
          (%i1) load(draw)$
          (%i2) pts: makelist([t,t^2,cos(t)], t, 0, 15)$
          (%i3) col_num: makelist(k, k, 1, length(pts))$
          (%i4) draw3d(
                  enhanced3d = ['part(col_num,k),k],
                  point_size = 3,
                  point_type = filled_circle,
                  points(pts))$

 -- Objeto gráfico: polar (<radius>,<ang>,<minang>,<maxang>)
     Dibuja funciones 2D definidas en coordenadas polares.

     2D

     `polar (<radius>,<ang>,<minang>,<maxang>)' dibuja la función
     `<radius>(<ang>)' definida en coordenadas polares, con la variable
     <ang> tomando valores desde <minang> hasta <maxang>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `nticks', `line_width', `line_type', `key' y `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(user_preamble = "set grid polar",
                       nticks        = 200,
                       xrange        = [-5,5],
                       yrange        = [-5,5],
                       color         = blue,
                       line_width    = 3,
                       title         = "Hyperbolic Spiral",
                       polar(10/theta,theta,1,10*%pi) )$

 -- Objeto gráfico: polygon ([[<x1>,<y1>], [<x2>,<y2>],...])
 -- Objeto gráfico: polygon ([<x1>,<x2>,...], [<y1>,<y2>,...])
     Dibuja polígonos en 2D.

     2D

     `polygon ([[<x1>,<y1>], [<x2>,<y2>],...])' o `polygon
     ([<x1>,<x2>,...], [<y1>,<y2>,...])': dibuja en el plano un
     polígono de vértices `[<x1>,<y1>]', `[<x2>,<y2>]', etc..

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `transparent', `fill_color', `border', `line_width', `key',
     `line_type' y `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(color      = "#e245f0",
                       line_width = 8,
                       polygon([[3,2],[7,2],[5,5]]),
                       border      = false,
                       fill_color  = yellow,
                       polygon([[5,2],[9,2],[7,5]]) )$

 -- Objeto gráfico: quadrilateral (<point_1>, <point_2>, <point_3>,
          <point_4>)
     Dibuja un cuadrilátero.

     2D

     `quadrilateral ([<x1>,<y1>], [<x2>,<y2>], [<x3>,<y3>],
     [<x4>,<y4>])' dibuja un cuadrilátero de vértices `[<x1>,<y1>]',
     `[<x2>,<y2>]', `[<x3>,<y3>]' y `[<x4>,<y4>]'.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `transparent', `fill_color', `border', `line_width', `key',
     `xaxis_secondary', `yaxis_secondary', `line_type', `transform' y
     `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(
                  quadrilateral([1,1],[2,2],[3,-1],[2,-2]))$

     3D

     `quadrilateral ([<x1>,<y1>,<z1>], [<x2>,<y2>,<z2>],
     [<x3>,<y3>,<z3>], [<x4>,<y4>,<z4>])' dibuja un cuadrilátero de
     vértices `[<x1>,<y1>,<z1>]', `[<x2>,<y2>,<z2>]',
     `[<x3>,<y3>,<z3>]' y `[<x4>,<y4>,<z4>]'.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `line_type', `line_width', `color', `key', `enhanced3d' y
     `transform'.

 -- Objeto gráfico: rectangle ([<x1>,<y1>], [<x2>,<y2>])
     Dibuja rectángulos en 2D.

     2D

     `rectangle ([<x1>,<y1>], [<x2>,<y2>])' dibuja un rectángulo de
     vértices opuestos `[<x1>,<y1>]' y `[<x2>,<y2>]'.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `transparent', `fill_color', `border', `line_width', `key',
     `line_type' y `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(fill_color  = red,
                       line_width  = 6,
                       line_type   = dots,
                       transparent = false,
                       fill_color  = blue,
                       rectangle([-2,-2],[8,-1]), /* opposite vertices */
                       transparent = true,
                       line_type   = solid,
                       line_width  = 1,
                       rectangle([9,4],[2,-1.5]),
                       xrange      = [-3,10],
                       yrange      = [-3,4.5] )$

 -- Objeto gráfico: region
          (<expr>,<var1>,<minval1>,<maxval1>,<var2>,<minval2>,<maxval2>)
     Dibuja una región del plano definida por desigualdades.

     2D <expr> es una expresión formada por desigualdades y los
     operadores lógicos `and', `or' y `not'. La región está acotada por
     el rectángulo definido por [<minval1>, <maxval1>] y [<minval2>,
     <maxval2>].

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `fill_color', `key', `x_voxel' y `y_voxel'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(
                  x_voxel = 30,
                  y_voxel = 30,
                  region(x^2+y^2<1 and x^2+y^2 > 1/2,
                         x, -1.5, 1.5, y, -1.5, 1.5));

 -- Objeto gráfico: spherical
          (<radius>,<azi>,<minazi>,<maxazi>,<zen>,<minzen>,<maxzen>)
     Dibuja funciones 3D definidas en coordenadas esféricas.

     3D

     `spherical
     (<radius>,<azi>,<minazi>,<maxazi>,<zen>,<minzen>,<maxzen>)' dibuja
     la función `<radius>(<azi>,<zen>)' definida en coordenadas
     esféricas, con el azimut <azi> tomando valores desde <minazi>
     hasta <maxazi> y el zenit <zen> tomando valores desde <minzen>
     hasta <maxzen>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `xu_grid', `yv_grid', `line_type', `key', `wired_surface',
     `enhanced3d' y `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(spherical(1,a,0,2*%pi,z,0,%pi))$

 -- Objeto gráfico: triangle (<punto_1>, <punto_2>, <punto_3>)
     Dibuja un triángulo.

     2D

     `triangle ([<x1>,<y1>], [<x2>,<y2>], [<x3>,<y3>])' dibuja un
     triángulo de vértices `[<x1>,<y1>]', `[<x2>,<y2>]' y `[<x3>,<y3>]'.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `transparent', `fill_color', `border', `line_width', `key',
     `xaxis_secondary', `yaxis_secondary', `line_type', `transform' y
     `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(
                  triangle([1,1],[2,2],[3,-1]))$

     3D

     `triangle ([<x1>,<y1>,<z1>], [<x2>,<y2>,<z2>], [<x3>,<y3>,<z3>])'
     dibuja un triángulo de vértices `[<x1>,<y1>,<z1>]',
     `[<x2>,<y2>,<z2>]' y `[<x3>,<y3>,<z3>]'.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `line_type', `line_width', `color', `key', `enhanced3d' y
     `transform'.

 -- Objeto gráfico: tube (<xfun>,<yfun>,<zfun>,<rfun>,<p>,<pmin>,<pmax>)
     Dibuja un tubo en 3D de diámetro variable.

     3D

     `[<xfun>,<yfun>,<zfun>]' es la curva paramétrica de parámetro <p>,
     el cual toma valores entre <pmin> y <pmax>. Se colocan círculos de
     radio <rfun> con sus centros sobre la curva paramétrica y
     perpendiculares a ella.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `xu_grid', `yv_grid', `line_type', `line_width', `key',
     `wired_surface', `enhanced3d', `color' y `tube_extremes'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(
                  enhanced3d = true,
                  xu_grid = 50,
                  tube(cos(a), a, 0, cos(a/10)^2,
                       a, 0, 4*%pi) )$


 -- Objeto gráfico: vector ([<x>,<y>], [<dx>,<dy>])
 -- Objeto gráfico: vector ([<x>,<y>,<z>], [<dx>,<dy>,<dz>])
     Dibuja vectores en 2D y 3D.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `head_both', `head_length', `head_angle', `head_type',
     `line_width', `line_type', `key' y `color'.

     2D

     `vector ([<x>,<y>], [<dx>,<dy>])' dibuja el vector `[<dx>,<dy>]'
     con origen en `[<x>,<y>]'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,12],
                       yrange      = [0,10],
                       head_length = 1,
                       vector([0,1],[5,5]), /* default type */
                       head_type = 'empty,
                       vector([3,1],[5,5]),
                       head_both = true,
                       head_type = 'nofilled,
                       line_type = dots,
                       vector([6,1],[5,5]))$

     3D

     `vector([<x>,<y>,<z>], [<dx>,<dy>,<dz>])' dibuja el vector
     `[<dx>,<dy>,<dz>]' con origen en `[<x>,<y>,<z>]'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(color = cyan,
                       vector([0,0,0],[1,1,1]/sqrt(3)),
                       vector([0,0,0],[1,-1,0]/sqrt(2)),
                       vector([0,0,0],[1,1,-2]/sqrt(6)) )$


File: maxima.info,  Node: Funciones y variables para picture,  Next: Funciones y variables para worldmap,  Prev: Funciones y variables para draw,  Up: draw

47.3 Funciones y variables para picture
=======================================

 -- Función: get_pixel (<pic>,<x>,<y>)
     Devuelve el pixel de la imagen <pic>. Las coordenadas <x> e <y>
     van desde 0 hasta `ancho-1' y `alto-1', respectivamente.

 -- Función: make_level_picture (<data>)
 -- Función: make_level_picture (<data>,<width>,<height>)
     Devuelve un objeto `picture' consistente en una imagen de niveles.
     `make_level_picture (<data>)' construye el objeto `picture' a
     partir de la matriz <data>.  `make_level_picture
     (<data>,<width>,<height>)' construye el objeto a partir de una
     lista de números, en cuyo caso deben indicarse el ancho <width> y
     la altura <height> en píxeles.

     El objeto  `picture' devuelto contiene los siguientes cuatro
     elemento:

       1. el símbolo `level'

       2. anchura de la imagen

       3. altura de la imagen

       4. un array de enteros con los valores de los píxeles entre 0 y
          255. El argumento <data> debe contener sólo números entre 0 y
          255; los cantidades negativas se transforman en ceros y las
          que son mayores de 255 se igualan a este número.

     Ejemplo:

     Imagen de niveles a partir de una matriz.
          (%i1) load(draw)$
          (%i2) make_level_picture(matrix([3,2,5],[7,-9,3000]));
          (%o2)         picture(level, 3, 2, {Array:  #(3 2 5 7 0 255)})

     Imagen de niveles a partir de una lista numérica.
          (%i1) load(draw)$
          (%i2) make_level_picture([-2,0,54,%pi],2,2);
          (%o2)            picture(level, 2, 2, {Array:  #(0 0 54 3)})

 -- Función: make_rgb_picture (<redlevel>,<greenlevel>,<bluelevel>)
     Devuelve un objeto <picture> conteniendo una imagen en color (RGB).
     Los tres argumentos deben ser imágenes de niveles, para el rojo
     (R), verde (G) y azul (B).

     El objeto  <picture> devuelto contiene los siguientes cuatro
     elemento:

       1. el símbolo `rgb'

       2. anchura de la imagen

       3. altura de la imagen

       4. un array de enteros de <3*ancho*alto> con los valores de los
          píxeles entre 0 y 255. Cada valor de pixel se representa en
          el array con tres números consecutivos (rojo, verde, azul).

     Ejemplo:

          (%i1) load(draw)$
          (%i2) red: make_level_picture(matrix([3,2],[7,260]));
          (%o2)           picture(level, 2, 2, {Array:  #(3 2 7 255)})
          (%i3) green: make_level_picture(matrix([54,23],[73,-9]));
          (%o3)           picture(level, 2, 2, {Array:  #(54 23 73 0)})
          (%i4) blue: make_level_picture(matrix([123,82],[45,32.5698]));
          (%o4)          picture(level, 2, 2, {Array:  #(123 82 45 33)})
          (%i5) make_rgb_picture(red,green,blue);
          (%o5) picture(rgb, 2, 2,
                        {Array:  #(3 54 123 2 23 82 7 73 45 255 0 33)})

 -- Función: negative_picture (<pic>)
     Devuelve el negativo de la imagen, sea ésta de tipo nivel (<level>)
     o color (<rgb>).

 -- Función: picture_equalp (<x>,<y>)
     Devuelve `true' si los dos argumentos son imágenes idénticas, o
     `false' en caso contrario.

 -- Función: picturep (<x>)
     Devuelve `true' si el argumento es una imagen bien formada, o
     `false' en caso contrario.

 -- Función: read_xpm (<xpm_file>)
     Lee el fichero gráfico en formato xpm y devuelve un objeto
     `picture'.

 -- Función: rgb2level (<pic>)
     Transforma una imagen en color <rgb> a otra de niveles <level>
     promediando los niveles.

 -- Función: take_channel (<im>,<color>)
     Si el argumento <color> es `red', `green' o `blue', la función
     `take_channel' devuelve el canal de color correspondiente de la
     imagen <im>.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) red: make_level_picture(matrix([3,2],[7,260]));
          (%o2)           picture(level, 2, 2, {Array:  #(3 2 7 255)})
          (%i3) green: make_level_picture(matrix([54,23],[73,-9]));
          (%o3)           picture(level, 2, 2, {Array:  #(54 23 73 0)})
          (%i4) blue: make_level_picture(matrix([123,82],[45,32.5698]));
          (%o4)          picture(level, 2, 2, {Array:  #(123 82 45 33)})
          (%i5) make_rgb_picture(red,green,blue);
          (%o5) picture(rgb, 2, 2,
                        {Array:  #(3 54 123 2 23 82 7 73 45 255 0 33)})
          (%i6) take_channel(%,'green);  /* simple quote!!! */
          (%o6)           picture(level, 2, 2, {Array:  #(54 23 73 0)})


File: maxima.info,  Node: Funciones y variables para worldmap,  Prev: Funciones y variables para picture,  Up: draw

47.4 Funciones y variables para worldmap
========================================

Este paquete carga automáticamente el paquete `draw'.

47.4.1 Variables y Funciones
----------------------------

 -- Global variable: boundaries_array
     Valor por defecto: `false'

     `boundaries_array' es donde el objeto gráfico `geomap' lee las
     coordenadas de las líneas fronterizas.

     Cada componente de `boundaries_array' es un array de números
     decimales en coma flotante representando las coordenadas que
     definen un segmento poligonal o línea fronteriza.

     Véase también `geomap'.

 -- Función: numbered_boundaries (<nlist>)
     Dibuja una lista de segmentos poligonales (líneas fronterizas),
     etiquetadas con sus números correspondientes (coordenadas de
     `boundaries_array'). Esta función es de mucha ayuda a la hora de
     definir nuevas entidades geográficas.

     Ejemplo:

     Mapa de Europa con las fronteras y costas etiquetadas con su
     componente numérica de `boundaries_array'.
          (%i1) load(worldmap)$
          (%i2) european_borders:
                     region_boundaries(-31.81,74.92,49.84,32.06)$
          (%i3) numbered_boundaries(european_borders)$

 -- Función: make_poly_continent (<continent_name>)
 -- Función: make_poly_continent (<country_list>)
     Construye los polígonos necesarios para dibujar un continente o
     lista de países coloreados.

     Ejemplo:

          (%i1) load(worldmap)$
          (%i2) /* A continent */
                make_poly_continent(Africa)$
          (%i3) apply(draw2d, %)$
          (%i4) /* A list of countries */
                make_poly_continent([Germany,Denmark,Poland])$
          (%i5) apply(draw2d, %)$

 -- Función: make_poly_country (<country_name>)
     Construye los polígonos necesarios para dibujar un país coloreado.
     En caso de contener islas, un país tendrá asociados varios
     polígonos.

     Ejemplo:

          (%i1) load(worldmap)$
          (%i2) make_poly_country(India)$
          (%i3) apply(draw2d, %)$

 -- Función: make_polygon (<nlist>)
     Devuelve un objeto `polygon' a partie de una lista de líneas
     fronterizas y de costas. El argumento <nlist> debe ser una lista
     de componentes de `boundaries_array'.

     Ejemplo:

     La variable Bhutan (Bután) está definida con los números
     fronterizos 171, 173 y 1143, de manera que
     `make_polygon([171,173,1143])' concatena los arrays
     `boundaries_array[171]', `boundaries_array[173]' y
     `boundaries_array[1143]' y devuelve un objeto `polygon' apto para
     ser dibujado por `draw'. A fin de evitar mensajes de errores, los
     arrays deben ser compatibles en el sentido de que dos de ellos
     consecutivos deben tener dos coordenadas comunes en los extremos.
     En este ejemplo, las dos primeras componentes de
     `boundaries_array[171]' son iguales a las dos últimas de
     `boundaries_array[173]', y las dos primeras de
     `boundaries_array[173]' coinciden con las dos primeras de
     `boundaries_array[1143]'; en conclusión, los números de segmentos
     poligonales171, 173 y 1143 (en este orden) son compatibles y el
     polígono coloreado se podrá dibujar.
          (%i1) load(worldmap)$
          (%i2) Bhutan;
          (%o2)                        [[171, 173, 1143]]
          (%i3) boundaries_array[171];
          (%o3) {Array:
                 #(88.750549 27.14727 88.806351 27.25305 88.901367 27.282221
                   88.917877 27.321039)}
          (%i4) boundaries_array[173];
          (%o4) {Array:
                 #(91.659554 27.76511 91.6008 27.66666 91.598022 27.62499
                   91.631348 27.536381 91.765533 27.45694 91.775253 27.4161
                   92.007751 27.471939 92.11441 27.28583 92.015259 27.168051
                   92.015533 27.08083 92.083313 27.02277 92.112183 26.920271
                   92.069977 26.86194 91.997192 26.85194 91.915253 26.893881
                   91.916924 26.85416 91.8358 26.863331 91.712479 26.799999
                   91.542191 26.80444 91.492188 26.87472 91.418854 26.873329
                   91.371353 26.800831 91.307457 26.778049 90.682457 26.77417
                   90.392197 26.903601 90.344131 26.894159 90.143044 26.75333
                   89.98996 26.73583 89.841919 26.70138 89.618301 26.72694
                   89.636093 26.771111 89.360786 26.859989 89.22081 26.81472
                   89.110237 26.829161 88.921631 26.98777 88.873016 26.95499
                   88.867737 27.080549 88.843307 27.108601 88.750549
                   27.14727)}
          (%i5) boundaries_array[1143];
          (%o5) {Array:
                 #(91.659554 27.76511 91.666924 27.88888 91.65831 27.94805
                   91.338028 28.05249 91.314972 28.096661 91.108856 27.971109
                   91.015808 27.97777 90.896927 28.05055 90.382462 28.07972
                   90.396088 28.23555 90.366074 28.257771 89.996353 28.32333
                   89.83165 28.24888 89.58609 28.139999 89.35997 27.87166
                   89.225517 27.795 89.125793 27.56749 88.971077 27.47361
                   88.917877 27.321039)}
          (%i6) Bhutan_polygon: make_polygon([171,173,1143])$
          (%i7) draw2d(Bhutan_polygon)$

 -- Función: region_boundaries (<x1>,<y1>,<x2>,<y2>)
     Detecta los segmentos poligonales almacenados en la variable global
     `boundaries_array' totalmente contenidos en el rectángulo de
     vértices (<x1>,<y1>) -superior izquierdo- y (<x2>,<y2>) -inferior
     derecho-.

     Ejemplo:

     Devuelve los números de los segmentos necesarios para dibujar el
     sur de Italia.
          (%i1) load(worldmap)$
          (%i2) region_boundaries(10.4,41.5,20.7,35.4);
          (%o2)                [1846, 1863, 1864, 1881, 1888, 1894]
          (%i3) draw2d(geomap(%))$

 -- Función: region_boundaries_plus (<x1>,<y1>,<x2>,<y2>)
     Detecta los segmentos poligonales almacenados en la variable global
     `boundaries_array' con al menos un vértice dentro del rectángulo
     definido por los extremos (<x1>,<y1>) -superior izquierdo- y
     (<x2>,<y2>) -inferior derecho-.

     Ejemplo:

          (%i1) load(worldmap)$
          (%i2) region_boundaries_plus(10.4,41.5,20.7,35.4);
          (%o2) [1060, 1062, 1076, 1835, 1839, 1844, 1846, 1858,
                 1861, 1863, 1864, 1871, 1881, 1888, 1894, 1897]
          (%i3) draw2d(geomap(%))$

47.4.2 Objetos gráficos
-----------------------

 -- Objeto gráfico: geomap (<numlist>)
 -- Objeto gráfico: geomap (<numlist>,<3Dprojection>)
     Dibuja mapas cartográficos en 2D y 3D.

     2D

     Esta función trabaja junto con la variable global
     `boundaries_array'.

     El argumento <numlist> es una lista de números o de listas de
     números. Todos estos números deben ser enteros mayores o iguales
     que cero, representando las componentes del array global
     `boundaries_array'.

     Cada componente de `boundaries_array' es un array de decimales en
     coma flotante, las coordenadas de un segmento poligonal o línea
     fronteriza.

     `geomap (<numlist>)' toma los enteros de sus argumentos y dibuja
     los segmentos poligonales asociados de `boundaries_array'.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `line_width', `line_type' y `color'.

     Ejemplos:

     Un sencillo mapa hecho a mano:
          (%i1) load(worldmap)$
          (%i2) /* Vertices of boundary #0: {(1,1),(2,5),(4,3)} */
             ( bnd0: make_array(flonum,6),
               bnd0[0]:1.0, bnd0[1]:1.0, bnd0[2]:2.0,
               bnd0[3]:5.0, bnd0[4]:4.0, bnd0[5]:3.0 )$
          (%i3) /* Vertices of boundary #1: {(4,3),(5,4),(6,4),(5,1)} */
             ( bnd1: make_array(flonum,8),
               bnd1[0]:4.0, bnd1[1]:3.0, bnd1[2]:5.0, bnd1[3]:4.0,
               bnd1[4]:6.0, bnd1[5]:4.0, bnd1[6]:5.0, bnd1[7]:1.0)$
          (%i4) /* Vertices of boundary #2: {(5,1), (3,0), (1,1)} */
             ( bnd2: make_array(flonum,6),
               bnd2[0]:5.0, bnd2[1]:1.0, bnd2[2]:3.0,
               bnd2[3]:0.0, bnd2[4]:1.0, bnd2[5]:1.0 )$
          (%i5) /* Vertices of boundary #3: {(1,1), (4,3)} */
             ( bnd3: make_array(flonum,4),
               bnd3[0]:1.0, bnd3[1]:1.0, bnd3[2]:4.0, bnd3[3]:3.0)$
          (%i6) /* Vertices of boundary #4: {(4,3), (5,1)} */
             ( bnd4: make_array(flonum,4),
               bnd4[0]:4.0, bnd4[1]:3.0, bnd4[2]:5.0, bnd4[3]:1.0)$
          (%i7) /* Pack all together in boundaries_array */
             ( boundaries_array: make_array(any,5),
               boundaries_array[0]: bnd0, boundaries_array[1]: bnd1,
               boundaries_array[2]: bnd2, boundaries_array[3]: bnd3,
               boundaries_array[4]: bnd4 )$
          (%i8) draw2d(geomap([0,1,2,3,4]))$

     El paquete auxiliar `worldmap' asigna al array global
     `boundaries_array' líneas fronterizas reales en coordenadas
     (longitud, latitud). Estos datos son de dominio público y proceden
     de `http://www-cger.nies.go.jp/grid-e/gridtxt/grid19.html'.  El
     paquete `worldmap' también define fronteras de países, continentes
     y líneas costeras a partir de las componentes de
     `boundaries_array' (véase el fichero `share/draw/worldmap.mac'
     para más información). El paquete `worldmap' carga automáticamente
     el paquete `draw'.
          (%i1) load(worldmap)$
          (%i2) c1: gr2d(geomap(Canada,United_States,
                                Mexico,Cuba))$
          (%i3) c2: gr2d(geomap(Africa))$
          (%i4) c3: gr2d(geomap(Oceania,China,Japan))$
          (%i5) c4: gr2d(geomap(France,Portugal,Spain,
                                Morocco,Western_Sahara))$
          (%i6) draw(columns  = 2,
                     c1,c2,c3,c4)$

     `worldmap' se puede utilizar para dibujar países como polígonos.
     En este caso, ya no será necesario hacer uso del objeto gráfico
     `geomap', pero sí de `polygon'. Puesto que en este caso se
     utilizan listas en lugar de arrays, los mapas se reproducirán de
     forma más lenta. Véanse también `make_poly_country' y
     `make_poly_continent' para comprender el siguiente código.
          (%i1) load(worldmap)$
          (%i2) mymap: append(
             [color      = white],  /* borders are white */
             [fill_color = red],             make_poly_country(Bolivia),
             [fill_color = cyan],            make_poly_country(Paraguay),
             [fill_color = green],           make_poly_country(Colombia),
             [fill_color = blue],            make_poly_country(Chile),
             [fill_color = "#23ab0f"],       make_poly_country(Brazil),
             [fill_color = goldenrod],       make_poly_country(Argentina),
             [fill_color = "midnight-blue"], make_poly_country(Uruguay))$
          (%i3) apply(draw2d, mymap)$

     3D

     `geomap (<numlist>)' proyecta los mapas sobre la esfera de radio 1
     y centro (0,0,0). Es posible cambiar la esfera o el tipo de
     proyección haciendo uso de `geomap (<numlist>,<3Dprojection>)'.

     Proyecciones 3D disponibles:

        * `[spherical_projection,<x>,<y>,<z>,<r>]': proyecta los mapas
          sobre la esfera de radio <r> y centro (<x>,<y>,<z>).
               (%i1) load(worldmap)$
               (%i2) draw3d(geomap(Australia), /* default projection */
                            geomap(Australia,
                                   [spherical_projection,2,2,2,3]))$

        * `[cylindrical_projection,<x>,<y>,<z>,<r>,<rc>]': re-proyecta
          mapas esféricos sobre el cilindro de radio <rc> cuyo eje pasa
          a través de los polos del globo de radio <r> y centro
          (<x>,<y>,<z>).
               (%i1) load(worldmap)$
               (%i2) draw3d(geomap([America_coastlines,Eurasia_coastlines],
                                   [cylindrical_projection,2,2,2,3,4]))$

        * `[conic_projection,<x>,<y>,<z>,<r>,<alpha>]': re-proyecta
          mapas esféricos sobre los conos de ángulo <alpha>, cuyos ejes
          pasan a través de los polos del globo de radio <r> y centro
          (<x>,<y>,<z>). Ambos conos, norte y sur, son tangentes a la
          esfera.
               (%i1) load(worldmap)$
               (%i2) draw3d(geomap(World_coastlines,
                                   [conic_projection,0,0,0,1,90]))$

     En `http://www.telefonica.net/web2/biomates/maxima/gpdraw/geomap'
     hay ejemplos más elaborados.


File: maxima.info,  Node: drawdf,  Next: dynamics,  Prev: draw,  Up: Top

48 drawdf
*********

* Menu:

* Introducción a drawdf::
* Funciones y variables para drawdf::


File: maxima.info,  Node: Introducción a drawdf,  Next: Funciones y variables para drawdf,  Prev: drawdf,  Up: drawdf

48.1 Introducción a drawdf
==========================

La función `drawdf' dibuja el campo de direcciones de una ecuación
diferencial ordinaria de primer orden (EDO) o de un sistema de dos
ecuaciones autónomas de primer orden.

   Puesto que `drawdf' es un paquete adicional, es necesario cargarlo en
memoria ejecutando previamente la instrucción `load(drawdf)'.  `drawdf'
utiliza el paquete `draw', que necesita como mínimo la versión 4.2 de
Gnuplot.

   Para dibujar el campo de direcciones de una EDO, ésta debe
escribirse de la forma
            dy
            -- = F(x,y)
            dx

   y ser la función <F> la que se pase a `drawdf' como argumento.  Si
las variables independiente y dependiente no son <x> e <y>, como en la
ecuación anterior, entonces deben nombrarse de forma explícita en una
lista que se pasará a `drawdf' (ver ejemplos más abajo).

   Para dibujar el campo de direcciones de un conjunto de dos EDOs
autónomas, deben escribirse de la forma
            dx             dy
            -- = G(x,y)    -- = F(x,y)
            dt             dt

   y será una lista con las dos funciones <G> y <F> la que se pase a
`drawdf' como argumento. El orden de las funciones es importante; la
primera será la derivada de la abscisa respecto del tiempo y la segunda
la derivada de la ordenada respecto del tiempo.  Si las variables no
son las <x> e <y> habituales, el segundo argumento que se pase a la
función `drawdf' será una lista con los nombres de ambas variables,
primero la correspondiente a las abscisas, seguida de la asociada a las
ordenadas.

   Si sólo se trata de una EDO, `drawdf' admitirá por defecto que `x=t'
y `G(x,y)=1', transformanado la ecuación no autónoma en un sistema de
dos ecuaciones autónomas.


File: maxima.info,  Node: Funciones y variables para drawdf,  Prev: Introducción a drawdf,  Up: drawdf

48.2 Funciones y variables para drawdf
======================================

48.2.1 Funciones
----------------

 -- Función: drawdf (<dydx>, ...options and objects...)
 -- Función: drawdf (<dvdu>, `['<u>,<v>`]', ...opciones y objetos...)
 -- Función: drawdf (<dvdu>, `['<u>,<umin>,<umax>`]',
          `['<v>,<vmin>,<vmax>`]', ...opciones y objetos...)
 -- Función: drawdf (`['<dxdt>,<dydt>`]', ...opciones y objetos...)
 -- Función: drawdf (`['<dudt>,<dvdt>`]', `['<u>,<v>`]', ...opciones y
          objetos...)
 -- Función: drawdf (`['<dudt>,<dvdt>`]', `['<u>,<umin>,<umax>`]',
          `['<v>,<vmin>,<vmax>`]', ...opciones y objetos...)
     La función `drawdf' dibuja un campo de direcciones 2D, incluyendo
     opcionalmente curvas asociadas a soluciones particulares, así como
     otros objeto gráficos del paquete `draw'.

     El primer argumento especifica la(s) derivada(s), el cual debe
     estar formado por una expresión o una lista de dos expresiones.
     <dydx>, <dxdt> y <dydt> son expresiones que dependen de <x> y <y>.
     <dvdu>, <dudt> y <dvdt> son expresiones que dependen de <u> y <v>.

     Si las variables independiente y dependiente no son <x> e <y>, sus
     nombres deben especificarse a continuación de las derivadas, bien
     como una lista de dos nombres, `['<u>,<v>`]', o como dos listas de
     la forma `['<u>,<umin>,<umax>`]' y `['<v>,<vmin>,<vmax>`]'.

     El resto de argumentos son opciones gráficas, objetos gráficos, o
     listas conteniendo elementos de ambos tipos. El conjunto de
     opciones y objetos gráficos soportados por `drawdf' incluye los
     soportados por `draw2d' y `gr2d' del paquete `draw'.

     Los argumentos se iterpretan secuencialmente: las opciones gráficas
     afectan a todos los objetos gráficos que le siguen. Además, los
     objetos gráficos se dibujan en el orden en el que se especifican,
     pudiendo tapar otros gráficos dibujados con anterioridad.  Algunas
     opciones gráficas afectan al aspecto general de la escena.

     Los nuevos objetos gráficos que se definen en `drawdf' son:
     `solns_at', `points_at', `saddles_at', `soln_at', `point_at' y
     `saddle_at'.

     Las nuevas opciones gráficas que se definen en `drawdf' son:
     `field_degree', `soln_arrows', `field_arrows', `field_grid',
     `field_color', `show_field', `tstep', `nsteps', `duration',
     `direction', `field_tstep', `field_nsteps' y `field_duration'.

     Objetos gráficos que se heredan del paquete `draw' incluyen:
     `explicit', `implicit', `parametric', `polygon', `points',
     `vector', `label' y cualesquiera otros soportados por `draw2d' y
     `gr2d'.

     Opciones gráficas que se heredan del paquete `draw' incluyen:
     `points_joined', `color', `point_type', `point_size', `line_width',
     `line_type', `key', `title', `xlabel', `ylabel', `user_preamble',
     `terminal', `dimensions', `file_name' y cualesquiera otros
     soportados por `draw2d' y `gr2d'.

     Véase también `draw2d'.

     Los usuarios de wxMaxima y Imaxima pueden hacer uso también
     `wxdrawdf', que es idéntica a `drawdf', pero que inserta el
     gráfico en el propio documento utilizando la función `wxdraw'.

     Para hacer uso de esta función, ejecútese primero `load(drawdf)'.

     Ejemplos:

          (%i1) load(drawdf)$
          (%i2) drawdf(exp(-x)+y)$        /* default vars: x,y */
          (%i3) drawdf(exp(-t)+y, [t,y])$ /* default range: [-10,10] */
          (%i4) drawdf([y,-9*sin(x)-y/5], [x,1,5], [y,-2,2])$

     A efectos de compatibilidad, `drawdf' acepta la mayor parte de
     parámetros soportados por `plotdf'.

          (%i5) drawdf(2*cos(t)-1+y, [t,y], [t,-5,10], [y,-4,9],
                       [trajectory_at,0,0])$

     `soln_at' y `solns_at' dibujan soluciones particulares que pasen
     por los puntos especificados, utilizando el integrador numérico de
     Runge Kutta de cuarto orden.

          (%i6) drawdf(2*cos(t)-1+y, [t,-5,10], [y,-4,9],
                       solns_at([0,0.1],[0,-0.1]),
                       color=blue, soln_at(0,0))$

     `field_degree=2' hace que el campo se componga de splines
     cuadráticos basados en las derivadas de primer y segundo orden en
     cada punto de la malla.  `field_grid=['<COLS>,<ROWS>`]' especifica
     el número de columnas y filas a utilizar en la malla.

          (%i7) drawdf(2*cos(t)-1+y, [t,-5,10], [y,-4,9],
                       field_degree=2, field_grid=[20,15],
                       solns_at([0,0.1],[0,-0.1]),
                       color=blue, soln_at(0,0))$

     `soln_arrows=true' añade flechas a las soluciones particulares y,
     por defecto, las borra. También cambia los colores por defecto para
     destacar las curvas de las soluciones particulares.

          (%i8) drawdf(2*cos(t)-1+y, [t,-5,10], [y,-4,9],
                       soln_arrows=true,
                       solns_at([0,0.1],[0,-0.1],[0,0]))$

     `duration=40' especifica el intervalo temporal de la integración
     numérica, cuyo valor por defecto es 10. La integración se detendrá
     automáticamente si la solución se aparta mucho de la región a
     dibujar, o si la derivada se vuelve compleja o infinita. Aquí
     también hacemos `field_degree=2' para dibujar splines cuadráticos.
     Las ecuaciones de este ejemplo modelizan un sistema
     depredador-presa.

          (%i9) drawdf([x*(1-x-y), y*(3/4-y-x/2)], [x,0,1.1], [y,0,1],
                       field_degree=2, duration=40,
                       soln_arrows=true, point_at(1/2,1/2),
                       solns_at([0.1,0.2], [0.2,0.1], [1,0.8], [0.8,1],
                                [0.1,0.1], [0.6,0.05], [0.05,0.4],
                                [1,0.01], [0.01,0.75]))$

     `field_degree='solns' hace que el campo se componga de muchas
     pequeñas soluciones calculadas a partir del Runge Kutta de cuarto
     orden.

          (%i10) drawdf([x*(1-x-y), y*(3/4-y-x/2)], [x,0,1.1], [y,0,1],
                        field_degree='solns, duration=40,
                        soln_arrows=true, point_at(1/2,1/2),
                        solns_at([0.1,0.2], [0.2,0.1], [1,0.8],
                                 [0.8,1], [0.1,0.1], [0.6,0.05],
                                 [0.05,0.4], [1,0.01], [0.01,0.75]))$

     `saddles_at' trata de linearizar automáticamente la ecuación en
     cada punto de silla y dibujar la solución numérica correspondiente
     a cada vector propio, incluyendo las separatrices. `tstep=0.05'
     establece el salto temporal máximo para el integrador numérico,
     cuyo valor por defecto es 0.1. Las siguientes ecuaciones modelizan
     un péndulo amortiguado.

          (%i11) drawdf([y,-9*sin(x)-y/5], tstep=0.05,
                        soln_arrows=true, point_size=0.5,
                        points_at([0,0], [2*%pi,0], [-2*%pi,0]),
                        field_degree='solns,
                        saddles_at([%pi,0], [-%pi,0]))$

     `show_field=false' elimina el campo completamente.

          (%i12) drawdf([y,-9*sin(x)-y/5], tstep=0.05,
                        show_field=false, soln_arrows=true,
                        point_size=0.5,
                        points_at([0,0], [2*%pi,0], [-2*%pi,0]),
                        saddles_at([3*%pi,0], [-3*%pi,0],
                                   [%pi,0], [-%pi,0]))$

     `drawdf' pasa todos los parámetros que no reconoce a `draw2d' o
     `gr2d', permitiendo combinar la potencia del paquete `draw' con
     `drawdf'.

          (%i13) drawdf(x^2+y^2, [x,-2,2], [y,-2,2], field_color=gray,
                        key="soln 1", color=black, soln_at(0,0),
                        key="soln 2", color=red, soln_at(0,1),
                        key="isocline", color=green, line_width=2,
                        nticks=100, parametric(cos(t),sin(t),t,0,2*%pi))$

     `drawdf' acepta listas anidadas de opciones y objetos gráficos,
     permitiendo el uso de `makelist' y otras funciones de forma más
     flexible para generar gráficos.

          (%i14) colors : ['red,'blue,'purple,'orange,'green]$
          (%i15) drawdf([x-x*y/2, (x*y - 3*y)/4],
                        [x,2.5,3.5], [y,1.5,2.5],
                        field_color = gray,
                        makelist([ key   = concat("soln",k),
                                   color = colors[k],
                                   soln_at(3, 2 + k/20) ],
                                 k,1,5))$



File: maxima.info,  Node: dynamics,  Next: ezunits,  Prev: drawdf,  Up: Top

49 dynamics
***********

* Menu:

* Introducción a dynamics::
* Funciones y variables para dynamics::


File: maxima.info,  Node: Introducción a dynamics,  Next: Funciones y variables para dynamics,  Prev: dynamics,  Up: dynamics

49.1 Introducción a dynamics
============================

El paquete adicional `dynamics' incluye varias funciones para crear
diversas representaciones gráficas de sistemas dinámicos y fractales, y
además una implementación del método numérico de Runge-Kutta de cuarto
orden, para resolver sistemas de ecuaciones diferenciales.

   Para usar las funciones en este paquete será necesario primero que
todo cargarlo con `load("dynamics")', y las funciones que crean
gráficas necesitan que Xmaxima esté instalado.


File: maxima.info,  Node: Funciones y variables para dynamics,  Prev: Introducción a dynamics,  Up: dynamics

49.2 Funciones y variables para dynamics
========================================

 -- Función: chaosgame (`[['<x1>, <y1>`]'...`['<xm>, <ym>`]]', `['<x0>,
          <y0>`]', <b>, <n>, ...opciones...);
     Usa el método llamado juego del caos, para producir fractales: se
     dibuja un punto inicial (<x0>, <y0>) y luego se elije
     aleatoriamente uno de los <m> puntos `['<x1>, <y1>`]'...`['<xm>,
     <ym>`]'. Después se dibuja un nuevo punto que estará en el
     segmento entre el último punto dibujado y el punto que se acabó de
     elegir aleatoriamente, a una distancia del punto elegido que será
     <b> veces la longitud del segmento. El proceso se repite <n> veces.


 -- Función: evolution (<F>, <y0>, <n>,...opciones...);
     Dibuja <n+1> puntos en una gráfica bidimensional (serie de
     tiempo), en que las coordenadas horizontales de los puntos son los
     números enteros 0, 1, 2, ..., <n>, y las coordenadas verticales
     son los valores <y(n)> correspondientes, obtenidos a partir de la
     relación de recurrencia
                  y(n+1) = F(y(n))

     Con valor inicial <y(0)> igual a <y0>. <F> deberá ser una
     expresión que dependa únicamente de la variable <y> (y no de <n>),
     <y0> deberá ser un número real y <n> un número entero positivo.


 -- Función: evolution2d (`['<F>, <G>`]', `['<x0>, <y0>`]', <n>,
          ...opciones...);
     Muestra, en una gráfica bidimensional, los primeros <n+1> puntos de
     la sucesión definida a partir del sistema dinámico discreto con
     relaciones de recurrencia:
                  x(n+1) = F(x(n), y(n))    y(n+1) = G(x(n), y(n))

     Con valores iniciales <x0> y <y0>. <F> y <G> deben ser dos
     expresiones que dependan únicamente de <x> y <y>.


 -- Función: ifs (`['<r1>,...,<rm>`]',`['<A1>,...,<Am>`]',
          `[['<x1>,<y1>`]'...`['<xm>, <ym>`]]', `['<x0>,<y0>`]', <n>,
          ...opciones...);
     Usa el método del Sistema de Funciones Iteradas (IFS, en inglés
     Iterated Function System). Ese método es semejante al método
     descrito en la función `chaosgame', pero en vez de aproximar el
     último punto al punto elegido aleatoriamente, las dos coordenadas
     del último punto se multiplican por una matriz 2 por 2 <Ai>
     correspondiente al punto que fue elegido aleatoriamente.

     La selección aleatoria de uno de los <m> puntos atractivos puede
     ser realizada con una función de probabilidad no uniforme, definida
     con los pesos <r1>,...,<rm>. Esos pesos deben ser dados en forma
     acumulada; por ejemplo, si se quieren 3 puntos con probabilidades
     0.2, 0.5 y 0.3, los pesos <r1>, <r2> y <r3> podrían ser 2, 7 y 10,
     o cualquier otro grupo de números que tengan la misma proporción.


 -- Función: julia (<x>, <y>, ...<opciones>...)
     Crea un fichero gráfico con la representación del conjunto de Julia
     del número complejo (<x> + i <y>). Los parámetros <x> y <y> deben
     ser reales. El fichero se crea en el directório actual o en el
     directório del usuario, usando el formato gráfico XPM. El programa
     puede demorar varios segundos a ser ejecutado y cuando termina
     imprime un mensaje con el nombre del fichero creado.

     Se asignan diferentes colores a los puntos que no pertenecen al
     conjunto de Julia, de acuerdo con el número de iteraciones que
     demore la secuencia, comenzando en ese punto, a salir fuera del
     círculo de convergencia con radio 2. El número máximo de
     iteraciones se define con la opción <levels>; después de
     ejecutadas ese número de iteraciones, si la secuencia aun está
     dentro del círculo de convergencia, el punto será coloreado con el
     color definido por la opción <color>.

     Todos los colores usados para los puntos que no pertenecen al
     conjunto de Julia tendrán los mismos valores de saturación
     (<saturation>) y valor (<value>), pero con diferentes ángulos de
     tonalidad, distribuidos uniformemente en el intervalo entre <hue>
     y (<hue> + <huerange>).

     Se puede dar a la función una secuencia de opciones. La lista de
     posibles opciones aparece en una sección más al frente.


 -- Función: mandelbrot (<options>)
     Crea un fichero gráfico con la representación del conjunto de
     Mandelbrot. El fichero se crea en el directório actual o en el
     directório del usuario, usando el formato gráfico XPM. El programa
     puede demorar varios segundos a ser ejecutado y cuando termina
     imprime un mensaje con el nombre del fichero creado.

     Se asignan diferentes colores a los puntos que no pertenecen al
     conjunto de Mandelbrot, de acuerdo con el número de iteraciones
     que demore la secuencia generada por ese punto a salir fuera del
     círculo de convergencia con radio 2. El número máximo de
     iteraciones se define con la opción <levels>; después de
     ejecutadas ese número de iteraciones, si la secuencia aun está
     dentro del círculo de convergencia, el punto será coloreado con el
     color definido por la opción <color>.

     Todos los colores usados para los puntos que no pertenecen al
     conjunto de Mandelbrot tendrán los mismos valores de saturación
     (<saturation>) y valor (<value>), pero con diferentes ángulos de
     tonalidad, distribuidos uniformemente en el intervalo entre <hue>
     y (<hue> + <huerange>).

     Se puede dar a la función una secuencia de opciones. La lista de
     posibles opciones aparece en una sección más al frente.


 -- Función: orbits (<F>, <y0>, <n1>, <n2>, [<x>, <x0>, <xf>, <xstep>],
          ...opciones...);
     Dibuja el diagrama de órbitas de una familia de sistemas dinámicos
     discretos unidimensionales, con un parámetro <x>; ese tipo de
     diagrama se usa para mostrar las bifurcaciones de un sistema
     discreto unidimensional.

     La función <F(y)> define una secuencia que comienza con un valor
     inicial <y0>, igual que en el caso de la función `evolution', pero
     en este caso la función también dependerá del parámetro <x>, el
     cual tomará valores comprendidos en el intervalo de <x0> a <xf>,
     con incrementos <xstep>. Cada valor usado para el parámetro <x> se
     muestra en el eje horizontal. En el eje vertical se mostrarán <n2>
     valores de la sucesión <y(n1+1)>,..., <y(n1+n2+1)>, obtenidos
     después de dejarla evolucionar durante <n1> iteraciones iniciales.


 -- Función: rk (EDO, var, inicial, dominio)
 -- Función: rk ([EDO1,...,EDOm], [v1,...,vm], [inic1,...,inicm],
          dominio)
     La primera forma se usa para resolver numéricamente una ecuación
     diferencial ordinaria de primer orden (EDO), y la segunda forma
     resuelve numéricamente un sistema de <m> de esas ecuaciones,
     usando el método de Runge-Kutta de cuarto orden. <var> representa
     la variable dependiente.  EDO debe ser una expresión que dependa
     únicamente de las variables independiente y dependente, y define
     la derivada de la variable dependiente en función de la variable
     independiente.

     La variable independiente se representa con <dominio>, que debe ser
     una lista con cuatro elementos, como por ejemplo:
          [t, 0, 10, 0.1]
     el primer elemento de la lista identifica la variable
     independiente, el segundo y tercer elementos son los valores
     inicial y final para esa variable, y el último elemento da el
     valor de los incrementos que deberán ser usados dentro de ese
     intervalo.

     Si se van a resolver <m> ecuaciones, deberá haber <m> variables
     dependientes <v1>, <v2>, ..., <vm>. Los valores iniciales para
     esas variables serán <inic1>, <inic2>, ..., <inicm>. Continuará
     existiendo apenas una variable independiente definida por la lista
     <domain>, como en el caso anterior. <EDO1>, ..., <EDOm> son las
     expresiones que definen las derivadas de cada una de las variables
     dependientes en función de la variable independiente. Las únicas
     variables que pueden aparecer en cada una de esas expresiones son
     la variable independiente y cualquiera de las variables
     dependientes. Es importante que las derivadas <EDO1>, ..., <EDOm>
     sean colocadas en la lista en el mismo orden en que fueron
     agrupadas las variables dependientes; por ejemplo, el tercer
     elemento de la lista será interpretado como la derivada de la
     tercera variable dependiente.

     El programa intenta integrar las ecuaciones desde el valor inicial
     de la variable independiente, hasta el valor final, usando
     incrementos fijos. Si en algún paso una de las variables
     dependientes toma un valor absoluto muy grande, la integración
     será suspendida en ese punto.  El resultado será una lista con un
     número de elementos igual al número de iteraciones realizadas.
     Cada elemento en la lista de resultados es también una lista con
     <m>+1 elementos: el valor de la variable independiente, seguido de
     los valores de las variables dependientes correspondientes a ese
     punto.


 -- Función: staircase (<F>, <y0>, <n>, ...opciones...);
     Dibuja un diagrama de escalera (o diagrama de red) para la sucesión
     definida por la ecuación de recurrencia
                  y(n+1) = F(y(n))

     La interpretación y valores permitidos de los parámetros de entrada
     es la misma que para la función `evolution'. Un diagrama de
     escalera consiste en una gráfica de la función <F(y)>, junto con
     la recta <G(y)> `=' <y>. Se comienza por dibujar un segmento
     vertical desde el punto (<y0>, <y0>) en la recta, hasta el punto
     de intersección con la función <F>. En seguida, desde ese punto se
     dibuja un segmento horizontal hasta el punto de intersección con
     la recta, (<y1>, <y1>); el procedimiento se repite <n> veces hasta
     alcanzar el punto (<yn>, <yn>).


   Opciones

   Cada opción es una lista con dos o más elementos. El primer elemento
en la lista es el nombre de la opción y el resto consiste en los
argumentos para esa opción.

   Las opciones aceptadas por las funciones evolution, evolution2,
staircase, orbits, ifs y chaosgame son las siguientes:

   * "domain" especifica los valores mínimo y máximo de la variable
     independiente para la gráfica de la función <F> representada por
     `staircase'.

   * "pointsize" define el radio de cada punto dibujado, en unidades de
     puntos.  El valor por omisión es 1.

   * "xaxislabel" es la etiqueta que se escribirá en el eje horizontal.

   * "xcenter" es la coordenada x del punto que deberá aparecer en el
     centro de la gráfica. Esta opción no es usada por la función
     `orbits'.

   * "xradius" es mitad de la longitud del intervalo de valores de x que
     será representado. Esta opción no es usada por la función `orbits'.

   * "yaxislabel" es la etiqueta que se escribirá en el eje vertical.

   * "ycenter" es la coordenada y del punto que deberá aparecer en el
     centro de la gráfica.

   * "yradius" es mitad de la longitud del intervalo de valores de y que
     será representado.


   Las opciones aceptadas por los programas julia y mandelbrot son las
siguientes:

   * "size" acepta uno o dos argumentos. Si se da solo un argumento, el
     ancho y la altura del fichero gráfico creado serán iguales a ese
     valor en pixels. Si se dan dos argumentos, esos dos valores serán
     usados para el ancho y la altura. El valor por omisión es 400
     pixels tanto para el ancho como para la altura. Si los dos valores
     no son iguales, el conjunto aparecerá distorcionado.

   * "levels" define el número máximo de iteraciones, que es también el
     número de colores usado para los puntos que no pertenecem al
     conjunto. El valor por omisión es 12; valores mayores implican
     tiempos de procesamiento más elevados.

   * "huerange" define el intervalo de ángulos usados para la tonalidad
     de los puntos que no pertenecen al conjunto. El valor por omisión
     es 360, que hace que los colores usados abarcarán todo el rango de
     tonalidades. Valores mayores que 360 implican repetición de algunos
     valores de la tonalidad, y pueden usarse valores negativos para
     que el ángulo de tonalidad sea menor a medida que el número de
     iteraciones aumente.

   * "hue" define la tonalidad, en grados, del primer color usado para
     representar los puntos que no pertenecen al conjunto.  Su valor por
     omisión es 300 grados, que corresponde al color magenta; el color
     correspondiente para otros valores estandar es rojo 0, naranja 45,
     amarillo 60, verde 120, cian 180 y azul 240. Consulte también la
     opción <huerange>.

   * "saturation" define el nivel de saturación que será usado para los
     colores de los puntos que no pertenecen al conjunto. Debe ser un
     valor entre 0 y 1. El valor por omisión es 0.46.

   * "value" define el valor de los colores usados para puntos que no
     pertenezcan al conjunto. Debe estar comprendido entre 0 y 1; cuanto
     mayor sea, mas brilhantes serán los colores. Su valor por omisión
     es 0.96.

   * "color" debe ir seguido de tres parámetros que definen la
     tonalidad, saturación y valor del color que será usado para los
     puntos del conjunto. El valor por omisión es 0 para los tres
     parámetros, que corresponde al negro. Consulte las explicación
     sobre el rango de valores aceptados en la explicación de las
     opciones <hue>, <saturation> y <value>.

   * "center" deberá tener dos parámetros reales que dan las
     coordenadas, en el plano complejo, del punto en el centro de la
     región representada. El valor por omisión es 0 para las dos
     coordenadas (el origen).

   * "radius" es el radio de el mayor círculo que cabe dentro de la
     región quadrada que será representada. El valor por omisión es 2.

   * "filename" da el nombre del fichero donde se guardará la gráfica
     producida. A ese nombre se le acrecentará la terminación .xpm. Si
     el fichero ya existe, será substituido por el fichero producido
     por la función. El valor por omisión es julia para el conjunto de
     Julia y mandelbrot para el conjunto de Mandelbrot.


   Ejemplos

   Representación gráfica y diagrama de escalera de la secuencia: 2,
cos(2), cos(cos(2)),...

     (%i1) load("dynamics")$
     (%i2) evolution(cos(y), 2, 11, [yaxislabel, "y"], [xaxislabel,"n"]);
     (%i3) staircase(cos(y), 1, 11, [domain, 0, 1.2]);

   Si su procesador es lento, tendrá que reducir el número de
iteraciones usado en los ejemplos siguientes. Y el valor de <pointsize>
que da mejores resultados depende del monitor y de la resolución que
use. Tendrá que experimentar con diferentes valores.

   Diagrama de órbitas para el mapa cuadrático
             y(n+1) = x + y(n)^2

     (%i4) orbits(y^2+x, 0, 50, 200, [x, -2, 0.25, 0.01], [pointsize, 0.9]);

   Para ampliar la región alrededor de la bifurcación en la parte de
abajo, cerca de x `=' -1.25, use el comando:
     (%i5) orbits(x+y^2, 0, 100, 400, [x,-1,-1.53,-0.001], [pointsize,0.9],
                  [ycenter,-1.2], [yradius,0.4]);

   Evolución de un sistema en dos dimensiones, que conduce a un fractal:

     (%i6) f: 0.6*x*(1+2*x)+0.8*y*(x-1)-y^2-0.9$
     (%i7) g: 0.1*x*(1-6*x+4*y)+0.1*y*(1+9*y)-0.4$
     (%i8) evolution2d([f,g],[-0.5,0],50000,[pointsize,0.7]);

   Y una ampliación de una pequeña región en el fractal:

     (%i9) evolution2d([f,g],[-0.5,0],300000,[pointsize,0.7], [xcenter,-0.7],
                       [ycenter,-0.3],[xradius,0.1],[yradius,0.1]);

   Una gráfica del triangulo de Sierpinsky, obtenida con el juego del
caos:

     (%i9) chaosgame([[0, 0], [1, 0], [0.5, sqrt(3)/2]], [0.1, 0.1], 1/2,
                      30000, [pointsize,0.7]);

   El helecho de Barnsley, obtenido con el Sistema de Funciones
Iteradas:

     (%i10) a1: matrix([0.85,0.04],[-0.04,0.85])$
     (%i11) a2: matrix([0.2,-0.26],[0.23,0.22])$
     (%i12) a3: matrix([-0.15,0.28],[0.26,0.24])$
     (%i13) a4: matrix([0,0],[0,0.16])$
     (%i14) p1: [0,1.6]$
     (%i15) p2: [0,1.6]$
     (%i16) p3: [0,0.44]$
     (%i17) p4: [0,0]$
     (%i18) w: [85,92,99,100]$
     (%i19) ifs(w,[a1,a2,a3,a4],[p1,p2,p3,p4],[5,0],50000,[pointsize,0.9]);

   Para crear un fichero llamado _dinamica9.xpm_ con la representación
gráfica del conjunto de Mandelbrot, con 12 colores, use el comando:

     mandelbrot([filename,"dinamica9"])$

   y el conjunto de Julia del número (-0.55 + i 0.6) puede ser obtenido
con:
     julia(-0.55, 0.6, [levels, 36], [center, 0, 0.6], [radius, 0.3],
           [hue, 240], [huerange, -180], [filename, "dinamica10"])$

   la gráfica se guardará en el fichero _dinamica10.xpm_ y mostrará la
región desde -0.3 hasta 0.3 en la dirección x, y desde 0.3 hasta 0.9 en
la dirección y. Serán usados 36 colores, comenzando con azul e
terminando con amarillo.

   Para resolver numéricamente la ecuación diferencial

               dx/dt = t - x^2

   Con valor inicial x(t=0) = 1, en el intervalo de t desde 0 hasta 8, y
con incrementos de 0.1, se usa:

     (%i20) resultados: rk(t-x^2,x,1,[t,0,8,0.1])$

   los resultados quedarán guardados en la lista resultados.

   Para resolver numéricamente el sistema:

             dx/dt = 4-x^2-4*y^2     dy/dt = y^2-x^2+1

   para t entre 0 y 4, con valores iniciales -1.25 y 0.75 para (x, y)
en t=0:

     (%i21) sol: rk([4-x^2-4*y^2,y^2-x^2+1],[x,y],[-1.25,0.75],[t,0,4,0.02])$


File: maxima.info,  Node: ezunits,  Next: f90,  Prev: dynamics,  Up: Top

50 ezunits
**********

* Menu:

* Introducción a ezunits::
* Introducción a physical_constants::
* Funciones y variables para ezunits::


File: maxima.info,  Node: Introducción a ezunits,  Next: Introducción a physical_constants,  Prev: ezunits,  Up: ezunits

50.1 Introducción a ezunits
===========================

`ezunits' es un paquete para trabajar con magnitudes dimensionales,
incluyendo algunas funciones para realizar análisis dimensional.
`ezunits' puede hacer operaciones aritméticas con magnitudes
dimensionales y efectuar conversiones entre unidades.  Las unidades que
se definen son las del Sistema Internacional (SI) y otras comunes en
los Estados Unidos, siendo posible declarar otras nuevas.

   Véase también `physical_constants', una colección de constantes
físicas.

   Es necesario ejecutar primero `load(ezunits)' para utilizar este
paquete.  Con `demo(ezunits)' se podrán ver algunos ejemplos de
utilización.  La función `known_units' devuelve una lista con todas las
unidades que están definidas y `display_known_unit_conversions' muestra
las conversiones conocidas por el sistema en un formato de lectura
sencilla.

   Una expresión tal como a ` b representa una magnitud dimensional,
siendo `a' una magnitud adimensional y `b' las unidades.  Se puede
utilizar un símbolo como unidad, sin necesidad de declararlo como tal
ni de que deba cumplir propiedades especiales.  Tanto la magnitud como
la unidad de una expresión de la forma a ` b pueden extraerse invocando
las funciones `qty' y `units', respectivamente.

   Una expresión tal como `a ` b `` c' convierte las unidades `b' en
`c'. El paquete `ezunits' contiene funciones conversoras para unidades
fundamentales del SI, unidades derivadas, así como algunas otras
unidades ajenas al SI.  Las conversiones entre unidades que no estén
programadas en `ezunits' podrán declararse a posteriori.  Las
conversiones conocidas por `ezunits' están especificadas en la variable
global `known_unit_conversions', incluyendo tanto las ya declaradas por
defecto como aquéllas introducidas por el usuario.  Las conversiones
para los productos, cocientes y potencias de unidades se derivan del
conjunto de conversiones ya conocidas.

   En general, Maxima prefiere números exactos (enteros o racionales) a
inexactos (decimales en coma flotante), por lo que `ezunits' respetará
los exactos cuando aparezcan en expresiones de magnitudes
dimensionales. Todas las conversiones del paquete se han definido en
términos de números exactos.

   No hay un sistema de representación de unidades que se considere
preferible, razón por la cual las unidades no se convierten a otras a
menos que se indique de forma explícita. `ezunits' reconoce los prefijos
m-, k-, M y G- para mili-, kilo-, mega- y giga-, respectivamente, tal
como se utilizan en el SI; estos prefijos sólo se utilizan cuando así
se indica de forma explícita.

   Las operaciones aritméticas con magnitudes dimensionales se realizan
de la forma convencional.

   * `(x ` a) * (y ` b)' es igual a (x * y) ` (a * b).

   * `(x ` a) + (y ` a)' es igual a (x + y) ` a.

   * `(x ` a)^y' es igual a x^y ` a^y si `y' es adimensional.

   `ezunits' no necesita que las unidades en una suma tengan las mismas
dimensiones; estos términos serán sumados sin emitirse mensaje de error.

   `ezunits' incluye funciones para el análisis dimensional elemental,
como las dimensiones fundamentales, las unidades fundamentales de una
magnitud dimensional o el cálculo de magnitudes adimensionales y
unidades naturales. Las funciones de análisis dimensional son
adaptaciones de funciones semejantes escritas por Barton Willis en otro
paquete.

   Con el fin de poder llevar a cabo análisis dimensionales, se
mantiene una lista de dimensiones fundamentales y otra lista asociada
de unidades fundamentales; por defecto, las dimensiones fundamentales
son longitud, masa, tiempo, carga, temperatura y cantidad de materia,
siendo las unidades fundamentales las propias del Sistema Internacional.
En cualquier caso, es posible declarar otras dimensiones y unidades
fundamentales.


File: maxima.info,  Node: Introducción a physical_constants,  Next: Funciones y variables para ezunits,  Prev: Introducción a ezunits,  Up: ezunits

50.2 Introducción a physical_constants
======================================

`physical_constants' contiene constantes físicas recomendadas por el
CODATA 2006 (`http://physics.nist.gov/constants').  La instrucción
`load(physical_constants)' carga este paquete en memoria junto con el
propio `ezunits', si éste no estaba previamente cargado.

   Una constante física se representa por un símbolo con la propiedad
de ser un valor constante. El valor constante es una magnitud
dimensional en la sintaxis de `ezunits'. La función `constvalue' extrae
el valor constante, el cual no es el valor ordinario del símbolo, por
lo que las constantes físicas se mantienen inalteradas en las
expresiones evaluadas hasta que sus valores sea extraído con la función
`constvalue'.

   `physical_constants' incluye cierta información adicional, como la
descripción de cada constante, una estimación del error de su valor
numérico y una propiedad para ser representada en TeX.  Para
identificar constantes físicas, cada símbolo tiene la propiedad
`physical_constant', de forma que `propvars(physical_constant)' muestra
la lista de todas las constantes físicas.

   `physical_constants' contiene las siguientes constantes:

`%c'
     velocidad de la luz en el vacío

`%mu_0'
     constante magnética

`%e_0'
     constante eléctrica

`%Z_0'
     impedancia característica del vacío

`%G'
     constante gravitatoria de Newton

`%h'
     constante de Planck

`%h_bar'
     constante de Planck

`%m_P'
     masa de Planck

`%T_P'
     temperature de Planck

`%l_P'
     longitud de Planck

`%t_P'
     tiempo de Planck

`%%e'
     carga elemental

`%Phi_0'
     flujo magnético cuántico

`%G_0'
     conductancia cuántica

`%K_J'
     constante de Josephson

`%R_K'
     constante de von Klitzing

`%mu_B'
     magnetón de Bohr

`%mu_N'
     magnetón nuclear

`%alpha'
     constante de estructura fina

`%R_inf'
     constante de Rydberg

`%a_0'
     radio de Bohr

`%E_h'
     energía de Hartree

`%ratio_h_me'
     cuanto de circulación

`%m_e'
     masa del electrón

`%N_A'
     número de Avogadro

`%m_u'
     constante de masa atómica atomic mass constant

`%F'
     constante de Faraday

`%R'
     constante molar de los gases

`%%k'
     constante de Boltzmann

`%V_m'
     volumen molar del gas ideal

`%n_0'
     constante de Loschmidt

`%ratio_S0_R'
     constante de Sackur-Tetrode (constante de entropía absoluta)

`%sigma'
     constante de Stefan-Boltzmann

`%c_1'
     primera constante de radiación

`%c_1L'
     primera constante de radiación para radiancia espectral

`%c_2'
     segunda constante de radiación

`%b'
     Constante de la ley del desplazamiento de Wien

`%b_prime'
     Constante de la ley del desplazamiento de Wien

   Ejemplos:

   Lista de todos los símbolos que tienen la propiedad
`physical_constant'.

     (%i1) load (physical_constants)$
     (%i2) propvars (physical_constant);
     (%o2) [%c, %mu_0, %e_0, %Z_0, %G, %h, %h_bar, %m_P, %T_P, %l_P,
     %t_P, %%e, %Phi_0, %G_0, %K_J, %R_K, %mu_B, %mu_N, %alpha,
     %R_inf, %a_0, %E_h, %ratio_h_me, %m_e, %N_A, %m_u, %F, %R, %%k,
     %V_m, %n_0, %ratio_S0_R, %sigma, %c_1, %c_1L, %c_2, %b, %b_prime]

   Propiedades de la constante física `%c'.

     (%i1) load (physical_constants)$
     (%i2) constantp (%c);
     (%o2)                         true
     (%i3) get (%c, description);
     (%o3)               speed of light in vacuum
     (%i4) constvalue (%c);
                                           m
     (%o4)                     299792458 ` -
                                           s
     (%i5) get (%c, RSU);
     (%o5)                           0
     (%i6) tex (%c);
     $$c$$
     (%o6)                         false

   Energía equivalente de una libra-masa. El símbolo `%c' se mantiene
hasta que su valor es extraído con la llamada a la función `constvalue'.

     (%i1) load (physical_constants)$
     (%i2) m * %c^2;
                                     2
     (%o2)                         %c  m
     (%i3) %, m = 1 ` lbm;
                                   2
     (%o3)                       %c  ` lbm
     (%i4) constvalue (%);
                                                 2
                                            lbm m
     (%o4)              89875517873681764 ` ------
                                               2
                                              s
     (%i5) E : % `` J;
     Computing conversions to base units; may take a moment.
                          366838848464007200
     (%o5)                ------------------ ` J
                                  9
     (%i6) E `` GJ;
                           458548560580009
     (%o6)                 --------------- ` GJ
                              11250000
     (%i7) float (%);
     (%o7)              4.0759872051556356e+7 ` GJ


File: maxima.info,  Node: Funciones y variables para ezunits,  Prev: Introducción a physical_constants,  Up: ezunits

50.3 Funciones y variables para ezunits
=======================================

 -- Operador: `
     Operador de magnitud dimensional.  Una expresión tal como a ` b
     representa una magnitud dimensional, siendo `a' una magnitud
     adimensional y `b' las unidades.  Se puede utilizar un símbolo
     como unidad, sin necesidad de declararlo como tal ni de que deba
     cumplir propiedades especiales.  Tanto la magnitud como la unidad
     de una expresión de la forma a ` b pueden extraerse invocando las
     funciones `qty' y `units', respectivamente.

     Las operaciones aritméticas con magnitudes dimensionales se
     realizan de la forma convencional.

        * `(x ` a) * (y ` b)' es igual a (x * y) ` (a * b).

        * `(x ` a) + (y ` a)' es igual a (x + y) ` a.

        * `(x ` a)^y' es igual a x^y ` a^y si `y' es adimensional.

     `ezunits' no necesita que las unidades en una suma tengan las
     mismas dimensiones; estos términos serán sumados sin emitirse
     mensaje de error.

     Para utilizar este operador ejecútese primero `load(ezunits)'.

     Ejemplos:

     Unidades del Sistema Internacional.

          (%i1) load (ezunits)$
          (%i2) foo : 10 ` m;
          (%o2)                        10 ` m
          (%i3) qty (foo);
          (%o3)                          10
          (%i4) units (foo);
          (%o4)                           m
          (%i5) dimensions (foo);
          (%o5)                        length

     Unidades definidas por el usuario.

          (%i1) load (ezunits)$
          (%i2) bar : x ` acre;
          (%o2)                       x ` acre
          (%i3) dimensions (bar);
                                             2
          (%o3)                        length
          (%i4) fundamental_units (bar);
                                          2
          (%o4)                          m

     Unidades ad hoc.

          (%i1) load (ezunits)$
          (%i2) baz : 3 ` sheep + 8 ` goat + 1 ` horse;
          (%o2)           8 ` goat + 3 ` sheep + 1 ` horse
          (%i3) subst ([sheep = 3*goat, horse = 10*goat], baz);
          (%o3)                       27 ` goat
          (%i4) baz2 : 1000`gallon/fortnight;
                                          gallon
          (%o4)                   1000 ` ---------
                                         fortnight
          (%i5) subst (fortnight = 14*day, baz2);
                                    500   gallon
          (%o5)                     --- ` ------
                                     7     day

     Operaciones aritméticas y magnitudes dimensionales.

          (%i1) load (ezunits)$
          (%i2) 100 ` kg + 200 ` kg;
          (%o2)                       300 ` kg
          (%i3) 100 ` m^3 - 100 ` m^3;
                                            3
          (%o3)                        0 ` m
          (%i4) (10 ` kg) * (17 ` m/s^2);
                                           kg m
          (%o4)                      170 ` ----
                                             2
                                            s
          (%i5) (x ` m) / (y ` s);
                                        x   m
          (%o5)                         - ` -
                                        y   s
          (%i6) (a ` m)^2;
                                        2    2
          (%o6)                        a  ` m


 -- Operador: ``
     Operador de conversión de unidades.  Una expresión tal como a ` b
     `` c convierte las unidades `b' en `c'. El paquete `ezunits'
     contiene funciones conversoras para unidades fundamentales del SI,
     unidades derivadas, así como algunas otras unidades ajenas al SI.
     Las conversiones entre unidades que no estén programadas en
     `ezunits' podrán declararse a posteriori.  Las conversiones
     conocidas por `ezunits' están especificadas en la variable global
     `known_unit_conversions', incluyendo tanto las ya declaradas por
     defecto como aquéllas introducidas por el usuario.  Las
     conversiones para los productos, cocientes y potencias de unidades
     se derivan del conjunto de conversiones ya conocidas.

     No hay un sistema de representación de unidades que se considere
     preferible, razón por la cual las unidades no se convierten a
     otras a menos que se indique de forma explícita. Del mismo modo,
     `ezunits' no transforma prefijos (milli-, centi-, deci-, etc) a
     menos que se le indique.

     Para utilizar este operador ejecútese primero `load(ezunits)'.

     Ejemplos:

     Conjunto de conversiones conocidas.

          (%i1) load (ezunits)$
          (%i2) display2d : false$
          (%i3) known_unit_conversions;
          (%o3) {acre = 4840*yard^2,Btu = 1055*J,cfm = feet^3/minute,
                 cm = m/100,day = 86400*s,feet = 381*m/1250,ft = feet,
                 g = kg/1000,gallon = 757*l/200,GHz = 1000000000*Hz,
                 GOhm = 1000000000*Ohm,GPa = 1000000000*Pa,
                 GWb = 1000000000*Wb,Gg = 1000000*kg,Gm = 1000000000*m,
                 Gmol = 1000000*mol,Gs = 1000000000*s,ha = hectare,
                 hectare = 100*m^2,hour = 3600*s,Hz = 1/s,inch = feet/12,
                 km = 1000*m,kmol = 1000*mol,ks = 1000*s,l = liter,
                 lbf = pound_force,lbm = pound_mass,liter = m^3/1000,
                 metric_ton = Mg,mg = kg/1000000,MHz = 1000000*Hz,
                 microgram = kg/1000000000,micrometer = m/1000000,
                 micron = micrometer,microsecond = s/1000000,
                 mile = 5280*feet,minute = 60*s,mm = m/1000,
                 mmol = mol/1000,month = 2629800*s,MOhm = 1000000*Ohm,
                 MPa = 1000000*Pa,ms = s/1000,MWb = 1000000*Wb,
                 Mg = 1000*kg,Mm = 1000000*m,Mmol = 1000000000*mol,
                 Ms = 1000000*s,ns = s/1000000000,ounce = pound_mass/16,
                 oz = ounce,Ohm = s*J/C^2,
                 pound_force = 32*ft*pound_mass/s^2,
                 pound_mass = 200*kg/441,psi = pound_force/inch^2,
                 Pa = N/m^2,week = 604800*s,Wb = J/A,yard = 3*feet,
                 year = 31557600*s,C = s*A,F = C^2/J,GA = 1000000000*A,
                 GC = 1000000000*C,GF = 1000000000*F,GH = 1000000000*H,
                 GJ = 1000000000*J,GK = 1000000000*K,GN = 1000000000*N,
                 GS = 1000000000*S,GT = 1000000000*T,GV = 1000000000*V,
                 GW = 1000000000*W,H = J/A^2,J = m*N,kA = 1000*A,
                 kC = 1000*C,kF = 1000*F,kH = 1000*H,kHz = 1000*Hz,
                 kJ = 1000*J,kK = 1000*K,kN = 1000*N,kOhm = 1000*Ohm,
                 kPa = 1000*Pa,kS = 1000*S,kT = 1000*T,kV = 1000*V,
                 kW = 1000*W,kWb = 1000*Wb,mA = A/1000,mC = C/1000,
                 mF = F/1000,mH = H/1000,mHz = Hz/1000,mJ = J/1000,
                 mK = K/1000,mN = N/1000,mOhm = Ohm/1000,mPa = Pa/1000,
                 mS = S/1000,mT = T/1000,mV = V/1000,mW = W/1000,
                 mWb = Wb/1000,MA = 1000000*A,MC = 1000000*C,
                 MF = 1000000*F,MH = 1000000*H,MJ = 1000000*J,
                 MK = 1000000*K,MN = 1000000*N,MS = 1000000*S,
                 MT = 1000000*T,MV = 1000000*V,MW = 1000000*W,
                 N = kg*m/s^2,R = 5*K/9,S = 1/Ohm,T = J/(m^2*A),V = J/C,
                 W = J/s}

     Converiones de unidades fundamentales.

          (%i1) load (ezunits)$
          (%i2) 1 ` ft `` m;
          Computing conversions to base units; may take a moment.
                                      381
          (%o2)                       ---- ` m
                                      1250
          (%i3) %, numer;
          (%o3)                      0.3048 ` m
          (%i4) 1 ` kg `` lbm;
                                      441
          (%o4)                       --- ` lbm
                                      200
          (%i5) %, numer;
          (%o5)                      2.205 ` lbm
          (%i6) 1 ` W `` Btu/hour;
                                     720   Btu
          (%o6)                      --- ` ----
                                     211   hour
          (%i7) %, numer;
                                                  Btu
          (%o7)               3.412322274881517 ` ----
                                                  hour
          (%i8) 100 ` degC `` degF;
          (%o8)                      212 ` degF
          (%i9) -40 ` degF `` degC;
          (%o9)                     (- 40) ` degC
          (%i10) 1 ` acre*ft `` m^3;
                                  60228605349    3
          (%o10)                  ----------- ` m
                                   48828125
          (%i11) %, numer;
                                                    3
          (%o11)                1233.48183754752 ` m

     Transformando pies a metros y viceversa.

          (%i1) load (ezunits)$
          (%i2) 100 ` m + 100 ` ft;
          (%o2)                  100 ` m + 100 ` ft
          (%i3) (100 ` m + 100 ` ft) `` ft;
                                     163100
          (%o3)                      ------ ` ft
                                      381
          (%i4) %, numer;
          (%o4)                428.0839895013123 ` ft
          (%i5) (100 ` m + 100 ` ft) `` m;
                                      3262
          (%o5)                       ---- ` m
                                       25
          (%i6) %, numer;
          (%o6)                      130.48 ` m

     Análisis dimensional para encontrar dimensiones y unidades
     fundamentales.

          (%i1) load (ezunits)$
          (%i2) foo : 1 ` acre * ft;
          (%o2)                      1 ` acre ft
          (%i3) dimensions (foo);
                                             3
          (%o3)                        length
          (%i4) fundamental_units (foo);
                                          3
          (%o4)                          m
          (%i5) foo `` m^3;
                                  60228605349    3
          (%o5)                   ----------- ` m
                                   48828125
          (%i6) %, numer;
                                                    3
          (%o6)                 1233.48183754752 ` m

     Declaración de conversiones.

          (%i1) load (ezunits)$
          (%i2) declare_unit_conversion (MMBtu = 10^6*Btu, kW = 1000*W);
          (%o2)                         done
          (%i3) declare_unit_conversion (kWh = kW*hour, MWh = 1000*kWh,
                                         bell = 1800*s);
          (%o3)                         done
          (%i4) 1 ` kW*s `` MWh;
          Computing conversions to base units; may take a moment.
                                       1
          (%o4)                     ------- ` MWh
                                    3600000
          (%i5) 1 ` kW/m^2 `` MMBtu/bell/ft^2;
                                 1306449      MMBtu
          (%o5)                 ---------- ` --------
                                8242187500          2
                                             bell ft

 -- Función: constvalue (<x>)
 -- Función: declare_constvalue (<a>, <x>)
 -- Función: remove_constvalue (<a>)
     Devuelve la constante declarada para un símbolo.  Los valores
     constantes se declaran con `declare_constvalue'.

     Los valores constantes reconocidos por `constvalue' son distintos
     de los valores declarados por `numerval' y reconocidos por
     `constantp'.

     El paquete `physical_units' declara los valores constantes de las
     constantes físicas.

     `remove_constvalue' deshace la acción de `declare_constvalue'.

     Para utilizar estas funciones ejecútese primero `load(ezunits)'.

     Ejemplos:

     Valor de una constante física.

          (%i1) load (physical_constants)$
          (%i2) constvalue (%G);
                                               3
                                              m
          (%o2)                    6.67428 ` -----
                                                 2
                                             kg s
          (%i3) get ('%G, 'description);
          (%o3)           Newtonian constant of gravitation

     Declarando una nueva constante.

          (%i1) load (ezunits)$
          (%i2) declare_constvalue (FOO, 100 ` lbm / acre);
                                           lbm
          (%o2)                      100 ` ----
                                           acre
          (%i3) FOO * (50 ` acre);
          (%o3)                     50 FOO ` acre
          (%i4) constvalue (%);
          (%o4)                      5000 ` lbm


 -- Función: units (<x>)
 -- Función: declare_units (<a>, <u>)
     Devuelve las unidades de la magnitud dimensional <x>, o 1 en caso
     de que <x> sea adimensional.

     <x> puede ser una expresión literal dimensional a ` b, un símbolo
     con unidades declaradas por medio de `declare_units', o una
     expresión que contenga cualquiera o ambos de los anteriores.

     `declare_constvalue' declara que `units(<a>)' debe devolver <u>,
     siendo <u> una expresión.

     Para utilizar estas funciones ejecútese primero `load(ezunits)'.

     Ejemplos:

     `units' aplicado a expresiones dimensionales literales.

          (%i1) load (ezunits)$
          (%i2) foo : 100 ` kg;
          (%o2)                              100 ` kg
          (%i3) bar : x ` m/s;
                                                   m
          (%o3)                                x ` -
                                                   s
          (%i4) units (foo);
          (%o4)                                 kg
          (%i5) units (bar);
                                                 m
          (%o5)                                  -
                                                 s
          (%i6) units (foo * bar);
                                               kg m
          (%o6)                                ----
                                                s
          (%i7) units (foo / bar);
                                               kg s
          (%o7)                                ----
                                                m
          (%i8) units (foo^2);
                                                  2
          (%o8)                                 kg

     `units' aplicado a símbolos con unidades declaradas.

          (%i1) load (ezunits)$
          (%i2) linenum:0;
          (%o0)                                  0
          (%i1) units (aa);
          (%o1)                                  1
          (%i2) declare_units (aa, J);
          (%o2)                                  J
          (%i3) units (aa);
          (%o3)                                  J
          (%i4) units (aa^2);
                                                 2
          (%o4)                                 J
          (%i5) foo : 100 ` kg;
          (%o5)                              100 ` kg
          (%i6) units (aa * foo);
          (%o6)                                kg J


 -- Función: qty (<x>)
 -- Función: declare_qty (<a>, <x>)
     `qty' devuelve la parte adimensional de la magnitud dimensional
     <x>, o <x>, si <x> es adimensional.  <x> puede ser una expresión
     literal dimensional a ` b, un símbolo con unidades declaradas o
     una expresión que contenga cualquiera o ambos de los anteriores.

     `declare_qty' declara que `qty(<a>)' debe devolver <x>, siendo <x>
     una magnitud dimensional.

     Para utilizar estas funciones ejecútese primero `load(ezunits)'.

     Ejemplos:

     `qty' aplicado a expresiones dimensionales literales.

          (%i1) load (ezunits)$
          (%i2) foo : 100 ` kg;
          (%o2)                       100 ` kg
          (%i3) qty (foo);
          (%o3)                          100
          (%i4) bar : v ` m/s;
                                            m
          (%o4)                         v ` -
                                            s
          (%i5) foo * bar;
                                            kg m
          (%o5)                     100 v ` ----
                                             s
          (%i6) qty (foo * bar);
          (%o6)                         100 v

     `qty' aplicado a símbolos con unidades declaradas.

          (%i1) load (ezunits)$
          (%i2) declare_qty (aa, xx);
          (%o2)                          xx
          (%i3) qty (aa);
          (%o3)                          xx
          (%i4) qty (aa^2);
                                           2
          (%o4)                          xx
          (%i5) foo : 100 ` kg;
          (%o5)                       100 ` kg
          (%i6) qty (aa * foo);
          (%o6)                        100 xx


 -- Función: unitp (<x>)
     Devuelve `true' si <x> es una expresión dimensional literal, un
     símbolo declarado como dimensional o una expresión en la que su
     operador principal ha sido declarado como dimensional. En
     cualquier otro caso, `unitp' devuelve `false'.

     Para utilizar esta función ejecútese primero `load(ezunits)'.

     Ejemplos:

     `unitp' aplicado a expresiones dimensionales literales.

          (%i1) load (ezunits)$
          (%i2) unitp (100 ` kg);
          (%o2)                         true

     `unitp' applied to a symbol declared dimensional.

          (%i1) load (ezunits)$
          (%i2) unitp (foo);
          (%o2)                         false
          (%i3) declare (foo, dimensional);
          (%o3)                         done
          (%i4) unitp (foo);
          (%o4)                         true

     `unitp' aplicado a una expresión en la que el operador principal
     se declara dimensional.

          (%i1) load (ezunits)$
          (%i2) unitp (bar (x, y, z));
          (%o2)                         false
          (%i3) declare (bar, dimensional);
          (%o3)                         done
          (%i4) unitp (bar (x, y, z));
          (%o4)                         true


 -- Función: declare_unit_conversion (<u> = <v>, ...)
     Añade las ecuaciones <u> = <v>, ... a la lista de conversiones de
     unidades conocidas por el operador de conversión ``.  <u> y <v>
     son términos multiplicativos en las que las variables son unidades
     o expresiones dimensionales literales.

     De momento, es imperativo expresar las conversiones de forma que
     el miembro izquierdo de cada ecuación sea una unidad simple (en
     opsición a una expresión multiplicativa) o una expresión
     dimensional literal con la cantidad igual a 1 y con unidad simple.
     Está previsto eliminar esta restricción en versiones futuras.

     `known_unit_conversions' es la lista de conversiones de unidades
     conocidas.

     Para utilizar esta función ejecútese primero `load(ezunits)'.

     Ejemplos:

     Conversión de unidades expresadas por ecuaciones con términos
     multiplicativos.

          (%i1) load (ezunits)$
          (%i2) declare_unit_conversion (nautical_mile = 1852 * m,
                                         fortnight = 14 * day);
          (%o2)                         done
          (%i3) 100 ` nautical_mile / fortnight `` m/s;
          Computing conversions to base units; may take a moment.
                                      463    m
          (%o3)                       ---- ` -
                                      3024   s

     Conversión de unidades expresadas por ecuaciones con expresiones
     dimensionales literales.

          (%i1) load (ezunits)$
          (%i2) declare_unit_conversion (1 ` fluid_ounce = 2 ` tablespoon);
          (%o2)                         done
          (%i3) declare_unit_conversion (1 ` tablespoon = 3 ` teaspoon);
          (%o3)                         done
          (%i4) 15 ` fluid_ounce `` teaspoon;
          Computing conversions to base units; may take a moment.
          (%o4)                     90 ` teaspoon


 -- Función: declare_dimensions (<a_1>, <d_1>, ..., <a_n>, <d_n>)
 -- Función: remove_dimensions (<a_1>, ..., <a_n>)
     `declare_dimensions' declara <a_1>, ..., <a_n> con las dimensiones
     <d_1>, ..., <d_n>, respectivamente.

     Cada <a_k> es un símbolo o lista de símbolos.  En caso de ser una
     lista, cada símbolo en <a_k> se declara de dimensión <d_k>.

     `remove_dimensions' invierte el efecto de `declare_dimensions'.

     Ejecútese `load(ezunits)' para hacer uso de estas funciones.

     Ejemplos:

          (%i1) load (ezunits) $
          (%i2) declare_dimensions ([x, y, z], length, [t, u], time);
          (%o2)                         done
          (%i3) dimensions (y^2/u);
                                             2
                                       length
          (%o3)                        -------
                                        time
          (%i4) fundamental_units (y^2/u);
          0 errors, 0 warnings
                                          2
                                         m
          (%o4)                          --
                                         s


 -- Función: declare_fundamental_dimensions (<d_1>, <d_2>, <d_3>, ...)
 -- Función: remove_fundamental_dimensions (<d_1>, <d_2>, <d_3>, ...)
 -- Variable global: fundamental_dimensions
     `declare_fundamental_dimensions' declara dimensiones fundamentales.
     Los símbolos <d_1>, <d_2>, <d_3>, ... se añaden a la lista de
     dimensiones fundamentales si no están ya presentes en la lista.

     `remove_fundamental_dimensions' invierte el efecto de
     `declare_fundamental_dimensions'.

     `fundamental_dimensions' es la lista de dimensiones fundamentales.
     Por defecto, la lista comprende algunas dimensiones físicas.

     Ejecútese `load(ezunits)' para hacer uso de estas funciones.

     Ejemplos:

          (%i1) load (ezunits) $
          (%i2) fundamental_dimensions;
          (%o2) [length, mass, time, current, temperature, quantity]
          (%i3) declare_fundamental_dimensions (money, cattle, happiness);
          (%o3)                         done
          (%i4) fundamental_dimensions;
          (%o4) [length, mass, time, current, temperature, quantity,
                                                  money, cattle, happiness]
          (%i5) remove_fundamental_dimensions (cattle, happiness);
          (%o5)                         done
          (%i6) fundamental_dimensions;
          (%o6) [length, mass, time, current, temperature, quantity, money]


 -- Función: declare_fundamental_units (<u_1>, <d_1>, ..., <u_n>, <d_n>)
 -- Función: remove_fundamental_units (<u_1>, ..., <u_n>)
     `declare_fundamental_units' declara <u_1>, ..., <u_n> de
     dimensiones <d_1>, ..., <d_n>, respectivamente.  Todos los
     argumentos deben símbolos.

     Tras la llamada a `declare_fundamental_units', `dimensions(<u_k>)'
     devuelve <d_k> para cada argumento <u_1>, ..., <u_n>, y
     `fundamental_units(<d_k>)' devuelve <u_k> para cada <d_1>, ...,
     <d_n>.

     `remove_fundamental_units' invierte el efecto de
     `declare_fundamental_units'.

     Ejecútese `load(ezunits)' para hacer uso de estas funciones.

     Ejemplos:

          (%i1) load (ezunits) $
          (%i2) declare_fundamental_dimensions (money, cattle, happiness);
          (%o2)                         done
          (%i3) declare_fundamental_units (dollar, money, goat, cattle,
                                           smile, happiness);
          (%o3)                 [dollar, goat, smile]
          (%i4) dimensions (100 ` dollar/goat/km^2);
                                       money
          (%o4)                    --------------
                                                2
                                   cattle length
          (%i5) dimensions (x ` smile/kg);
                                      happiness
          (%o5)                       ---------
                                        mass
          (%i6) fundamental_units (money*cattle/happiness);
          0 errors, 0 warnings
                                     dollar goat
          (%o6)                      -----------
                                        smile


 -- Función: dimensions (<x>)
 -- Función: dimensions_as_list (<x>)
     `dimensions' devuelve las dimensiones de la magnitud dimensional
     <x> en forma de expresión que contiene productos y potencias de
     dimensiones fundamentales.

     `dimensions_as_list' devuelve las dimensiones de la magnitud
     dimensional <x> en forma de lista, cuyos elementos indican las
     potencias de las dimensiones fundamentales correspondientes.

     Para utilizar estas funciones ejecútese primero `load(ezunits)'.

     Ejemplos:

          (%i1) load (ezunits)$
          (%i2) dimensions (1000 ` kg*m^2/s^3);
                                          2
                                    length  mass
          (%o2)                     ------------
                                           3
                                       time
          (%i3) declare_units (foo, acre*ft/hour);
                                       acre ft
          (%o3)                        -------
                                        hour
          (%i4) dimensions (foo);
                                             3
                                       length
          (%o4)                        -------
                                        time

          (%i1) load (ezunits)$
          (%i2) fundamental_dimensions;
          (%o2)  [length, mass, time, charge, temperature, quantity]
          (%i3) dimensions_as_list (1000 ` kg*m^2/s^3);
          (%o3)                 [2, 1, - 3, 0, 0, 0]
          (%i4) declare_units (foo, acre*ft/hour);
                                       acre ft
          (%o4)                        -------
                                        hour
          (%i5) dimensions_as_list (foo);
          (%o5)                 [3, 0, - 1, 0, 0, 0]


 -- Función: fundamental_units (<x>)
 -- Función: fundamental_units ()
     `fundamental_units(<x>)' devuelve las unidades asociadas a las
     dimensiones fundamentales de <x>, tal como queda determinada por
     `dimensions(<x>)'.

     <x> puede ser una expresión literal dimensional a ` b, un símbolo
     con unidades declaradas a través de `declare_units' o una
     expresión que contenga a ambos.

     `fundamental_units()' devuelve una lista con las unidades
     fundamentales conocidas, tal como fueron declaradas por
     `declare_fundamental_units'.

     Para utilizar esta función ejecútese primero `load(ezunits)'.

     Ejemplos:

          (%i1) load (ezunits)$
          (%i2) fundamental_units ();
          (%o2)                 [m, kg, s, A, K, mol]
          (%i3) fundamental_units (100 ` mile/hour);
                                          m
          (%o3)                           -
                                          s
          (%i4) declare_units (aa, g/foot^2);
                                          g
          (%o4)                         -----
                                            2
                                        foot
          (%i5) fundamental_units (aa);
                                         kg
          (%o5)                          --
                                          2
                                         m


 -- Función: dimensionless (<L>)
     Devuelve una expresión sin dimensiones que se puede formar a
     partir de una lista <L> de cantidades dimensionales

     Para utilizar esta función ejecútese primero `load(ezunits)'.

     Ejemplos:

          (%i1) load (ezunits) $
          (%i2) dimensionless ([x ` m, y ` m/s, z ` s]);
          0 errors, 0 warnings
          0 errors, 0 warnings
                                         y z
          (%o2)                         [---]
                                          x

     Cantidades adimensionales obtenidas a partir de cantidades físicas.
     Nótese que el primer elemento de la lista es proporcional a la
     constante de estructura fina.

          (%i1) load (ezunits) $
          (%i2) load (physical_constants) $
          (%i3) dimensionless([%h_bar, %m_e, %m_P, %%e, %c, %e_0]);
          0 errors, 0 warnings
          0 errors, 0 warnings
                                        2
                                     %%e        %m_e
          (%o3)                [--------------, ----]
                                %c %e_0 %h_bar  %m_P


 -- Función: natural_unit (<expr>, [<v_1>, ..., <v_n>])
     Busca los exponentes <e_1>, ..., <e_n> tales que
     `dimension(<expr>) = dimension(<v_1>^<e_1> ... <v_n>^<e_n>)'.

     Para utilizar esta función ejecútese primero `load(ezunits)'.



File: maxima.info,  Node: f90,  Next: finance,  Prev: ezunits,  Up: Top

51 f90
******

* Menu:

* Funciones y variables para f90::


File: maxima.info,  Node: Funciones y variables para f90,  Prev: f90,  Up: f90

51.1 Funciones y variables para f90
===================================

 -- Función: f90 (<expr_1>, ..., <expr_n>)
     Imprime una o más expresiones <expr_1>, ..., <expr_n> como un
     programa Fortran 90. El programa se obtiene a través de la salida
     estándar.

     La función `f90' imprime su salida en el llamado formato libre de
     Fortran 90: no se presta atención alguna a las posiciones de
     caracteres respecto de las columnas y los renglones largos se
     dividen a un ancho fijo con el carácter `&' indicando continuación
     de código.

     Ejecútese `load(f90)' antes de utilizar esta función.

     Véase también `fortran'.

     Ejemplos:

          (%i1) load (f90)$
          (%i2) foo : expand ((xxx + yyy + 7)^4);
                   4            3         3        2    2             2
          (%o2) yyy  + 4 xxx yyy  + 28 yyy  + 6 xxx  yyy  + 84 xxx yyy
                    2        3             2
           + 294 yyy  + 4 xxx  yyy + 84 xxx  yyy + 588 xxx yyy + 1372 yyy
                4         3          2
           + xxx  + 28 xxx  + 294 xxx  + 1372 xxx + 2401
          (%i3) f90 ('foo = foo);
          foo = yyy**4+4*xxx*yyy**3+28*yyy**3+6*xxx**2*yyy**2+84*xxx*yyy**2&
          +294*yyy**2+4*xxx**3*yyy+84*xxx**2*yyy+588*xxx*yyy+1372*yyy+xxx**&
          4+28*xxx**3+294*xxx**2+1372*xxx+2401
          (%o3)                         false

     Expresiones múltiples. Captura de la salida estándar a un fichero
     por medio de la función `with_stdout'.

          (%i1) load (f90)$
          (%i2) foo : sin (3*x + 1) - cos (7*x - 2);
          (%o2)              sin(3 x + 1) - cos(7 x - 2)
          (%i3) with_stdout ("foo.f90",
                             f90 (x=0.25, y=0.625, 'foo=foo, 'stop, 'end));
          (%o3)                         false
          (%i4) printfile ("foo.f90");
          x = 0.25
          y = 0.625
          foo = sin(3*x+1)-cos(7*x-2)
          stop
          end
          (%o4)                        foo.f90


File: maxima.info,  Node: finance,  Next: fractals,  Prev: f90,  Up: Top

52 finance
**********

* Menu:

* Introducción a finance::
* Funciones y Variables para finance::


File: maxima.info,  Node: Introducción a finance,  Next: Funciones y Variables para finance,  Prev: finance,  Up: finance

52.1 Introducción a finance
===========================

Este es el Paquete "Finance" (Ver 0.1).

   En todas las funciones, <rate> es la tasa de interés compuesto,
<num> es el número de periodos y debe ser positivo, y <flow> se refiere
al flujo de caja; entonces, si se tiene un egreso el flujo es negativo
y para un ingreso un valor positivo.

   Note que antes de usar las funciones definidas en este paquete, debe
cargarla escribiendo `load(finance)$'.

   Autor: Nicolás Guarin Zapata.


File: maxima.info,  Node: Funciones y Variables para finance,  Prev: Introducción a finance,  Up: finance

52.2 Funciones y Variables para finance
=======================================

 -- Function: days360 (<año1>,<mes1>,<dia1>,<año2>,<mes2>,<dia2>)
     Calcula la distancia entre 2 fechas, asumiendo años de 360 dias y
     meses de 30 días.

     Ejemplo:

          (%i1) load(finance)$
          (%i2) days360(2008,12,16,2007,3,25);
          (%o2)                      - 621

 -- Function: fv (<rate>,<PV>,<num>)
     Calcular el Valor Futuro a partir de uno en el Presente para una
     tasa de interés dada.  <rate> es la tasa de interés, <PV> es el
     valor prestente y <num> es el número de periodos.

     Ejemplo:

          (%i1) load(finance)$
          (%i2) fv(0.12,1000,3);
          (%o2)                     1404.928

 -- Function: pv (<rate>,<FV>,<num>)
     Calcula el valor actual de un valor futuro dada la tasa de
     interés. <rate> es la tasa de interés, <FV> es el valor futuro y
     <num> es el número de periodos.

     Ejemplo:

          (%i1) load(finance)$
          (%i2) pv(0.12,1000,3);
          (%o2)                711.7802478134108

 -- Function: graph_flow (<val>)
     Grafica el flujo de caja en una línea de tiempo, los valores
     positivos están en azul y hacia arriba; los negativos están en
     rojo y hacia abajo.  La dirección del flujo está dada por el signo
     de los valores.  <val> es una lista de los valores del flujo de
     caja.

     Ejemplo:

          (%i1) load(finance)$
          (%i2) graph_flow([-5000,-3000,800,1300,1500,2000])$

 -- Function: annuity_pv (<rate>,<PV>,<num>)
     Calcula una anualidad conociendo el valor presente (tipo deuda),
     para unos pagos periódicos y constantes. <rate> es la tasa de
     interés, <PV> es el valor presente y <num> es el número de
     periodos.

     Ejemplo:

          (%i1) load(finance)$
          (%i2) annuity_pv(0.12,5000,10);
          (%o2)                884.9208207992202

 -- Function: annuity_fv (<rate>,<FV>,<num>)
     Calcula una anualidad conociendo el valor deseado (valor futuro),
     para una serie de pagos periódicos y constantes. <rate> es la tasa
     de interés, <FV> es el valor futuroe y <num> es el número de
     periodos.

     Ejemplo:

          (%i1) load(finance)$
          (%i2) annuity_fv(0.12,65000,10);
          (%o2)                3703.970670389863

 -- Function: geo_annuity_pv (<rate>,<growing_rate>,<PV>,<num>)
     Calcula una anualidad conociendo el valor presente (tipo deuda) en
     una serie de pagos periodicos crecientes.  <rate> es la tasa de
     interés, <growing_rate> es el crecimiento de los pagos, <PV> es el
     valor presente, y <num> es el número de periodos.

     Ejemplo:

          (%i1) load(finance)$
          (%i2) geo_annuity_pv(0.14,0.05,5000,10);
          (%o2)                802.6888176505123

 -- Function: geo_annuity_fv (<rate>,<growing_rate>,<FV>,<num>)
     Calcular una anualidad conociendo el valor deseado (valor futuro)
     en una serie de pagos periodicos crecientes.  <rate> es la tasa de
     interés, <growing_rate> es el crecimiento de los pagos, <FV> es el
     valor futuro, y <num> es el número de periodos.

     Ejemplo:

          (%i1) load(finance)$
          (%i2) geo_annuity_fv(0.14,0.05,5000,10);
          (%o2)                216.5203395312695

 -- Function: amortization (<rate>,<ammount>,<num>)
     La tabla de amortización determinada por una tasa.  Siendo <rate>
     es la tasa de interés, <ammount> es el valor de la deuda, and
     <num> es el número de periodos.

     Ejemplo:

          (%i1) load(finance)$
          (%i2) amortization(0.05,56000,12)$
                "n"    "Balance"     "Interest"   "Amortization"  "Payment"
               0.000     56000.000         0.000         0.000         0.000
               1.000     52481.777      2800.000      3518.223      6318.223
               2.000     48787.643      2624.089      3694.134      6318.223
               3.000     44908.802      2439.382      3878.841      6318.223
               4.000     40836.019      2245.440      4072.783      6318.223
               5.000     36559.597      2041.801      4276.422      6318.223
               6.000     32069.354      1827.980      4490.243      6318.223
               7.000     27354.599      1603.468      4714.755      6318.223
               8.000     22404.106      1367.730      4950.493      6318.223
               9.000     17206.088      1120.205      5198.018      6318.223
              10.000     11748.170       860.304      5457.919      6318.223
              11.000      6017.355       587.408      5730.814      6318.223
              12.000         0.000       300.868      6017.355      6318.223

 -- Function: arit_amortization (<rate>,<increment>,<ammount>,<num>)
     La tabla de amortización determinada por una tasa específica y
     unos pagos crecientes se puede hallar con `arit_amortization'.
     Nótese que los pagos no son constantes, estos presentan un
     crecimiento aritmético, el incremento es la diferencia entre dos
     filas consecutivas en la columna "Payment".  <rate> es la tasa de
     interés, <increment> es el incremento, <ammount> es el valor de la
     deuda, and <num> es el número de periodos.

     Ejemplo:

          (%i1) load(finance)$
          (%i2) arit_amortization(0.05,1000,56000,12)$
                "n"    "Balance"     "Interest"   "Amortization"  "Payment"
               0.000     56000.000         0.000         0.000         0.000
               1.000     57403.679      2800.000     -1403.679      1396.321
               2.000     57877.541      2870.184      -473.863      2396.321
               3.000     57375.097      2893.877       502.444      3396.321
               4.000     55847.530      2868.755      1527.567      4396.321
               5.000     53243.586      2792.377      2603.945      5396.321
               6.000     49509.443      2662.179      3734.142      6396.321
               7.000     44588.594      2475.472      4920.849      7396.321
               8.000     38421.703      2229.430      6166.892      8396.321
               9.000     30946.466      1921.085      7475.236      9396.321
              10.000     22097.468      1547.323      8848.998     10396.321
              11.000     11806.020      1104.873     10291.448     11396.321
              12.000        -0.000       590.301     11806.020     12396.321

 -- Function: geo_amortization (<rate>,<growing_rate>,<ammount>,<num>)
     La tabla de amortización determinada por la tasa, el valor de la
     deuda, y el número de periodos se puede hallar con
     `geo_amortization'.  Nótese que los pagos no son constantes, estos
     presentan un crecimiento geométrico, growin_rate es entonces el
     cociente entre dos filas consecutivas de la columna "Payment".
     <rate> es la tasa de interés, <growing_rate> es el crecimeinto de
     los pagos, <ammount> es el valor de la deuda, y <num> es el numero
     de periodos.

     Ejemplo:

          (%i1) load(finance)$
          (%i2) geo_amortization(0.05,0.03,56000,12)$
                "n"    "Balance"     "Interest"   "Amortization"  "Payment"
               0.000     56000.000         0.000         0.000         0.000
               1.000     53365.296      2800.000      2634.704      5434.704
               2.000     50435.816      2668.265      2929.480      5597.745
               3.000     47191.930      2521.791      3243.886      5765.677
               4.000     43612.879      2359.596      3579.051      5938.648
               5.000     39676.716      2180.644      3936.163      6116.807
               6.000     35360.240      1983.836      4316.475      6300.311
               7.000     30638.932      1768.012      4721.309      6489.321
               8.000     25486.878      1531.947      5152.054      6684.000
               9.000     19876.702      1274.344      5610.176      6884.520
              10.000     13779.481       993.835      6097.221      7091.056
              11.000      7164.668       688.974      6614.813      7303.787
              12.000         0.000       358.233      7164.668      7522.901

 -- Function: saving (<rate>,<ammount>,<num>)
     La tabla que presenta los valores para un ahorro constante y
     periódico se pueden hallar con `saving'.  <ammount> representa la
     cantidad deseada y <num> el número de periodos durante los que se
     ahorrará.

     Ejemplo:

          (%i1) load(finance)$
          (%i2) saving(0.15,12000,15)$
                "n"    "Balance"     "Interest"   "Payment"
               0.000         0.000         0.000         0.000
               1.000       252.205         0.000       252.205
               2.000       542.240        37.831       252.205
               3.000       875.781        81.336       252.205
               4.000      1259.352       131.367       252.205
               5.000      1700.460       188.903       252.205
               6.000      2207.733       255.069       252.205
               7.000      2791.098       331.160       252.205
               8.000      3461.967       418.665       252.205
               9.000      4233.467       519.295       252.205
              10.000      5120.692       635.020       252.205
              11.000      6141.000       768.104       252.205
              12.000      7314.355       921.150       252.205
              13.000      8663.713      1097.153       252.205
              14.000     10215.474      1299.557       252.205
              15.000     12000.000      1532.321       252.205

 -- Function: npv (<rate>,<val>)
     Calcular el valor presente neto de una serie de valores para
     evaluar la viabilidad de un proyecto.  <flowValues> es una lista
     con los valores para cada periodo.

     Ejemplo:

          (%i1) load(finance)$
          (%i2) npv(0.25,[100,500,323,124,300]);
          (%o2)                714.4703999999999

 -- Function: irr (<val>,<IO>)
     Tasa interna de retorno (en inglés Internal Rate of Return - IRR),
     es el valor de tasa que hace que el Valor Presente Neto (NPV) sea
     cero.  <flowValues> los valores para cada periodo (para periodos
     mayores a 0) y <I0> el valor para el periodo cero.

     Ejemplo:

          (%i1) load(finance)$
          (%i2) res:irr([-5000,0,800,1300,1500,2000],0)$
          (%i3) rhs(res[1][1]);
          (%o3)                .03009250374237132

 -- Function: benefit_cost (<rate>,<input>,<output>)
     Calcular la relación Beneficio/Costo, Beneficio es el Valor
     Presente Neto (NPV) de los flujos de caja positivos (inputs), y
     Costo es el Valor Presente Neto de los flujos de caja negativos
     (outputs).  Nótese que si se desea tener un valor de cero para un
     periodo especifico, esta entrada/salida debe indicarse como cero
     para ese periodo.  <rate> es la tasa de interés, <input> es una
     lista con los ingresos, y <output> es una lista con los egresos.

     Ejemplo:

          (%i1) load(finance)$
          (%i2) benefit_cost(0.24,[0,300,500,150],[100,320,0,180]);
          (%o2)               1.427249324905784


File: maxima.info,  Node: fractals,  Next: ggf,  Prev: finance,  Up: Top

53 fractals
***********

* Menu:

* Introducción a fractals::
* Definiciones para IFS fractals::
* Definiciones para fractales complejos::
* Definiciones para cops de Koch::
* Definiciones para curvas de Peano::


File: maxima.info,  Node: Introducción a fractals,  Next: Definiciones para IFS fractals,  Prev: fractals,  Up: fractals

53.1 Introducción a fractals
============================

Este paquete define algunos fractales:

   - con IFS (Iterated Function System) aleatorias: triángulo de
Sierpinsky, un árbol y un helecho.

   - Fractales complejos: conjuntos de Mandelbrot y de Julia.

   - Copos de Koch.

   - Funciones de Peano: funciones de Sierpinski y Hilbert.

   Autor: José Rammírez Labrador.

   Para preguntas, sugerencias y fallos,

   pepe DOT ramirez AAATTT uca DOT es


File: maxima.info,  Node: Definiciones para IFS fractals,  Next: Definiciones para fractales complejos,  Prev: Introducción a fractals,  Up: fractals

53.2 Definiciones para IFS fractals
===================================

Algunos fractales se pueden generar por medio de la aplicación iterativa
de transformaciones afines contractivas de forma aleatoria; véase

   Hoggar S. G., "Mathematics for computer graphics", Cambridge
University Press 1994.

   Definimos una lista con varias transformaciones afines contractivas,
luego las vamos seleccionando de forma aleatoria y recursiva. La
probabilidad de selección de una transformación debe estar relacionada
con la razón de contracción.

   Se pueden cambiar las transformaciones y encontrar nuevos fractales.

 -- Función: sierpinskiale (<n>)
     Triángulo de Sierpinski: 3 aplicaciones contractivas; constante de
     contracción de 0.5 y traslaciones. Todas las aplicaciones tienen
     la misma constante de contracción. El argumento <n> debe ser
     suficientemente alto, 10000 o mayor.

     Ejemplo:

          (%i1) load(fractals)$
          (%i2) n: 10000$
          (%i3) plot2d([discrete,sierpinskiale(n)], [style,dots])$

 -- Función: treefale (<n>)
     3 aplicaciones contractivas, todas ellas con el mismo coeficiente
     de contracción. El argumento <n> debe ser suficientemente alto,
     10000 o mayor.

     Ejemplo:

          (%i1) load(fractals)$
          (%i2) n: 10000$
          (%i3) plot2d([discrete,treefale(n)], [style,dots])$

 -- Función: fernfale (<n>)
     4 aplicaciones contractivas, cuyas probabilidades de selección
     deben estar relacionadas con su constante de contracción. El
     argumento <n> debe ser suficientemente alto, 10000 o mayor.

     Ejemplo:

          (%i1) load(fractals)$
          (%i2) n: 10000$
          (%i3) plot2d([discrete,fernfale(n)], [style,dots])$


File: maxima.info,  Node: Definiciones para fractales complejos,  Next: Definiciones para cops de Koch,  Prev: Definiciones para IFS fractals,  Up: Top

53.3 Definiciones para fractales complejos
==========================================

 -- Función: mandelbrot_set (<x>, <y>)
     Conjunto de Mandelbrot.

     Esta función debe realizar muchas operaciones y puede tardar
     bastante tiempo en ejecutarse, tiempo que también depende del
     número de puntos de la malla.

     Ejemplo:

          (%i1) load(fractals)$
          (%i2) plot3d (mandelbrot_set, [x, -2.5, 1], [y, -1.5, 1.5],
                          [gnuplot_preamble, "set view map"],
                          [gnuplot_pm3d, true],
                          [grid, 150, 150])$

 -- Función: julia_set (<x>, <y>)
     Conjuntos de Julia.

     Esta función debe realizar muchas operaciones y puede tardar
     bastante tiempo en ejecutarse, tiempo que también depende del
     número de puntos de la malla.

     Ejemplo:

          (%i1) load(fractals)$
          (%i2) plot3d (julia_set, [x, -2, 1], [y, -1.5, 1.5],
                          [gnuplot_preamble, "set view map"],
                          [gnuplot_pm3d, true],
                          [grid, 150, 150])$

     Véase también `julia_parameter'.

 -- Variable opcional: julia_parameter
     Valor por defecto: `%i'

     Parámetro complejo para fractales de Julia. Su valor por defecto
     es `%i', y otros que se sugieren son: `-.745+%i*.113002',
     `-.39054-%i*.58679', `-.15652+%i*1.03225', `-.194+%i*.6557' y
     `.011031-%i*.67037'.


 -- Función: julia_sin (<x>, <y>)
     Mientras que la función `julia_set' implementa la transformación
     `julia_parameter+z^2', la función `julia_sin' implementa
     `julia_parameter*sin(z)'. Véase el código fuente para más detalles.

     Este programa es lento porque calcula muchos senos; el tiempo de
     ejecución también depende del número de puntos de la malla.

     Ejemplo:

          (%i1) load(fractals)$
          (%i2) julia_parameter:1+.1*%i$
          (%i3) plot3d (julia_sin, [x, -2, 2], [y, -3, 3],
                          [gnuplot_preamble, "set view map"],
                          [gnuplot_pm3d, true],
                          [grid, 150, 150])$

     Véase también `julia_parameter'.


File: maxima.info,  Node: Definiciones para cops de Koch,  Next: Definiciones para curvas de Peano,  Prev: Definiciones para fractales complejos,  Up: Top

53.4 Definiciones para cops de Koch
===================================

 -- Función: snowmap (<ent>, <nn>)
     Copos de Koch. La función `snowmap' dibuja el copo de Koch sobre
     los vértices de un polígono convexo inicial del plano complejo. La
     orientación del polígono es importante.  El argumento <nn> es el
     número de recursividades de la transformación de Koch, el cual
     debe ser pequeño (5 o 6).

     Ejemplos:

          (%i1) load(fractals)$
          (%i2) plot2d([discrete,
                        snowmap([1,exp(%i*%pi*2/3),exp(-%i*%pi*2/3),1],4)])$
          (%i3) plot2d([discrete,
                        snowmap([1,exp(-%i*%pi*2/3),exp(%i*%pi*2/3),1],4)])$
          (%i4) plot2d([discrete, snowmap([0,1,1+%i,%i,0],4)])$
          (%i5) plot2d([discrete, snowmap([0,%i,1+%i,1,0],4)])$


File: maxima.info,  Node: Definiciones para curvas de Peano,  Prev: Definiciones para cops de Koch,  Up: fractals

53.5 Definiciones para curvas de Peano
======================================

Funciones continuas que cubren un área. Aviso: el número de puntos
crece exponencialmente con <n>.

 -- Función: hilbertmap (<nn>)
     Curva de Hilbert. El argumento <nn> debe ser pequeño (por ejemplo,
     5).  Maxima se puede detener si <nn> es 7 o mayor.

     Ejemplo:

          (%i1) load(fractals)$
          (%i2) plot2d([discrete,hilbertmap(6)])$

 -- Función: sierpinskimap (<nn>)
     Curva de Sierpinski. El argumento <nn> debe ser pequeño (por
     ejemplo, 5).  Maxima se puede detener si <nn> es 7 o mayor.

     Ejemplo:

          (%i1) load(fractals)$
          (%i2) plot2d([discrete,sierpinskimap(6)])$


File: maxima.info,  Node: ggf,  Next: graphs,  Prev: fractals,  Up: Top

54 ggf
******

* Menu:

* Funciones y variables para ggf::


File: maxima.info,  Node: Funciones y variables para ggf,  Prev: ggf,  Up: ggf

54.1 Funciones y variables para ggf
===================================

 -- Variable opcional: GGFINFINITY
     Valor por defecto: 3

     Variable opcional para la función `ggf'.

     Cuando se calcula la fracción continua de la función generatriz,
     si un cociente parcial tiene grado estrictamente mayor que
     <GGFINFINITY> será descartado y la convergencia alcanzada hasta
     ese momento será considerada como exacta para la función
     generatriz. Lo más frecuente es que el grado de todos los
     cocientes parciales sea 0 ó 1, de modo que si se utiliza un valor
     mayor se deberán dar más términos para conseguir un cálculo más
     exacto.

     Véase también `ggf'.

 -- Variable opcional: GGFCFMAX
     Valor por defeco: 3

     Variable opcional para la función `ggf'.

     Cuando se calcula la fracción continua de la función generatriz,
     si no se ha encontrado un resultado aceptable (véase la variable
     <GGFINFINITY>) después de haber calculado <GGFCFMAX> cocientes
     parciales, la función generatriz será considerada no equivalente a
     una fracción racional y la función `ggf' se detendrá. Puede
     asignársele a <GGFCFMAX> un valor mayor para funciones
     generatrices más complicadas.

     Véase también `ggf'.

 -- Función: ggf (<l>)
     Calcula la función generatriz de una sucesión de la que se
     suministran tan solo los primeros valores y cuyo término general
     es una fracción algebraica (cociente de dos polinomios).

     La solución se devuelve como una fracción de polinomios.  En caso
     de no poder encontrar una solución, se devuelve `done'.

     Esta función está controlada por las variables globales
     <GGFINFINITY> y <GGFCFMAX>. Véanse también <GGFINFINITY> y
     <GGFCFMAX>.

     Antes de hacer uso de esta función ejecútese  `load("ggf")'.


File: maxima.info,  Node: graphs,  Next: grobner,  Prev: ggf,  Up: Top

55 graphs
*********

* Menu:

* Introducción a graphs::
* Funciones y variables para graphs::


File: maxima.info,  Node: Introducción a graphs,  Next: Funciones y variables para graphs,  Prev: graphs,  Up: graphs

55.1 Introducción a graphs
==========================

El paquete `graphs' permite trabajar con estructuras de grafos y
digrafos en Maxima. Tanto los grafos como los digrafos son de
estructura simples (no tienen ni aristas mÃºltiples ni bucles), pero los
digrafos pueden tener una arista dirigida desde <u> hasta <v> y otra
desde <v> hasta <u>.

   Los grafos se representan internamente como listas de adyacencia y se
implementan como estructuras de lisp. Los vértices se identifican por
sus números de identificacin' (siempre enteros). Las aristas/arcos se
representan por listas de longitud 2. Se pueden asignar etiquetas a los
vértices de los grafos/digrafos y pesos a sus aristas/arcos.

   La función `draw_graph' dibuja grafos siguiendo un criterio rígido
de posicionamiento de los vértices. También puede hacer uso del
programa graphviz disponible en `http://www.graphviz.org'. La función
`draw_graph' utiliza el paquete `draw' de Maxima.

   Para hacer uso de este paquete, ejecútese primero `load(graphs)'.


File: maxima.info,  Node: Funciones y variables para graphs,  Prev: Introducción a graphs,  Up: graphs

55.2 Funciones y variables para graphs
======================================

55.2.1 Construyendo grafos
--------------------------

 -- Función: create_graph (<v_list>, <e_list>)
 -- Función: create_graph (<n>, <e_list>)
 -- Función: create_graph (<v_list>, <e_list>, <directed>)
     Crea un nuevo grafo sobre el conjunto de vértices <v_list> con
     aristas <e_list>.

     <v_list> es una lista de vértices (`[v1, v2,..., vn]') o una lista
     de vértices junto con sus respectivas etiquetas (`[[v1,l1],
     [v2,l2],..., [vn,ln]]').

     <n> es el número de vértices, los cuales se identificarán desde 0
     hasta n-1.

     <e_list> es una lista de aristas (`[e1, e2,..., em]') o una lista
     de aristas con sus respectivas ponderaciones (`[[e1, w1], ...,
     [em, wm]]').

     Si <directed> is not `false', se devolverá un grafo orientado.

     Ejemplos:

     Crea un ciclo de 3 vértices.

          (%i1) load (graphs)$
          (%i2) g : create_graph([1,2,3], [[1,2], [2,3], [1,3]])$
          (%i3) print_graph(g)$
          Graph on 3 vertices with 3 edges.
          Adjacencies:
            3 :  1  2
            2 :  3  1
            1 :  3  2

     Crea un ciclo de 3 vértices y aristas ponderadas:

          (%i1) load (graphs)$
          (%i2) g : create_graph([1,2,3], [[[1,2], 1.0], [[2,3], 2.0],
                                          [[1,3], 3.0]])$
          (%i3) print_graph(g)$
          Graph on 3 vertices with 3 edges.
          Adjacencies:
            3 :  1  2
            2 :  3  1
            1 :  3  2

     Crea un grafo orientado:

          (%i1) load (graphs)$
          (%i2) d : create_graph(
                 [1,2,3,4],
                 [
                  [1,3], [1,4],
                  [2,3], [2,4]
                 ],
                 'directed = true)$
          (%i3) print_graph(d)$
          Digraph on 4 vertices with 4 arcs.
          Adjacencies:
            4 :
            3 :
            2 :  4  3
            1 :  4  3

 -- Función: copy_graph (<g>)
     Devuelve una copia del grafo <g>.

 -- Función: circulant_graph (<n>, <d>)
     Devuelve un grafo cirlulante de parámetros <n> y <d>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : circulant_graph(10, [1,3])$
          (%i3) print_graph(g)$
          Graph on 10 vertices with 20 edges.
          Adjacencies:
            9 :  2  6  0  8
            8 :  1  5  9  7
            7 :  0  4  8  6
            6 :  9  3  7  5
            5 :  8  2  6  4
            4 :  7  1  5  3
            3 :  6  0  4  2
            2 :  9  5  3  1
            1 :  8  4  2  0
            0 :  7  3  9  1

 -- Función: clebsch_graph ()
     Devuelve el grafo de Clebsch.

 -- Función: complement_graph (<g>)
     Devuelve el complemento del grafo <g>.

 -- Función: complete_bipartite_graph (<n>, <m>)
     Devuelve el grafo bipartido completo de <n+m> vértices.

 -- Función: complete_graph (<n>)
     Devuelve el grafo completo de <n> vértices.

 -- Función: cycle_digraph (<n>)
     Devuelve el ciclo dirigido de <n> vértices.

 -- Función: cycle_graph (<n>)
     Devuelve el ciclo de <n> vértices.

 -- Función: cuboctahedron_graph (<n>)
     Devuelve el grafo cubooctaédrico.

 -- Función: cube_graph (<n>)
     Devuelve el cubo de <n> dimensiones.

 -- Función: dodecahedron_graph ()
     Devuelve el grafo del dodecaedro.

 -- Función: empty_graph (<n>)
     Devuelve el grafo vacío de <n> vértices.

 -- Función: flower_snark (<n>)
     Devuelve el grafo de flor de <4n> vértices.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) f5 : flower_snark(5)$
          (%i3) chromatic_index(f5);
          (%o3)                                  4

 -- Función: from_adjacency_matrix (<A>)
     Devuelve el grafo definido por la matriz de adyacencia <A>.

 -- Función: frucht_graph ()
     Devuelve el grafo de Frucht.

 -- Función: graph_product (<g1>, <g1>)
     Devuelve el producto dirigido de los grafos <g1> y <g2>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) grid : graph_product(path_graph(3), path_graph(4))$
          (%i3) draw_graph(grid)$

 -- Función: graph_union (<g1>, <g1>)
     Devuelve la unión (suma) de los grafos <g1> y <g2>.

 -- Función: grid_graph (<n>, <m>)
     Devuelve la rejilla <n x m>.

 -- Función: great_rhombicosidodecahedron_graph ()
     Devuelve el grafo gran rombicosidodecaédrico.

 -- Función: great_rhombicuboctahedron_graph ()
     Devuelve el grafo gran rombicocubicooctaédrico.

 -- Función: grotzch_graph ()
     Devuelve el grafo de Grotzch.

 -- Función: heawood_graph ()
     Devuelve el grafo de Heawood.

 -- Función: icosahedron_graph ()
     Devuelve el grafo icosaédrico.

 -- Función: icosidodecahedron_graph ()
     Devuelve el grafo icosidodecaédrico.

 -- Función: induced_subgraph (<V>, <g>)
     Devuelve el grafo inducido por el subconjunto <V> de vértices del
     grafo <g>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) p : petersen_graph()$
          (%i3) V : [0,1,2,3,4]$
          (%i4) g : induced_subgraph(V, p)$
          (%i5) print_graph(g)$
          Graph on 5 vertices with 5 edges.
          Adjacencies:
            4 :  3  0
            3 :  2  4
            2 :  1  3
            1 :  0  2
            0 :  1  4

 -- Función: line_graph (<g>)
     Devuelve el grafo de línea del grafo <g>.

 -- Función: make_graph (<vrt>, <f>)
 -- Función: make_graph (<vrt>, <f>, <oriented>)
     Crea un grafo por medio de la función de predicado <f>.

     <vrt> es una lista o conjunto de vértices o un simplemente un
     número entero.  Si <vrt> es un número entero, entonces los
     vértices del grafo serán los enteros desde 1 hasta <vrt>.

     <f> es una función de predicado. Dos vértices <a> y <b> se
     conectarán si `f(a,b)=true'.

     Si <directed> no es <false>, entonces en grafo será dirigido.

     Ejemplo 1:
          (%i1) load(graphs)$
          (%i2) g : make_graph(powerset({1,2,3,4,5}, 2), disjointp)$
          (%i3) is_isomorphic(g, petersen_graph());
          (%o3)                         true
          (%i4) get_vertex_label(1, g);
          (%o4)                        {1, 2}

     Ejemplo 2:
          (%i1) load(graphs)$
          (%i2) f(i, j) := is (mod(j, i)=0)$
          (%i3) g : make_graph(20, f, directed=true)$
          (%i4) out_neighbors(4, g);
          (%o4)                    [8, 12, 16, 20]
          (%i5) in_neighbors(18, g);
          (%o5)                    [1, 2, 3, 6, 9]

 -- Función: mycielski_graph (<g>)
     Devuelve el grafo de Mycielski del grafo <g>.

 -- Función: new_graph ()
     Devuelve el grafo sin vértices ni aristas.

 -- Función: path_digraph (<n>)
     Devuelve el camino dirigido de <n> vértices.

 -- Función: path_graph (<n>)
     Devuelve el camino de <n> vértices.

 -- Función: petersen_graph ()
 -- Función: petersen_graph (<n>, <d>)
     Devuelve el grafo de Petersen <P_{n,d}>. Los valores por defecto
     para <n> y <d> son `n=5' y `d=2'.

 -- Función: random_bipartite_graph (<a>, <b>, <p>)
     Devuelve un grafo aleatorio bipartido a partir de los vértices
     `a+b'. Cada arista se genera con probabilidad <p>.

 -- Función: random_digraph (<n>, <p>)
     Devuelve un grafo aleatorio dirigido de <n> vértices. Cada arco se
     presenta con una probabilidad <p>.

 -- Función: random_regular_graph (<n>)
 -- Función: random_regular_graph (<n>, <d>)
     Devuelve un grafo aleatorio <d>-regular de <n> vértices. El valor
     por defecto para <d> es `d=3'.

 -- Función: random_graph (<n>, <p>)
     Devuelve un grafo aleatorio de <n> vértices. Cada arco se presenta
     con una probabilidad <p>.

 -- Función: random_graph1 (<n>, <m>)
     Devuelve un grafo aleatorio de <n> vértices y <m> arcos aleatorios.

 -- Función: random_network (<n>, <p>, <w>)
     Devuelve una red aleatoria de <n> vértices. Cada arco se presenta
     con probabilidad <p> y tiene un peso dentro del rango `[0,w]'.  La
     función devuelve una lista `[network, source, sink]'.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) [net, s, t] : random_network(50, 0.2, 10.0);
          (%o2)                         [DIGRAPH, 50, 51]
          (%i3) max_flow(net, s, t)$
          (%i4) first(%);
          (%o4)                   27.65981397932507

 -- Función: random_tournament (<n>)
     Devuelve un torneo aleatorio de <n> vértices.

 -- Función: random_tree (<n>)
     Devuelve un árbol aleatorio de <n> vértices.

 -- Función: small_rhombicosidodecahedron_graph ()
     Devuelve el grafo pequeño rombicosidodecaédrico.

 -- Función: small_rhombicuboctahedron_graph ()
     Devuelve el grafo pequeño rombicocubicooctaédrico.

 -- Función: snub_cube_graph ()
     Devuelve el grafo cúbico volteado.

 -- Función: snub_dodecahedron_graph ()
     Devuelve el grafo dodecaédrico volteado.

 -- Función: truncated_cube_graph ()
     Devuelve el grafo cúbico truncado.

 -- Función: truncated_dodecahedron_graph ()
     Devuelve el grafo dodecaédrico truncado.

 -- Función: truncated_icosahedron_graph ()
     Devuelve el grafo icosaédrico truncado.

 -- Función: truncated_tetrahedron_graph ()
     Devuelve el grafo del tetraedro truncado.

 -- Función: tutte_graph ()
     Devuelve el grafo de Tutte.

 -- Función: underlying_graph (<g>)
     Devuelve el grafo asociado al grafo orientado <g>.

 -- Función: wheel_graph (<n>)
     Devuelve el grafo de rueda de <n+1> vértices.

55.2.2 Propiedades de los grafos
--------------------------------

 -- Función: adjacency_matrix (<gr>)
     Devuelve la matriz de adyacencia del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) c5 : cycle_graph(4)$
          (%i3) adjacency_matrix(c5);
                                          [ 0  1  0  1 ]
                                          [            ]
                                          [ 1  0  1  0 ]
          (%o3)                           [            ]
                                          [ 0  1  0  1 ]
                                          [            ]
                                          [ 1  0  1  0 ]

 -- Función: average_degree (<gr>)
     Devuelve el grado medio de los vértices del garfo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) average_degree(grotzch_graph());
                                                40
          (%o2)                                 --
                                                11

 -- Función: biconnected_components (<gr>)
     Devuelve los subconjuntos de vértices biconectados del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : create_graph(
                      [1,2,3,4,5,6,7],
                      [
                       [1,2],[2,3],[2,4],[3,4],
                       [4,5],[5,6],[4,6],[6,7]
                      ])$
          (%i3) biconnected_components(g);
          (%o3)               [[6, 7], [4, 5, 6], [1, 2], [2, 3, 4]]


 -- Función: bipartition (<gr>)
     Devuelve una bipartición de los vértices del grafo <gr>, o una
     lista vacía si <gr> no es bipartido.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) h : heawood_graph()$
          (%i3) [A,B]:bipartition(h);
          (%o3)         [[8, 12, 6, 10, 0, 2, 4], [13, 5, 11, 7, 9, 1, 3]]
          (%i4) draw_graph(h, show_vertices=A, program=circular)$

 -- Función: chromatic_index (<gr>)
     Devuelve el índice cromático del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) p : petersen_graph()$
          (%i3) chromatic_index(p);
          (%o3)                                  4

 -- Función: chromatic_number (<gr>)
     Devuelve el número cromático del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) chromatic_number(cycle_graph(5));
          (%o2)                                  3
          (%i3) chromatic_number(cycle_graph(6));
          (%o3)                                  2

 -- Función: clear_edge_weight (<e>, <gr>)
     Elimina el peso del arco <e> del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : create_graph(3, [[[0,1], 1.5], [[1,2], 1.3]])$
          (%i3) get_edge_weight([0,1], g);
          (%o3)                                 1.5
          (%i4) clear_edge_weight([0,1], g)$
          (%i5) get_edge_weight([0,1], g);
          (%o5)                                  1

 -- Función: clear_vertex_label (<v>, <gr>)
     Elimina la etiqueta del vértice <v> del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : create_graph([[0,"Zero"], [1, "One"]], [[0,1]])$
          (%i3) get_vertex_label(0, g);
          (%o3)                               Zero
          (%i4) clear_vertex_label(0, g);
          (%o4)                               done
          (%i5) get_vertex_label(0, g);
          (%o5)                               false

 -- Función: connected_components (<gr>)
     Devuelve las componentes conexas del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g: graph_union(cycle_graph(5), path_graph(4))$
          (%i3) connected_components(g);
          (%o3)                  [[1, 2, 3, 4, 0], [8, 7, 6, 5]]

 -- Función: diameter (<gr>)
     Devuelve el diámetro del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) diameter(dodecahedron_graph());
          (%o2)                                 5

 -- Función: edge_coloring (<gr>)
     Devuelve una coloración óptima de los arcos del grafo <gr>.

     La función devuelve el índice cromático y una lista que representa
     el coloreado de los arcos de <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) p : petersen_graph()$
          (%i3) [ch_index, col] : edge_coloring(p);
          (%o3) [4, [[[0, 5], 3], [[5, 7], 1], [[0, 1], 1], [[1, 6], 2],
          [[6, 8], 1], [[1, 2], 3], [[2, 7], 4], [[7, 9], 2], [[2, 3], 2],
          [[3, 8], 3], [[5, 8], 2], [[3, 4], 1], [[4, 9], 4], [[6, 9], 3],
          [[0, 4], 2]]]
          (%i4) assoc([0,1], col);
          (%o4)                           1
          (%i5) assoc([0,5], col);
          (%o5)                           3

 -- Función: degree_sequence (<gr>)
     Devuelve una lista con los grados de los vértices del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) degree_sequence(random_graph(10, 0.4));
          (%o2)            [2, 2, 2, 2, 2, 2, 3, 3, 3, 3]

 -- Función: edge_connectivity (<gr>)
     Devuelve la conectividad de las aristas del grafo <gr>.

     Véase también `min_edge_cut'.

 -- Función: edges (<gr>)
     Devuelve la lista de las aristas (arcos) del grafo (dirigido) <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) edges(complete_graph(4));
          (%o2)         [[2, 3], [1, 3], [1, 2], [0, 3], [0, 2], [0, 1]]

 -- Función: get_edge_weight (<e>, <gr>)
 -- Función: get_edge_weight (<e>, <gr>, <ifnot>)
     Devuelve el peso de la arista <e> del grafo <gr>.

     Si la arista no tiene peso, la función devuelve 1. Si la arista no
     pertenece al grafo, la función emite un mensaje de error o devuelve
     el argumento opcional <ifnot>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) c5 : cycle_graph(5)$
          (%i3) get_edge_weight([1,2], c5);
          (%o3)                                 1
          (%i4) set_edge_weight([1,2], 2.0, c5);
          (%o4)                               done
          (%i5) get_edge_weight([1,2], c5);
          (%o5)                                2.0

 -- Función: get_vertex_label (<v>, <gr>)
     Devuelve la etiqueta del vértice <v> del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : create_graph([[0,"Zero"], [1, "One"]], [[0,1]])$
          (%i3) get_vertex_label(0, g);
          (%o3)                               Zero

 -- Función: graph_charpoly (<gr>, <x>)
     Devuelve el polinomio característico (de variable <x>) del grafo
     <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) p : petersen_graph()$
          (%i3) graph_charpoly(p, x), factor;
                                                   5        4
          (%o3)                     (x - 3) (x - 1)  (x + 2)

 -- Función: graph_center (<gr>)
     Devuelve el centro del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : grid_graph(5,5)$
          (%i3) graph_center(g);
          (%o3)                               [12]

 -- Función: graph_eigenvalues (<gr>)
     Devuelve los valores propios del grafo <gr>. La función devuelve
     los valores propios en el mismo formato en el que lo hace la
     función `eigenvalue'.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) p : petersen_graph()$
          (%i3) graph_eigenvalues(p);
          (%o3)                     [[3, - 2, 1], [1, 4, 5]]

 -- Función: graph_periphery (<gr>)
     Devuelve la periferia del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : grid_graph(5,5)$
          (%i3) graph_periphery(g);
          (%o3)                          [24, 20, 4, 0]

 -- Función: graph_size (<gr>)
     Devuelve el número de aristas del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) p : petersen_graph()$
          (%i3) graph_size(p);
          (%o3)                                15

 -- Función: graph_order (<gr>)
     Devuelve el número de vértices del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) p : petersen_graph()$
          (%i3) graph_order(p);
          (%o3)                                10

 -- Función: girth (<gr>)
     Devuelve la longitud del ciclo más corto del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : heawood_graph()$
          (%i3) girth(g);
          (%o3)                                 6

 -- Función: hamilton_cycle (<gr>)
     Devuelve el ciclo de Hamilton del grafo <gr> o una lista vacía si
     <gr> no es hamiltoniano.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) c : cube_graph(3)$
          (%i3) hc : hamilton_cycle(c);
          (%o3)              [7, 3, 2, 6, 4, 0, 1, 5, 7]
          (%i4) draw_graph(c, show_edges=vertices_to_cycle(hc))$

 -- Función: hamilton_path (<gr>)
     Devuelve el camino de Hamilton del grafo <gr> o una lista vacía si
     <gr> no los tiene.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) p : petersen_graph()$
          (%i3) hp : hamilton_path(p);
          (%o3)                  [0, 5, 7, 2, 1, 6, 8, 3, 4, 9]
          (%i4) draw_graph(p, show_edges=vertices_to_path(hp))$

 -- Función: isomorphism (<gr1>, <gr2>)
     Devuelve un isomorfismo entre los grafos/digrafos <gr1> y <gr2>.
     Si <gr1> y <gr2> no son isomorfos, devuelve una lista vacía.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) clk5:complement_graph(line_graph(complete_graph(5)))$
          (%i3) isomorphism(clk5, petersen_graph());
          (%o3) [9 -> 0, 2 -> 1, 6 -> 2, 5 -> 3, 0 -> 4, 1 -> 5, 3 -> 6,
                                                    4 -> 7, 7 -> 8, 8 -> 9]

 -- Función: in_neighbors (<v>, <gr>)
     Devuelve la lista de los nodos hijos del vértice <v> del grafo
     orientado <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) p : path_digraph(3)$
          (%i3) in_neighbors(2, p);
          (%o3)                                 [1]
          (%i4) out_neighbors(2, p);
          (%o4)                                 []

 -- Función: is_biconnected (<gr>)
     Devuelve `true' si <gr> está biconectado y `false' en caso
     contrario.

     Ejemplo:

     Example:
          (%i1) load (graphs)$
          (%i2) is_biconnected(cycle_graph(5));
          (%o2)                         true
          (%i3) is_biconnected(path_graph(5));
          (%o3)                         false

 -- Función: is_bipartite (<gr>)
     Devuelve `true' si <gr> es bipartido (2-coloreable) y `false' en
     caso contrario.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) is_bipartite(petersen_graph());
          (%o2)                               false
          (%i3) is_bipartite(heawood_graph());
          (%o3)                               true

 -- Función: is_connected (<gr>)
     Devuelve `true' si el grafo <gr> es conexo y `false' en caso
     contrario.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) is_connected(graph_union(cycle_graph(4), path_graph(3)));
          (%o2)                               false

 -- Función: is_digraph (<gr>)
     Devuelve `true' si <gr> es un grafo orientado (digrafo) y `false'
     en caso contrario.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) is_digraph(path_graph(5));
          (%o2)                               false
          (%i3) is_digraph(path_digraph(5));
          (%o3)                               true

 -- Función: is_edge_in_graph (<e>, <gr>)
     Devuelve `true' si <e> es una arista (arco) del grafo (digrafo)
     <g> y `false' en caso contrario.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) c4 : cycle_graph(4)$
          (%i3) is_edge_in_graph([2,3], c4);
          (%o3)                               true
          (%i4) is_edge_in_graph([3,2], c4);
          (%o4)                               true
          (%i5) is_edge_in_graph([2,4], c4);
          (%o5)                               false
          (%i6) is_edge_in_graph([3,2], cycle_digraph(4));
          (%o6)                               false

 -- Función: is_graph (<gr>)
     Devuelve `true' si <gr> es un grafo y `false' en caso contrario.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) is_graph(path_graph(5));
          (%o2)                               true
          (%i3) is_graph(path_digraph(5));
          (%o3)                               false

 -- Función: is_graph_or_digraph (<gr>)
     Devuelve `true' si <gr> es una grafo, orientado o no, y `false' en
     caso contrario.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) is_graph_or_digraph(path_graph(5));
          (%o2)                               true
          (%i3) is_graph_or_digraph(path_digraph(5));
          (%o3)                               true

 -- Función: is_isomorphic (<gr1>, <gr2>)
     Devuelve `true' si los grafos/digrafos <gr1> y <gr2> son isomorfos
     y `false' en caso contrario.

     Véase también `isomorphism'.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) clk5:complement_graph(line_graph(complete_graph(5)))$
          (%i3) is_isomorphic(clk5, petersen_graph());
          (%o3)                         true

 -- Función: is_planar (<gr>)
     Devuelve `true' si <gr> es un grafo planar y `false' en caso
     contrario.

     El algoritmo utilizado es el de Demoucron, que es de tiempo
     cuadrático.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) is_planar(dodecahedron_graph());
          (%o2)                                true
          (%i3) is_planar(petersen_graph());
          (%o3)                                false
          (%i4) is_planar(petersen_graph(10,2));
          (%o4)                                true

 -- Función: is_sconnected (<gr>)
     Devuelve `true' si el grafo orientado <gr> es fuertemente conexo,
     devolviendo `false' en caso contrario.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) is_sconnected(cycle_digraph(5));
          (%o2)                               true
          (%i3) is_sconnected(path_digraph(5));
          (%o3)                               false

 -- Función: is_vertex_in_graph (<v>, <gr>)
     Devuelve `true' si <v> es un vértice del grafo <g> y `false' en
     caso contrario.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) c4 : cycle_graph(4)$
          (%i3) is_vertex_in_graph(0, c4);
          (%o3)                               true
          (%i4) is_vertex_in_graph(6, c4);
          (%o4)                               false

 -- Función: is_tree (<gr>)
     Devuelve `true' si <gr> es un árbol y `false' en caso contrario.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) is_tree(random_tree(4));
          (%o2)                               true
          (%i3) is_tree(graph_union(random_tree(4), random_tree(5)));
          (%o3)                               false

 -- Función: laplacian_matrix (<gr>)
     Devuelve el laplaciano de la matriz del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) laplacian_matrix(cycle_graph(5));
                                    [  2   - 1   0    0   - 1 ]
                                    [                         ]
                                    [ - 1   2   - 1   0    0  ]
                                    [                         ]
          (%o2)                     [  0   - 1   2   - 1   0  ]
                                    [                         ]
                                    [  0    0   - 1   2   - 1 ]
                                    [                         ]
                                    [ - 1   0    0   - 1   2  ]

 -- Función: max_clique (<gr>)
     Devuelve el clique máximo del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : random_graph(100, 0.5)$
          (%i3) max_clique(g);
          (%o3)       [6, 12, 31, 36, 52, 59, 62, 63, 80]

 -- Función: max_degree (<gr>)
     Devuelve el grado máximo de los vértices del grafo <gr> y un
     vértice de grado máximo.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : random_graph(100, 0.02)$
          (%i3) max_degree(g);
          (%o3)                        [6, 79]
          (%i4) vertex_degree(95, g);
          (%o4)                           3

 -- Función: max_flow (<net>, <s>, <t>)
     Devuelve el flujo maximal de la red <net> con origen en <s> y
     final en <t>.

     La función devuelve el valor del flujo maximal y una lista con los
     pesos de los arcos del flujo óptimo.

     Ejemplo:

     Example:
          (%i1) load (graphs)$
          (%i2) net : create_graph(
            [1,2,3,4,5,6],
            [[[1,2], 1.0],
             [[1,3], 0.3],
             [[2,4], 0.2],
             [[2,5], 0.3],
             [[3,4], 0.1],
             [[3,5], 0.1],
             [[4,6], 1.0],
             [[5,6], 1.0]],
            directed=true)$
          (%i3) [flow_value, flow] : max_flow(net, 1, 6);
          (%o3) [0.7, [[[1, 2], 0.5], [[1, 3], 0.2], [[2, 4], 0.2],
          [[2, 5], 0.3], [[3, 4], 0.1], [[3, 5], 0.1], [[4, 6], 0.3],
          [[5, 6], 0.4]]]
          (%i4) fl : 0$
          (%i5) for u in out_neighbors(1, net)
                   do fl : fl + assoc([1, u], flow)$
          (%i6) fl;
          (%o6)                                 0.7

 -- Función: max_independent_set (<gr>)
     Devuelve un conjunto maximal independiente de vértices del grafo
     <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) d : dodecahedron_graph()$
          (%i3) mi : max_independent_set(d);
          (%o3)             [0, 3, 5, 9, 10, 11, 18, 19]
          (%i4) draw_graph(d, show_vertices=mi)$

 -- Función: max_matching (<gr>)
     Devuelve un conjunto maximal independiente de aristas del grafo
     <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) d : dodecahedron_graph()$
          (%i3) m : max_matching(d);
          (%o3) [[5, 7], [8, 9], [6, 10], [14, 19], [13, 18], [12, 17],
                                         [11, 16], [0, 15], [3, 4], [1, 2]]
          (%i4) draw_graph(d, show_edges=m)$

 -- Función: min_degree (<gr>)
     Devuelve el grado mínimo de los vértices del grafo <gr> y un
     vértice de grado mínimo.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : random_graph(100, 0.1)$
          (%i3) min_degree(g);
          (%o3)                              [3, 49]
          (%i4) vertex_degree(21, g);
          (%o4)                                 9

 -- Función: min_edge_cut (<gr>)
     Devuelve el mínimo edge cut del grafo <gr>. Un edge cut es un
     conjunto de aristas cuya eliminación aumenta el número de
     componentes del grafo.

     Véase también `edge_connectivity'.

 -- Función: min_vertex_cover (<gr>)
     Devuelve el mínimo nodo covering del grafo <gr>.

 -- Función: min_vertex_cut (<gr>)
     Devuelve el mínimo vertex cut del grafo <gr>.

     Véase también `vertex_connectivity'.

 -- Función: minimum_spanning_tree (<gr>)
     Devuelve el grafo de expansión mínimo del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : graph_product(path_graph(10), path_graph(10))$
          (%i3) t : minimum_spanning_tree(g)$
          (%i4) draw_graph(g, show_edges=edges(t))$

 -- Función: neighbors (<v>, <gr>)
     Devuelve la lista de los vecinos del vértice <v> del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) p : petersen_graph()$
          (%i3) neighbors(3, p);
          (%o3)                             [4, 8, 2]

 -- Función: odd_girth (<gr>)
     Devuelve la longitud del ciclo impar más corto del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : graph_product(cycle_graph(4), cycle_graph(7))$
          (%i3) girth(g);
          (%o3)                                 4
          (%i4) odd_girth(g);
          (%o4)                                 7

 -- Función: out_neighbors (<v>, <gr>)
     Devuelve la lista de los nodos padres del vértice <v> del grafo
     orientado <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) p : path_digraph(3)$
          (%i3) in_neighbors(2, p);
          (%o3)                                 [1]
          (%i4) out_neighbors(2, p);
          (%o4)                                 []

 -- Función: planar_embedding (<gr>)
     Devuelve la lista de caminos faciales en una proyección planar de
     <gr>, o `false' si <gr> no es un grafo planar.

     El grafo <gr> debe estar biconectado.

     El algoritmo utilizado es el de Demoucron, que es de tiempo
     cuadrático.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) planar_embedding(grid_graph(3,3));
          (%o2) [[3, 6, 7, 8, 5, 2, 1, 0], [4, 3, 0, 1], [3, 4, 7, 6],
                                                [8, 7, 4, 5], [1, 2, 5, 4]]

 -- Función: print_graph (<gr>)
     Muestra alguna información sobre el grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) c5 : cycle_graph(5)$
          (%i3) print_graph(c5)$
          Graph on 5 vertices with 5 edges.
          Adjacencies:
            4 :  0  3
            3 :  4  2
            2 :  3  1
            1 :  2  0
            0 :  4  1
          (%i4) dc5 : cycle_digraph(5)$
          (%i5) print_graph(dc5)$
          Digraph on 5 vertices with 5 arcs.
          Adjacencies:
            4 :  0
            3 :  4
            2 :  3
            1 :  2
            0 :  1
          (%i6) out_neighbors(0, dc5);
          (%o6)                                [1]

 -- Función: radius (<gr>)
     Devuelve el radio del grafo  <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) radius(dodecahedron_graph());
          (%o2)                                 5

 -- Función: set_edge_weight (<e>, <w>, <gr>)
     Asigna el peso <w> a la arista <e> del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : create_graph([1, 2], [[[1,2], 1.2]])$
          (%i3) get_edge_weight([1,2], g);
          (%o3)                                1.2
          (%i4) set_edge_weight([1,2], 2.1, g);
          (%o4)                               done
          (%i5) get_edge_weight([1,2], g);
          (%o5)                                2.1

 -- Función: set_vertex_label (<v>, <l>, <gr>)
     Asigna la etiqueta <l> al vértice <v> del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : create_graph([[1, "One"], [2, "Two"]], [[1,2]])$
          (%i3) get_vertex_label(1, g);
          (%o3)                                One
          (%i4) set_vertex_label(1, "oNE", g);
          (%o4)                               done
          (%i5) get_vertex_label(1, g);
          (%o5)                                oNE

 -- Función: shortest_path (<u>, <v>, <gr>)
     Devuelve el camino más corto desde <u> hasta <v> del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) d : dodecahedron_graph()$
          (%i3) path : shortest_path(0, 7, d);
          (%o3)                          [0, 1, 19, 13, 7]
          (%i4) draw_graph(d, show_edges=vertices_to_path(path))$

 -- Función: shortest_weighted_path (<u>, <v>, <gr>)
     Devuelve la longitud del camino más corto ponderado y el propio
     camino más corto ponderado desde <u> hasta <v> en el grafo <gr>.

     La longitud del camino ponderado es la suma de los pesos de las
     aristas del camino. Si una arista no tiene peso asignado, su valor
     por defecto es la unidad.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g: petersen_graph(20, 2)$
          (%i3) for e in edges(g) do set_edge_weight(e, random(1.0), g)$
          (%i4) shortest_weighted_path(0, 10, g);
          (%o4) [2.575143920268482, [0, 20, 38, 36, 34, 32, 30, 10]]


 -- Función: strong_components (<gr>)
     Devuelve las componentes fuertes del grafo orientado <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) t : random_tournament(4)$
          (%i3) strong_components(t);
          (%o3)                         [[1], [0], [2], [3]]
          (%i4) vertex_out_degree(3, t);
          (%o4)                                 3

 -- Función: topological_sort (<dag>)
     Devuelve el orden topológico de los vértices del grafo orientado
     <dag> o una lista vacía si <dag> no es un grafo orientado acíclico.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g:create_graph(
                   [1,2,3,4,5],
                   [
                    [1,2], [2,5], [5,3],
                    [5,4], [3,4], [1,3]
                   ],
                   directed=true)$
          (%i3) topological_sort(g);
          (%o3)                           [1, 2, 5, 3, 4]

 -- Función: vertex_connectivity (<g>)
     Devuelve la conectividad de los vértices del grafo <g>.

     Véase también `min_vertex_cut'.

 -- Función: vertex_degree (<v>, <gr>)
     Devuelve el grado del vértice <v> del grafo <gr>.

 -- Función: vertex_distance (<u>, <v>, <gr>)
     Devuelve la longitud del camino más corto entre <u> y <v> del
     grafo o digrafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) d : dodecahedron_graph()$
          (%i3) vertex_distance(0, 7, d);
          (%o3)                                 4
          (%i4) shortest_path(0, 7, d);
          (%o4)                         [0, 1, 19, 13, 7]

 -- Función: vertex_eccentricity (<v>, <gr>)
     Devuelve la excentricidad del vértice <v> del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g:cycle_graph(7)$
          (%i3) vertex_eccentricity(0, g);
          (%o3)                           3

 -- Función: vertex_in_degree (<v>, <gr>)
     Devuelve el grado de entrada del vértice <v> del grafo orientado
     <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) p5 : path_digraph(5)$
          (%i3) print_graph(p5)$
          Digraph on 5 vertices with 4 arcs.
          Adjacencies:
            4 :
            3 :  4
            2 :  3
            1 :  2
            0 :  1
          (%i4) vertex_in_degree(4, p5);
          (%o4)                                 1
          (%i5) in_neighbors(4, p5);
          (%o5)                                [3]

 -- Función: vertex_out_degree (<v>, <gr>)
     Devuelve el grado de salida del vértice <v> del grafo orientado
     <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) t : random_tournament(10)$
          (%i3) vertex_out_degree(0, t);
          (%o3)                           2
          (%i4) out_neighbors(0, t);
          (%o4)                        [7, 1]

 -- Función: vertices (<gr>)
     Devuelve la lista de vértices del grafo <gr>.

     Example

          (%i1) load (graphs)$
          (%i2) vertices(complete_graph(4));
          (%o2)                           [3, 2, 1, 0]

 -- Función: vertex_coloring (<gr>)
     Devuelve un coloreado óptimo de los vértices del grafo <gr>.

     La función devuelve el número cromático y una lista representando
     el coloreado de los vértices de <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) p:petersen_graph()$
          (%i3) vertex_coloring(p);
          (%o3) [3, [[0, 2], [1, 3], [2, 2], [3, 3], [4, 1], [5, 3],
                                           [6, 1], [7, 1], [8, 2], [9, 2]]]

 -- Función: wiener_index (<gr>)
     Devuelve el índice de Wiener del grafo <gr>.

     Ejemplo:

          (%i1) wiener_index(dodecahedron_graph());
          (%o1)                          500

55.2.3 Modificación de grafos
-----------------------------

 -- Función: add_edge (<e>, <gr>)
     Añade la arista <e> al grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) p : path_graph(4)$
          (%i3) neighbors(0, p);
          (%o3)                                [1]
          (%i4) add_edge([0,3], p);
          (%o4)                               done
          (%i5) neighbors(0, p);
          (%o5)                              [3, 1]

 -- Función: add_edges (<e_list>, <gr>)
     Añade las aristas de la lista  <e_list> al grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : empty_graph(3)$
          (%i3) add_edges([[0,1],[1,2]], g)$
          (%i4) print_graph(g)$
          Graph on 3 vertices with 2 edges.
          Adjacencies:
            2 :  1
            1 :  2  0
            0 :  1

 -- Función: add_vertex (<v>, <gr>)
     Añade el vértice <v> al grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : path_graph(2)$
          (%i3) add_vertex(2, g)$
          (%i4) print_graph(g)$
          Graph on 3 vertices with 1 edges.
          Adjacencies:
            2 :
            1 :  0
            0 :  1

 -- Función: add_vertices (<v_list>, <gr>)
     Añade los vértices de la lista  <v_list> al grafo <gr>.

 -- Función: connect_vertices (<v_list>, <u_list>, <gr>)
     Conecta todos los vértices de la lista <v_list> con los vértices
     de la lista <u_list> del grafo <gr>.

     <v_list> y <u_list> pueden ser vértices aislados o una lista de
     vértices.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : empty_graph(4)$
          (%i3) connect_vertices(0, [1,2,3], g)$
          (%i4) print_graph(g)$
          Graph on 4 vertices with 3 edges.
          Adjacencies:
            3 :  0
            2 :  0
            1 :  0
            0 :  3  2  1

 -- Función: contract_edge (<e>, <gr>)
     Contrae la arista <e> del <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g: create_graph(
                 8, [[0,3],[1,3],[2,3],[3,4],[4,5],[4,6],[4,7]])$
          (%i3) print_graph(g)$
          Graph on 8 vertices with 7 edges.
          Adjacencies:
            7 :  4
            6 :  4
            5 :  4
            4 :  7  6  5  3
            3 :  4  2  1  0
            2 :  3
            1 :  3
            0 :  3
          (%i4) contract_edge([3,4], g)$
          (%i5) print_graph(g)$
          Graph on 7 vertices with 6 edges.
          Adjacencies:
            7 :  3
            6 :  3
            5 :  3
            3 :  5  6  7  2  1  0
            2 :  3
            1 :  3
            0 :  3

 -- Función: remove_edge (<e>, <gr>)
     Elimina la arista <e> del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) c3 : cycle_graph(3)$
          (%i3) remove_edge([0,1], c3)$
          (%i4) print_graph(c3)$
          Graph on 3 vertices with 2 edges.
          Adjacencies:
            2 :  0  1
            1 :  2
            0 :  2

 -- Función: remove_vertex (<v>, <gr>)
     Elimina el vértice <v> del grafo <gr>.

 -- Función: vertex_coloring (<gr>)
     Devuelve un coloreado óptimo de los vértice del grafo <gr>.

     La función devuelve el número cromático y una lista representando
     el coloreado de los vértices de <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) p:petersen_graph()$
          (%i3) vertex_coloring(p);
          (%o3) [3, [[0, 2], [1, 3], [2, 2], [3, 3], [4, 1], [5, 3],
                                          [6, 1], [7, 1], [8, 2], [9, 2]]]

55.2.4 Lectura y escritura de ficheros
--------------------------------------

 -- Función: dimacs_export (<gr>, <fl>)
 -- Función: dimacs_export (<gr>, <fl>, <comment1>, ..., <commentn>)
     Exporta el grafo al fichero <fl> en formato DIMACS. Los comentarios
     adicionales se anãdirán al comienzo del fichero.

 -- Función: dimacs_import (<fl>)
     Lee el grafo almacenado en el fichero <fl> en formato DIMACS.

 -- Función: graph6_decode (<str>)
     Devuelve el grafo codificado en formato graph6 en la cadena <str>.

 -- Función: graph6_encode (<gr>)
     Devuelve una cadena codificando el grafo <gr> en formato graph6.

 -- Función: graph6_export (<gr_list>, <fl>)
     Exporta los grafos de la lista <gr_list> al fichero <fl> en
     formato graph6.

 -- Función: graph6_import (<fl>)
     Lee la lista de grafos almacenados en el fichero <fl> en formato
     graph6.

 -- Función: sparse6_decode (<str>)
     Devuelve el grafo codificado en formato sparse6 en la cadena <str>.

 -- Función: sparse6_encode (<gr>)
     Devuelve una cadena codificando el grafo <gr> en formato sparse6.

 -- Función: sparse6_export (<gr_list>, <fl>)
     Exporta los grafos de la lista <gr_list> al fichero <fl> en
     formato sparse6.

 -- Función: sparse6_import (<fl>)
     Lee la lista de grafos almacenados en el fichero <fl> en formato
     sparse6.

55.2.5 Visualización
--------------------

 -- Función: draw_graph (<graph>)
 -- Función: draw_graph (<graph>, <option1>, ..., <optionk>)
     Dibuja el grafo utilizando el paquete `draw'.

     El algoritmo utilizado para posicionar los vértices se especifica
     con el argumento opcional <program>, cuyo valor por defecto es
     `program=spring_embedding'.  <draw_graph> también puede utilizar
     los programas de graphviz para posicionar los vértices, para lo
     cual deberá instalarse separadamente el programa graphviz.

     Ejemplo 1:

          (%i1) load (graphs)$
          (%i2) g:grid_graph(10,10)$
          (%i3) m:max_matching(g)$
          (%i4) draw_graph(g,
             spring_embedding_depth=100,
             show_edges=m, edge_type=dots,
             vertex_size=0)$

     Ejemplo 2:

          (%i1) load (graphs)$
          (%i2) g:create_graph(16,
              [
               [0,1],[1,3],[2,3],[0,2],[3,4],[2,4],
               [5,6],[6,4],[4,7],[6,7],[7,8],[7,10],[7,11],
               [8,10],[11,10],[8,9],[11,12],[9,15],[12,13],
               [10,14],[15,14],[13,14]
              ])$
          (%i3) t:minimum_spanning_tree(g)$
          (%i4) draw_graph(
              g,
              show_edges=edges(t),
              show_edge_width=4,
              show_edge_color=green,
              vertex_type=filled_square,
              vertex_size=2
              )$

     Ejemplo 3:

          (%i1) load (graphs)$
          (%i2) mi : max_independent_set(g)$
          (%i3) draw_graph(
              g,
              show_vertices=mi,
              show_vertex_type=filled_up_triangle,
              show_vertex_size=2,
              edge_color=cyan,
              edge_width=3,
              =true,
              text_color=brown
              )$

     Ejemplo 4:

          (%i1) load (graphs)$
          (%i2) net : create_graph(
              [0,1,2,3,4,5],
              [
               [[0,1], 3], [[0,2], 2],
               [[1,3], 1], [[1,4], 3],
               [[2,3], 2], [[2,4], 2],
               [[4,5], 2], [[3,5], 2]
              ],
              directed=true
              )$
          (%i3) draw_graph(
              net,
              show_weight=true,
              vertex_size=0,
              show_vertices=[0,5],
              show_vertex_type=filled_square,
              head_length=0.2,
              head_angle=10,
              edge_color="dark-green",
              text_color=blue
              )$

     Ejemplo 5:

          (%i1) load(graphs)$
          (%i2) g: petersen_graph(20, 2);
          (%o2)                         GRAPH
          (%i3) draw_graph(g, redraw=true, program=planar_embedding);
          (%o3)                         done

     Ejemplo 6:

          (%i1) load(graphs)$
          (%i2) t: tutte_graph();
          (%o2)                         GRAPH
          (%i3) draw_graph(t, redraw=true,
                              fixed_vertices=[1,2,3,4,5,6,7,8,9]);
          (%o3)                         done


 -- Variable opcional: draw_graph_program
     Valor por defecto: <spring_embedding>

     Programa a utilizar por defecto para posicionar los vértices en la
     función `draw_graph'.

 -- Opción de draw_graph: show_id
     Valor por defecto: <false>

     Si <show_id> vale <true> entonces se muestran los números
     identificadores de los vértices.

 -- Opción de draw_graph: show_label
     Valor por defecto: <false>

     Si <show_label> vale <true> entonces se muestran las etiquetas de
     los vértices.

 -- Opción de draw_graph: label_alignment
     Valor por defecto: <center>

     Indica cómo se deben alinear las etiquetas o números
     identificadores de los vértices. Puede ser: `left', `center' or
     `right'.

 -- Opción de draw_graph: show_weight
     Valor por defecto: <false>

     si <show_weight> vale <true> entonces se mostrarán los pesos de
     las aristas.

 -- Opción de draw_graph: vertex_type
     Valor por defecto: <circle>

     Establece cómo se mostrarán los vértices. Véase la opción
     <point_type> del paquete `draw'.

 -- Opción de draw_graph: vertex_size
     Tamanõ de los vértices.

 -- Opción de draw_graph: vertex_color
     Color a utilizar en los vértices.

 -- Opción de draw_graph: show_vertices
     Valor por defecto: []

     Dibuja los vértices seleccionados en la lista con colores
     diferentes.

 -- Opción de draw_graph: show_vertex_type
     Establece cómo se mostrarán los vértices de <show_vertices>. Véase
     la opción <point_type> del paquete `draw'.

 -- Opción de draw_graph: show_vertex_size
     Tamanõs de los vértices de <show_vertices>.

 -- Opción de draw_graph: show_vertex_color
     Color a utilizar en los vértices de la lista <show_vertices>.

 -- Opción de draw_graph: vertex_partition
     Valor por defecto: []

     Una partición `[[v1,v2,...],...,[vk,...,vn]]' de los vértices del
     grafo. Los vértices de cada lista se dibujarán de diferente color.

 -- Opción de draw_graph: vertex_coloring
     Colores de los vértices. Los colores <col> deben especificarse en
     el mismo formato que el devuelto por <vertex_coloring>.

 -- Opción de draw_graph: edge_color
     Color a utilizar en las aristas.

 -- Opción de draw_graph: edge_width
     Ancho de las aristas.

 -- Opción de draw_graph: edge_type
     Establece cómo se dibujarán las aristas. Véase la opción
     <line_type> del paquete `draw'.

 -- Opción de draw_graph: show_edges
     Dibuja las aristas de la lista <e_list> con colores diferentes.

 -- Opción de draw_graph: show_edge_color
     Color a utilizar en las aristas de la lista <show_edges>.

 -- Opción de draw_graph: show_edge_width
     Anchos de las aristas de <show_edges>.

 -- Opción de draw_graph: show_edge_type
     Establece cómo se dibujarán las aristas de <show_edges>.  Véase la
     opción <line_type> del paquete `draw'.

 -- Opción de draw_graph: edge_partition
     Una partición `[[e1,e2,...],...,[ek,...,em]]' de las aristas del
     grafo.  Las aristas de cada lista se dibujarán de diferente color.

 -- Opción de draw_graph: edge_coloring
     Colores de las aristas. Los colores <col> deben especificarse en
     el mismo formato que el devuelto por <edge_coloring>.

 -- Opción de draw_graph: redraw
     Valor por defecto: <false>

     Si <redraw> vale `true', las posiciones de los vértices se
     recalculan incluso si las posiciones están almacenadas de un
     dibujo previo del grafo.

 -- Opción de draw_graph: head_angle
     Valor por defecto: 15

     Ángulo de las flechas de los arcos en los grafos orientados.

 -- Opción de draw_graph: head_length
     Valor por defecto: 0.1

     Longitud de las flechas de los arcos en los grafos orientados.

 -- Opción de draw_graph: spring_embedding_depth
     Valor por defecto: 50

     Número de iteraciones del algoritmo de dibujo de grafos.

 -- Opción de draw_graph: terminal
     Terminal utilizado para ver el gráfo. Véase la opción <terminal>
     del paquete `draw'.

 -- Opción de draw_graph: file_name
     Nombre del fichero cuando el terminal especificado no es la
     pantalla.

 -- Opción de draw_graph: program
     establece el programa para posicionado de vértices del grafo.
     Puede ser cualquiera de los programas graphviz (dot, neato, twopi,
     circ, fdp), <circular> o <spring_embedding> o <planar_embedding>;
     <planar_embedding> sl'o está disponible para grafos planares
     2-conectados. Si `program=spring_embedding', se puede especificar
     un conjunto de vértices de posición fija con la opción
     <fixed_vertices>.

 -- Opción de draw_graph: fixed_vertices
     Especifica una lista de vértices con posiciones fijas en un
     polígono regular. Se puede utilizar cuando
     `program=spring_embedding'.

 -- Función: vertices_to_path (<v_list>)
     Convierte una lista <v_list> de vértices en la lista de aristas
     del camino definido por la propia <v_list>.

 -- Función: vertices_to_cycle (<v_list>)
     Convierte una lista <v_list> de vértices en la lista de aristas
     del ciclo definido por la propia <v_list>.


File: maxima.info,  Node: grobner,  Next: impdiff,  Prev: graphs,  Up: Top

56 grobner
**********

* Menu:

* Introducción a grobner::
* Funciones y variables para grobner::


File: maxima.info,  Node: Introducción a grobner,  Next: Funciones y variables para grobner,  Prev: Top,  Up: Top

56.1 Introducción a grobner
===========================

`grobner' es un paquete para operar con bases de Groebner en Maxima.

Para hacer uso de las funciones de este paquete es necesario cargar
previamente el archivo `grobner.lisp':

     load(grobner);

Es posible ejecutar una demostración haciendo
     demo("grobner.demo");

o
     batch("grobner.demo")

Algunos de los cálculos de la demostración pueden llevar tiempo, razón
por la cual sus resultados se han guardado en el archivo
`grobner-demo.output', que se encuentra en el mismo directorio que el
archivo de demostración.

56.1.1 Notas sobre el paquete grobner
-------------------------------------

El autor del paquete es

Marek Rychlik

`http://alamos.math.arizona.edu'

habiendo sido distribuido el 24-05-2002 bajo los términos de la General
Public License (GPL) (ver archivo `grobner.lisp'). Esta documentación
ha sido extraída de los archivos
`README', `grobner.lisp', `grobner.demo' y `grobner-demo.output'

por Günter Nowak. Las sugerencias para mejorar la documentación se
pueden hacer en la lista de correos de _maxima_,
<maxima@math.utexas.edu>.

   El código está algo anticuado. Las implementaciones modernas utilizan
el algoritmo _F4_, más rápido, descrito en
A new efficient algorithm for computing Gröbner bases (F4)
Jean-Charles Faugère
LIP6/CNRS Université Paris VI
January 20, 1999

56.1.2 Implementaciones de órdenes admisibles de monomios
---------------------------------------------------------

   * `lex'

     lexicográfico puro; orden por defecto para la comparación de
     monomios.

   * `grlex'

     grado total, con empates resueltos por el orden lexicográfico.

   * `grevlex'

     grado total, con empates resueltos por el orden lexicográfico
     inverso.

   * `invlex'

     orden lexicográfico inverso.



File: maxima.info,  Node: Funciones y variables para grobner,  Prev: Introducción a grobner,  Up: Top

56.2 Funciones y variables para grobner
=======================================

56.2.1 Variables opcionales
---------------------------

 -- Variable opcional: poly_monomial_order
     Valor por defecto: `lex'

     Controla qué orden de monomios utiliza en los cálculos con
     polinomios y bases de Groebner. Si no se le asigna valor alguno,
     se utilizará `lex'.

 -- Variable opcional: poly_coefficient_ring
     Valor por defecto: `expression_ring'

     Indica el anillo de coeficientes de los polinomios que se va a
     utilizar en los cálculos. Si no se le asigna ningún valor, se
     utilizará el anillo de expresiones propio de _maxima_.  A esta
     variable se le puede asignar el valor `ring_of_integers'.

 -- Variable opcional: poly_primary_elimination_order
     Valor por defecto: `false'

     Nombre del orden por defecto para las variables eliminadas en las
     funciones basadas en eliminaciones. Si no se le asigna ningún
     valor, se utilizará `lex'.

 -- Variable opcional: poly_secondary_elimination_order
     Valor por defecto: `false'

     Nombre del orden por defecto para las variables almacenadas en
     funciones basadas en eliminaciones. Si no se le asigna ningún
     valor, se utilizará `lex'.

 -- Variable opcional: poly_elimination_order
     Valor por defecto: `false'

     Nombre del orden de eliminación por defecto utilizado en los
     cálculos de eliminación. Si se le asigna un valor, ignorará los
     guardados en `poly_primary_elimination_order' y
     `poly_secondary_elimination_order'.  El usuario se asegurará que
     este es un orden válido de eliminación.

 -- Variable opcional: poly_return_term_list
     Valor por defecto: `false'

     Si vale `true', todas las funciones de este paquete devolverán los
     polinomios como una lista de términos en el orden activo de
     monomios, en lugar de una expresión ordinaria de _maxima_.

 -- Variable opcional: poly_grobner_debug
     Valor por defecto: `false'

     Si vale `true', genera una salida de seguimiento y depuración.

 -- Variable opcional: poly_grobner_algorithm
     Valor por defecto: `buchberger'

     Valores posibles:
        * `buchberger'

        * `parallel_buchberger'

        * `gebauer_moeller'

     Es el nombre del algoritmo utilizado para encontrar las bases de
     Groebner.

 -- Variable opcional: poly_top_reduction_only
     Valor por defecto: `false'

     Si no vale `false', siempre que sea posible el algoritmo de
     división se detendrá tras la primera reducción.

56.2.2 Operadores simples
-------------------------

`poly_add', `poly_subtract', `poly_multiply' y `poly_expt' son los
operadores aritméticos para polinomios. Se ejecutan utilizando la
representación interna, pero los resultados se devuelven en forma de
expresión ordinaria de _maxima_.

 -- Función: poly_add (<poly1>, <poly2>, <varlist>)
     Suma los polinomios <poly1> y <poly2>.

          (%i1) poly_add(z+x^2*y,x-z,[x,y,z]);
                                              2
          (%o1)                              x  y + x


 -- Función: poly_subtract (<poly1>, <poly2>, <varlist>)
     Resta el polinomio <poly2> de <poly1>.

          (%i1) poly_subtract(z+x^2*y,x-z,[x,y,z]);
                                                2
          (%o1)                          2 z + x  y - x

 -- Función: poly_multiply (<poly1>, <poly2>, <varlist>)
     Multiplica <poly1> por <poly2>.

          (%i2) poly_multiply(z+x^2*y,x-z,[x,y,z])-(z+x^2*y)*(x-z),expand;
          (%o1)                                  0

 -- Función: poly_s_polynomial (<poly1>, <poly2>, <varlist>)
     Devuelve el _polinomio syzygy_ (_S-polinomio_) de dos polinomios
     <poly1> y <poly2>.

 -- Función: poly_primitive_part (<poly1>, <varlist>)
     Devuelve el polinomio <poly> dividido por el MCD de sus
     coeficientes.

          (%i1) poly_primitive_part(35*y+21*x,[x,y]);
          (%o1)                              5 y + 3 x

 -- Función: poly_normalize (<poly>, <varlist>)
     Devuelve el polinomio <poly> dividido por el coeficiente
     principal. Da por supuesto que la división es posible, lo cual
     puede no ser siempre cierto en anillos que no son campos.

56.2.3 Otras funciones
----------------------

 -- Función: poly_expand (<poly>, <varlist>)
     Esta función expande los polinomios. Equivale a `expand(<poly>)'
     si <poly> es un polinomio. Si la representación no es compatible
     con un polinomio de variables <varlist>, devuelve un error.

          (%i1) poly_expand((x-y)*(y+x),[x,y]);
                                               2    2
          (%o1)                               x  - y
          (%i2) poly_expand((y+x)^2,[x,y]);
                                          2            2
          (%o2)                          y  + 2 x y + x
          (%i3) poly_expand((y+x)^5,[x,y]);
                            5      4         2  3       3  2      4      5
          (%o3)            y  + 5 x y  + 10 x  y  + 10 x  y  + 5 x  y + x
          (%i4) poly_expand(-1-x*exp(y)+x^2/sqrt(y),[x]);
                                                    2
                                            y      x
          (%o4)                       - x %e  + ------- - 1
                                                 sqrt(y)

          (%i5) poly_expand(-1-sin(x)^2+sin(x),[sin(x)]);
                                          2
          (%o5)                      - sin (x) + sin(x) - 1

 -- Función: poly_expt (<poly>, <number>, <varlist>)
     Eleva el polinomio <poly> a la potencia <number>, siendo este un
     entero positivo. Si <number> no es un número entero positivo,
     devolverá un error.

          (%i1) poly_expt(x-y,3,[x,y])-(x-y)^3,expand;
          (%o1)                                  0

 -- Función: poly_content (<poly>. <varlist>)
     `poly_content' calcula el MCD de los coeficientes.

          (%i1) poly_content(35*y+21*x,[x,y]);
          (%o1)                                  7

 -- Función: poly_pseudo_divide (<poly>, <polylist>, <varlist>)
     Realiza la seudo-división del polinomio <poly> por la lista de n
     polinomios de <polylist>.  Devuelve varios resultados. El primer
     resultado es una lista de cocientes a. El segundo resultado es el
     resto r. El tercer resultado es un coeficiente escalar c, tal que
     c*poly puede dividirse por <polylist> dentro del anillo de
     coeficientes, el cual no es necesariamente un campo. Por último,
     el cuarto resultado es un entero que guarda el recuento de
     reducciones realizadas. El objeto resultante satisface la ecuación:

     c*poly=sum(a[i]*polylist[i],i=1...n)+r.

 -- Función: poly_exact_divide (<poly1>, <poly2>, <varlist>)
     Divide el polinomio <poly1> por otro polinomio <poly2>. Da por
     supuesto que es posible la división de resto nulo. Devuelve el
     cociente.

 -- Función: poly_normal_form (<poly>, <polylist>, <varlist>)
     `poly_normal_form' encuentra la forma normal de un polinomio
     <poly> respecto de un conjunto de polinomios <polylist>.

 -- Función: poly_buchberger_criterion (<polylist>, <varlist>)
     Devuelve `true' si <polylist> es una base de Groebner respecto del
     orden de términos activo, utilizando el criterio de Buchberger:
     para cualesquiera polinomios h1 y h2 de <polylist> el S-polinomio
     S(h1,h2) se reduce a 0 modulo <polylist>.


 -- Función: poly_buchberger (<polylist_fl> <varlist>)
     `poly_buchberger' ejecuta el algoritmo de Buchberger sobre una
     lista de polinomios y devuelve la base de Groebner resultante.


56.2.4 Postprocesamiento estándar de bases de Groebner
------------------------------------------------------

El _k-ésimo ideal de eliminación_ I_k de un ideal I sobre K[
x[1],...,x[n] ] es el ideal intersect(I, K[ x[k+1],...,x[n] ]).
El _ideal_ I:J es el ideal {h|para todo w en J: w*h pertence a I}.
El ideal I:p^inf es el ideal {h| existe un n en N: p^n*h pertence a I}.
El ideal I:J^inf es el ideal {h| existe un n en N y un p en J: p^n*h
pertence a I}.
El _ideal radical_ sqrt(I) es el ideal {h| existe un n en N : h^n
pertence a I }.



 -- Función: poly_reduction (<polylist>, <varlist>)
     `poly_reduction' reduce una lista de polinomios <polylist> de
     manera que cada polinomio se reduce completamente respecto de los
     otros polinomios.

 -- Función: poly_minimization (<polylist>, <varlist>)
     Devuelve una sublista de la lista de polinomios <polylist> con el
     mismo ideal de monomios que <polylist>, pero mínimo, esto es,
     ningún monomio principal de los polinomios de la sublista divide a
     los monomios principales de los demás polinomios.


 -- Función: poly_normalize_list (<polylist>, <varlist>)
     `poly_normalize_list' aplica `poly_normalize' a cada polinomio de
     la lista. Esto significa que divide cada polinomio de <polylist>
     por su coeficiente principal.


 -- Función: poly_grobner (<polylist>, <varlist>)
     Devuelve la base de Groebner del ideal asociado a los polinomios
     de <polylist>. El resultado depende de las variables globales.

 -- Función: poly_reduced_grobner (<polylist>, <varlist>)
     Devuelve la base de Groebner reducida del ideal asociado a los
     polinomios de <polylist>. El resultado depende de las variables
     globales.

 -- Función: poly_depends_p (<poly>, <var>, <varlist>)
     `poly_depends' comprueba si el polinomio depende de la variable
     <var>.

 -- Función: poly_elimination_ideal (<polylist>, <n>, <varlist>)
     `poly_elimination_ideal' devuelve la base de Groebner del n-ésimo
     ideal de eliminación de un ideal especificado como una lista de
     polinomios generadores (no necesariamente una base de Groebner).

 -- Función: poly_colon_ideal (<polylist1>, <polylist2>, <varlist>)
     Devuelve la base de Groebner reducida del ideal

     I(polylist1):I(polylist2)

     siendo polylist1 y polylist2 dos listas de polinomios.

 -- Función: poly_ideal_intersection (<polylist1>, <polylist2>,
          <varlist>)
     `poly_ideal_intersection' devuelve la intersección de dos ideales.

 -- Función: poly_lcm (<poly1>, <poly2>, <varlist>)
     Devuelve el MCM de <poly1> y <poly2>.

 -- Función: poly_gcd (<poly1>, <poly2>, <varlist>)
     Devuelve el MCD de <poly1> y <poly2>.

     Véanse también `ezgcd', `gcd', `gcdex' y `gcdivide'.

     Ejemplo:

          (%i1) p1:6*x^3+19*x^2+19*x+6;
                                  3       2
          (%o1)                6 x  + 19 x  + 19 x + 6
          (%i2) p2:6*x^5+13*x^4+12*x^3+13*x^2+6*x;
                            5       4       3       2
          (%o2)          6 x  + 13 x  + 12 x  + 13 x  + 6 x
          (%i3) poly_gcd(p1, p2, [x]);
                                      2
          (%o3)                    6 x  + 13 x + 6

 -- Función: poly_grobner_equal (<polylist1>, <polylist2>, <varlist>)
     `poly_grobner_equal' comprueba si dos bases de Groebner generan el
     mismo ideal. Devuelve `true' si dos listas de polinomios
     <polylist1> y <polylist2>, supuestas bases de Groebner, generan el
     mismo ideal, o `false' en caso contrario.  Eso equivale a
     comprobar si cada polinomio de la primera base se reduce a 0
     módulo la segunda base y viceversa. Nótese que en el ejemplo que
     sigue la primera lista no es una base de Groebner, por lo que el
     resultado es `false'.

          (%i1) poly_grobner_equal([y+x,x-y],[x,y],[x,y]);
          (%o1)                         false


 -- Función: poly_grobner_subsetp (<polylist1>, <polylist2>, <varlist>)
     `poly_grobner_subsetp' comprueba si el ideal generado por
     <polylist1> está contenido en el ideal generado por <polylist2>.
     Para que esta comprobación tenga éxito, <polylist2> debe ser una
     base de Groebner.

 -- Función: poly_grobner_member (<poly>, <polylist>, <varlist>)
     Devuelve `true' si el polinomio <poly> pertenece al ideal generado
     por la lista de polinomios <polylist>, la cual se supone una base
     de Groebner.  Devolverá `false' en caso contrario.

 -- Función: poly_ideal_saturation1 (<polylist>, <poly>, <varlist>)
     Devuelve la base de Groebner reducida de la saturación del ideal

     I(polylist):poly^inf

     Desde un punto de vista geométrico, sobre un campo algebraicamente
     cerrado, este es el conjunto de polinomios del ideal generado por
     <polylist> que no se anulan sobre la variedad de  <poly>.

 -- Función: poly_ideal_saturation (<polylist1>, <polylist2>, <varlist>)
     Devuelve la base de Groebner reducida de la saturación del ideal

     I(polylist1):I(polylist2)^inf

     Desde un punto de vista geométrico, sobre un campo algebraicamente
     cerrado, este es el conjunto de polinomios del ideal generado por
     <polylist1> que no se anulan sobre la variedad de  <polylist2>.

 -- Función: poly_ideal_polysaturation1 (<polylist1>, <polylist2>,
          <varlist>)
     <polylist2> es una lista de n poliomios `[poly1,...,polyn]'.
     Devuelve la base de Groebner reducida del ideal

     I(polylist):poly1^inf:...:polyn^inf

     obtenida a partir de una secuencia de saturaciones sucesivas de
     los polinomios de la lista <polylist2> del ideal generado por la
     lista de polinomios <polylist1>.

 -- Función: poly_ideal_polysaturation (<polylist>, <polylistlist>,
          <varlist>)
     <polylistlist> es una lista de n listas de polinomios
     `[polylist1,...,polylistn]'.  Devuelve la base de Groebner
     reducida de la saturación del ideal

     I(polylist):I(polylist_1)^inf:...:I(polylist_n)^inf

 -- Función: poly_saturation_extension (<poly>, <polylist>, <varlist1>,
          <varlist2>)
     `poly_saturation_extension' ejecuta el truco de Rabinowitz.

 -- Función: poly_polysaturation_extension (<poly>, <polylist>,
          <varlist1>, <varlist2>)


File: maxima.info,  Node: impdiff,  Next: interpol,  Prev: grobner,  Up: Top

57 impdiff
**********

* Menu:

* Funciones y variables para impdiff::


File: maxima.info,  Node: Funciones y variables para impdiff,  Prev: impdiff,  Up: impdiff

57.1 Funciones y variables para impdiff
=======================================

 -- Función: implicit_derivative (<f>,<indvarlist>,<orderlist>,<depvar>)
     Calcula las derivadas implícitas de funciones multivariantes. <f>
     es una función array, los índices son los grados de las derivadas
     en el orden establecido en <indvarlist>, <indvarlist> es la lista
     de variables independientes, <orderlist> es el orden deseado y
     <depvar> es la variable dependiente.

     Antes de hacer uso de esta función ejecútese  `load("impdiff")'.



File: maxima.info,  Node: interpol,  Next: lapack,  Prev: impdiff,  Up: Top

58 interpol
***********

* Menu:

* Introducción a interpol::
* Funciones y variables para interpol::


File: maxima.info,  Node: Introducción a interpol,  Next: Funciones y variables para interpol,  Prev: interpol,  Up: interpol

58.1 Introducción a interpol
============================

El paquete `interpol' desarrolla los métodos de interpolación
polinómica de Lagrange, lineal y de splines cúbicos.

   Para comentarios, fallos o sugerencias, contactar con <'mario ARROBA
edu PUNTO xunta PUNTO es'>.



Local Variables:
coding: iso-8859-1
End:
