This is maxima.info, produced by makeinfo version 4.13 from maxima.texi.

Ver. 5.30 Este es el Manual de Maxima en versión Texinfo

   Copyright 1994, 2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).  Un sistema de cálculo simbólico
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Funciones y variables para expresiones,  Prev: Desigualdades,  Up: Expresiones

8.5 Funciones y variables para expresiones
==========================================

 -- Función: alias (<new_name_1>, <old_name_1>, ..., <new_name_n>,
          <old_name_n>)
     provee un nombre alternativo para una (bien sea definida por el
     usuario o por el sistema) función, variable, arreglo, etc.
     Cualquier número par de argumentos puede ser usado.

 -- Variable del sistema: aliases
     Valor por defecto: `[]'

     La variable `aliases' es la lista de átomos que tienen un "alias"
     definido por el usuario (establecido mediante las funciones
     `alias', `ordergreat' o `orderless' o declarando el átomo como un
     `noun' (nombre) con `declare'.

 -- Clave: allbut
     Opera con los comandos `part' (como `part', `inpart', `substpart',
     `substinpart', `dpart' y `lpart'). Por ejemplo:

          (%i1) expr : e + d + c + b + a;
          (%o1)                   e + d + c + b + a
          (%i2) part (expr, [2, 5]);
          (%o2)                         d + a

     mientras que:

          (%i1) expr : e + d + c + b + a;
          (%o1)                   e + d + c + b + a
          (%i2) part (expr, allbut (2, 5));
          (%o2)                       e + c + b

     La función `kill' también reconoce a `allbut'.

          (%i1) [aa : 11, bb : 22, cc : 33, dd : 44, ee : 55];
          (%o1)                 [11, 22, 33, 44, 55]
          (%i2) kill (allbut (cc, dd));
          (%o0)                         done
          (%i1) [aa, bb, cc, dd];
          (%o1)                   [aa, bb, 33, 44]

     La sentencia `kill(allbut(<a_1>, <a_2>, ...))' tiene el mismo
     efecto que `kill(all)', excepto que no elimina los símbolos <a_1>,
     <a_2>, ... .


 -- Función: args (<expr>)
     Devuelve la lista de argumentos de `expr', que puede ser cualquier
     tipo de expresión a excepción de un átomo. Tan solo se muestran
     los argumentos del operador principal; subexpresiones de `expr'
     aparecen como elementos o subexpresiones de elementos de la lista
     de argumentos.

     El orden de los miembros de la lista puede depender de la variable
     global `inflag'.

     La llamada `args (<expr>)' es equivalente a `substpart ("[",
     <expr>, 0)'.

     Véanse también `substpart' y `op'.


 -- Función: atom (<expr>)
     Devuelve `true' si <expr> es un átomo (número, nombre o cadena
     alfanumérica) y `false' en caso contario. Así, `atom(5)' devolverá
     `true', mientras que `atom(a[1])' y `atom(sin(x))' darán como
     resultado `false' (dando por hecho que tanto `a[1]' como `x' no
     tienen valores asignados).


 -- Función: box (<expr>)
 -- Función: box (<expr>, <a>)
     Devuelve <expr> encerrada en una caja.  El valor devuelto es una
     expresión con `box' como operador y <expr> como argumento.  Se
     dibujará una caja cuando `display2d' valga `true'.

     La llamada `box (<expr>, <a>)' encierra <expr> en una caja
     etiquetada con el símbolo <a>.  La etiqueta se recorta si es más
     larga que el ancho de la caja.

     La función `box' evalúa su argumento. Sin embargo, la expresión
     encerrada no se evalúa, siendo excluída de los cálculos.

     La variable `boxchar' guarda el carácter a utilizar para dibujar
     la caja en las funciones `box', `dpart' y `lpart'.

     Ejemplos:

          (%i1) box (a^2 + b^2);
                                      """""""""
                                      " 2    2"
          (%o1)                       "b  + a "
                                      """""""""
          (%i2) a : 1234;
          (%o2)                         1234
          (%i3) b : c - d;
          (%o3)                         c - d
          (%i4) box (a^2 + b^2);
                                """"""""""""""""""""
                                "       2          "
          (%o4)                 "(c - d)  + 1522756"
                                """"""""""""""""""""
          (%i5) box (a^2 + b^2, term_1);
                                term_1""""""""""""""
                                "       2          "
          (%o5)                 "(c - d)  + 1522756"
                                """"""""""""""""""""
          (%i6) 1729 - box (1729);
                                           """"""
          (%o6)                     1729 - "1729"
                                           """"""
          (%i7) boxchar: "-";
          (%o7)                           -
          (%i8) box (sin(x) + cos(y));
                                  -----------------
          (%o8)                   -cos(y) + sin(x)-
                                  -----------------


 -- Variable opcional: boxchar
     Valor por defecto: `"'

     La variable `boxchar' guarda el carácter a utilizar para dibujar
     la caja en las funciones `box', `dpart' y `lpart'.

     Todas las cajas en una expresión se dibujan con el valor actual de
     `boxchar', carácter que no se almacena con las expresión encerrada.


 -- Función: collapse (<expr>)
     Colapsa <expr> haciendo que todas las subexpresiones que sean
     iguales compartan las mismas celdas, ahorrando espacio. `collapse'
     es una subrutina utilizada por la instrucción `optimize'. El uso de
     `collapse' puede ser útil después de  cargar un fichero creado con
     `save'. Se pueden colapsar varias expresiones de forma conjunta
     utilizando `collapse ([<expr_1>, ..., <expr_n>])'.  También se
     pueden colapsar los elementos del array `A' haciendo `collapse
     (listarray ('A))'.

 -- Función: disolate (<expr>, <x_1>, ..., <x_n>)
     Es similar a `isolate (<expr>, <x>)', excepto que permite al
     usuario aislar más de una variable simultáneamente. Puede ser útil
     para hacer un cambio de variables en integrales múltiples en las
     que tales variables dependan de de dos o más variables de
     integración.  Esta función se carga automáticamente desde
     `simplification/disol.mac'.  Se dispone de una demostyración en
     `demo("disol")$'.


 -- Función: dispform (<expr>)
 -- Function: dispform (<expr>, all)
     `dispform(<expr>)' devuelve la representación externa de <expr>
     respecto del operador del nivel superior.  `dispform(<expr>, all)'
     devuelve la representación externa respecto de todos los
     operadores que haya en <expr>.

     Véase también `part', `inpart' y `inflag'.

     Ejemplos:

     La representación interna de `- x' es "menos uno multiplicado por
     `x'", mientras que la representación externa es "menos `x'".

          (%i1) - x;
          (%o1)                          - x
          (%i2) ?format (true, "~S~%", %);
          ((MTIMES SIMP) -1 $X)
          (%o2)                         false
          (%i3) dispform (- x);
          (%o3)                          - x
          (%i4) ?format (true, "~S~%", %);
          ((MMINUS SIMP) $X)
          (%o4)                         false

     La representación interna de `sqrt(x)' es "`x' elevado a 1/2",
     mientras que su representación externa es "raíz de `x'".

          (%i1) sqrt (x);
          (%o1)                        sqrt(x)
          (%i2) ?format (true, "~S~%", %);
          ((MEXPT SIMP) $X ((RAT SIMP) 1 2))
          (%o2)                         false
          (%i3) dispform (sqrt (x));
          (%o3)                        sqrt(x)
          (%i4) ?format (true, "~S~%", %);
          ((%SQRT SIMP) $X)
          (%o4)                         false

     Utilización del argumento opcional `all'.

          (%i1) expr : sin (sqrt (x));
          (%o1)                     sin(sqrt(x))
          (%i2) freeof (sqrt, expr);
          (%o2)                         true
          (%i3) freeof (sqrt, dispform (expr));
          (%o3)                         true
          (%i4) freeof (sqrt, dispform (expr, all));
          (%o4)                         false

 -- Función: dpart (<expr>, <n_1>, ..., <n_k>)
     Selecciona la misma expresión que `part', pero en lugar de
     devolver esa expresión como su valor, devuelve la expresión
     completa con la subexpresión seleccionada dentro de una caja. La
     caja es parte de la expresión.

          (%i1) dpart (x+y/z^2, 1, 2, 1);
                                       y
          (%o1)                       ---- + x
                                         2
                                      """
                                      "z"
                                      """

 -- Variable opcional: exptisolate
     Valor por defecto: `false'

     Véase `isolate'.


 -- Variable opcional: exptsubst
     Valor por defecto: `false'

     Si `exptsubst' vale `true' permite la sustitución `y' por `%e^x'
     en `%e^(a x)'.


 -- Función: freeof (<x_1>, ..., <x_n>, <expr>)
     `freeof (<x_1>, <expr>)' devuelve `true' si ninguna subexpresión
     de <expr> coincide con <x_1>, o si <x_1> aparece como variable
     muda en <expr>, o si <x_1> no es ni una forma nominal ni verbal de
     cualesquiera operadores presentes en <expr>, devolviendo `false'
     en otro caso.

     La llamada `freeof (<x_1>, ..., <x_n>, <expr>)' equivale a `freeof
     (<x_1>, <expr>) and ... and freeof (<x_n>, <expr>)'.

     Los argumentos <x_1>, ..., <x_n> pueden seer nombres de funciones
     y variables, nombres subindicados, operadores (encerrados entre
     comillas dobles) o expresiones generales.

     La función `freeof' evalúa sus argumentos.

     Una variable es una variable muda en una expresión si no tiene
     valor asignado fuera de la expresión.  Variable mudas reconocidas
     por  `freeof' son el índice de una suma o producto, la variable
     límite en `limit', la variable de integración en la versión de
     integral definida de `integrate', la variable original en
     `laplace', variables formales en expresiones `at' y los argumentos
     de las expresiones  `lambda'.

     La versión indefinida de  `integrate' no está libre de su variable
     de integración.

     Ejemplos:

     Los argumentos son nombres de funciones, variables, nombres
     subindicados, operaores y expresiones. La llamada `freeof (a, b,
     expr)' equivale a `freeof (a, expr) and freeof (b, expr)'.

          (%i1) expr: z^3 * cos (a[1]) * b^(c+d);
                                           d + c  3
          (%o1)                   cos(a ) b      z
                                       1
          (%i2) freeof (z, expr);
          (%o2)                         false
          (%i3) freeof (cos, expr);
          (%o3)                         false
          (%i4) freeof (a[1], expr);
          (%o4)                         false
          (%i5) freeof (cos (a[1]), expr);
          (%o5)                         false
          (%i6) freeof (b^(c+d), expr);
          (%o6)                         false
          (%i7) freeof ("^", expr);
          (%o7)                         false
          (%i8) freeof (w, sin, a[2], sin (a[2]), b*(c+d), expr);
          (%o8)                         true

     `freeof' evalúa sus argumentos.

          (%i1) expr: (a+b)^5$
          (%i2) c: a$
          (%i3) freeof (c, expr);
          (%o3)                         false

     `freeof' no considera funciones equivalentes.  La simplificación
     puede dar una expresión equivalente pero diferente.

          (%i1) expr: (a+b)^5$
          (%i2) expand (expr);
                    5        4       2  3       3  2      4      5
          (%o2)    b  + 5 a b  + 10 a  b  + 10 a  b  + 5 a  b + a
          (%i3) freeof (a+b, %);
          (%o3)                         true
          (%i4) freeof (a+b, expr);
          (%o4)                         false
          (%i5) exp (x);
                                           x
          (%o5)                          %e
          (%i6) freeof (exp, exp (x));
          (%o6)                         true

     Un sumatorio o integral definida está libre de su variable muda.
     Una integral indefinida de  `integrate' no está libre de su
     variable de integración.

          (%i1) freeof (i, 'sum (f(i), i, 0, n));
          (%o1)                         true
          (%i2) freeof (x, 'integrate (x^2, x, 0, 1));
          (%o2)                         true
          (%i3) freeof (x, 'integrate (x^2, x));
          (%o3)                         false

 -- Variable opcional: inflag
     Valor por defecto: `false'

     Si `inflag' vale `true', las funciones para la extracción de
     partes inspeccionan la forma interna de `expr'.

     Nótese que el simplificador reordena expresiones.  Así,  `first (x
     + y)' devuelve `x' si `inflag' vale `true' y `y' si `inflag' vale
     `false'.  (`first (y + x)' devuelve el mismo resultado.)

     Además, dándole a  `inflag' el valor `true' y llamando a `part' o
     a `substpart' es lo mismo que llamar a `inpart' o a `substinpart'.

     Las funciones que se ven afectadas por el valor de `inflag' son:
     `part', `substpart', `first', `rest', `last', `length', la
     construcción `for' ... `in', `map', `fullmap', `maplist', `reveal'
     y `pickapart'.


 -- Función: inpart (<expr>, <n_1>, ..., <n_k>)
     Similar a `part', pero trabaja con la representación interna de la
     expresión, siendo más rápida. Se debe tener cuidado con el orden
     de subexpresiones en sumas y productos, pues el orden de las
     variables en la forma interna es normalmente diferente al que se
     muestra por el terminal, y cuando se trata con el signo menos
     unario, resta y división, pues estos operadores desaparecen de la
     expresión. Las llamadas `part (x+y, 0)' o `inpart (x+y, 0)'
     devuelven `+', siendo necesario encerrar el operador entre
     comillas dobles cuando se haga referencia aél. Por ejemplo, `...
     if inpart (%o9,0) = "+" then ...'.

     Ejemplos:

          (%i1) x + y + w*z;
          (%o1)                      w z + y + x
          (%i2) inpart (%, 3, 2);
          (%o2)                           z
          (%i3) part (%th (2), 1, 2);
          (%o3)                           z
          (%i4) 'limit (f(x)^g(x+1), x, 0, minus);
                                            g(x + 1)
          (%o4)                 limit   f(x)
                                x -> 0-
          (%i5) inpart (%, 1, 2);
          (%o5)                       g(x + 1)


 -- Función: isolate (<expr>, <x>)
     Devuelve <expr> con subexpresiones que son sumas y que no
     contienen variables reemplazadas por etiquetas de expresiones
     intermedias (tales etiquetas son símbolos atómicos como `%t1',
     `%t2', ...).  Esta función es de utilidad para evitar la expansión
     innecesaria de subexpresiones que no contienen la variable de
     interés. Puesto que las etiquetas intermedias toman el valor de
     subexpresiones pueden ser todas sustituidas evaluando la expresión
     en la que aparecen.

     Si la variable `exptisolate', cuyo valor por defecto es `false',
     vale `true' hará que `isolate' busque exponentes de átomos (como
     `%e') que contengan la variable.

     Si `isolate_wrt_times' vale `true', entonces `isolate' también
     aislará respecto de los productos. Véase `isolate_wrt_times'.

     Para ejemplos, ejecútese `example (isolate)'.


 -- Variable opcional: isolate_wrt_times
     Valor por defecto: `false'

     Si `isolate_wrt_times' vale `true', entonces `isolate' también
     aislará respecto de los productos. Compárese el comportamiento de
     `isolate' al cambiar el valor de esta variable global en el
     siguiente ejemplo,

          (%i1) isolate_wrt_times: true$
          (%i2) isolate (expand ((a+b+c)^2), c);

          (%t2)                          2 a


          (%t3)                          2 b


                                    2            2
          (%t4)                    b  + 2 a b + a

                               2
          (%o4)               c  + %t3 c + %t2 c + %t4
          (%i4) isolate_wrt_times: false$
          (%i5) isolate (expand ((a+b+c)^2), c);
                               2
          (%o5)               c  + 2 b c + 2 a c + %t4


 -- Variable opcional: listconstvars
     Valor por defecto: `false'

     Si `listconstvars' vale `true', hará que `listofvars' incluya
     `%e', `%pi', `%i' y cualquier otra variable que sea declarada
     constante de las que aparezcan en el argumento de `listofvars'.
     Estas constantes se omiten por defecto.


 -- Variable opcional: listdummyvars
     Valor por defecto: `true'

     Si `listdummyvars' vale `false', las "variables mudas" de la
     expresión no serán incluídas en la lista devuelta por
     `listofvars'. (La definición de "variables mudas" se encuentra en
     la descripción de `freeof'.  "Variables mudas" son objetos
     matemáticos como el índice de un sumatorio o producto, una
     variable límite o la variable de una integración definida.)
     Ejemplo:

          (%i1) listdummyvars: true$
          (%i2) listofvars ('sum(f(i), i, 0, n));
          (%o2)                        [i, n]
          (%i3) listdummyvars: false$
          (%i4) listofvars ('sum(f(i), i, 0, n));
          (%o4)                          [n]


 -- Función: listofvars (<expr>)
     Devuelve una lista con las variables presentes en <expr>.

     Si la variable `listconstvars' vale `true' entonces `listofvars'
     incluirá `%e', `%pi', `%i' y cualquier otra variable declarada
     constante de las que aparezcan en <expr>.  Estas constantes se
     omiten por defecto.

     Véase también la variable opcional `listdummyvars' para excluir o
     incluir variables ficticias en la lista de variables.

     Ejemplo:

          (%i1) listofvars (f (x[1]+y) / g^(2+a));
          (%o1)                     [g, a, x , y]
                                            1


 -- Función: lfreeof (<list>, <expr>)
     Para cada miembro  <m> de <list>, realiza la llamada `freeof (<m>,
     <expr>)'.  Devuelve `false' si alguna de estas llamadas a `freeof'
     retornó `false', y `true' en caso contrario.

 -- Función: lpart (<label>, <expr>, <n_1>, ..., <n_k>)
     Similar a `dpart' pero utiliza una caja etiquetada. Una caja
     etiquetada es similar a la que produce `dpart', pero con un nombre
     en la línea superior.

 -- Propiedad: mainvar
     Se pueden declarar variables de tipo `mainvar'.  El orden de los
     átomos es: números < constantes (como `%e' o `%pi') < escalares <
     otras variables < "mainvars".  Por ejemplo, compárese `expand
     ((X+Y)^4)' con `(declare (x, mainvar), expand ((x+y)^4))'.  (Nota:
     Se debe tener cuidado si se quiere hacer uso de esta declaración.
     Por ejemplo, si se resta una expresión en la que `x' ha sido
     declarada como `mainvar' de otra en la que `x' no es `mainvar',
     puede ser necesario volver a simplificar, `ev (expr, simp)', a fin
     de obtener cancelaciones.  Además, si se guarda una expresión en
     la que `x' es `mainvar', quizás sea necesario guardar también `x'.)


 -- Propiedad: noun
     El símbolo `noun' es una de las opciones de la instrucción
     `declare'. Hace que una función se declare como "nombre", lo que
     significa que no se evaluará automáticamente.


 -- Variable opcional: noundisp
     Valor por defecto: `false'

     Si `noundisp' vale `true', los nombres se muestran precedidos de
     un apóstrofo. Siempre debe valer `true' cuando se quiera
     representar la definición de funciones.


 -- Función: nounify (<f>)
     Devuelve la forma nominal de la función cuyo nombre es <f>.  Puede
     ser útil cuando se quiera hacer referencia al nombre de una
     función sin que ésta se ejecute.  Nótese que algunas funciones
     verbales devolverán su forma nominal si no pueden ser evaluadas
     para ciertos argumentos.  Esta es también la expresión que se
     obtiene cuando la llamada a una función va precedida por del
     apóstrofo.


 -- Función: nterms (<expr>)
     Devuelve el número de términos que  <expr> llegaría a tener si
     fuese completamente expandida y no hubiesen cancelaciones ni
     combinaciones de términos semejantes.  Nótese que expresiones como
     `sin (<expr>)', `sqrt (<expr>)', `exp (<expr>)', etc.  cuentan
     como un sólo término, independientemente de cuántos términos tenga
     a su vez <expr> en caso de tratarse de una suma.


 -- Función: op (<expr>)
     Devuelve el operador principal de la expresión <expr>. La llamada
     `op (<expr>)' equivale a `part (<expr>, 0)'.

     La función `op' devuelve una cadena si el operador principal es un
     operador prefijo, infijo (binario o `n'-ario), postfijo, "bi-fijo"
     o "no-fijo" ("bi-fijo"  se refiere a un par de símbolos que
     encierran su o sus argumentos, y "no-fijo" es un operador que no
     necesita argumentos).  Si <expr> es la expresión de una función
     subindicada, `op' devuelve la función subindicada; en cuyo caso el
     valor devuelto no es un átomo.  En otro caso, <expr> es la
     expresión de una función array u ordinaria, y entonces `op'
     devuelve un símbolo.

     La función `op' observa el valor de la variable global `inflag'.

     La función `op' evalúa sus argumentos.

     Véase también `args'.

     Ejemplos:

          (%i1) stringdisp: true$
          (%i2) op (a * b * c);
          (%o2)                          "*"
          (%i3) op (a * b + c);
          (%o3)                          "+"
          (%i4) op ('sin (a + b));
          (%o4)                          sin
          (%i5) op (a!);
          (%o5)                          "!"
          (%i6) op (-a);
          (%o6)                          "-"
          (%i7) op ([a, b, c]);
          (%o7)                          "["
          (%i8) op ('(if a > b then c else d));
          (%o8)                         "if"
          (%i9) op ('foo (a));
          (%o9)                          foo
          (%i10) prefix (foo);
          (%o10)                        "foo"
          (%i11) op (foo a);
          (%o11)                        "foo"
          (%i12) op (F [x, y] (a, b, c));
          (%o12)                        F
                                         x, y
          (%i13) op (G [u, v, w]);
          (%o13)                          G


 -- Función: operatorp (<expr>, <op>)
 -- Función: operatorp (<expr>, [<op_1>, ..., <op_n>])
     La llamada `operatorp (<expr>, <op>)' devuelve `true' si <op> es
     igual al operador de <expr>.

     La llamada `operatorp (<expr>, [<op_1>, ..., <op_n>])' devuelve
     `true' si algún elemento  <op_1>, ..., <op_n> es igual al operador
     de <expr>.


 -- Variable opcional: opsubst
     Valor por defecto: `true'

     Si `opsubst' vale `false', `subst' no sustituye el operdor de una
     expresión, de manera que `(opsubst: false, subst (x^2, r,
     r+r[0]))' trabajará correctamente.


 -- Función: optimize (<expr>)
     Devuelve una expresión que produce el mismo valor y efectos
     secundarios que <expr>, pero de forma más eficiente al evitar
     recalcular subexpresiones comunes. La función `optimize' también
     tiene el efecto secundario de colapsar su argumento de manera que
     se compartan todas sus subexpresiones comunes.  Hágase `example
     (optimize)' para ver ejemplos.


 -- Variable opcional: optimprefix
     Valor por defecto: `%'

     La variable `optimprefix' es el prefijo utilizado para los
     símbolos generados por la instrucción `optimize'.


 -- Función: ordergreat (<v_1>, ..., <v_n>)
 -- Función: orderless (<v_1>, ..., <v_n>)
     `ordergreat' cambia el orden canónico de las expresiones de
     Maxima, de manera que <v_1> prevalece sobre <v_2>, que prevalece
     sobre ..., que prevalece sobre <v_n>, que prevalece sobre
     cualquier otro símbolo no presente en la lista de argumentos.

     `orderless' cambia el orden canónico de las expresiones de Maxima,
     de manera que <v_1> precede a <v_2>, que precede a ..., que
     precede a <v_n>, que precede a cualquier otra variable no presente
     en la lista de argumentos.

     El orden impuesto por `ordergreat' y `orderless' se destruye con
     `unorder'. `ordergreat' y `orderless' sólo se pueden llamar una
     vez, a menos que se invoque a `unorder'.  La última llamada a
     `ordergreat' y `orderless' es la que se mantiene activa.

     Véase también `ordergreatp'.


 -- Función: ordergreatp (<expr_1>, <expr_2>)
 -- Función: orderlessp (<expr_1>, <expr_2>)
     `ordergreatp' devuelve `true' si <expr_1> prevalece sobre <expr_2>
     en el orden canónico de las expresiones de Maxima, o `false' en
     caso contrario.

     `orderlessp' devuelve `true' si <expr_1> precede a <expr_2> en el
     orden canónico de las expresiones de Maxima, o `false' en caso
     contrario.

     Todos los átomos y expresiones de Maxima son comparables bajo
     `ordergreatp' y `orderlessp', aunque existen ejemplos aislados de
     expresiones para los que estos predicados no son transitivos.

     La ordenación canónica de átomos (símbolos, números literales y
     cadenas) es la siguiente: (enteros y decimales en coma flotante)
     preceden a (números decimales grandes o bigfloats), que preceden a
     (constantes declaradas), que preceden a (cadenas), que preceden a
     (escalares declarados), que preceden a (primer argumento de
     `orderless'), que precede a ..., que precede a (último argumento
     de `orderless'), que precede a (otros símbolos), que preceden a
     (último argumento de `ordergreat'), que precede a ..., que precede
     a (primer argumento de `ordergreat'), que precede a (variables
     principales declaradas).

     Para las expresiones no atómicas, la ordenación canónica se deriva
     de la ordenación de átomos. Para los operadores nativos `+', `*' y
     `^', los criterios de ordenación no son sencillos de resumir.
     Para otros operadores nativos, y todas las demás funciones y
     operadores, las expresiones se ordenan por sus argumentos
     (empezando por el primero), después por el nombre del operador o
     función. En caso de expresiones con subíndices, el símbolo
     subindicado se considera operador y el subíndice un argumento del
     mismo.

     El orden canónico de expresiones se modifica mediante las funciones
     `ordergreat' y `orderless', así como por las declaraciones
     `mainvar', `constant' y `scalar'.

     Véase también `sort'.

     Ejemplos:

     Ordenación de símbolos comunes y constantes.  Nótese que `%pi' no
     se ordena en función de su valor numérico.

          (%i1) stringdisp : true;
          (%o1)                         true
          (%i2) sort ([%pi, 3b0, 3.0, x, X, "foo", 3, a, 4, "bar", 4.0, 4b0]);
          (%o2) [3, 3.0, 4, 4.0, 3.0b0, 4.0b0, %pi, "bar", "foo", a, x, X]

     Efecto producido por las funciones `ordergreat' y `orderless'.

          (%i1) sort ([M, H, K, T, E, W, G, A, P, J, S]);
          (%o1)           [A, E, G, H, J, K, M, P, S, T, W]
          (%i2) ordergreat (S, J);
          (%o2)                         done
          (%i3) orderless (M, H);
          (%o3)                         done
          (%i4) sort ([M, H, K, T, E, W, G, A, P, J, S]);
          (%o4)           [M, H, A, E, G, K, P, T, W, J, S]

     Efecto producido por las declaraciones `mainvar', `constant' y
     `scalar'.

          (%i1) sort ([aa, foo, bar, bb, baz, quux, cc, dd, A1, B1, C1]);
          (%o1)   [aa, bar, baz, bb, cc, dd, foo, quux, A1, B1, C1]
          (%i2) declare (aa, mainvar);
          (%o2)                         done
          (%i3) declare ([baz, quux], constant);
          (%o3)                         done
          (%i4) declare ([A1, B1], scalar);
          (%o4)                         done
          (%i5) sort ([aa, foo, bar, bb, baz, quux, cc, dd, A1, B1, C1]);
          (%o5)   [baz, quux, A1, B1, bar, bb, cc, dd, foo, C1, aa]

     Ordenación de expresiones no atómicas.

          (%i1) sort ([1, 2, n, f(1), f(2), f(2, 1), g(1), g(1, 2), g(n), f(n, 1)]);
          (%o1) [1, 2, f(1), g(1), g(1, 2), f(2), f(2, 1), n, g(n),
                                                                   f(n, 1)]
          (%i2) sort ([foo(1), X[1], X[k], foo(k), 1, k]);
          (%o2)            [1, foo(1), X , k, foo(k), X ]
                                        1              k

 -- Función: part (<expr>, <n_1>, ..., <n_k>)
     Devuelve partes de la forma mostrada de `expr'. Obtiene la parte
     de `expr' que se especifica por los índices <n_1>, ..., <n_k>.
     Primero se obtiene la parte <n_1> de `expr', después la parte
     <n_2> del resultado anterior, y así sucesivamente.  El resultado
     que se obtiene es la parte <n_k> de ... la parte <n_2> de la parte
     <n_1> de `expr'.  Si no se especifican índices, devuelve `expr'.

     La función `part' se puede utilizar para obtener un elemento de
     una lista, una fila de una matriz, etc.

     Si el último argumento de la función `part' es una lista de
     índices, entonces se toman varias subexpresiones, cada una de las
     cuales correspondiente a un índice de la lista.  Así, `part (x + y
     + z, [1, 3])' devuelve `z+x'.

     La variable `piece' guarda la última expresión seleccionada con la
     función `part'. Se actualiza durante la ejecución de la función,
     por lo que puede ser referenciada en la misma función.

     Si `partswitch' vale `true' entonces de devuelve `end' cuando no
     exista la parte seleccionada de una expresión, si vale `false' se
     mostrará un mensaje de error.

     Véanse también `inpart', `substpart', `substinpart', `dpart' y
     `lpart'.

     Ejemplos:

          (%i1) part(z+2*y+a,2);
          (%o1)                                 2 y
          (%i2) part(z+2*y+a,[1,3]);
          (%o2)                                z + a
          (%i3) part(z+2*y+a,2,1);
          (%o3)                                  2

     La instrucción `example (part)' muestra más ejemplos.


 -- Función: partition (<expr>, <x>)
     Devuelve una lista con dos expresiones, que son: (1) los factores
     de <expr> si es un producto, los términos de <expr> si es una
     suma, o los elementos de <expr>, si es una lista, que no contengan
     a <x>, (2) los factores, términos o lista que contengan a <x>.

          (%i1) partition (2*a*x*f(x), x);
          (%o1)                     [2 a, x f(x)]
          (%i2) partition (a+b, x);
          (%o2)                      [b + a, 0]
          (%i3) partition ([a, b, f(a), c], a);
          (%o3)                  [[b, c], [a, f(a)]]


 -- Variable opcional: partswitch
     Valor por defecto: `false'

     Si `partswitch' vale `true' entonces de devuelve `end' cuando no
     exista la parte seleccionada de una expresión, si vale `false' se
     mostrará un mensaje de error.


 -- Función: pickapart (<expr>, <n>)
     Asigna etiquetas de expresiones intermedias a subexpresiones de
     <expr> al nivel de profundidad <n>, que es un entero. A las
     subexpresiones a un nivel de profundidad mayor o menor no se les
     asignan etiquetas. La función `pickapart' devuelve una expresión
     en términos de expresiones intermedias equivalente a la expresión
     original <expr>.

     Véanse también `part', `dpart', `lpart', `inpart' y `reveal'.

     Ejemplos:

          (%i1) expr: (a+b)/2 + sin (x^2)/3 - log (1 + sqrt(x+1));
                                                    2
                                               sin(x )   b + a
          (%o1)       - log(sqrt(x + 1) + 1) + ------- + -----
                                                  3        2
          (%i2) pickapart (expr, 0);

                                                    2
                                               sin(x )   b + a
          (%t2)       - log(sqrt(x + 1) + 1) + ------- + -----
                                                  3        2

          (%o2)                          %t2
          (%i3) pickapart (expr, 1);

          (%t3)                - log(sqrt(x + 1) + 1)


                                            2
                                       sin(x )
          (%t4)                        -------
                                          3


                                        b + a
          (%t5)                         -----
                                          2

          (%o5)                    %t5 + %t4 + %t3
          (%i5) pickapart (expr, 2);

          (%t6)                 log(sqrt(x + 1) + 1)


                                            2
          (%t7)                        sin(x )


          (%t8)                         b + a

                                   %t8   %t7
          (%o8)                    --- + --- - %t6
                                    2     3
          (%i8) pickapart (expr, 3);

          (%t9)                    sqrt(x + 1) + 1


                                          2
          (%t10)                         x

                            b + a              sin(%t10)
          (%o10)            ----- - log(%t9) + ---------
                              2                    3
          (%i10) pickapart (expr, 4);

          (%t11)                     sqrt(x + 1)

                                2
                           sin(x )   b + a
          (%o11)           ------- + ----- - log(%t11 + 1)
                              3        2
          (%i11) pickapart (expr, 5);

          (%t12)                        x + 1

                             2
                        sin(x )   b + a
          (%o12)        ------- + ----- - log(sqrt(%t12) + 1)
                           3        2
          (%i12) pickapart (expr, 6);
                            2
                       sin(x )   b + a
          (%o12)       ------- + ----- - log(sqrt(x + 1) + 1)
                          3        2


 -- Variable del sistema: piece
     Guarda la última expresión seleccionada por las funciones `part'.


 -- Función: psubst (<list>, <expr>)
 -- Función: psubst (<a>, <b>, <expr>)
     `psubst(<a>, <b>, <expr>)' es simliar a `subst'.  Véase `subst'.

     A diferencia de `subst', la función `psubst' hace sustituciones en
     paralelo si su primer argumento es una lista de ecuaciones.

     Véase también `sublis' para hacer sustituciones en paralelo.

     Ejemplo:

     El primer ejemplo muestra la sustitución en paralelo con `psubst'.
     El segundo ejemplo muestra el resultado de la función `subst', que
     realiza la sustitución en serie.

          (%i4) psubst ([a^2=b, b=a], sin(a^2) + sin(b));
          (%o4)                           sin(b) + sin(a)
          (%i5) subst ([a^2=b, b=a], sin(a^2) + sin(b));
          (%o5)                              2 sin(a)


 -- Función: rembox (<expr>, unlabelled)
 -- Función: rembox (<expr>, <label>)
 -- Función: rembox (<expr>)
     Elimina cajas de <expr>.

     La llamada `rembox (<expr>, unlabelled)' elimina todas las cajas
     no etiquetadas de <expr>.

     La llamada `rembox (<expr>, <label>)' sólo elimina las cajas
     etiquetadas con <label>.

     La llamada `rembox (<expr>)' elimina todas las caajs,
     independientemente de que estén etiquetadas o no.

     Las cajas son dibujadas por las funciones `box', `dpart' y `lpart'.

     Ejemplos:

          (%i1) expr: (a*d - b*c)/h^2 + sin(%pi*x);
                                            a d - b c
          (%o1)                sin(%pi x) + ---------
                                                2
                                               h
          (%i2) dpart (dpart (expr, 1, 1), 2, 2);
                                  """""""    a d - b c
          (%o2)               sin("%pi x") + ---------
                                  """""""      """"
                                               " 2"
                                               "h "
                                               """"
          (%i3) expr2: lpart (BAR, lpart (FOO, %, 1), 2);
                            FOO"""""""""""   BAR""""""""
                            "    """"""" "   "a d - b c"
          (%o3)             "sin("%pi x")" + "---------"
                            "    """"""" "   "  """"   "
                            """"""""""""""   "  " 2"   "
                                             "  "h "   "
                                             "  """"   "
                                             """""""""""
          (%i4) rembox (expr2, unlabelled);
                                            BAR""""""""
                             FOO"""""""""   "a d - b c"
          (%o4)              "sin(%pi x)" + "---------"
                             """"""""""""   "    2    "
                                            "   h     "
                                            """""""""""
          (%i5) rembox (expr2, FOO);
                                            BAR""""""""
                                 """""""    "a d - b c"
          (%o5)              sin("%pi x") + "---------"
                                 """""""    "  """"   "
                                            "  " 2"   "
                                            "  "h "   "
                                            "  """"   "
                                            """""""""""
          (%i6) rembox (expr2, BAR);
                             FOO"""""""""""
                             "    """"""" "   a d - b c
          (%o6)              "sin("%pi x")" + ---------
                             "    """"""" "     """"
                             """"""""""""""     " 2"
                                                "h "
                                                """"
          (%i7) rembox (expr2);
                                            a d - b c
          (%o7)                sin(%pi x) + ---------
                                                2
                                               h


 -- Función: reveal (<expr>, <nivel>)
     Reemplaza partes de <expr> al <nivel> especificado y las sutituye
     por descripciones cortas.

        * Las sumas y restas se reemplazan por `Sum(<n>)', siendo <n>
          el número de términos de la suma.

        * Los productos se reemplazan por `Product(<n>)', siendo <n> el
          número de factores del producto.

        * Las potencias se reemplazan por `Expt'.

        * Los cocientes se reemplazan por `Quotient'.

        * El símbolo negativo se reemplaza por `Negterm'.

        * Las listas se reemplazan por `List(<n>)', siendo <n> el
          número de elementos de la lista.

     Si el entero  <depth> es mayor o igual que la profundidad máxima
     de <expr>, `reveal (<expr>, <depth>)' devuelve <expr> sin
     modificar.

     La función `reveal' evalúa sus argumentos y devuelve la expresión
     con las modificaciones solicitadas.

     Ejemplo:

          (%i1) e: expand ((a - b)^2)/expand ((exp(a) + exp(b))^2);
                                    2            2
                                   b  - 2 a b + a
          (%o1)               -------------------------
                                  b + a     2 b     2 a
                              2 %e      + %e    + %e
          (%i2) reveal (e, 1);
          (%o2)                       Quotient
          (%i3) reveal (e, 2);
                                       Sum(3)
          (%o3)                        ------
                                       Sum(3)
          (%i4) reveal (e, 3);
                               Expt + Negterm + Expt
          (%o4)               ------------------------
                              Product(2) + Expt + Expt
          (%i5) reveal (e, 4);
                                 2                 2
                                b  - Product(3) + a
          (%o5)         ------------------------------------
                                   Product(2)     Product(2)
                        2 Expt + %e           + %e
          (%i6) reveal (e, 5);
                                   2            2
                                  b  - 2 a b + a
          (%o6)              --------------------------
                                 Sum(2)     2 b     2 a
                             2 %e       + %e    + %e
          (%i7) reveal (e, 6);
                                    2            2
                                   b  - 2 a b + a
          (%o7)               -------------------------
                                  b + a     2 b     2 a
                              2 %e      + %e    + %e

 -- Función: sublis (<list>, <expr>)
     Hace sustituciones múltiples en paralelo dentro de las expresiones.
     <list> es una lista de ecuaciones, cuyos miembros izquierdos deben
     ser átomos.

     La variable `sublis_apply_lambda' controla la simplificación
     después de `sublis'.

     Véase también `psubst' para hacer sustituciones en paralelo.

     Ejemplo:

          (%i1) sublis ([a=b, b=a], sin(a) + cos(b));
          (%o1)                    sin(b) + cos(a)

 -- Variable opcional: sublis_apply_lambda
     Valor por defecto: `true'

     Controla si los `lambda' sustituidos son aplicados en la
     simplificación después de invocar a `sublis', o si se tiene que
     hacer un `ev' para hacerlo. Si `sublis_apply_lambda' vale `true',
     significa que se ejecute la aplicación.


 -- Variable opcional: subnumsimp
     Valor por defecto: `false'

     Si vale `true', las funciones `subst' y `psubst' puede sustituir
     una variable subindicada `f[x]' por un número simplemente
     utilizando el símbolo `f'.

     Véase también `subst'.

          (%i1) subst(100,g,g[x]+2);

          subst: cannot substitute 100 for operator g in expression g
                                                                     x
           -- an error. To debug this try: debugmode(true);

          (%i2) subst(100,g,g[x]+2),subnumsimp:true;
          (%o2)                          102


 -- Función: subst (<a>, <b>, <c>)
     Sustituye <a> por <b> en <c>. El argumento  <b> debe ser un átomo
     o una subexpresión completa de <c>.  Por ejemplo, `x+y+z' es una
     subexpresión completa de  `2*(x+y+z)/w' mientras que `x+y' no lo
     es. Cuando <b> no cumple esta característica, se puede utilizar en
     algunos casos `substpart' o `ratsubst' (ver más abajo).
     Alternativamente, si <b> no es de la forma `e/f' entonces se puede
     usar `subst (a*f, e, c)', pero si <b> es de la forma `e^(1/f)' se
     debe usar `subst (a^f, e, c)'.  La instrucción `subst' también
     reconoce `x^y' en `x^-y', de manera que  `subst (a, sqrt(x),
     1/sqrt(x))' da `1/a'. Los argumentos <a> y <b> también pueden ser
     operadores de una expresión acotados por comillas dobles `"' o
     nombres de funciones.  Si se quiere sustituir la variable
     independiente en expresiones con derivadas se debe utilizar la
     función `at' (ver más abajo).

     La función `subst' es sinónimo de `substitute'.

     La llamada `subst (<eq_1>, <expr>)' o `subst ([<eq_1>, ...,
     <eq_k>], <expr>)' están permitidas. Las <eq_i> son ecuaciones que
     indican las sustituciones a realizar.  Para cada ecuación, el
     miembro izquierdo será sustituido por la expresión del miembro
     derecho en <expr>. Las ecuaciones se sustituyen secuencialmente de
     izquierda a derecha en <expr>. Véanse las funciones `sublis' y
     `psubst' para sustituciones en paralelo.

     Si la variable `exptsubst' vale `true' se permiten ciertas
     sustituciones de exponentes; por ejemplo, sustituir `y' por `%e^x'
     en `%e^(a*x)'.

     Si `opsubst' vale `false', `subst' no intentará sustituir un
     operador de una expresión. Por ejemplo, `(opsubst: false, subst
     (x^2, r, r+r[0]))' trabajará sin problemas.

     Ejemplos:

          (%i1) subst (a, x+y, x + (x+y)^2 + y);
                                              2
          (%o1)                      y + x + a
          (%i2) subst (-%i, %i, a + b*%i);
          (%o2)                       a - %i b

     La sustitución se hace secuencialmente según una lista de
     ecuaciones. Compárese con la sustitución en paralelo.

          (%i3) subst([a=b, b=c], a+b);
          (%o3)                                 2 c
          (%i4) sublis([a=b, b=c], a+b);
          (%o4)                                c + b

     Para más ejemplos, ejecútese `example (subst)'.


 -- Función: substinpart (<x>, <expr>, <n_1>, ..., <n_k>)
     Es similar a `substinpart', pero trabaja con la representación
     interna de <expr>.

     Ejemplos:

          (%i1) x . 'diff (f(x), x, 2);
                                        2
                                       d
          (%o1)                   x . (--- (f(x)))
                                         2
                                       dx
          (%i2) substinpart (d^2, %, 2);
                                            2
          (%o2)                        x . d
          (%i3) substinpart (f1, f[1](x + 1), 0);
          (%o3)                       f1(x + 1)

     Si el último argumento pasado a la función `part' es una lista de
     índices, se obtendrá la lista de subexpresiones correspondientes a
     cada uno de los índices.

          (%i1) part (x + y + z, [1, 3]);
          (%o1)                         z + x

     La variable `piece' guarda el valor de la última expresión
     seleccionada al utilizar las funciones `part'. El valor es
     asignado durante la ejecución de la función y puede ser utilizada
     tal como se muestra más abajo. Si a `partswitch' se le asigna el
     valor `true' entonces se devolverá `end' cuando no existe la parte
     solicitada; con otro valor devuelve un mensaje de error.

          (%i1) expr: 27*y^3 + 54*x*y^2 + 36*x^2*y + y + 8*x^3 + x + 1;
                        3         2       2            3
          (%o1)     27 y  + 54 x y  + 36 x  y + y + 8 x  + x + 1
          (%i2) part (expr, 2, [1, 3]);
                                            2
          (%o2)                         54 y
          (%i3) sqrt (piece/54);
          (%o3)                        abs(y)
          (%i4) substpart (factor (piece), expr, [1, 2, 3, 5]);
                                         3
          (%o4)               (3 y + 2 x)  + y + x + 1
          (%i5) expr: 1/x + y/x - 1/z;
                                       1   y   1
          (%o5)                      - - + - + -
                                       z   x   x
          (%i6) substpart (xthru (piece), expr, [2, 3]);
                                      y + 1   1
          (%o6)                       ----- - -
                                        x     z

     Además, dándole a `inflag' el valor `true' y llamando a `part' o
     `substpart' es lo mismo que invocar a  `inpart' o `substinpart'.


 -- Función: substpart (<x>, <expr>, <n_1>, ..., <n_k>)
     Sustituye por <x> la subexpresión que se obtiene de aplicar el
     resto de argumentos a la función `part', devolviendo el nuevo
     valor de <expr>.  <x> puede ser un operador que sustituya otro
     operador de <expr>. En ciertos casos, <x> necesita estar
     entrecomillado por comillas dobles (`"'); por ejemplo, de
     `substpart ("+", a*b, 0)' se obtiene `b + a'.

     Ejemplo:

          (%i1) 1/(x^2 + 2);
                                         1
          (%o1)                        ------
                                        2
                                       x  + 2
          (%i2) substpart (3/2, %, 2, 1, 2);
                                         1
          (%o2)                       --------
                                       3/2
                                      x    + 2
          (%i3) a*x + f(b, y);
          (%o3)                     a x + f(b, y)
          (%i4) substpart ("+", %, 1, 0);
          (%o4)                    x + f(b, y) + a

     Además, dándole a `inflag' el valor `true' y llamando a `part' o
     `substpart' es lo mismo que invocar a  `inpart' o `substinpart'.


 -- Función: symbolp (<expr>)
     Devuelve `true' si <expr> es un símbolo y `false' en caso
     contrario.  La llamada `symbolp(x)' equivale al predicado `atom(x)
     and not numberp(x)'.

     Véase también `Identifiers'.


 -- Función: unorder ()
     Desactiva las asociaciones creadas por la última utilización de
     los comandos de ordenación `ordergreat' y `orderless', los cuales
     no pueden ser utilizados más de una vez sin invocar a `unorder'.

     `unorder' no sustituye en expresiones los símbolos originales por
     los alias introducidos por `ordergreat' y `orderless'. Es por ello
     que tras la ejecuciÃ³n de `unorder' los alias aparecen en
     expresiones anteriores.

     Véase también `ordergreat' y `orderless'.

     Ejemplos:

     `ordergreat(a)' introduce un alias para el símbolo `a', razón por
     la cual la diferencia de `%o2' y `%o4' no se anula.  `unorder' no
     restablece el símbolo `a' y el alias aparece en el resultado `%o7'.

          (%i1)
          (%o1)                          []
          (%i2) b*x+a^2;
                                             2
          (%o2)                       b x + a
          (%i3) ordergreat(a);
          (%o3)                         done
          (%i4) b*x+a^2;
                                       2
          (%o4)                       a  + b x
          (%i5) %th(1)-%th(3);
                                        2    2
          (%o5)                        a  - a
          (%i6) unorder();
          (%o6)                          [a]
          (%i7) %th(2);
                                          2    2
          (%o7)                      _101a  - a

 -- Función: verbify (<f>)
     Devuelve la forma verbal del nombre de función <f>.

     Véanse también `verb', `noun' y `nounify'.

     Ejemplos:

          (%i1) verbify ('foo);
          (%o1)                          foo
          (%i2) :lisp $%
          $FOO
          (%i2) nounify (foo);
          (%o2)                          foo
          (%i3) :lisp $%
          %FOO



File: maxima.info,  Node: Simplificación,  Next: Funciones matemáticas,  Prev: Expresiones,  Up: Top

9 Simplificación
****************

* Menu:

* Introducción a la simplificación::
* Funciones y variables para simplificación::


File: maxima.info,  Node: Introducción a la simplificación,  Next: Funciones y variables para simplificación,  Prev: Simplificación,  Up: Simplificación

9.1 Introducción a la simplificación
====================================

Tras la evaluación de una expresión se procede a su simplificación. Las
funciones matemáticas que involucran cálculos simbólicos y las
expresiones con operadores aritméticos no son evaluadas, sino
simplificadas, para lo cual Maxima las representa internamente en forma
nominal; de ahí que el cálculo numérico de una suma o de una
multiplicación no se considera una evaluación, sino una simplificación.
La evaluación de una expresión puede inhibirse con el operador de
comilla simple (`'') y su simplificación se puede controlar con el
valor asignado a la variable opcional `simp'.

   En el siguiente ejemplo, se evita la simplificación con el operador
de comilla simple, siendo el resultado una expresión nominal. A
continuación, se inhibe la simplificación tras la evaluación de la
derivada, dejando sin reducir el resultado a `2*x'.

     (%i1) 'diff(x*x,x);
                                  d    2
     (%o1)                        -- (x )
                                  dx
     (%i2) simp:false;
     (%o2)                         false
     (%i3) diff(x*x,x);
     (%o3)                       1 x + 1 x

   Para cada función u operador matemático dispone Maxima de una rutina
interna que será utilizada para su simplificación siempre que se la
encuentre en una expresión. Estas rutinas implementan propiedades
simétricas, valores especiales de las funciones y otras propiedades y
reglas. La gran cantidad de variables opcionales permiten mantener bajo
control la simplificación de funciones y operadores.

   Veamos un ejemplo. La simplificación de la función exponencial `exp'
se controla con las siguientes variables opcionales: `%enumer',
`%emode', `%e_to_numlog', `code', `logsimp' y `demoivre'.  En el primer
caso la expresión con la función exponencial no se simplifica, pero en
el segundo se reduce a `%i*%pi/2'.

     (%i1) exp(x+%i*%pi/2), %emode:false;
                                     %i %pi
                                 x + ------
                                       2
     (%o1)                     %e
     (%i2) exp(x+%i*%pi/2), %emode:true;
                                       x
     (%o2)                        %i %e

   Junto con la simplificación aislada de funciones y operadores que
Maxima realiza de forma automática, existen también funciones como
`expand' o `radcan' que realizan sobre las expresiones simplificaciones
especiales. Sigue un ejemplo:

     (%i1) (log(x+x^2)-log(x))^a/log(1+x)^(a/2);
                                2               a
                          (log(x  + x) - log(x))
     (%o1)                -----------------------
                                         a/2
                               log(x + 1)
     (%i2) radcan(%);
                                         a/2
     (%o2)                     log(x + 1)

   A un operador o función se le pueden asignar propiedades tales como
la linealidad, la simetría u otras. Maxima tiene en cuenta estas
propiedades durante la simplificación. Por ejemplo, la instrucción
`declare(f, oddfun)' declara la función como impar, con lo que Maxima
sabrá que las formas `f(-x)' y `-f(x)' son equivalentes, llevando a
cabo la reducción oportuna.

   Las siguientes propiedades están en la lista `opproperties' y
controlan la simplificación de funciones y operadores:

   additive        lassociative     oddfun
   antisymmetric   linear           outative
   commutative     multiplicative   rassociative
   evenfun         nary             symmetric

   Tanto las propiedades como los hechos (o hipótesis) establecidos por
el usuario dentro de un contexto influyen sobre el proceso de
simplificación.  Para más detalles véase el capítulo sobre la base de
datos de Maxima.

   La función seno reduce los múltiplos enteros de `%pi' al valor cero.
En este ejemplo se muestra cómo al dotar al símbolo `n' de la propiedad
de ser entero, la función se simplifica de la forma apropiada.

     (%i1) sin(n*%pi);
     (%o1)                      sin(%pi n)
     (%i2) declare(n, integer);
     (%o2)                         done
     (%i3) sin(n*%pi);
     (%o3)                           0

   Si las técnicas anteriores no devuelven el resultado esperado por el
usuario, éste puede extender a voluntad las reglas que pueda aplicar
Maxima; para más información al respecto, véase el capítulo dedicado a
las reglas y patrones.


File: maxima.info,  Node: Funciones y variables para simplificación,  Prev: Introducción a la simplificación,  Up: Simplificación

9.2 Funciones y variables para simplificación
=============================================

 -- Propiedad: additive
     Si `declare(f,additive)' ha sido ejecutado, entonces:

     (1) Si `f' es univariado, cada vez que el simplificador encuentre
     `f' aplicada a una suma, `f' será distribuida bajo esta suma. Por
     ejemplo, `f(x+y)' se simplificará a `f(x)+f(y)'.

     (2) Si `f' es una función de 2 o más argumentos, aditivamente es
     definida como aditiva en el primer argumento de `f', como en el
     caso de `sum' o `integrate'. Por ejemplo, `f(h(x)+g(x),x)' se
     simplificará a `f(h(x),x)+f(g(x),x)'. Esta simplificación no
     ocurre cuando `f' se aplica a expresiones de la forma
     `sum(x[i],i,lower-limit,upper-limit)'.

     Ejemplo:

          (%i1) F3 (a + b + c);
          (%o1)                     F3(c + b + a)
          (%i2) declare (F3, additive);
          (%o2)                         done
          (%i3) F3 (a + b + c);
          (%o3)                 F3(c) + F3(b) + F3(a)

 -- Propiedad: antisymmetric
     Si `declare(h,antisymmetric)' es ejecutado, esto dice al
     simplificador que `h' es antisimétrico. E.g. `h(x,z,y)' será
     simplificado a `-h(x,y,z)'. Que es, el producto de (-1)^n por el
     resultado dado por `symmetric' o `commutative', donde n es el
     número de intercambios necesarios de dos argumentos para
     convertirle a esta forma.

     Ejemplos:

          (%i1) S (b, a);
          (%o1)                        S(b, a)
          (%i2) declare (S, symmetric);
          (%o2)                         done
          (%i3) S (b, a);
          (%o3)                        S(a, b)
          (%i4) S (a, c, e, d, b);
          (%o4)                   S(a, b, c, d, e)
          (%i5) T (b, a);
          (%o5)                        T(b, a)
          (%i6) declare (T, antisymmetric);
          (%o6)                         done
          (%i7) T (b, a);
          (%o7)                       - T(a, b)
          (%i8) T (a, c, e, d, b);
          (%o8)                   T(a, b, c, d, e)

 -- Función: combine (<expr>)
     Simplifica la suma <expr> combinando términos de con igual
     denominador reduciéndolos a un único término.


 -- Propiedad: commutative
     Si `declare(h,commutative)' es ejecutado, le dice al simplificador
     que `h' es una función conmutaiva. Por ejemplo, `h(x,z,y)' se
     simplificará a `h(x,y,z)'. Esto es lo mismo que `symmetric'.


 -- Función: demoivre (<expr>)
 -- Variable opcional: demoivre
     La función `demoivre (expr)' convierte una expresión sin modificar
     la variable global `demoivre'.

     Cuando `demoivre' vale `true', los exponenciales complejos se
     convierten en expresiones equivalentes pero en términos de las
     funciones trigonométricas: `exp (a + b*%i)' se reduce a `%e^a *
     (cos(b) + %i*sin(b))' si `b' no contiene a `%i'. Las expresiones
     `a' y `b' no se expanden.

     El valor por defecto de `demoivre' es `false'.

     La función `exponentialize' convierte funciones trigonométricas e
     hiperbólicas a la forma exponencial, por lo que  `demoivre' y
     `exponentialize' no pueden valer `true' al mismo tiempo.


 -- Función: distrib (<expr>)
     Distribuye sumas sobre productos. Difiere de `expand' en que
     trabaja sólo al nivel superior de una expresión, siendo más rápida
     que `expand'.  Difiere de  `multthru' en que expande todas las
     sumas del nivel superior.

     Ejemplos:

          (%i1) distrib ((a+b) * (c+d));
          (%o1)                 b d + a d + b c + a c
          (%i2) multthru ((a+b) * (c+d));
          (%o2)                 (b + a) d + (b + a) c
          (%i3) distrib (1/((a+b) * (c+d)));
                                          1
          (%o3)                    ---------------
                                   (b + a) (d + c)
          (%i4) expand (1/((a+b) * (c+d)), 1, 0);
                                          1
          (%o4)                 ---------------------
                                b d + a d + b c + a c


 -- Variable opcional: distribute_over
     Valor por defecto: `true'

     `distribute_over' controla la distribución de funciones sobre
     estructuras como listas, matrices y ecuaciones. Actualmente, no
     todas las funciones de Maxima tienen esta propiedad. Es posible
     consultar si una función tiene esta propiedad con la instrucción
     `properties'.

     La propiedad distributiva se desactiva asignándole a
     `distribute_over' el valor `false'.

     Ejemplos:

     La función `sin' se distribuye sobre una lista:

          (%i1) sin([x,1,1.0]);
          (%o1)                 [sin(x), sin(1), .8414709848078965]

     `mod' es una función de dos argumentos que se distribuye sobre
     listas.  La distribución sobre listas anidadas también es posible.

          (%i2) mod([x,11,2*a],10);
          (%o2)                    [mod(x, 10), 1, 2 mod(a, 5)]
          (%i3) mod([[x,y,z],11,2*a],10);
          (%o3)       [[mod(x, 10), mod(y, 10), mod(z, 10)], 1, 2 mod(a, 5)]

     Distribución de la función `floor' sobre una matriz y una ecuación.

          (%i4) floor(matrix([a,b],[c,d]));
                                      [ floor(a)  floor(b) ]
          (%o4)                       [                    ]
                                      [ floor(c)  floor(d) ]
          (%i5) floor(a=b);
          (%o5)                         floor(a) = floor(b)

     Funciones con más de un argumento se distribuyen sobre cualquiera
     de sus argumentos, o sobre todos ellos.

          (%i6) expintegral_e([1,2],[x,y]);
          (%o6) [[expintegral_e(1, x), expintegral_e(1, y)],
                 [expintegral_e(2, x), expintegral_e(2, y)]]

     Comprueba si una función tiene la propiedad `distribute_over':

          (%i7) properties(abs);
          (%o7) [integral, distributes over bags, noun, rule, gradef]

 -- Variable opcional: domain
     Valor por defecto: `real'

     Si `domain' vale `complex', `sqrt (x^2)' permanecerá como `sqrt
     (x^2)' en lugar de devolver `abs(x)'.


 -- Propiedad: evenfun
 -- Propiedad: oddfun
     `declare(f, evenfun' o `declare(f, oddfun' indican a Maxima que
     reconozca la función `f' como par o impar, respectivamente.

     Ejemplos:

          (%i1) o (- x) + o (x);
          (%o1)                     o(x) + o(- x)
          (%i2) declare (o, oddfun);
          (%o2)                         done
          (%i3) o (- x) + o (x);
          (%o3)                           0
          (%i4) e (- x) - e (x);
          (%o4)                     e(- x) - e(x)
          (%i5) declare (e, evenfun);
          (%o5)                         done
          (%i6) e (- x) - e (x);
          (%o6)                           0

 -- Función: expand (<expr>)
 -- Función: expand (<expr>, <p>, <n>)
     Expande la expresión <expr>. Los productos de sumas y de sumas con
     exponentes se multiplican, los numeradores de las expresiones
     racionales que son sumas se separan en sus respectivos términos, y
     las multiplicaciones (tanto las que son conmutativas como las que
     no) se distribuyen sobre las sumas en todos los niveles de <expr>.

     En el caso de los polinomios es más aconsejable utilizar
     `ratexpand', que utiliza un algoritmo más eficiente.

     Las variables `maxnegex' y `maxposex' controlan los máximos
     exponentes negativos y positivos que se van a expandir.

     La llamada `expand (<expr>, <p>, <n>)' expande <expr> asignando a
     `maxposex' el valor <p> y a `maxnegex' el <n>. Esto es útil para
     expandir sólo parte de la expresión.

     La variable `expon' guarda el mayor exponente negativo que será
     expandido automáticamente, independientemente de `expand'. Por
     ejemplo, si `expon' vale 4 entonces `(x+1)^(-5)' no se expandirá
     automáticamente.

     La variable `expop' guarda el mayor exponente positivo que será
     expandido automáticamente.  Así, `(x+1)^3' se expandirá
     automáticamente sólo si `expop' es mayor o igual que 3. Si se
     quiere expandir `(x+1)^n', siendo `n' mayor que `expop', entonces
     `expand ((x+1)^n)' se desarrollará sólo si `maxposex' no es menor
     que `n'.

     `expand(expr, 0, 0)' provoca que se vuelva a simplificar `expr'.
     `expr' no se vuelve a evaluar. A diferencia de `ev(expr, noeval)',
     se elimina la representación canónica de la expresión.  Véase
     también `ev'.

     La variable `expand' utilizada con `ev' provocará una expansión.

     El fichero `share/simplification/facexp.mac' contiene algunas
     funciones relacionadas con `expand' (en concreto, `facsum',
     `factorfacsum' y `collectterms', que se cargan automáticamente) y
     variables (`nextlayerfactor' y `facsum_combine') que permiten al
     usuario estructurar las expresiones controlando la expansión.  En
     `simplification/facexp.usg' se pueden encontrar breves
     descripciones de estas funciones.  Se accederá a una demostración
     con la instrucción `demo("facexp")'.

     Ejemplo:

          (%i1) expr:(x+1)^2*(y+1)^3;
                                                2        3
          (%o1)                          (x + 1)  (y + 1)
          (%i2) expand(expr);
                 2  3        3    3      2  2        2      2      2
          (%o2) x  y  + 2 x y  + y  + 3 x  y  + 6 x y  + 3 y  + 3 x  y
                                                           2
                                          + 6 x y + 3 y + x  + 2 x + 1

          (%i3) expand(expr,2);
                                2        3              3          3
          (%o3)                x  (y + 1)  + 2 x (y + 1)  + (y + 1)

          (%i4) expr:(x+1)^-2*(y+1)^3;
                                                    3
                                             (y + 1)
          (%o4)                              --------
                                                    2
                                             (x + 1)
          (%i5) expand(expr);
                           3               2
                          y             3 y            3 y             1
          (%o5)      ------------ + ------------ + ------------ + ------------
                      2              2              2              2
                     x  + 2 x + 1   x  + 2 x + 1   x  + 2 x + 1   x  + 2 x + 1

          (%i6) expand(expr,2,2);
                                                    3
                                             (y + 1)
          (%o6)                            ------------
                                            2
                                           x  + 2 x + 1

     Vuelve a simplificar una expresión pero sin expansión:

          (%i7) expr:(1+x)^2*sin(x);
                                                 2
          (%o7)                           (x + 1)  sin(x)
          (%i8) exponentialize:true;
          (%o8)                                true
          (%i9) expand(expr,0,0);
                                             2    %i x     - %i x
                                   %i (x + 1)  (%e     - %e      )
          (%o9)                  - -------------------------------
                                                  2

 -- Función: expandwrt (<expr>, <x_1>, ..., <x_n>)
     Expande la expresión `expr' con respecto a las variables <x_1>,
     ..., <x_n>.  Todos los productos que contengan a las variables
     aparecen explícitamente. El resultado que se obtenga no tendr'a
     productos de sumas de expresiones que contengan a las variables.
     Los argumentos  <x_1>, ..., <x_n> pueden ser variables, operadores
     o expresiones.

     Por defecto, no se expanden los denominadores, pero esto puede
     cambiarse mediante el uso de la variable `expandwrt_denom'.

     Esta función se carga automáticamente de
     `simplification/stopex.mac'.


 -- Variable opcional: expandwrt_denom
     Valor por defecto: `false'

     La variable `expandwrt_denom' controla el tratamiento de las
     expresiones racinales por parte de `expandwrt'. Si vale `true', se
     expandirán tanto el numerador como el denominador de la expresión
     respecto de los argumentos de `expandwrt', pero si
     `expandwrt_denom' vale `false', sólo se expandirá el numerador.


 -- Función: expandwrt_factored (<expr>, <x_1>, ..., <x_n>)
     Es similar a `expandwrt', pero trata a las expresiones que son
     productos de una forma algo diferente. La función
     `expandwrt_factored' expande sólo aquellos factores de `expr' que
     contienen a las variables <x_1>, ..., <x_n>.

     Esta función se carga automáticamente de
     `simplification/stopex.mac'.


 -- Variable opcional: expon
     Valor por defecto: 0

     La variable `expon' guarda el mayor exponente negativo que será
     expandido automáticamente, independientemente de `expand'. Por
     ejemplo, si `expon' vale 4 entonces `(x+1)^(-5)' no se expandirá
     automáticamente.


 -- Función: exponentialize (<expr>)
 -- Variable opcional: exponentialize
     La función `exponentialize (expr)' convierte las funciones
     trigonométricas e hiperbólicas de <expr> a exponenciales, sin
     alterar la variable global `exponentialize'.

     Cuando la variable `exponentialize' vale `true', todas las
     funciones trigonométricas e hiperbólicas se convierten a forma
     exponencial. El valor por defecto es `false'.

     La función `demoivre' convierte funciones trigonométricas e
     hiperbólicas a la forma exponencial, por lo que  `demoivre' y
     `exponentialize' no pueden valer `true' al mismo tiempo.


 -- Variable opcional: expop
     Valor por defecto: 0

     La variable `expop' guarda el mayor exponente positivo que será
     expandido automáticamente.  Así, `(x+1)^3' se expandirá
     automáticamente sólo si `expop' es mayor o igual que 3. Si se
     quiere expandir `(x+1)^n', siendo `n' mayor que `expop', entonces
     `expand ((x+1)^n)' se desarrollará sólo si `maxposex' no es menor
     que `n'.


 -- Propiedad: lassociative
     La instrucción `declare (g, lassociative)' le indica al
     simplificador de Maxima que `g' es asociativo por la izquierda.
     Por ejemplo, `g (g (a, b), g (c, d))'se reduce a `g (g (g (a, b),
     c), d)'.


 -- Propiedad: linear
     Es una de las propiedades de operadores de Maxima. Si la función
     univariante `f' se declara lineal, la expansión de  `f(x + y)'
     produce `f(x) + f(y)', `f(a*x)' produce `a*f(x)' si `a' es una
     constante.  Si la función tiene dos o más argumentos, la linealidad
     se interpreta como la de `sum' o `integrate', esto es, `f (a*x +
     b, x)' produce `a*f(x,x) + b*f(1,x)' si `a' y `b' no contienen a
     `x'.

     `linear' equivale a `additive' y `outative'.  Véase también
     `opproperties'.

     Ejemplo:

          (%i1) 'sum (F(k) + G(k), k, 1, inf);
                                 inf
                                 ====
                                 \
          (%o1)                   >    (G(k) + F(k))
                                 /
                                 ====
                                 k = 1
          (%i2) declare (nounify (sum), linear);
          (%o2)                         done
          (%i3) 'sum (F(k) + G(k), k, 1, inf);
                               inf          inf
                               ====         ====
                               \            \
          (%o3)                 >    G(k) +  >    F(k)
                               /            /
                               ====         ====
                               k = 1        k = 1

 -- Variable opcional: maxnegex
     Valor por defecto: 1000

     La variable `maxnegex' es el mayor exponente negativo que
     expandirá la función `expand'. Véase también `maxposex'.


 -- Variable opcional: maxposex
     Valor por defecto: 1000

     La variable `maxposex' es el mayor exponenteque expandirá la
     función `expand'. Véase también `maxnegex'.


 -- Propiedad: multiplicative
     La instrucción `declare (f, multiplicative)' indica al
     simplificador de Maxima que `f' is multiplicativa.

       1. Si `f' es univariante, cada vez que el simplificador
          encuentre a `f' aplicad a un producto, `f' se distribuirá
          sobre ese producto.  Por ejemplo, `f(x*y)' se reduciría a
          `f(x)*f(y)'.

       2. Si `f' es una función de 2 o más argumentos, la
          multiplicabilidad se define como multiplicabilidad para el
          primer argumento de `f', de modo que `f (g(x) * h(x), x)' se
          reduciría a `f (g(x) ,x) * f (h(x), x)'.

     Esta transformación no se realiza cuando `f' se aplica a
     expresiones de la forma `product (x[i], i, m, n)'.

     Ejemplo:

          (%i1) F2 (a * b * c);
          (%o1)                       F2(a b c)
          (%i2) declare (F2, multiplicative);
          (%o2)                         done
          (%i3) F2 (a * b * c);
          (%o3)                   F2(a) F2(b) F2(c)

 -- Función: multthru (<expr>)
 -- Función: multthru (<expr_1>, <expr_2>)
     Multiplica un factor (que debería ser una suma) de <expr> por los
     otros factores de <expr>.  Esto es, <expr> es `<f_1> <f_2> ...
     <f_n>', donde al menos un factor, por ejemplo <f_i>, es una suma
     de términos.  Cada término en esta suma se multiplica por los
     otros factores del producto, excepto el propio <f_i>. La función
     `multthru' no expande sumas elevadas a exponentes, siendo el
     método más rápido para distribuir productos (sean o no
     conmutativos) sobre sumas. Puesto que los cocientes se representan
     como productos, puede utilizarse`multthru' para dividir sumas
     entre productos.

     La llamada `multthru (<expr_1>, <expr_2>)' multiplica cada término
     de <expr_2> (que debería ser una suma o una ecuación) por
     <expr_1>.  Si <expr_1> no es ella misma una suma, entonces la
     llamada es equivalente a `multthru (<expr_1>*<expr_2>)'.

          (%i1) x/(x-y)^2 - 1/(x-y) - f(x)/(x-y)^3;
                                1        x         f(x)
          (%o1)             - ----- + -------- - --------
                              x - y          2          3
                                      (x - y)    (x - y)
          (%i2) multthru ((x-y)^3, %);
                                     2
          (%o2)             - (x - y)  + x (x - y) - f(x)
          (%i3) ratexpand (%);
                                     2
          (%o3)                   - y  + x y - f(x)
          (%i4) ((a+b)^10*s^2 + 2*a*b*s + (a*b)^2)/(a*b*s^2);
                                  10  2              2  2
                           (b + a)   s  + 2 a b s + a  b
          (%o4)            ------------------------------
                                            2
                                       a b s
          (%i5) multthru (%);  /* note that this does not expand (b+a)^10 */
                                                  10
                                 2   a b   (b + a)
          (%o5)                  - + --- + ---------
                                 s    2       a b
                                     s
          (%i6) multthru (a.(b+c.(d+e)+f));
          (%o6)            a . f + a . c . (e + d) + a . b
          (%i7) expand (a.(b+c.(d+e)+f));
          (%o7)         a . f + a . c . e + a . c . d + a . b


 -- Propiedad: nary
     `declare(f, nary)' le indica a Maxima que reconozca la función `f'
     como n-aria.

     La declaración `nary' no equivale a invocar la función
     `function_nary, nary'. El único efecto de `declare(f, nary)' es
     indicar al simplificador de Maxima que aplane expresiones anidadas,
     como simplificar `foo(x, foo(y, z))' a `foo(x, y, z)'.  Véase
     también `declare'.

     Ejemplo:

          (%i1) H (H (a, b), H (c, H (d, e)));
          (%o1)               H(H(a, b), H(c, H(d, e)))
          (%i2) declare (H, nary);
          (%o2)                         done
          (%i3) H (H (a, b), H (c, H (d, e)));
          (%o3)                   H(a, b, c, d, e)

 -- Variable opcional: negdistrib
     Valor por defecto: `true'

     Si `negdistrib' vale `true', -1 se distribuye sobre una expresión.
     Por ejemplo, `-(x + y)' se transforma en `- y - x'.  Dándole el
     valor `false' se mostrará `- (x + y)' tal cual. Esto puede ser
     útil, pero también peligroso; al igual que el indicador `simp', no
     conviene asignarle el valor `false'.


 -- Variable del sistema: opproperties
     La variable `opproperties' es la lista con las propiedades
     especiales de los operadores reconocidas por el simplificador de
     Maxima: `linear', `additive', `multiplicative', `outative',
     `evenfun', `oddfun', `commutative', `symmetric', `antisymmetric',
     `nary', `lassociative', `rassociative'.


 -- Propiedad: outative
     La instrucción `declare (f, outative)' le indica al simplificador
     de Maxima que los factores constantes del argumento de la función
     `f' pueden ser extraídos.

       1. Si `f' es univariante, cada vez que el simplificador se
          encuentra con `f' aplicada a un producto, éste será
          particionado en factores que son constantes y factores que no
          lo son, siendo entonces los constantes extraídos de la
          función.  Por ejemplo, `f(a*x)' se reducirá a `a*f(x)' siendo
          `a' una constante. Las constantes no atómicas no serán
          extraídas.

       2. Si `f' es una función de 2 o más argumentos, esta propiedad
          se define como en  `sum' o `integrate', esto es, `f (a*g(x),
          x)' se reducirá a `a * f(g(x), x)' si `a' no contiene a `x'.

     Las funciones `sum', `integrate' y `limit' han sido todas
     declaradas con la propiedad `outative'.

     Ejemplo:

          (%i1) F1 (100 * x);
          (%o1)                       F1(100 x)
          (%i2) declare (F1, outative);
          (%o2)                         done
          (%i3) F1 (100 * x);
          (%o3)                       100 F1(x)
          (%i4) declare (zz, constant);
          (%o4)                         done
          (%i5) F1 (zz * y);
          (%o5)                       zz F1(y)

 -- Función: radcan (<expr>)
     Simplifica la expresión <expr>, que puede contener logaritmos,
     exponenciales y radicales, convirtiéndola a una forma canónica, lo
     que significa que todas las expresiones funcionalmente equivalentes
     se reducen a una forma única.  Ciertas expresiones, sin embargo,
     son reducidas por `radcan' a una forma regular, lo que significa
     que dos expresiones equivalentes no tienen necesariamente el mismo
     aspecto, pero su diferencia puede ser reducida por `radcan' a cero.

     Con algunas expresiones `radcan' puede consunir mucho tiempo. Este
     es el coste por explorar ciertas relaciones entre las componentes
     de la expresión para simplificaciones basadas en factorizaciones y
     expansiones parciales de fracciones de exponentes.

     Ejemplos:

          (%i1) radcan((log(x+x^2)-log(x))^a/log(1+x)^(a/2));
                                                     a/2
          (%o1)                            log(x + 1)

          (%i2) radcan((log(1+2*a^x+a^(2*x))/log(1+a^x)));
          (%o2)                                  2

          (%i3) radcan((%e^x-1)/(1+%e^(x/2)));
                                               x/2
          (%o3)                              %e    - 1


 -- Variable opcional: radexpand
     Valor por defecto: `true'

     La variable `radexpand' controla algunas simplificaciones de
     radicales.

     Si `radexpand' vale `all', las raíces <n>-ésimas de los factores
     de un producto que sean potencias de <n> se extraen del símbolo
     radical. Por ejemplo, si `radexpand' vale `all', `sqrt (16*x^2)'
     se reduce a `4*x'.

     Más concretamente, considérese `sqrt (x^2)'.
        * Si `radexpand' vale `all' o se ha ejecutado `assume (x > 0)',
          `sqrt(x^2)' se reduce a `x'.

        * Si `radexpand' vale `true' y `domain' es `real' (su valor por
          defecto), `sqrt(x^2)' se reduce a `abs(x)'.

        * Si `radexpand' vale `false' o `radexpand' vale `true' y
          `domain' es `complex', `sqrt(x^2)' no se simplifica.

     Nótese que  `domain' sólo se tiene en cuenta si `radexpand' vale
     `true'.


 -- Propiedad: rassociative
     La instrucción `declare (g, rassociative)' le indica al
     simplificador de Maxima que `g' es asociativa por la derecha.  Por
     ejemplo, `g(g(a, b), g(c, d))' se reduce a `g(a, g(b, g(c, d)))'.


 -- Función: scsimp (<expr>, <rule_1>, ..., <rule_n>)
     Es el "Sequential Comparative Simplification" (método debido a
     Stoute).  La función `scsimp' intenta simplificar <expr> de
     acuerdo con las reglas <rule_1>, ..., <rule_n>.  Si se obtiene una
     expresión más pequeña, el proceso se repite. En caso contrario,
     después de que se hayan intentado todas las simplificaciones,
     devuelve la respuesta original.

     La instrucción `example (scsimp)' muestra algunos ejemplos.


 -- Variable opcional: simp
     Valor por defecto: `true'

     La variable `simp' activa y desactiva la simplificación.  La
     simplificación está activada por defecto. La variable `simp'
     también es reconocida por la función `ev' como variable de entorno.
     Véase también `ev'.

     Cuando `simp' se utiliza en un entorno `ev' con el valor `false',
     la simplificación se evita sólo durante la fase de evaluación de
     una expresión. La variable no evita la simplificación que sigue a
     la fase de evaluación.

     Ejemplos:

     La simplificación se suspende globalmente. La expresión `sin(1.0)'
     no se simplifica a su valor numérico. La variable de entorno `simp'
     conmuta el estado de la simplificación.

          (%i1) simp:false;
          (%o1)                                false
          (%i2) sin(1.0);
          (%o2)                              sin(1.0)
          (%i3) sin(1.0),simp;
          (%o3)                          .8414709848078965

     La simplificación se vuelve a activar. La variable de entorno
     `simp' no puede suprimir totalmente la simplificación. El
     resultado muestra una expresión simplificada, pero la variable `x'
     guarda como valor una expresión sin simplificar, porque la
     asignación se realizó durante la fase de evaluación de la
     expresión.

          (%i4) simp:true;
          (%o4)                                true
          (%i5) x:sin(1.0),simp:false;
          (%o5)                          .8414709848078965
          (%i6) :lisp $X
          ((%SIN) 1.0)

 -- Propiedad: symmetric
     La instrucción `declare (h, symmetric)' le indica al simplificador
     de  Maxima que `h' es una función simétrica.  Por ejemplo, `h (x,
     z, y)'  se reduce a `h (x, y, z)'.

     El nombre `commutative' es sinónimo de `symmetric'.


 -- Función: xthru (<expr>)
     Combina todos los términos de <expr> (la cual debe ser una suma)
     sobre un común denominador sin expandir productos ni sumas
     elevadas a exponentes al modo que lo hace `ratsimp'. La función
     `xthru' cancela factores comunes en el numerador y denominador de
     expresiones racionales, pero sólo si los factores son explícitos.

     En ocasiones puede ser útil el uso de `xthru' antes de la llamada
     a `ratsimp' a fin de cancelar factores explícitos del máximo común
     divisor del numerador y denominador y así simplificar la expresión
     a la que se va a aplicar `ratsimp'.

          (%i1) ((x+2)^20 - 2*y)/(x+y)^20 + (x+y)^(-19) - x/(x+y)^20;
           xthru (%);
                                          20
                           1       (x + 2)   - 2 y       x
          (%o1)        --------- + --------------- - ---------
                              19             20             20
                       (y + x)        (y + x)        (y + x)



File: maxima.info,  Node: Funciones matemáticas,  Next: Base de datos de Maxima,  Prev: Simplificación,  Up: Top

10 Funciones matemáticas
************************

* Menu:

* Funciones para los números::
* Funciones para los números complejos::
* Funciones combinatorias::
* Funciones radicales exponenciales y logarítmicas::
* Funciones trigonométricas::
* Números aleatorios::


File: maxima.info,  Node: Funciones para los números,  Next: Funciones para los números complejos,  Prev: Funciones matemáticas,  Up: Funciones matemáticas

10.1 Funciones para los números
===============================

 -- Función: abs (<z>)
     La función `abs' representa el valor absoluto y se puede aplicar
     tanto a argumentos numéricos como simbólicos. Si el argumento <z>
     es un número real o complejo, `abs' devuelve el valor absoluto de
     <z>.  Si es posible, las expresiones simbólicas que utilizan la
     función del valor absoluto también se simplifican.

     Maxima puede derivar, integrar y calcular límites de expresiones
     que contengan a `abs'. El paquete `abs_integrate' extiende las
     capacidades de Maxima para calcular integrales que contengan
     llamadas a `abs'. Véase `(%i12)' en el ejemplo de más abajo.

     Cuando se aplica a una lista o matriz, `abs' se distribuye
     automáticamente sobre sus elementos. De forma similar, también se
     distribuye sobre los dos miembros de una igualdad. Para cambiar
     este comportamiento por defecto, véase la variable
     `distribute_over'.

     Ejemplos:

     Cálculo del valor absoluto de números reales y complejos,
     incluyendo constantes numéricas e infinitos. El primer ejemplo
     muestra cómo `abs' se distribuye sobre los elementos de una lista.

          (%i1) abs([-4, 0, 1, 1+%i]);
          (%o1)                  [4, 0, 1, sqrt(2)]

          (%i2) abs((1+%i)*(1-%i));
          (%o2)                           2
          (%i3) abs(%e+%i);
                                          2
          (%o3)                    sqrt(%e  + 1)
          (%i4) abs([inf, infinity, minf]);
          (%o4)                   [inf, inf, inf]

     Simplificación de expresiones que contienen `abs':

          (%i5) abs(x^2);
                                          2
          (%o5)                          x
          (%i6) abs(x^3);
                                       2
          (%o6)                       x  abs(x)

          (%i7) abs(abs(x));
          (%o7)                       abs(x)
          (%i8) abs(conjugate(x));
          (%o8)                       abs(x)

     Integrando y derivando con la función `abs'. Nótese que se pueden
     calcular más integrales que involucren la función `abs' si se
     carga el paquete `abs_integrate'. El último ejemplo muestra la
     transformada de Laplace de `abs'. Véase `laplace'.

          (%i9) diff(x*abs(x),x),expand;
          (%o9)                       2 abs(x)

          (%i10) integrate(abs(x),x);
                                       x abs(x)
          (%o10)                       --------
                                          2

          (%i11) integrate(x*abs(x),x);
                                     /
                                     [
          (%o11)                     I x abs(x) dx
                                     ]
                                     /

          (%i12) load(abs_integrate)$
          (%i13) integrate(x*abs(x),x);
                                2           3
                               x  abs(x)   x  signum(x)
          (%o13)               --------- - ------------
                                   2            6

          (%i14) integrate(abs(x),x,-2,%pi);
                                         2
                                      %pi
          (%o14)                      ---- + 2
                                       2

          (%i15) laplace(abs(x),x,s);
                                         1
          (%o15)                         --
                                          2
                                         s

 -- Función: ceiling (<x>)
     Si <x> es un número real, devuelve el menor entero mayor o igual
     que <x>.

     Si <x> es una expresión constante (por ejemplo, `10 * %pi'),
     `ceiling' evalúa <x> haciendo uso de números grandes en coma
     flotante (big floats), aplicando a continuación  `ceiling' al
     número decimal obtenido. Puesto que `ceiling' hace evaluaciones en
     coma flotante, es posible, pero improbable, que esta función
     devuelva un valor erróneo para entradas constantes. Para evitar
     estos errores, la evaluación en punto flotante se lleva a cabo
     utilizando tres valores para `fpprec'.

     Para argumentos no constantes, `ceiling' intenta devolver un valor
     simplificado. Aquí se presentan algunos ejemplos sobre las
     simplificaciones que `ceiling' es capaz de hacer:

          (%i1) ceiling (ceiling (x));
          (%o1)                      ceiling(x)
          (%i2) ceiling (floor (x));
          (%o2)                       floor(x)
          (%i3) declare (n, integer)$
          (%i4) [ceiling (n), ceiling (abs (n)), ceiling (max (n, 6))];
          (%o4)                [n, abs(n), max(n, 6)]
          (%i5) assume (x > 0, x < 1)$
          (%i6) ceiling (x);
          (%o6)                           1
          (%i7) tex (ceiling (a));
          $$\left \lceil a \right \rceil$$
          (%o7)                                false

     La función `ceiling' no se extiende automáticamente a los
     elementos de listas y matrices.  Por último, para todos los
     argumentos que tengan una forma compleja, `ceiling' devuelve una
     forma nominal.

     Si el rango de una función es subconjunto de los números enteros,
     entonces puede ser declarada como `integervalued'. Tanto `ceiling'
     como `floor' son funciones que hacen uso de esta información; por
     ejemplo:

          (%i1) declare (f, integervalued)$
          (%i2) floor (f(x));
          (%o2)                         f(x)
          (%i3) ceiling (f(x) - 1);
          (%o3)                       f(x) - 1


 -- Función: entier (<x>)
     Devuelve el mayor entero menor o igual a <x>, siendo <x> numérico.
     La función  `fix' (como en `fixnum') es un sinónimo, de modo que
     `fix(<x>)' hace justamente lo mismo.


 -- Función: floor (<x>)
     Si <x> es un número real, devuelve el mayor entero menor o igual
     que <x>.

     Si <x> es una expresión constante (por ejemplo, `10 * %pi'),
     `floor' evalúa <x> haciendo uso de números grandes en coma
     flotante (big floats), aplicando a continuación  `floor' al número
     decimal obtenido. Puesto que `floor' hace evaluaciones en coma
     flotante, es posible, pero improbable, que esta función devuelva
     un valor erróneo para entradas constantes. Para evitar estos
     errores, la evaluación en punto flotante se lleva a cabo
     utilizando tres valores para `fpprec'.

     Para argumentos no constantes, `floor' intenta devolver un valor
     simplificado. Aquí se presentan algunos ejemplos sobre las
     simplificaciones que `floor' es capaz de hacer:

          (%i1) floor (ceiling (x));
          (%o1)                      ceiling(x)
          (%i2) floor (floor (x));
          (%o2)                       floor(x)
          (%i3) declare (n, integer)$
          (%i4) [floor (n), floor (abs (n)), floor (min (n, 6))];
          (%o4)                [n, abs(n), min(n, 6)]
          (%i5) assume (x > 0, x < 1)$
          (%i6) floor (x);
          (%o6)                           0
          (%i7) tex (floor (a));
          $$\left \lfloor a \right \rfloor$$
          (%o7)                         false

     La función `floor' no se extiende automáticamente a los elementos
     de listas y matrices.  Por último, para todos los argumentos que
     tengan una forma compleja, `floor' devuelve una forma nominal.

     Si el rango de una función es subconjunto de los números enteros,
     entonces puede ser declarada como `integervalued'. Tanto `ceiling'
     como `floor' son funciones que hacen uso de esta información; por
     ejemplo:

          (%i1) declare (f, integervalued)$
          (%i2) floor (f(x));
          (%o2)                         f(x)
          (%i3) ceiling (f(x) - 1);
          (%o3)                       f(x) - 1


 -- Función: fix (<x>)
     Es un sinónimo de  `entier (<x>)'.


 -- Función: lmax (<L>)
     Si <L> es una lista o conjunto, devuelve `apply ('max, args
     (<L>))'.  Si <L> no es una lista o conjunto, envía un mensaje de
     error.

 -- Función: lmin (<L>)
     Si <L> es una lista o conjunto, devuelve `apply ('min, args
     (<L>))'.  Si <L> no es una lista o conjunto, envía un mensaje de
     error.

 -- Función: max (<x_1>, ..., <x_n>)
     Devuelve un valor simplificado de la mayor de las expresiones
     desde <x_1> hasta <x_n>.  Si `get (trylevel, maxmin)' es 2 o más,
     `max' aplica la simplificación `max (e, -e) --> |e|'.  Si `get
     (trylevel, maxmin)' es 3 o más, <max> intenta eliminar las
     expresiones que estén entre otros dos de los argumentos dados; por
     ejemplo, `max (x, 2*x, 3*x) --> max (x, 3*x)'. Para asignar el
     valor 2 a `trylevel' se puede hacer `put (trylevel, 2, maxmin)'.


 -- Función: min (<x_1>, ..., <x_n>)
     Devuelve un valor simplificado de la menor de las expresiones
     desde <x_1> hasta <x_n>.  Si `get (trylevel, maxmin)' es 2 o más,
     `min' aplica la simplificación `min (e, -e) --> |e|'.  Si `get
     (trylevel, maxmin)' es 3 o más, <min> intenta eliminar las
     expresiones que estén entre otros dos de los argumentos dados; por
     ejemplo, `min (x, 2*x, 3*x) --> min (x, 3*x)'. Para asignar el
     valor 2 a `trylevel' se puede hacer `put (trylevel, 2, maxmin)'.


 -- Función: round (<x>)
     Si <x> es un número real, la función devuelve el entero más
     próximo a <x>. Los múltiplos de 1/2 se redondean al entero par más
     próximo.  La evaluación de <x> es similar a `floor' y `ceiling'.


 -- Función: signum (<x>)
     Tanto sea <x> real o complejo, la función `signum' devuelve 0 si
     <x> es cero. Para un valor no nulo de <x>, la función devuelve
     `abs(x)/x'.

     Para valores no numéricos de <x>, Maxima intenta determinar el
     signo del argumento. Cuando es negativo, cero o positivo, `signum'
     devuelve -1, 0 o 1, respectivamente. En caso de no poder
     determinarse, `signum' devuelve una forma simplificada
     equivalente. Estas simplificaciones incluyen la transformación de
     `signum(-x)' en `-signum(x)' y la de `signum(x*y)' en `signum(x) *
     signum(y)'.

     La función `signum' es distributiva respecto de listas, matrices o
     ecuaciones. Véase `distribute_over'.



File: maxima.info,  Node: Funciones para los números complejos,  Next: Funciones combinatorias,  Prev: Funciones para los números,  Up: Funciones matemáticas

10.2 Funciones para los números complejos
=========================================

 -- Función: cabs (<expr>)
     Calcula el valor absoluto de una expresión que representa a un
     número complejo. Al contrario que `abs', la función `cabs' siempre
     descompone su argumento en sus partes real e imaginaria. Si `x' e
     `y' representan variables o expresiones reales, la función `cabs'
     calcula el valor absoluto de `x + %i*y' como
                                     2    2
                               sqrt(y  + x )

     La función `cabs' puede utilizar propiedades como la simetría de
     funciones complejas para calcular el valor absoluto de una
     expresión.

     `cabs' no es una función apropiada para cálculos simbólicos; en
     tales casos, que incluyen la integración, diferenciación y límites
     que contienen valores absolutos, es mejor utilizar `abs'.

     El resultado devuelto por `cabs' puede incluir la función de valor
     absoluto, `abs', y el arco tangente, `atan2'.

     Cuando se aplica a una lista o matriz, `cabs' automáticamente se
     distribuye sobre sus elementos. También se distribuye sobre los
     dos miembros de una igualdad.

     Para otras formas de operar con números complejos, véanse las
     funciones `rectform', `realpart', `imagpart', `carg', `conjugate'
     y `polarform'.

     Ejemplos:

     Ejemplos con `sqrt' and `sin':

          (%i1) cabs(sqrt(1+%i*x));
                                       2     1/4
          (%o1)                      (x  + 1)
          (%i2) cabs(sin(x+%i*y));
                              2        2         2        2
          (%o2)       sqrt(cos (x) sinh (y) + sin (x) cosh (y))

     La simetría especular de la función de error `erf' se utiliza para
     calcular el valor absoluto del argumento complejo:

          (%i3) cabs(erf(x+%i*y));
                                                    2
                     (erf(%i y + x) - erf(%i y - x))
          (%o3) sqrt(--------------------------------
                                    4
                                                                         2
                                          (erf(%i y + x) + erf(%i y - x))
                                        - --------------------------------)
                                                         4

     Dado que Maxima reconoce algunas identidades complejas de las
     funciones de Bessel, le permite calcular su valor absoluto cuando
     tiene argumentos complejos. Un ejemplo para `bessel_j':

          (%i4) cabs(bessel_j(1,%i));
          (%o4)                 abs(bessel_j(1, %i))

 -- Función: carg (<z>)
     Devuelve el argumento complejo de <z>.  El argumento complejo es
     un ángulo `theta' en `(-%pi, %pi]' tal que `r exp (theta %i) =
     <z>' donde `r' es la magnitud de <z>.

     La función `carg' es computacional, no simplificativa.

     Véanse también `abs' (módulo complejo), `polarform', `rectform',
     `realpart' y `imagpart'.

     Ejemplos:

          (%i1) carg (1);
          (%o1)                           0
          (%i2) carg (1 + %i);
                                         %pi
          (%o2)                          ---
                                          4
          (%i3) carg (exp (%i));
          (%o3)                           1
          (%i4) carg (exp (%pi * %i));
          (%o4)                          %pi
          (%i5) carg (exp (3/2 * %pi * %i));
                                          %pi
          (%o5)                         - ---
                                           2
          (%i6) carg (17 * exp (2 * %i));
          (%o6)                           2


 -- Función: conjugate (<x>)
     Devuelve el conjugado complejo de <x>.

          (%i1) declare ([aa, bb], real, cc, complex, ii, imaginary);

          (%o1)                         done
          (%i2) conjugate (aa + bb*%i);

          (%o2)                      aa - %i bb
          (%i3) conjugate (cc);

          (%o3)                     conjugate(cc)
          (%i4) conjugate (ii);

          (%o4)                         - ii
          (%i5) conjugate (xx + yy);

          (%o5)             conjugate(yy) + conjugate(xx)


 -- Función: imagpart (<expr>)
     Devuelve la parte imaginaria de la expresión <expr>.

     La función `imagpart' es computacional, no simplificativa.

     Véanse también `abs', `carg', `polarform', `rectform' y `realpart'.


 -- Función: polarform (<expr>)
     Devuelve una expresión de la forma `r %e^(%i theta)' equivalente a
     <expr>, con `r' y `theta' son reales.


 -- Función: realpart (<expr>)
     Devuelve la parte real de <expr>. La funciones `realpart' y
     `imagpart' operan también con expresiones que contengan funciones
     trigonométricas e hiperbólicas, raíces cuadradas, logaritmos y
     exponentes.


 -- Función: rectform (<expr>)
     Devuelve una expresión de la forma `a + b %i' equivalente a
     <expr>, con <a> y <b> reales.



File: maxima.info,  Node: Funciones combinatorias,  Next: Funciones radicales exponenciales y logarítmicas,  Prev: Funciones para los números complejos,  Up: Funciones matemáticas

10.3 Funciones combinatorias
============================

 -- Operador: !!
     El operador doble factorial.

     Para un número entero, de punto flotante o racional `n', `n!!' se
     evaluará como el producto de `n (n-2) (n-4) (n-6) ... (n - 2
     (k-1))' donde `k' es igual a `entier(n/2)', que es, el mayor entero
     menor o igual a `n/2'.  Note que esta definición no coincide con
     otras definciones publicadas para argumentos, los cuales no son
     enteros.

     Para un entero par (o impar) `n', `n!' se evalua el producto de
     todos los enteros pares (o impares) consecutivos desde 2 (o 1) por
     `n' inclusive.

     Para un argumento `n' el cual no es un número entero, punto
     flotante o racional, `n!!' produce una forma de nombre `genfact
     (n, n/2, 2)'.


 -- Función: binomial (<x>, <y>)
     Es el coeficiente binomial `<x>!/(<y>! (<x> - <y>)!)'.  Si <x> y
     <y> son enteros, entonces se calcula el valor numérico del
     coeficiente binomial. Si <y> o <x - y> son enteros, el coeficiente
     binomial se expresa como un polinomio.

     Ejemplos:

          (%i1) binomial (11, 7);
          (%o1)                          330
          (%i2) 11! / 7! / (11 - 7)!;
          (%o2)                          330
          (%i3) binomial (x, 7);
                  (x - 6) (x - 5) (x - 4) (x - 3) (x - 2) (x - 1) x
          (%o3)   -------------------------------------------------
                                        5040
          (%i4) binomial (x + 7, x);
                (x + 1) (x + 2) (x + 3) (x + 4) (x + 5) (x + 6) (x + 7)
          (%o4) -------------------------------------------------------
                                         5040
          (%i5) binomial (11, y);
          (%o5)                    binomial(11, y)

 -- Función: factcomb (<expr>)
     Trata de combinar los coeficientes de los factoriales de <expr>
     con los mismos factoriales, convirtiendo, por ejemplo, `(n +
     1)*n!' en `(n + 1)!'.

     Si la variable `sumsplitfact' vale `false' hará que `minfactorial'
     se aplique después de `factcomb'.


 -- Función: factorial (<x>)
 -- Operador: !
     Representa la función factorial. Maxima considera `factorial (<x>)'
     y `<x>!' como sinónimos.

     Para cualquier número complejo `x', excepto para enteros
     negativos, `x!' se define como `gamma(x+1)'.

     Para un entero `x', `x!' se reduce al producto de los enteros
     desde 1 hasta `x' inclusive. `0!' se reduce a 1.  Para un número
     real o complejo en formato de coma flotante `x', `x!' se reduce al
     valor de `gamma(x+1)'. Cuando `x' es igual a `n/2', siendo `n' un
     entero impar, entonces `x!' se reduce a un factor racional
     multiplicado por `sqrt(%pi)' (pues `gamma(1/2)') es igual a
     `sqrt(%pi)').

     Las variables opcionales `factlim' y `gammalim' controlan la
     evaluación numérica de factoriales de argumentos enteros y
     racionales.

     Las funciones `minfactorial' y `factcomb' simplifican expresiones
     que contiene factoriales.

     Véanse también `factlim', `gammalim', `minfactorial' y `factcomb'.

     Las funciones `gamma', `bffac' y `cbffac' son variaciones de la
     función matemática gamma. Las funciones `bffac' y `cbffac' son
     llamadas internamente desde `gamma' para evaluar la función gamma
     de números reales y complejos decimales con precisión de reales
     grandes (bigfloats).

     Las funciones `makegamma' substituye a `gamma' para factoriales y
     funciones relacionadas.

     Maxima reconoce la derivada de la función factorial y los límites
     para ciertos valores específicos, tales como los enteros negativos.

     La variable opcional `factorial_expand' controla la simplificación
     de expresiones como `(n+x)!', para `n' entero.

     Véase también `binomial'.

     Ejemplos:

     El factorial de un entero se reduce a un número exacto, a menos que
     el argumento sea mayor que `factlim'. Los factoriales de números
     reales o complejos se evalúan como decimales de coma flotante.

          (%i1) factlim:10;
          (%o1)                                 10
          (%i2) [0!, (7/2)!, 8!, 20!];
                                      105 sqrt(%pi)
          (%o2)                   [1, -------------, 40320, 20!]
                                           16
          (%i3) [4.77!, (1.0+%i)!];
          (%o3)    [81.44668037931197,
                    .3430658398165454 %i + .6529654964201665]
          (%i4) [2.86b0!, (1.0b0+%i)!];
          (%o4) [5.046635586910012b0,
                 3.430658398165454b-1 %i + 6.529654964201667b-1]

     El factorial de una constante conocida o de una expresión general
     no se calcula. Pero puede ser posible reducir el factorial después
     de evaluado el argumento.

          (%i1) [(%i + 1)!, %pi!, %e!, (cos(1) + sin(1))!];
          (%o1)      [(%i + 1)!, %pi!, %e!, (sin(1) + cos(1))!]
          (%i2) ev (%, numer, %enumer);
          (%o2) [.3430658398165454 %i + .6529654964201665,
                 7.188082728976031,
                 4.260820476357003, 1.227580202486819]

     Los factoriales son simplificados o reducidos, no evaluados.  Así
     `x!' puede ser reemplazado en una expresión nominal.

          (%i1) '([0!, (7/2)!, 4.77!, 8!, 20!]);
                    105 sqrt(%pi)
          (%o1) [1, -------------, 81.44668037931199, 40320,
                         16
                                       2432902008176640000]

     Maxima reconoce la derivada de la función factorial.

          (%i1) diff(x!,x);
          (%o1)                           x! psi (x + 1)
                                                0

     La variable opcional `factorial_expand' controla la simplificación
     de expresiones con la función factorial.

          (%i1) (n+1)!/n!,factorial_expand:true;
          (%o1)                                n + 1

 -- Variable opcional: factlim
     Valor por defecto: -1

     La variable `factlim' especifica el mayor factorial que será
     expandido automáticamente.  Si su valor es -1, entonces se
     expandirán todos los enteros.


 -- Variable opcional: factorial_expand
     Valor por defecto: false

     La variable `factorial_expand' controla la simplificación de
     expresiones tales como `(n+1)!', siendo `n' un entero.

     Véase `!' para un ejemplo.


 -- Función: genfact (<x>, <y>, <z>)
     Devuelve el factorial generalizado, definido como `x (x-z) (x - 2
     z) ... (x - (y - 1) z)'.  Así, para el entero <x>, `genfact (x, x,
     1) = x!' y `genfact (x, x/2, 2) = x!!'.


 -- Función: minfactorial (<expr>)
     Busca en <expr> la presencia de dos factoriales que solo se
     diferencien en una unidad; en tal caso, `minfactorial' devuelve
     una expresión simplificada.

          (%i1) n!/(n+2)!;
                                         n!
          (%o1)                       --------
                                      (n + 2)!
          (%i2) minfactorial (%);
                                          1
          (%o2)                    ---------------
                                   (n + 1) (n + 2)


 -- Variable opcional: sumsplitfact
     Valor por defecto: `true'

     Si `sumsplitfact' vale `false', `minfactorial' se aplica después
     de  `factcomb'.



File: maxima.info,  Node: Funciones radicales exponenciales y logarítmicas,  Next: Funciones trigonométricas,  Prev: Funciones combinatorias,  Up: Funciones matemáticas

10.4 Funciones radicales, exponenciales y logarítmicas
======================================================

 -- Variable opcional: %e_to_numlog
     Valor por defecto: `false'

     Si `%e_to_numlog' vale `true', `r' es un número racional y `x' una
     expresión, `%e^(r*log(x))' se reduce a `x^r' .  Téngase en cuenta
     que la instrucción `radcan' también hace este tipo de
     transformaciones, así como otras más complicadas. La instrucción
     `logcontract' "contrae" expresiones que contienen algún `log'.

 -- Variable opcional: %emode
     Valor por defecto: `true'

     Si `%emode' vale `true', `%e^(%pi %i x)' se simplifica como sigue.

     `%e^(%pi %i x)' se simplifica a `cos (%pi x) + %i sin (%pi x)' si
     `x' es un número decimal de coma flotante, un entero o un múltiplo
     de 1/2, 1/3, 1/4 o 1/6, y luego se sigue simplificando.

     Para otros valores numéricos de `x', `%e^(%pi %i x)' se simplifica
     a `%e^(%pi %i y)' donde `y' es `x - 2 k' para algún entero `k' tal
     que `abs(y) < 1'.

     Si `%emode' vale `false', no se realizan simplificaciones
     especiales a `%e^(%pi %i x)'.


 -- Variable opcional: %enumer
     Valor por defecto: `false'

     Si la variable `%enumer' vale `true' hace que `%e' se reemplace por
     2.718...  siempre que `numer' valga `true'.

     Si `%enumer' vale `false', esta sustitución se realiza sólo si el
     exponente en `%e^x' tiene un valor numérico.

     Véanse también `ev' y `numer'.


 -- Función: exp (<x>)
     Representa la función exponencial.  La expresión  `exp (<x>)' en
     la entrada se simplifica en `%e^<x>'; `exp' no aparece en
     expresiones simplificadas.

     Si la variable `demoivre' vale `true' hace que `%e^(a + b %i)' se
     simplifique a `%e^(a (cos(b) + %i sin(b)))' si `b' no contiene a
     `%i'. Véase `demoivre'.

     Si la variable `%emode' vale `true', hace que  `%e^(%pi %i x)' se
     simplifique. Véase `%emode'.

     Si la variable `%enumer' vale `true' hace que `%e' se reemplace por
     2.718...  siempre que `numer' valga `true'. Véase `%enumer'.


 -- Función: li [<s>] (<z>)
     Representa la función polilogarítmica de orden <s> y argumento <z>,
     definida por la serie infinita

                                           inf
                                           ====   k
                                           \     z
                                  Li (z) =  >    --
                                    s      /      s
                                           ====  k
                                           k = 1

     `li [1]' es `- log (1 - z)'.  `li [2]' y `li [3]' son las
     funciones di- y trilogaritmo, respectivamente.

     Cuando el orden es 1, el polilogaritmo se simplifica a `- log (1 -
     z)', el cual a su vez se reduce a un valor numérico si <z> es un
     número real o complejo en coma flotante o si está presente el
     término `numer'.

     Cuando el orden es 2 ó 3, el polilogaritmo se reduce a un valor
     numérico si <z> es un número real en coma flotante o si está
     presente el término `numer'.

     Ejemplos:

          (%i1) assume (x > 0);
          (%o1)                        [x > 0]
          (%i2) integrate ((log (1 - t)) / t, t, 0, x);
          (%o2)                       - li (x)
                                          2
          (%i3) li [2] (7);
          (%o3)                        li (7)
                                         2
          (%i4) li [2] (7), numer;
          (%o4)        1.24827317833392 - 6.113257021832577 %i
          (%i5) li [3] (7);
          (%o5)                        li (7)
                                         3
          (%i6) li [2] (7), numer;
          (%o6)        1.24827317833392 - 6.113257021832577 %i
          (%i7) L : makelist (i / 4.0, i, 0, 8);
          (%o7)   [0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0]
          (%i8) map (lambda ([x], li [2] (x)), L);
          (%o8) [0, .2676526384986274, .5822405249432515,
          .9784693966661848, 1.64493407, 2.190177004178597
           - .7010261407036192 %i, 2.374395264042415
           - 1.273806203464065 %i, 2.448686757245154
           - 1.758084846201883 %i, 2.467401098097648
           - 2.177586087815347 %i]
          (%i9) map (lambda ([x], li [3] (x)), L);
          (%o9) [0, .2584613953442624, 0.537213192678042,
          .8444258046482203, 1.2020569, 1.642866878950322
           - .07821473130035025 %i, 2.060877505514697
           - .2582419849982037 %i, 2.433418896388322
           - .4919260182322965 %i, 2.762071904015935
           - .7546938285978846 %i]


 -- Función: log (<x>)
     Representa el logaritmo natural (en base e) de <x>.

     Maxima no tiene definida una función para el logaritmo de base 10 u
     otras bases. El usuario puede hacer uso de la definición `log10(x)
     := log(x) / log(10)'.

     La simplificación y evaluación de logaritmos se controla con
     ciertas variables globales:

    ``logexpand''
          hace que `log(a^b)' se convierta en `b*log(a)'.  Si toma el
          valor `all', `log(a*b)' también se reducirá a
          `log(a)+log(b)'.  Si toma el valor `super', entonces
          `log(a/b)' también se reducirá a `log(a)-log(b)', siendo
          `a/b' racional con `a#1', (la expresión `log(1/b)', para `b'
          entero, se simplifica siempre).  Si toma el valor  `false',
          se desactivarán todas estas simplificaciones.

    ``logsimp''
          si vale `false', entonces no se transforma `%e' a potencias
          que contengan logaritmos.

    ``lognegint''
          si vale `true' se aplica la regla `log(-n)' ->
          `log(n)+%i*%pi', siendo `n' un entero positivo.

    ``%e_to_numlog''
          si vale `true', `r' es un número racional y `x' una expresión,
          `%e^(r*log(x))' se reduce a `x^r'. Téngase en cuenta que la
          instrucción `radcan' también hace este tipo de
          transformaciones, así como otras más complicadas. La
          instrucción `logcontract' "contrae" expresiones que contengan
          algún `log'.


 -- Variable opcional: logabs
     Valor por defecto: `false'

     Cuando se calculan integrales indefinidas en las que se generan
     logaritmos, como en `integrate(1/x,x)', el resultado se devuelve
     de la forma  `log(abs(...))' si `logabs' vale `true', o de la
     forma `log(...)' si `logabs' vale `false'. En la integración
     definida se hace la asignación `logabs:true', ya que aquí es
     normalmente necesario evaluar la integral indefinida en los
     extremos del intervalo de integración.


 -- Variable opcional: logarc
 -- Función: logarc (<expr>)
     Si la variable global `logarc' toma el valor `true', las funciones
     circulares e hiperbólicas inversas se reemplazan por funciones
     logarítmicas equivalentes.  El valor por defecto de `logarc' es
     `false'.

     La función `logarc(<expr>)' realiza la anterior transformación en
     la expresión <expr> sin necesidad de alterar el valor de la
     variable global `logarc'.


 -- Variable opcional: logconcoeffp
     Valor por defecto: `false'

     Controla qué coeficientes se contraen cuando se utiliza
     `logcontract'. Se le puede asignar el nombre de una función de
     predicado de un argumento; por ejemplo, si se quiere introducir
     raíces cuadradas, se puede hacer `logconcoeffp:'logconfun$
     logconfun(m):=featurep(m,integer) or ratnump(m)$' .  Entonces
     `logcontract(1/2*log(x));' devolverá `log(sqrt(x))'.


 -- Función: logcontract (<expr>)
     Analiza la expresión <expr> recursivamente, transformando
     subexpresiones de la forma `a1*log(b1) + a2*log(b2) + c' en
     `log(ratsimp(b1^a1 * b2^a2)) + c'

          (%i1) 2*(a*log(x) + 2*a*log(y))$
          (%i2) logcontract(%);
                                           2  4
          (%o2)                     a log(x  y )

     Si se hace `declare(n,integer);' entonces
     `logcontract(2*a*n*log(x));' da `a*log(x^(2*n))'.  Los
     coeficientes que se contraen de esta manera son aquellos que como
     el 2 y el `n' satisfacen `featurep(coeff,integer)'. El usuario
     puede controlar qué coeficientes se contraen asignándole a la
     variable global `logconcoeffp' el nombre de una función de
     predicado de un argumento; por ejemplo, si se quiere introducir
     raíces cuadradas, se puede hacer `logconcoeffp:'logconfun$
     logconfun(m):=featurep(m,integer) or ratnump(m)$' .  Entonces
     `logcontract(1/2*log(x));' devolverá `log(sqrt(x))'.


 -- Variable opcional: logexpand
     Valor por defecto: `true'

     Si `logexpand' vale `true' hace que `log(a^b)' se convierta en
     `b*log(a)'. Si toma el valor `all', `log(a*b)' también se reducirá
     a  `log(a)+log(b)'. Si toma el valor `super', entonces `log(a/b)'
     también se reducirá a `log(a)-log(b)', siendo `a/b' racional con
     `a#1',  (la expresión `log(1/b)', para `b' entero, se simplifica
     siempre). Si toma el valor  `false', se desactivarán todas estas
     simplificaciones.

 -- Variable opcional: lognegint
     Valor por defecto: `false'

     Si `lognegint' vale `true' se aplica la regla `log(-n)' ->
     `log(n)+%i*%pi' siendo `n' un entero positivo.


 -- Variable opcional: logsimp
     Valor por defecto: `true'

     Si `logsimp' vale `false', entonces no se transforma `%e' a
     potencias que contengan logaritmos.


 -- Función: plog (<x>)
     Representa la rama principal del logaritmo natural complejo con
     `-%pi' < `carg(<x>)' <= `+%pi' .


 -- Función: sqrt (<x>)
     Raíz cuadrada de <x>. Se representa internamente por `<x>^(1/2)'.
     Véase también `rootscontract'.

     Si la variable `radexpand' vale `true' hará que las raíces
     `n'-ésimas de los factores de un producto que sean potencias de
     `n' sean extraídas del radical; por ejemplo, `sqrt(16*x^2)' se
     convertirá en `4*x' sólo si `radexpand' vale `true'.



File: maxima.info,  Node: Funciones trigonométricas,  Next: Números aleatorios,  Prev: Funciones radicales exponenciales y logarítmicas,  Up: Funciones matemáticas

10.5 Funciones trigonométricas
==============================

* Menu:

* Introducción a la trigonometría::
* Funciones y variables para trigonometría::


File: maxima.info,  Node: Introducción a la trigonometría,  Next: Funciones y variables para trigonometría,  Prev: Funciones trigonométricas,  Up: Funciones trigonométricas

10.5.1 Introducción a la trigonometría
--------------------------------------

Maxima reconoce muchas funciones trigonométricas. No están programadas
todas las identidades trigonométricas, pero el usuario puede añadir
muchas de ellas haciendo uso de las técnicas basadas en patrones.  Las
funciones trigonométricas definidas en Maxima son:  `acos', `acosh',
`acot', `acoth', `acsc', `acsch', `asec', `asech', `asin', `asinh',
`atan', `atanh', `cos', `cosh', `cot', `coth', `csc', `csch', `sec',
`sech', `sin', `sinh', `tan' y `tanh'. Hay también un determinado
número de instrucciones especiales para manipular funciones
trigonométricas;  véanse a este respecto `trigexpand', `trigreduce' y
la variable `trigsign'.  Dos paquetes adicionales amplían las reglas de
simplificación de Maxima, `ntrig' y `atrig1'.  Ejecútese
`describe(<command>)' para más detalles.


File: maxima.info,  Node: Funciones y variables para trigonometría,  Prev: Introducción a la trigonometría,  Up: Funciones trigonométricas

10.5.2 Funciones y variables para trigonometría
-----------------------------------------------

 -- Variable opcional: %piargs
     Valor por defecto: `true'

     Cuando `%piargs' vale `true', las funciones trigonométricas se
     simplifican a constantes algebraicas cuando el argumento es
     múltiplo entero de %pi, %pi/2, %pi/3, %pi/4 o %pi/6.

     Maxima conoce algunas identidades aplicables cuando %pi, etc., se
     multiplican por una variable entera (esto es, un símbolo declarado
     como entero).

     Ejemplo:

          (%i1) %piargs : false$
          (%i2) [sin (%pi), sin (%pi/2), sin (%pi/3)];
                                          %pi       %pi
          (%o2)            [sin(%pi), sin(---), sin(---)]
                                           2         3
          (%i3) [sin (%pi/4), sin (%pi/5), sin (%pi/6)];
                                %pi       %pi       %pi
          (%o3)            [sin(---), sin(---), sin(---)]
                                 4         5         6
          (%i4) %piargs : true$
          (%i5) [sin (%pi), sin (%pi/2), sin (%pi/3)];
                                          sqrt(3)
          (%o5)                    [0, 1, -------]
                                             2
          (%i6) [sin (%pi/4), sin (%pi/5), sin (%pi/6)];
                                   1         %pi   1
          (%o6)                [-------, sin(---), -]
                                sqrt(2)       5    2
          (%i7) [cos (%pi/3), cos (10*%pi/3), tan (10*%pi/3),
                 cos (sqrt(2)*%pi/3)];
                          1    1               sqrt(2) %pi
          (%o7)          [-, - -, sqrt(3), cos(-----------)]
                          2    2                    3

     Se aplican ciertas identidades cuando %pi o %pi/2 se multiplican
     por una variable entera.

          (%i1) declare (n, integer, m, even)$
          (%i2) [sin (%pi * n), cos (%pi * m), sin (%pi/2 * m),
                 cos (%pi/2 * m)];
                                                m/2
          (%o2)                  [0, 1, 0, (- 1)   ]


 -- Variable opcional: %iargs
     Valor por defecto: `true'

     Cuando `%iargs' vale `true', las funciones trigonométricas se
     simplifican a funciones hiperbólicas si el argumento es
     aparentemente un múltiplo de la unidad imaginaria %i.

     La simplificación se lleva a cabo incluso cuando el argumento es
     manifiestamente real; Maxima sólo se fija en si el argumento es un
     múltiplo literal de %i.

     Ejemplos:

          (%i1) %iargs : false$
          (%i2) [sin (%i * x), cos (%i * x), tan (%i * x)];
          (%o2)           [sin(%i x), cos(%i x), tan(%i x)]
          (%i3) %iargs : true$
          (%i4) [sin (%i * x), cos (%i * x), tan (%i * x)];
          (%o4)           [%i sinh(x), cosh(x), %i tanh(x)]

     La simplificación se aplica incluso en el caso de que el argumento
     se reduzca a un número real.

          (%i1) declare (x, imaginary)$
          (%i2) [featurep (x, imaginary), featurep (x, real)];
          (%o2)                     [true, false]
          (%i3) sin (%i * x);
          (%o3)                      %i sinh(x)


 -- Function: acos (<x>)
     Arco coseno.


 -- Función: acosh (<x>)
     Arco coseno hiperbólico.


 -- Función: acot (<x>)
     Arco cotangente.


 -- Función: acoth (<x>)
     Arco cotangente hiperbólica.


 -- Función: acsc (<x>)
     Arco cosecante.


 -- Función: acsch (<x>)
     Arco cosecante hiperbólica.


 -- Función: asec (<x>)
     Arco secante.


 -- Función: asech (<x>)
     Arco secante hiperbólica.


 -- Función: asin (<x>)
     Arco seno.


 -- Función: asinh (<x>)
     Arco seno hiperbólico.


 -- Función: atan (<x>)
     Arco tangente.


 -- Función: atan2 (<y>, <x>)
     Calcula el valor de `atan(<y>/<x>)' en el intervalo de `-%pi' a
     `%pi'.


 -- Función: atanh (<x>)
     Arco tangente hiperbólica.


 -- Paquete: atrig1
     El paquete `atrig1' contiene ciertas reglas de simplificación
     adicionales para las funciones trigonométricas inversas. Junto con
     las reglas que ya conoce Maxima, los siguientes ángulos están
     completamente implementados: `0', `%pi/6', `%pi/4', `%pi/3' y
     `%pi/2'.  Los ángulos correspondientes en los otros tres
     cuadrantes también están disponibles.  Para hacer uso de estas
     reglas, ejecútese `load(atrig1);'.


 -- Función: cos (<x>)
     Coseno.


 -- Función: cosh (<x>)
     Coseno hiperbólico.


 -- Función: cot (<x>)
     Cotangente.


 -- Función: coth (<x>)
     Cotangente hiperbólica.


 -- Función: csc (<x>)
     Cosecante.


 -- Función: csch (<x>)
     Cosecante hiperbólica.


 -- Variable opcional: halfangles
     Valor por defecto: `false'

     Si `halfangles' vale `true', las funciones trigonométricas con
     argumentos del tipo `<expr>/2' se simplifican a funciones con
     argumentos <expr>.

     Para un argumento real <x> en el intervalo `0 < x < 2*%pi' el seno
     del semiángulo se simplifica como

                              sqrt(1 - cos(x))
                              ----------------
                                  sqrt(2)

     Se necesita un factor relativamente complicado para que esta
     fórmula sea también válida para cualquier argumento complejo <z>:

                     realpart(z)
               floor(-----------)
                        2 %pi
          (- 1)                   (1 - unit_step(- imagpart(z))

                                realpart(z)            realpart(z)
                          floor(-----------) - ceiling(-----------)
                                   2 %pi                  2 %pi
                    ((- 1)                                          + 1))

     Maxima reconoce este factor y otros similares para las funciones
     `sin', `cos', `sinh' y `cosh'. Para valores especiales del
     argumento z, estos factores se simplifican de forma apropiada.

     Ejemplos:

          (%i1) halfangles:false;
          (%o1)                                false
          (%i2) sin(x/2);
                                                  x
          (%o2)                               sin(-)
                                                  2
          (%i3) halfangles:true;
          (%o3)                                true
          (%i4) sin(x/2);
                                                              x
                                                      floor(-----)
                                                            2 %pi
                                sqrt(1 - cos(x)) (- 1)
          (%o4)                 ----------------------------------
                                             sqrt(2)
          (%i5) assume(x>0, x<2*%pi)$
          (%i6) sin(x/2);
                                         sqrt(1 - cos(x))
          (%o6)                          ----------------
                                             sqrt(2)


 -- Paquete: ntrig
     El paquete `ntrig' contiene un conjunto de reglas de
     simplificación que se pueden usar para simplificar funciones
     trigonométricas cuyos argumentos son de la forma `<f>(<n> %pi/10)'
     donde <f> es cualquiera de las funciones `sin', `cos', `tan',
     `csc', `sec' o `cot'.


 -- Función: sec (<x>)
     Secante.


 -- Función: sech (<x>)
     Secante hiperbólica.


 -- Función: sin (<x>)
     Seno.


 -- Función: sinh (<x>)
     Seno hiperbólico.


 -- Función: tan (<x>)
     Tangente.


 -- Función: tanh (<x>)
     Tangente hiperbólica.


 -- Función: trigexpand (<expr>)
     Expande funciones trigonométricas e hiperbólicas de sumas de
     ángulos y de múltiplos de ángulos presentes en <expr>.  Para
     mejorar los resultados, <expr> debería expandirse. Para facilitar
     el control por parte del usuario de las simplificaciones, esta
     función tan solo expande un nivel de cada vez, expandiendo sumas
     de ángulos o de múltiplos de ángulos. A fin de obtener una
     expansión completa en senos y coseno, se le dará a la variable
     `trigexpand' el valor `true'.

     La función `trigexpand' está controlada por las siguientes
     variables:

    `trigexpand'
          Si vale `true', provoca la expansión de todas las expresiones
          que contengan senos y cosenos.

    `trigexpandplus'
          Controla la regla de la suma para `trigexpand', la expansión
          de una suma como `sin(x + y)' se llevará a cabo sólo si
          `trigexpandplus' vale `true'.

    `trigexpandtimes'
          Controla la regla del producto para `trigexpand', la
          expansión de un producto como `sin(2 x)' se llevará a cabo
          sólo si `trigexpandtimes' vale `true'.

     Ejemplos:

          (%i1) x+sin(3*x)/sin(x),trigexpand=true,expand;
                                   2           2
          (%o1)               - sin (x) + 3 cos (x) + x
          (%i2) trigexpand(sin(10*x+y));
          (%o2)          cos(10 x) sin(y) + sin(10 x) cos(y)


 -- Variable optativa: trigexpandplus
     Valor por defecto: `true'

     La variable `trigexpandplus' controla la regla de la suma para
     `trigexpand'.  Así, si la instrucción `trigexpand' se utiliza o si
     la variable `trigexpand' vale `true', se realizará la expansión de
     sumas como `sin(x+y)' sólo si `trigexpandplus' vale `true'.


 -- Variable optativa: trigexpandtimes
     Valor por defecto: `true'

     La variable `trigexpandtimes' controla la regla del producto para
     `trigexpand'.  Así, si la instrucción `trigexpand' se utiliza o si
     la variable `trigexpand' vale `true', se realizará la expansión de
     productos como `sin(2*x)' sólo si `trigexpandtimes' vale `true'.


 -- Variable optativa: triginverses
     Valor por defecto: `true'

     La variable `triginverses' controla la simplificación de la
     composición de funciones trigonométricas e hiperbólicas con sus
     funciones inversas.

     Si vale `all', tanto `atan(tan(<x>))'  como `tan(atan(<x>))' se
     reducen a <x>.

     Si vale `true', se desactiva la simplificación de
     `<arcfun>(<fun>(<x>))'.

     Si vale `false', se desactivan las simplificaciones de
     `<arcfun>(<fun>(<x>))' y `<fun>(<arcfun>(<x>))'.


 -- Función: trigreduce (<expr>, <x>)
 -- Función: trigreduce (<expr>)
     Combina productos y potencias de senos y cosenos trigonométricos e
     hiperbólicos de <x>, transformándolos en otros que son múltiplos
     de <x>.  También intenta eliminar estas funciones cuando aparecen
     en los denominadores.  Si no se introduce el argumento <x>,
     entonces se utilizan todas las variables de <expr>.

     Véase también `poissimp'.

          (%i1) trigreduce(-sin(x)^2+3*cos(x)^2+x);
                         cos(2 x)      cos(2 x)   1        1
          (%o1)          -------- + 3 (-------- + -) + x - -
                            2             2       2        2

     Las rutinas de simplificación trigonométrica utilizan información
     declarada en algunos casos sencillos. Las declaraciones sobre
     variables se utilizan como se indica a continuación:

          (%i1) declare(j, integer, e, even, o, odd)$
          (%i2) sin(x + (e + 1/2)*%pi);
          (%o2)                        cos(x)
          (%i3) sin(x + (o + 1/2)*%pi);
          (%o3)                       - cos(x)


 -- Variable optativa: trigsign
     Valor por defecto: `true'

     Si `trigsign' vale `true', se permite la simplificación de
     argumentos negativos en funciones trigonométricas, como en
     `sin(-x)', que se transformará en `-sin(x)' sólo si `trigsign'
     vale `true'.


 -- Función: trigsimp (<expr>)
     Utiliza las identidades sin(x)^2 + cos(x)^2 = 1 y cosh(x)^2 -
     sinh(x)^2 = 1 para simplificar expresiones que contienen `tan',
     `sec', etc., en expresiones con `sin', `cos', `sinh', `cosh'.

     Las funciones `trigreduce', `ratsimp' y `radcan' puden seguir
     siendo útiles para continuar el proceso de simplificación.

     La instrucción `demo ("trgsmp.dem")' muestra algunos ejemplos de
     `trigsimp'.


 -- Función: trigrat (<expr>)
     Devuelve una forma canónica simplificada cuasi-lineal de una
     expresión trigonométrica; <expr> es una fracción racional que
     contiene `sin', `cos' o `tan', cuyos argumentos son formas
     lineales respecto de ciertas variables (o kernels) y `%pi/<n>'
     (<n> entero) con coeficientes enteros. El resultado es una
     fracción simplificada con el numerador y denominador lineales
     respecto de `sin' y `cos'. Así,  `trigrat' devuelve una expresión
     lineal siempre que sea posible.

          (%i1) trigrat(sin(3*a)/sin(a+%pi/3));
          (%o1)            sqrt(3) sin(2 a) + cos(2 a) - 1

     El siguiente ejemplo se ha tomado de Davenport, Siret y Tournier,
     Calcul Formel, Masson (o en inglés, Addison-Wesley), sección
     1.5.5, teorema de Morley.

          (%i1) c : %pi/3 - a - b$
          (%i2) bc : sin(a)*sin(3*c)/sin(a+b);
                                                    %pi
                            sin(a) sin(3 (- b - a + ---))
                                                     3
          (%o2)             -----------------------------
                                     sin(b + a)
          (%i3) ba : bc, c=a, a=c;
                                                   %pi
                              sin(3 a) sin(b + a - ---)
                                                    3
          (%o3)               -------------------------
                                            %pi
                                    sin(a - ---)
                                             3
          (%i4) ac2 : ba^2 + bc^2 - 2*bc*ba*cos(b);
                   2         2         %pi
                sin (3 a) sin (b + a - ---)
                                        3
          (%o4) ---------------------------
                          2     %pi
                       sin (a - ---)
                                 3
                                                 %pi
           - (2 sin(a) sin(3 a) sin(3 (- b - a + ---)) cos(b)
                                                  3
                       %pi            %pi
           sin(b + a - ---))/(sin(a - ---) sin(b + a))
                        3              3
                2       2              %pi
             sin (a) sin (3 (- b - a + ---))
                                        3
           + -------------------------------
                          2
                       sin (b + a)
          (%i5) trigrat (ac2);
          (%o5) - (sqrt(3) sin(4 b + 4 a) - cos(4 b + 4 a)
           - 2 sqrt(3) sin(4 b + 2 a) + 2 cos(4 b + 2 a)
           - 2 sqrt(3) sin(2 b + 4 a) + 2 cos(2 b + 4 a)
           + 4 sqrt(3) sin(2 b + 2 a) - 8 cos(2 b + 2 a) - 4 cos(2 b - 2 a)
           + sqrt(3) sin(4 b) - cos(4 b) - 2 sqrt(3) sin(2 b) + 10 cos(2 b)
           + sqrt(3) sin(4 a) - cos(4 a) - 2 sqrt(3) sin(2 a) + 10 cos(2 a)
           - 9)/4



File: maxima.info,  Node: Números aleatorios,  Prev: Funciones trigonométricas,  Up: Funciones matemáticas

10.6 Números aleatorios
=======================

 -- Función: make_random_state (<n>)
 -- Función: make_random_state (<s>)
 -- Función: make_random_state (true)
 -- Función: make_random_state (false)
     Un objeto de estado aleatorio representa el estado del generador
     de números aleatorios. El estado consiste en 627 cadenas binarias
     de 32 bits.

     La llamada `make_random_state (<n>)' devuelve un nuevo objeto de
     estado aleatorio creado a partir de una semilla entera igual a <n>
     módulo 2^32. El argumento <n> puede ser negativo.

     La llamada `make_random_state (<s>)' devuelve una copia del estado
     aleatorio <s>.

     La llamada `make_random_state (true)' devuelve un nuevo objeto de
     estado aleatorio, cuya semilla se genera a partir de la hora
     actual del reloj del sistema como semilla.

     La llamada `make_random_state (false)' devuelve una copia del
     estado actual del generador de números aleatorios.


 -- Función: set_random_state (<s>)
     Establece <s> como estado del generador de números aleatorios.

     La función `set_random_state' devuelve `done' en todo caso.


 -- Función: random (<x>)
     Devuelve un número seudoaleatorio. Si <x> es un entero, `random
     (<x>)' devuelve un entero entre 0 y `<x> - 1', ambos inclusive. Si
     <x> es un decimal en punto flotante, `random (<x>)' devuelve un
     decimal no negativo en punto flotante menor que <x>.  La función
     `random' emite un mensaje de error si <x> no es ni entero ni de
     punto flotante, o si <x> no es positivo.

     Las funciones `make_random_state' y `set_random_state' permiten
     controlar el estado del generador de números aleatorios.

     El generador de números aleatorios de Maxima implementa el
     algoritmo de Mersenne twister MT 19937.

     Ejemplos:

          (%i1) s1: make_random_state (654321)$
          (%i2) set_random_state (s1);
          (%o2)                         done
          (%i3) random (1000);
          (%o3)                          768
          (%i4) random (9573684);
          (%o4)                        7657880
          (%i5) random (2^75);
          (%o5)                11804491615036831636390
          (%i6) s2: make_random_state (false)$
          (%i7) random (1.0);
          (%o7)                   .2310127244107132
          (%i8) random (10.0);
          (%o8)                   4.394553645870825
          (%i9) random (100.0);
          (%o9)                   32.28666704056853
          (%i10) set_random_state (s2);
          (%o10)                        done
          (%i11) random (1.0);
          (%o11)                  .2310127244107132
          (%i12) random (10.0);
          (%o12)                  4.394553645870825
          (%i13) random (100.0);
          (%o13)                  32.28666704056853



File: maxima.info,  Node: Base de datos de Maxima,  Next: Gráficos,  Prev: Funciones matemáticas,  Up: Top

11 Base de datos de Maxima
**************************

* Menu:

* Introducción a la base de datos de Maxima::
* Funciones y variables para las propiedades::
* Funciones y variables para los hechos::
* Funciones y variables para los predicados::


File: maxima.info,  Node: Introducción a la base de datos de Maxima,  Next: Funciones y variables para las propiedades,  Prev: Base de datos de Maxima,  Up: Base de datos de Maxima

11.1 Introducción a la base de datos de Maxima
==============================================

Propiedades
-----------

A las variables y funciones se les puede asignar propiedades con la
función `declare'. Estas propiedades son almacenadas en un banco de
datos o registradas en una lista de propiedades que proporciona Lisp.
Con la función `featurep' se puede comprobar si un símbolo tiene una
determinada propiedad y con la función `properties' se pueden obtener
todas las propiedades asociadas a él. A su vez, la función `remove'
elimina una propiedad de la base de datos o de la lista de propiedades.
En caso de utilizar `kill' para borrar el valor asignado a una
variable, también serán borradas todas las propiedades asociadas a la
misma.

   El usuario tiene la facultad de añadirle propiedades a un símbolo
con las funciones `put' y `qput'. Con la función `get' podrá leer sus
propiedades y borrarlas con `rem'.

   Las variables pueden tener las siguientes propiedades a almacenar en
el banco de datos:

   constant
   integer        noninteger
   even           odd
   rational       irrational
   real           imaginary      complex

   Las funciones pueden tener las siguientes propiedades a almacenar en
el banco de datos:

   increasing     decreasing
   posfun         integervalued

   Las siguientes propiedades se pueden aplicar a funciones y se
utilizan para su correcta simplificación. Estas propiedades se
describen en el capítulo dedicado a la simplificación:

   linear         additive       multiplicative
   outative       commutative    symmetric
   antisymmetric  nary           lassociativ
   rassociative   evenfun        oddfun

   Otras propiedades aplicables a variables y funciones, y que se
almacenan en la lista de propiedades de Lisp, son:

   bindtest       feature        alphabetic
   scalar         nonscalar      nonarray

Contextos
---------

Maxima administra contextos en los que se almacenan tanto las
propiedades de las variables y funciones como hechos o hipótesis sobre
las mismas. Los hechos se establecen con la función `assume' y se
almacenan en el contexto actual.  Por ejemplo, con `assume(a>10)'
guarda Maxima la información sobre el hecho de que la variable `a' es
mayor que `10'. Con la función `forget' se borran los hechos de la base
de datos. Cuando Maxima pregunta al usuario sobre las propiedades de
una variable, éstas son almacenadas en un contexto.

   Cada contexto se identifica por un nombre. Al iniciarse Maxima, el
contexto actual recibe el nombre de `initial' y se puede definir un
número arbitrario de contextos adicionales que pueden organizarse de
forma jerárquica.  Así, el contexto `initial' está incluido en el
contexto `global'. Los hechos definidos en un contexto dado están
siempre activos en los contextos de nivel inferior. Por ejemplo, el
contexto `global' contiene hechos que se inicializan por el propio
Maxima y estarán activos, por tanto, en el contexto `initial'.

   Los contextos pueden almacenar un número arbitrario de hechos y
pueden desactivarse con la función `deactivate'. Desactivar un contexto
no implica la pérdida de los hechos almacenados, pudiendo ser
posteriormente reactivado con la función `activate', estando los hechos
siempre a disposición del usuario.


File: maxima.info,  Node: Funciones y variables para las propiedades,  Next: Funciones y variables para los hechos,  Prev: Introducción a la base de datos de Maxima,  Up: Base de datos de Maxima

11.2 Funciones y variables para las propiedades
===============================================

 -- Propiedad: alphabetic
     `alphabetic' es un tipo de propiedad reconocida por `declare'.  La
     expresión `declare(<s>, alphabetic)' le indica a Maxima que
     reconozca como alfabéticos todos los caracteres que haya en <s>,
     que debe ser una cadena de texto.

     Véase también `Identifiers'.

     Ejemplo:

          (%i1) xx\~yy\`\@ : 1729;
          (%o1)                         1729
          (%i2) declare ("~`@", alphabetic);
          (%o2)                         done
          (%i3) xx~yy`@ + @yy`xx + `xx@@yy~;
          (%o3)               `xx@@yy~ + @yy`xx + 1729
          (%i4) listofvars (%);
          (%o4)                  [@yy`xx, `xx@@yy~]

 -- Propiedad: bindtest
     La sentencia `declare(<x>, bindtest' le indica a Maxima que
     devuelva un mensaje de error cuando el símbolo <x> no tenga
     asociado valor alguno.

     Ejemplo:

          (%i1) aa + bb;
          (%o1)                        bb + aa
          (%i2) declare (aa, bindtest);
          (%o2)                         done
          (%i3) aa + bb;
          aa unbound variable
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) aa : 1234;
          (%o4)                         1234
          (%i5) aa + bb;
          (%o5)                       bb + 1234

 -- Propiedad: constant
     `declare(<a>, constant)' declara <a> como constante.  La
     declaración de un símbolo como constante no impide que se le
     asigne un valor no constante al símbolo.

     Véanse `constantp' y `declare'

     Ejemplo:

          (%i1) declare(c, constant);
          (%o1)                         done
          (%i2) constantp(c);
          (%o2)                         true
          (%i3) c : x;
          (%o3)                           x
          (%i4) constantp(c);
          (%o4)                         false

 -- Función: constantp (<expr>)
     Devuelve `true' si <expr> es una expresión constante y `false' en
     caso contrario.

     Una expresión se considera constante si sus argumentos son números
     (incluidos los números racionales que se muestran con `/R/'),
     constantes simbólicas como `%pi', `%e' o `%i', variables con valor
     constante o declarada como constante por `declare', o funciones
     cuyos argumentos son constantes.

     La función `constantp' evalúa sus argumentos.

     Ejemplos:

          (%i1) constantp (7 * sin(2));
          (%o1)                                true
          (%i2) constantp (rat (17/29));
          (%o2)                                true
          (%i3) constantp (%pi * sin(%e));
          (%o3)                                true
          (%i4) constantp (exp (x));
          (%o4)                                false
          (%i5) declare (x, constant);
          (%o5)                                done
          (%i6) constantp (exp (x));
          (%o6)                                true
          (%i7) constantp (foo (x) + bar (%e) + baz (2));
          (%o7)                                false
          (%i8)

 -- Función: declare (<a_1>, <f_1>, <a_2>, <f_2>, ...)
     Asigna al átomo o lista de átomos <a_i> la propiedad o lista de
     propiedades<p_i>. Si <a_i> y/o <p_i> son listas, cada uno de los
     átomos adquiere todas las propiedades.

     La función `declare' no evalúa sus argumentos y siempre devuelve la
     expresión `done'.

     La llamada `featurep (<object>, <feature>)' devuelve `true' si
     <object> ha sido previamente declarado como poseedor de la
     propiedad <feature>.

     Véase también `features'.

     La función `declare' reconoce las siguientes propiedades:

    `additive'
          Hace que Maxima simplifique las expresiones <a_i>
          haciendo uso de la sustitución       `<a_i>(x + y + z + ...)'
          `-->'       `<a_i>(x) + <a_i>(y) + <a_i>(z) + ...'.
          Tal sustitución se aplica únicamente al primer argumento.

    `alphabetic'
          Indica a Maxima que reconozca todos los caracteres de la
          cadena alfanumérica       <a_i> como caracteres alfabéticos.

    `antisymmetric, commutative, symmetric'
          Hace que Maxima reconozca a <a_i> como una función simétrica o
               antisimétrica. La propiedad `commutative' equivale a
          `symmetric'.

    `bindtest'
          Hace que Maxima envíe un error si <a_i> es evaluado sin
          habérsele       asignado un valor.

    `constant'
          Hace que Maxima considere a <a_i> como una constante
          simbólica.

    `even, odd'
          Hace que Maxima reconozca a <a_i> como una variable entera
          par o impar.

    `evenfun, oddfun'
          Hace que Maxima reconozca a <a_i> como una función par o
          impar.

    `evflag'
          Hace que <a_i> sea reconocida por `ev', de manera que a <a_i>
          se le       asigne el valor `true' durante la ejecución de
          `ev' cuando <a_i>       aparezca como argumento de control de
          `ev'. Véase también `evflag'.

    `evfun'
          Hace que <a_i> sea reconocida por `ev', de manera que la
          función       nombrada por <a_i> se aplique cuando <a_i>
          aparezca como argumento       de control de `ev'. Véase
          también `evfun'.

    `feature'
          Hace que Maxima considere a <a_i> como el nombre de una
          propiedad.        Otros átomos podrán ser declarados entonces
          como poseedores de       la propiedad <a_i>.

    `increasing, decreasing'
          Hace que Maxima reconozca a <a_i> como una función creciente
          o decreciente.

    `integer, noninteger'
          Hace que Maxima reconozca a <a_i> como una variable entera o
          no entera.

    `integervalued'
          Hace que Maxima reconozca a <a_i> como una función de valor
          entero.

    `lassociative, rassociative'
          Hace que Maxima reconozca a <a_i> como una función asociativa
          por la derecha o       por la izquierda.

    `linear'
          Equivale a declarar <a_i> conjuntamente como `outative' y
          `additive'.

    `mainvar'
          Hace que Maxima considere a <a_i> como una "variable
          principal",       dándole prioridad frente a cualesquiera
          otras constantes o       variables en la ordenación canónica
          de expresiones de Maxima,       tal como determina
          `ordergreatp'.

    `multiplicative'
          Hace que Maxima simplifique las expresiones <a_i>
          haciendo uso de la sustitución       `<a_i>(x * y * z * ...)'
          `-->' `<a_i>(x) * <a_i>(y) * <a_i>(z) * ...'.        Tal
          sustitución se aplica únicamente al primer argumento.

    `nary'
          Hace que Maxima reconozca a <a_i> como una función n-aria.

          La declaración `nary' no es equivalente a la función `nary'.
               El único efecto de `declare(foo, nary)' consiste en
          hacer que       el simplificador de Maxima reduzca
          expresiones anidadas; por ejemplo,       para transformar
          `foo(x, foo(y, z))' a `foo(x, y, z)'.

    `nonarray'
          Indica que Maxima no debe considerar <a_i> como un array.
          Esta declaración       evita la evaluación múltiple de
          variables subindicadas.

    `nonscalar'
          Hace que Maxima considere a <a_i> como una variable no
          escalar.        Se aplica comúnmente para declarar una
          variable como un vector simbólico       o una matriz
          simbólica.

    `noun'
          Hace que Maxima considere a <a_i> como un nombre. El efecto
             que se obtiene es que se reemplazan todas las expresiones
          <a_i>       por `'<a_i>' o `nounify (<a_i>)',
          dependiendo del contexto.

    `outative'
          Hace que Maxima simplifique las expresiones <a_i>
          extrayendo los factores constantes del primer argumento.

          Cuando <a_i> tenga un único argumento, un factor se
          considerará constante       si es una constante literal o
          declarada.

          Cuando <a_i> tenga dos o más argumentos, un factor se
          considerará constante       si el segundo argumento es un
          símbolo y el factor no contiene al       segundo argumento.

    `posfun'
          Hace que Maxima reconozca a <a_i> como una función positiva.

    `rational, irrational'
          Hace que Maxima reconozca a <a_i> como una variable real
          racional o irracional.

    `real, imaginary, complex'
          Hace que Maxima reconozca a <a_i> como una variable real,
          imaginaria o compleja.

    `scalar'
          Hace que Maxima considere a <a_i> como una variable escalar.


     Ejemplos sobre el uso de estas propiedades están disponibles en la
     documentación correspondiente a cada propiedad por separado.

 -- Propiedad: decreasing
 -- Propiedad: increasing
     Las instrucciones `declare(<f>, decreasing)' y `declare(<f>,
     increasing' le indican a Maxima que reconozca la función <f> como
     una función decreciente o creciente.

     Véase también `declare' para más propiedades.

     Ejemplo:

          (%i1) assume(a > b);
          (%o1)                        [a > b]
          (%i2) is(f(a) > f(b));
          (%o2)                        unknown
          (%i3) declare(f, increasing);
          (%o3)                         done
          (%i4) is(f(a) > f(b));
          (%o4)                         true

 -- Propiedad: even
 -- Propiedad: odd
     `declare(<a>, even)' y `declare(<a>, odd)' le indican a Maxima que
     reconozca el símbolo <a> como entero par o impar.  Las propiedades
     `even' y `odd' no son reconocidas por las funciones `evenp',
     `oddp' y `integerp'.

     Véanse también `declare' y `askinteger'.

     Ejemplo:

          (%i1) declare(n, even);
          (%o1)                         done
          (%i2) askinteger(n, even);
          (%o2)                          yes
          (%i3) askinteger(n);
          (%o3)                          yes
          (%i4) evenp(n);
          (%o4)                         false

 -- Propiedad: feature
     Maxima interpreta dos tipos diferentes de propiedades, del sistema
     y las que se aplican a expresiones matemáticas. Véase `status'
     para obtener información sobre propiedades del sistema, así como
     `features' y `featurep' para propiedades de las expresiones
     matemáticas.

     `feature' no es el nombre de ninguna función o variable.

 -- Función: featurep (<a>, <f>)
     Intenta determinar si el objeto <a> tiene la propiedad <f> en base
     a los hechos almacenados en la base de datos. En caso afirmativo,
     devuelve `true', o `false' en caso contrario.

     Nótese que `featurep' devuelve `false' cuando no se puedan
     verificar ni <f> ni su negación.

     `featurep' evalúa su argumento.

     Véanse también `declare' y `features'.

     Ejemplos:

          (%i1) declare (j, even)$
          (%i2) featurep (j, integer);
          (%o2)                           true

 -- Declaración: features
     Maxima reconoce ciertas propiedades matemáticas sobre funciones y
     variables.

     La llamada `declare (<x>, <foo>)' asocia la propiedad <foo> a la
     función o variable <x>.

     La llamada `declare (<foo>, feature)' declara una nueva propiedad
     <foo>.  Por ejemplo, `declare ([rojo, verde, azul], feature)'
     declara tres nuevas propiedades, `rojo', `verde' y `azul'.

     El predicado `featurep (<x>, <foo>)' devuelve `true' si <x> goza
     de la propiedad <foo>, y `false' en caso contrario.

     La lista `features' contiene las propiedades que reconoce Maxima;
     a saber,

        integer        noninteger      even
        odd            rational        irrational
        real           imaginary       complex
        analytic       increasing      decreasing
        oddfun         evenfun         posfun
        commutative    lassociative    rassociative
        symmetric      antisymmetric

     junto con las definidas por el usuario.

     La lista `features' sólo contiene propiedades matemáticas.  Hay
     otra lista con propiedades no matemáticas; Véase `status'.

     Ejemplo:

          (%i1) declare (FOO, feature);
          (%o1)                         done
          (%i2) declare (x, FOO);
          (%o2)                         done
          (%i3) featurep (x, FOO);
          (%o3)                         true

 -- Función: get (<a>, <i>)
     Recupera la propiedad de usuario indicada por <i> asociada al
     átomo <a> o devuelve `false' si <a> no tiene la propiedad <i>.

     La función `get' evalúa sus argumentos.

     Véanse también `put' y `qput'.

          (%i1) put (%e, 'transcendental, 'type);
          (%o1)                    transcendental
          (%i2) put (%pi, 'transcendental, 'type)$
          (%i3) put (%i, 'algebraic, 'type)$
          (%i4) typeof (expr) := block ([q],
                  if numberp (expr)
                  then return ('algebraic),
                  if not atom (expr)
                  then return (maplist ('typeof, expr)),
                  q: get (expr, 'type),
                  if q=false
                  then errcatch (error(expr,"is not numeric.")) else q)$
          (%i5) typeof (2*%e + x*%pi);
          x is not numeric.
          (%o5)  [[transcendental, []], [algebraic, transcendental]]
          (%i6) typeof (2*%e + %pi);
          (%o6)     [transcendental, [algebraic, transcendental]]

 -- Propiedad: integer
 -- Propiedad: noninteger
     `declare(<a>, integer)' o `declare(<a>, noninteger)' indica a
     Maxima que reconozca <a> como una variable entera o no entera.

     Véase también `declare'.

     Ejemplo:

          (%i1) declare(n, integer, x, noninteger);
          (%o1)                         done
          (%i2) askinteger(n);
          (%o2)                          yes
          (%i3) askinteger(x);
          (%o3)                          no

 -- Propiedad: integervalued
     `declare(<f>, integervalued)' indica a MAxima que reconozca <f>
     como una función que toma valores enteros.

     Véase también `declare'.

     Ejemplo:

          (%i1) exp(%i)^f(x);
                                        %i f(x)
          (%o1)                      (%e  )
          (%i2) declare(f, integervalued);
          (%o2)                         done
          (%i3) exp(%i)^f(x);
                                        %i f(x)
          (%o3)                       %e

 -- Propiedad: nonarray
     La instrucción `declare(a, nonarray)' le indica a Maxima que no
     considere <a> como un array. Esta declaración evita la evaluación
     múltiple de <a>, si ésta es una variable subindicada.

     Véase también `declare'.

     Ejemplo:

          (%i1) a:'b$ b:'c$ c:'d$

          (%i4) a[x];
          (%o4)                          d
                                          x
          (%i5) declare(a, nonarray);
          (%o5)                         done
          (%i6) a[x];
          (%o6)                          a
                                          x

 -- Propiedad: nonscalar
     Hace que los átomos se comporten como hace una lista o matriz con
     respecto del operador `.' del la multiplicación no conmutativa.

     Véase también `declare'.

 -- Función: nonscalarp (<expr>)
     Devuelve `true' si <expr> no es escalar, es decir, si contiene
     átomos declarados como no escalares, listas o matrices.

 -- Declaración: posfun
     La instrucción `declare (f, posfun)' declara a `f' como función
     positiva, de forma que `is (f(x) > 0)' devolverá `true'.

     Véase también `declare'.

 -- Función: printprops (<a>, <i>)
 -- Función: printprops ([<a_1>, ..., <a_n>], <i>)
 -- Función: printprops (all, <i>)
     Muestra la propiedad con el indicador <i> asociado con el átomo
     <a>. <a> puede ser también una lista de átomos o el átomo `all' en
     cuyo caso todos los átomos a los cuales se les haya dado esa
     propiedad serán usados.  Por ejemplo, `printprops ([f, g],
     atvalue)'. `printprops' es para propiedades que no pueden ser
     mostradas de otra manera, i.e. para `atvalue', `atomgrad',
     `gradef', y `matchdeclare'.


 -- Función: properties (<a>)
     Devuelve una lista con los nombres de todas las propiedades
     asociadas al t'omo <a>.

 -- Variable del sistema: props
     Valor por defecto: `[]'

     `props' son t'omos que tienen asociadas otras propiedades además
     de las explícitamente mencionadas en `infolists', tales como las
     especificadas por `atvalue', `matchdeclare' y la función `declare'.

 -- Función: propvars (<prop>)
     Devuelve la lista con los átomos de la lista `props' que tienen la
     propiedad indicada por <prop>. Así, `propvars (atvalue)' devuelve
     la lista con los átomos a los que se les ha asociado valores con
     `atvalue'.

 -- Función: put (<átomo>, <valor>, <indicador>)
     Asigna el <valor> a la propiedad  (especificada por <indicador>)
     de <átomo>; <indicador> puede ser el nombre de cualquier propiedad
     y no solamente de aquellas definidas por el sistema.

     `rem' deshace la asignación realizada por `put'.

     La función `put' evalúa sus argumentos y devuelve <valor>.

     Ejemplos:

          (%i1) put (foo, (a+b)^5, expr);
                                             5
          (%o1)                       (b + a)
          (%i2) put (foo, "Hello", str);
          (%o2)                         Hello
          (%i3) properties (foo);
          (%o3)            [[user properties, str, expr]]
          (%i4) get (foo, expr);
                                             5
          (%o4)                       (b + a)
          (%i5) get (foo, str);
          (%o5)                         Hello


 -- Función: qput (<átomo>, <valor>, <indicador>)
     Asigna <valor> a la propiedad de <átomo> que especifique
     <indicador>.  Actúa del mismo modeo que `put', excepto que sus
     argumentos no son evaluados.

     Véase también `get'.

     Ejemplo:

          (%i1) foo: aa$
          (%i2) bar: bb$
          (%i3) baz: cc$
          (%i4) put (foo, bar, baz);
          (%o4)                          bb
          (%i5) properties (aa);
          (%o5)                [[user properties, cc]]
          (%i6) get (aa, cc);
          (%o6)                          bb
          (%i7) qput (foo, bar, baz);
          (%o7)                          bar
          (%i8) properties (foo);
          (%o8)            [value, [user properties, baz]]
          (%i9) get ('foo, 'baz);
          (%o9)                          bar

 -- Propiedad: rational
 -- Propiedad: irrational
     `declare(<a>, rational)' o `declare(<a>, irrational)' indica a
     Maxima que reconozca <a> como una variable real racional o
     irracional.

     Véase también `declare'.

 -- Propiedad: real
 -- Propiedad: imaginary
 -- Propiedad: complex
     `declare(<a>, real)', `declare(<a>, imaginary)' o `declare(<a>,
     complex)' indican a Maxima que reconozca <a> como variable real,
     imaginaria puro o compleja, respectivamente.

     Véase también `declare'.

 -- Función: rem (<átomo>, <indicador>)
     Elimina del <átomo> la propiedad indicada por <indicador>.  `rem'
     deshace la asignación realizada por `put'.

     `rem' devuelve `done' si <átomo> tenía la propiedad <indicador>
     cuando `rem' fue invocado, devolviendo `false' si carecía tal
     propiedad.


 -- Función: remove (<a_1>, <p_1>, ..., <a_n>, <p_n>)
 -- Función: remove ([<a_1>, ..., <a_m>], [<p_1>, ..., <p_n>], ...)
 -- Función: remove ("<a>", operator)
 -- Función: remove (<a>, transfun)
 -- Función: remove (all, <p>)
     Elimina propiedades asociadas con átomos.

     La llamada `remove (<a_1>, <p_1>, ..., <a_n>, <p_n>)' elimina la
     propiedad `p_k' del átomo `a_k'.

     La llamada `remove ([<a_1>, ..., <a_m>], [<p_1>, ..., <p_n>], ...)'
     elimina las propiedades `<p_1>, ..., <p_n>' de los átomos <a_1>,
     ..., <a_m>. Puede tener más de un par de listas.

     La llamada `remove (all, <p>)' elimina la propiedad <p> de todos
     los átomos que la tengan.

     Las propiedades eliminadas pueden ser de las que define el
     sistema, como `function', `macro' o `mode_declare'; `remove' no
     elimina las propiedades definidas por `put'.

     La llamada `remove ("<a>", operator)' o su equivalente `remove
     ("<a>", op)' elimina de  <a> las propiedades de operador
     declaradas por `prefix', `infix', `nary', `postfix', `matchfix' o
     `nofix'. Nótese que el nombre del operador debe escribirse como
     cadena precedida de apóstrofo.

     La función `remove' devuelve siempre `done' independientemente que
     haya algún átomo con la propiedad especificada.

     La función `remove' no evalúa sus argumentos.

 -- Propiedad: scalar
     `declare(<a>, scalar)' indica a Maxima que considere a <a> como
     una variable escalar.

     Véase también `declare'.

 -- Función: scalarp (<expr>)
     Devuelve `true' si <expr> es un número, constante  o variable
     declarada como `scalar' con `declare', o compuesta completamente
     de tales números, constantes o variables, pero que no contengan
     matrices ni listas.


File: maxima.info,  Node: Funciones y variables para los hechos,  Next: Funciones y variables para los predicados,  Prev: Funciones y variables para las propiedades,  Up: Base de datos de Maxima

11.3 Funciones y variables para los hechos
==========================================

 -- Función: activate (<context_1>, ..., <context_n>)
     Activa los contextos <context_1>, ..., <context_n>.  Los hechos en
     estos contextos están disponibles para hacer deducciones y extraer
     información.  Los hechos en estos contextos no se listan al
     invocar `facts ()'.

     La variable `activecontexts' es la lista de contextos que se han
     activado por medio de la función `activate'.


 -- Variable del sistema: activecontexts
     Valor por defecto: `[]'

     La variable `activecontexts' es la lista de contextos que se han
     activado por medio de la función `activate', pero que no se han
     activado por ser subcontextos del contexto actual.


 -- Función: askinteger (<expr>, integer)
 -- Función: askinteger (<expr>)
 -- Función: askinteger (<expr>, even)
 -- Función: askinteger (<expr>, odd)
     La llamada `askinteger (<expr>, integer)' intenta determinar a
     partir de la base de datos de `assume' si <expr> es un entero. La
     función `askinteger' pide más información al usuario si no
     encuentra la respuesta, tratando de almacenar la nueva información
     en la base de datos si es posible. La llamada `askinteger
     (<expr>)' equivale a `askinteger (<expr>, integer)'.

     La llamadas `askinteger (<expr>, even)' ay `askinteger (<expr>,
     odd)' intentan determinar si <expr> es un entero par o impar,
     respectivamente.


 -- Función: asksign (<expr>)
     Primero intenta determinar si la expresión especificada es
     positiva, negativa o cero.  Si no lo consigue, planteará al
     usuario preguntas que le ayuden a conpletar la deducción. Las
     respuestas del usuario son almacenadas en la base de datos durante
     el tiempo que dure este cálculo. El valor que al final devuelva
     `asksign' será `pos', `neg' o `zero'.


 -- Función: assume (<pred_1>, ..., <pred_n>)
     Añade los predicados <pred_1>, ..., <pred_n> al contexto actual.
     Si un predicado es inconsistente o redundante con los otros
     predicados del contexto actual, entonces no es añadido al contexto.
     El contexto va acumulando predicados con cada llamada a `assume'.

     La función `assume' devuelve una lista cuyos miembros son los
     predicados que han sido añadidos al contexto, o los átomos
     `redundant' o `inconsistent' si fuere necesario.

     Los predicados <pred_1>, ..., <pred_n> tan solo pueden ser
     expresiones formadas con los operadores relacionales `< <= equal
     notequal >=' y `>'. Los predicados no pueden estar formados por
     expresiones que sean del tipo igualdad `=' ni del tipo desigualdad
     `#', ni tampoco pueden ser funciones de predicado como `integerp'.

     En cambio, sí se reconocen predicados compuestos de la forma
     `<pred_1> and ... and <pred_n>', pero no `<pred_1> or ... or
     <pred_n>'.  También se reconoce `not <pred_k>' si <pred_k> es un
     predicado relacional. Expresiones de la forma `not (<pred_1> and
     <pred_2>)' y `not (<pred_1> or <pred_2>)' no son reconocidas.

     El mecanismo deductivo de Maxima no es muy potente; existen muchas
     consecuencias que, siendo obvias, no pueden ser obtenidas por `is'.
     Se trata de una debilidad reconocida.

     `assume' no gestiona predicados con números complejos. Si un
     predicado contiene un número complejo, `assume' devuelve
     `inconsistent' o `redunant'.

     La función `assume' evalúa sus argumentos.

     Véanse también `is', `facts', `forget', `context' y `declare'.

     Ejemplos:

          (%i1) assume (xx > 0, yy < -1, zz >= 0);
          (%o1)              [xx > 0, yy < - 1, zz >= 0]
          (%i2) assume (aa < bb and bb < cc);
          (%o2)                  [bb > aa, cc > bb]
          (%i3) facts ();
          (%o3)     [xx > 0, - 1 > yy, zz >= 0, bb > aa, cc > bb]
          (%i4) is (xx > yy);
          (%o4)                         true
          (%i5) is (yy < -yy);
          (%o5)                         true
          (%i6) is (sinh (bb - aa) > 0);
          (%o6)                         true
          (%i7) forget (bb > aa);
          (%o7)                       [bb > aa]
          (%i8) prederror : false;
          (%o8)                         false
          (%i9) is (sinh (bb - aa) > 0);
          (%o9)                        unknown
          (%i10) is (bb^2 < cc^2);
          (%o10)                       unknown


 -- Variable opcional: assumescalar
     Valor por defecto: `true'

     La variable `assumescalar' ayuda a controlar si una expresión
     `expr' para la cual `nonscalarp (expr)' es `false' va a tener un
     comportamiento similar a un escalar bajo ciertas transformaciones.

     Sea `expr' cualquier expresión distinta de una lista o matriz, y
     sea también `[1, 2, 3]' una lista o una matriz. Entonces, `expr .
     [1, 2, 3]' dará como resultado `[expr, 2 expr, 3 expr]' si
     `assumescalar' es `true', o si `scalarp (expr)' es `true', o si
     `constantp (expr)' es `true'.

     Si `assumescalar' vale `true', la expresión se comportará como un
     escalar sólo en operaciones conmutativas, pero no en el caso de la
     multiplicación no conmutativa o producto matricial `.'.

     Si `assumescalar' vale `false', la expresión se comportará como un
     no escalar.

     Si `assumescalar' vale `all', la expresión se comportará como un
     escalar para todas las operaciones.


 -- Variable opcional: assume_pos
     Valor por defecto: `false'

     Si `assume_pos' vale `true' y el signo de un parámetro <x> no
     puede ser determinado a partir del contexto actual o de otras
     consideraciones, `sign' y `asksign (<x>)' devolverán `true'. Con
     esto se pueden evitar algunas preguntas al usuario que se generan
     automáticamente, como las que hacen `integrate' y otras funciones.

     By default, a parameter is <x> such that `symbolp (<x>)' or
     `subvarp (<x>)'.

     Por defecto, un parámetro <x> es aquel para el que `symbolp (<x>)'
     o `subvarp (<x>)' devuelven `true'.  La clase de expresiones que
     se consideran parámetros se puede extender mediante la utilización
     de la variable `assume_pos_pred'.

     Las funciones `sign' y `asksign' intentan deducir el signo de una
     expresión a partir de los signos de los operandos que contiene.
     Por ejemplo, si `a' y `b' son ambos positivos, entonces `a + b'
     también es positivo.

     Sin embargo, no es posible obviar todas las preguntas que hace
     `asksign'. En particular, cuando el argumento de `asksign' es una
     diferencia `<x> - <y>' o un logaritmo `log(<x>)', `asksign'
     siempre solicita una respuesta por parte del usuario, incluso
     cuando `assume_pos' vale `true' y `assume_pos_pred' es una función
     que devuelve `true' para todos los argumentos.


 -- Variable opcional: assume_pos_pred
     Valor por defecto: `false'

     Cuando a `assume_pos_pred' se le asigna el nombre de una función o
     una expresión lambda de un único argumento <x>, ésta será invocada
     para determinar si <x> se considera un parámetro por `assume_pos'.
     La variable `assume_pos_pred' se ignora cuando `assume_pos' vale
     `false'.

     La función `assume_pos_pred' es invocada por  `sign' y por
     `asksign' con un argumento <x>, el cual puede ser un átomo, una
     variable subindicada o una expresión de llamada a una función. Si
     la función `assume_pos_pred' devuelve `true', <x> será considerada
     como un parámetro por `assume_pos'.

     Por defecto, un parámetro <x> es aquel para el que `symbolp (<x>)'
     o `subvarp (<x>)' devuelven `true'.

     Véanse también `assume' y `assume_pos'.

     Ejemplos:

          (%i1) assume_pos: true$
          (%i2) assume_pos_pred: symbolp$
          (%i3) sign (a);
          (%o3)                          pos
          (%i4) sign (a[1]);
          (%o4)                          pnz
          (%i5) assume_pos_pred: lambda ([x], display (x), true)$
          (%i6) asksign (a);
                                        x = a

          (%o6)                          pos
          (%i7) asksign (a[1]);
                                       x = a
                                            1

          (%o7)                          pos
          (%i8) asksign (foo (a));
                                     x = foo(a)

          (%o8)                          pos
          (%i9) asksign (foo (a) + bar (b));
                                     x = foo(a)

                                     x = bar(b)

          (%o9)                          pos
          (%i10) asksign (log (a));
                                        x = a

          Is  a - 1  positive, negative, or zero?

          p;
          (%o10)                         pos
          (%i11) asksign (a - b);
                                        x = a

                                        x = b

                                        x = a

                                        x = b

          Is  b - a  positive, negative, or zero?

          p;
          (%o11)                         neg


 -- Variable opcional: context
     Valor por defecto: `initial'

     La variable `context' da nombre al conjunto de hechos establecidos
     desde `assume' y `forget'. La función `assume' añade nuevos hechos
     al conjunto nombrado por `context', mientras que `forget' los va
     eliminando.  Asignando a `context' un nuevo nombre <foo> cambia el
     contexto actual a <foo>. Si el contexto <foo> no existe todavía,
     se crea automáticamente mediante una llamada a `newcontext'.

     Véase `contexts' para una descripción general del mecanismo que
     siguen los contextos.


 -- Variable opcional: contexts
     Valor por defecto: `[initial, global]'

     La variable `contexts' es una lista que contiene los contextos
     existentes, incluyendo el actualmente activo.

     El mecanismo que siguen los contextos permiten al usuario agrupar
     y nombrar un conjunto de hechos, que recibe el nombre de contexto.
     Una vez hecho esto, el usuario puede hacer que Maxima tenga en
     cuenta o que olvide cualquier número de hechos sin más que activar
     o desactivar su contexto.

     Cualquier átomo simbólico puede ser el nombre de un contexto, y
     los hechos contenidos en tal contexto pueden ser almacenados hasta
     que se destruyan uno a uno mediante llamadas a la función
     `forget', o que se destruyan conjuntamente invocando a `kill' para
     eliminar el contexto al que pertenecen.

     Los contextos tienen estructura jerárquica, siendo su raíz el
     contexto `global', el cual contiene información sobre Maxima que
     necesitan algunas funciones. Cuando en un contexto todos los
     hechos están activos (lo que significa que están siendo utilizados
     en deducciones) lo estarán también en cualquier subcontexto del
     contexto actual.

     Cuando se comienza una sesión de Maxima, el usuario estará
     trabajando en un contexto llamado `initial', el cual tiene un
     subcontexto de nombre `global'.

     Véanse también `facts', `newcontext', `supcontext', `killcontext',
     `activate', `deactivate', `assume' y `forget'.


 -- Función: deactivate (<contexto_1>, ..., <contexto_n>)
     Desactiva los contextos especificados <contexto_1>, ...,
     <contexto_n>.


 -- Función: facts (<item>)
 -- Función: facts ()
     Si <item> es el nombre de un contexto, `facts (<item>)' devuelve
     una lista con los hechos asociados al contexto especificado.

     Si <item> no es el nombre de un contexto, `facts (<item>)'
     devuelve una lista con los hechos conocidos acerca de <item> en el
     contexto actual. Los hechos que estén activos en contextos
     diferentes no aparecen en la lista.

     La llamada `facts ()', sin argumentos, muestra el contexto actual.


 -- Función: forget (<pred_1>, ..., <pred_n>)
 -- Función: forget (<L>)
     Borra los predicados establecidos por `assume'. Los predicados
     pueden ser expresiones equivalentes, pero no necesariamente
     idénticas, a las establecidas por `assume'.

     La llamada `forget (<L>)', siendo <L> una lista de predicados,
     borra todos los predicados contenidos en ella.


 -- Función: is (<expr>)
     Intenta determinar si el predicado <expr>  se puede deducir de los
     hechos almacenados en la base de datos gestionada por `assume'.

     Si el predicado se reduce a `true' o `false', `is' devuelve `true'
     o `false', respectivamente.  En otro caso, el valor devuelto está
     controlado por la variable global `prederror'.  Si `prederror'
     vale `true', `is' emite un mensaje de error; en caso contrario,
     `is' devuelve `unknown'.

     La instrucción `ev(<expr>, pred)' (que puede escribirse como
     `<expr>, pred' en el modo interactivo) equivale a `is(<expr>)'.

     Véanse también `assume', `facts' y `maybe'.

     Ejemplos:

     `is' evalúa los predicados,

          (%i1) %pi > %e;
          (%o1)                       %pi > %e
          (%i2) is (%pi > %e);
          (%o2)                         true

     `is' intenta evaluar predicados a partir del conocimiento
     almacenado en la base de datos de `assume'.

          (%i1) assume (a > b);
          (%o1)                        [a > b]
          (%i2) assume (b > c);
          (%o2)                        [b > c]
          (%i3) is (a < b);
          (%o3)                         false
          (%i4) is (a > c);
          (%o4)                         true
          (%i5) is (equal (a, c));
          (%o5)                         false

     Si `is' no puede evaluar el valor lógico del predicado a partir de
     la base de datos gestionada por `assume', la variable global
     `prederror' controla el comportamiento de `is'.

          (%i1) assume (a > b);
          (%o1)                        [a > b]
          (%i2) prederror: true$
          (%i3) is (a > 0);
          Maxima was unable to evaluate the predicate:
          a > 0
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) prederror: false$
          (%i5) is (a > 0);
          (%o5)                        unknown


 -- Función: killcontext (<contexto_1>, ..., <contexto_n>)
     Elimina los contextos <contexto_1>, ..., <contexto_n>.

     Si alguno de estos contextos es el actual, el nuevo contexto
     activo será el primer subcontexto disponible del actual que no
     haya sido eliminado. Si el primer contexto no eliminado disponible
     es `global' entonces `initial' será usado en su lugar.  Si el
     contexto `initial' es eliminado, se creará un nuevo contexto
     `initial' completamente vacío.

     La función `killcontext' no elimina un contexto actualmente activo
     si es un subcontexto del contexto actual, o si se hace uso de la
     función `activate'.

     La función `killcontext' evalúa sus argumentos y devuelve `done'.


 -- Función: maybe (<expr>)
     Intenta determinar si el predicado <expr>  se puede deducir de los
     hechos almacenados en la base de datos gestionada por `assume'.

     Si el predicado se reduce a `true' o `false', `maybe' devuelve
     `true' o `false', respectivamente.  En otro caso, `maybe' devuelve
     `unknown'.

     La función `maybe' es funcionalmente equivalente a `is' con
     `prederror: false', pero el resultado se calcula sin asignar valor
     alguno a `prederror'.

     Véanse también `assume', `facts' y `is'.

     Ejemplos:

          (%i1) maybe (x > 0);
          (%o1)                        unknown
          (%i2) assume (x > 1);
          (%o2)                        [x > 1]
          (%i3) maybe (x > 0);
          (%o3)                         true


 -- Función: newcontext (<nombre>)
     Crea un nuevo contexto vacío <nombre>, el cual tiene a `global'
     como su único subcontexto. El recién creado contexto pasa a ser el
     contexto actualmente activo.

     La función `newcontext' evalúa sus argumentos y devuelve <nombre>.


 -- Función: sign (<expr>)
     Intenta determinar el signo de <expr> en base a los hechos
     almacenados en la base de datos. Devuelve una de las siguientes
     respuestas: `pos' (positivo), `neg' (negativo), `zero' (cero), `pz'
     (positivo o cero), `nz' (negativo o cero), `pn' (positivo o
     negativo), o `pnz' (positivo, negativo o cero, lo que significa
     que el signo es desconocido).


 -- Función: supcontext (<nombre>, <contexto>)
 -- Función: supcontext (<nombre>)
     Crea un nuevo contexto <nombre>, que tiene a <contexto> como
     subcontexto. El argumento <contexto> debe existir ya.

     Si no se especifica <context>, se tomará como tal el actual.



File: maxima.info,  Node: Funciones y variables para los predicados,  Prev: Funciones y variables para los hechos,  Up: Base de datos de Maxima

11.4 Funciones y variables para los predicados
==============================================

 -- Función: charfun (<p>)
     Devuelve 0 cuando el predicado <p> toma el valor `false', y
     devuelve 1 cuando vale `true'.  Si el predicado toma un valor
     diferente de `true' y `false' (desconocido), entonces devuelve una
     forma nominal.

     Ejemplos:

          (%i1) charfun(x<1);
          (%o1) charfun(x<1)
          (%i2) subst(x=-1,%);
          (%o2) 1
          (%i3) e : charfun('"and"(-1 < x, x < 1))$
          (%i4) [subst(x=-1,e), subst(x=0,e), subst(x=1,e)];
          (%o4) [0,1,0]


 -- Función: compare (<x>, <y>)
     Devuelve un operador de comparación <op> (`<', `<=', `>', `>=',
     `=' o `#') de manera que `is (<x> <op> <y>)' tome el valor `true';
     cuando tanto <x> como <y> dependan de `%i' y `<x> # <y>', devuelve
     `notcomparable'; cuando no exista tal operador o Maxima sea
     incapaz de determinarlo, devolverá `unknown'.

     Ejemplos:

          (%i1) compare(1,2);
          (%o1) <
          (%i2) compare(1,x);
          (%o2) unknown
          (%i3) compare(%i,%i);
          (%o3) =
          (%i4) compare(%i,%i+1);
          (%o4) notcomparable
          (%i5) compare(1/x,0);
          (%o5) #
          (%i6) compare(x,abs(x));
          (%o6) <=

     La función `compare' no intenta determinar si los dominios reales
     de sus argumentos son conjuntos no vacíos; así,

          (%i1) compare(acos(x^2+1), acos(x^2+1) + 1);
          (%o1) <

     Aquí, el dominio real de `acos (x^2 + 1)' es el conjunto vacío.


 -- Función: equal (<a>, <b>)
     Representa la equivalencia, esto es, la igualdad de los valores.

     Por sí misma, `equal' no evalúa ni simplifica.  La función `is'
     intenta evaluar `equal' a un resultado booleano. La instrucción
     `is(equal(<a>, <b>))' devuelve `true' (o `false') si y sólo si <a>
     y <b> son iguales (o no iguales) para todos los posibles valores
     de sus variables, tal como lo determina `ratsimp(<a> - <b>)'; si
     `ratsimp' devuelve 0, las dos expresiones se consideran
     equivalentes. Dos expresiones pueden ser equivalentes  sin ser
     sintácticamente iguales (es decir, idénticas).

     Si `is' no consigue reducir `equal' a `true' o `false', el
     resultado está controlado por la variable global `prederror'.  Si
     `prederror' vale `true', `is' emite un mensaje de error; en caso
     contrario, `is' devuelve `unknown'.

     Además de `is', otros operadores evalúan `equal' y `notequal' a
     `true' o `false'; a saber, `if', `and', `or' y `not'.

     La negación de `equal' es `notequal'.

     Ejemplos:

     Por sí misma, `equal' no evalúa ni simplifica.

          (%i1) equal (x^2 - 1, (x + 1) * (x - 1));
                                  2
          (%o1)            equal(x  - 1, (x - 1) (x + 1))
          (%i2) equal (x, x + 1);
          (%o2)                    equal(x, x + 1)
          (%i3) equal (x, y);
          (%o3)                      equal(x, y)

     La función `is' intenta evaluar `equal' a un resultado booleano.
     La instrucción `is(equal(<a>, <b>))' devuelve `true' si
     `ratsimp(<a> - <b>)' devuelve 0. Dos expresiones pueden ser
     equivalentes  sin ser sintácticamente iguales (es decir,
     idénticas).

          (%i1) ratsimp (x^2 - 1 - (x + 1) * (x - 1));
          (%o1)                           0
          (%i2) is (equal (x^2 - 1, (x + 1) * (x - 1)));
          (%o2)                         true
          (%i3) is (x^2 - 1 = (x + 1) * (x - 1));
          (%o3)                         false
          (%i4) ratsimp (x - (x + 1));
          (%o4)                          - 1
          (%i5) is (equal (x, x + 1));
          (%o5)                         false
          (%i6) is (x = x + 1);
          (%o6)                         false
          (%i7) ratsimp (x - y);
          (%o7)                         x - y
          (%i8) is (equal (x, y));
          (%o8)                        unknown
          (%i9) is (x = y);
          (%o9)                         false

     Si `is' no consigue reducir `equal' a `true' o `false', el
     resultado está controlado por la variable global `prederror'.

          (%i1) [aa : x^2 + 2*x + 1, bb : x^2 - 2*x - 1];
                              2             2
          (%o1)             [x  + 2 x + 1, x  - 2 x - 1]
          (%i2) ratsimp (aa - bb);
          (%o2)                        4 x + 2
          (%i3) prederror : true;
          (%o3)                         true
          (%i4) is (equal (aa, bb));
          Maxima was unable to evaluate the predicate:
                 2             2
          equal(x  + 2 x + 1, x  - 2 x - 1)
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i5) prederror : false;
          (%o5)                         false
          (%i6) is (equal (aa, bb));
          (%o6)                        unknown

     Otros operadores evalúan `equal' y `notequal' a  `true' o `false'.

          (%i1) if equal (y, y - 1) then FOO else BAR;
          (%o1)                          BAR
          (%i2) eq_1 : equal (x, x + 1);
          (%o2)                    equal(x, x + 1)
          (%i3) eq_2 : equal (y^2 + 2*y + 1, (y + 1)^2);
                                   2                   2
          (%o3)             equal(y  + 2 y + 1, (y + 1) )
          (%i4) [eq_1 and eq_2, eq_1 or eq_2, not eq_1];
          (%o4)                  [false, true, true]

     Debido a que `not <expr>' obliga a la evaluación previa de <expr>,
     `not equal(<a>, <b>)' equivale a `is(notequal(<a>, <b>))'.

          (%i1) [notequal (2*z, 2*z - 1), not equal (2*z, 2*z - 1)];
          (%o1)            [notequal(2 z, 2 z - 1), true]
          (%i2) is (notequal (2*z, 2*z - 1));
          (%o2)                         true

 -- Función: notequal (<a>, <b>)
     Representa la negación de `equal (<a>, <b>)'.

     Ejemplos:

          (%i1) equal (a, b);
          (%o1)                      equal(a, b)
          (%i2) maybe (equal (a, b));
          (%o2)                        unknown
          (%i3) notequal (a, b);
          (%o3)                    notequal(a, b)
          (%i4) not equal (a, b);
          (%o4)                    notequal(a, b)
          (%i5) maybe (notequal (a, b));
          (%o5)                        unknown
          (%i6) assume (a > b);
          (%o6)                        [a > b]
          (%i7) equal (a, b);
          (%o7)                      equal(a, b)
          (%i8) maybe (equal (a, b));
          (%o8)                         false
          (%i9) notequal (a, b);
          (%o9)                    notequal(a, b)
          (%i10) maybe (notequal (a, b));
          (%o10)                        true


 -- Función: unknown (<expr>)
     Devuelve `true' si y sólo si <expr> contiene un operador o función
     no reconocido por el simplificador de Maxima.


 -- Función: zeroequiv (<expr>, <v>)
     Analiza si la expresión <expr> de variable <v> equivale a cero,
     devolviendo `true', `false' o `dontknow'.

     La función `zeroequiv' tiene estas restricciones:
       1. No utilizar funciones que Maxima no sepa derivar y evaluar.

       2. Si la expresión tiene polos en la recta real, pueden aparecer
          errores en el resultado, aunque es poco probable.

       3. Si la expresión contiene funciones que no son soluciones de
          ecuaciones diferenciales ordinarias de primer orden (como las
          funciones de Bessel) pueden presentarse resultados
          incorrectos.

       4. El algoritmo utiliza evaluaciones en puntos aleatoriamente
          seleccionados. Esto conlleva un riesgo,aunque el algoritmo
          intenta minimizar el error.

     Por ejemplo, `zeroequiv (sin(2*x) - 2*sin(x)*cos(x), x)' devuelve
     `true' y `zeroequiv (%e^x + x, x)' devuelve `false'.  Por otro
     lado `zeroequiv (log(a*b) - log(a) - log(b), a)' devuelve
     `dontknow' debido a la presencia del parámetro `b'.



File: maxima.info,  Node: Gráficos,  Next: Lectura y escritura,  Prev: Base de datos de Maxima,  Up: Top

12 Gráficos
***********

* Menu:

* Introducción a los gráficos::
* Formatos gráficos::
* Funciones y variables para gráficos::
* Opciones gráficas::
* Opciones para Gnuplot::
* Funciones para el formato Gnuplot_pipes::


File: maxima.info,  Node: Introducción a los gráficos,  Next: Formatos gráficos,  Prev: Gráficos,  Up: Gráficos

12.1 Introducción a los gráficos
================================

Maxima utiliza un programa gráfico externo para hacer figuras (véase la
sección Formatos gráficos). Las funciones gráficas calculan un conjunto
de puntos y se los pasa al programa gráfico, junto con una serie de
instrucciones. Estas instrucciones pueden pasarse al programa gráfico,
bien a través de una tubería (pipe, en inglés), bien llamando al
programa, junto con el nombre del fichero en el que se almacenan los
datos. Al fichero de datos se le da el nombre `maxout.interface', donde
`interface' es el nombre del intefaz a ser utilizado (gnuplot, xmaxima,
mgnuplot o gnuplot_pipes).

   El fichero `maxout.interface', si se utiliza, se almacena en la
carpeta especificada por la variable <maxima_tempdir>, cuyo valor se
puede cambiar por una cadena de texto que represente la ruta a una
carpeta válida, en la que Maxima pueda guardar nuevos ficheros.

   Una vez creado el gráfico, el fichero `maxout.interface' puede
ejecutarse nuevamente con el programa externo adecuado. Si una
instrucción gráfica de Maxima falla, este fichero puede ser
inspeccionado a fin de encontrar el origen del problema.

   Junto con las funciones gráficas descritas en esta sección, el
paquete `draw' añade otras funcionalidades. Nótese que algunas opciones
gráficas se llaman igual en ambos contextos gráficos, pero con
diferente sintaxis; para acceder a la información de estas opciones en
el ámbito de `draw', es necesario teclear `?? opc', donde `opc' es el
nombre de la opción.


File: maxima.info,  Node: Formatos gráficos,  Next: Funciones y variables para gráficos,  Prev: Introducción a los gráficos,  Up: Gráficos

12.2 Formatos gráficos
======================

Actualmente, Maxima utiliza dos programas gráficos externos: Gnuplot y
Xmaxima.  Existen varios formatos diferentes para estos programas, que
pueden seleccionarse con la opción `plot_format' (véase la sección
Opciones gráficas).

   Los formatos gráficos se listan a continuación:

   * *gnuplot* (formato por defecto para Windows)

     Se utiliza para ejecutar el programa externo Gnuplot, el cual debe
     estar instalado en el sistema. Las instrucciones gráficas y los
     datos se almacenan en el fichero `maxout.gnuplot'.

   * *gnuplot_pipes* (formato por defecto para plataformas distintas de
     Windows)

     Este formato no está disponible en plataformas Windows. Es similar
     al formato `gnuplot', excepto por el hecho de que las
     instrucciones son enviadas a Gnuplot por una tubería, mientras que
     los datos se almacenan en el fichero `maxout.gnuplot_pipes'.
     Mediante esta técnica, un único proceso de Gnuplot se mantiene
     activo y sucesivos gráficos son enviados al mismo proceso, a menos
     que la tubería a Gnuplot se cierre con la función
     `gnuplot_close()'. Cuando se utiliza este formato, se puede
     utilizar la función `gnuplot_replot' para modificar un gráfico que
     ya había sido representado previamente en la pantalla (véase
     `gnuplot_replot').

     Este formato debería ser utilizado únicamente cuando se
     representen los gráficos por pantalla; para gráficos almacenados
     en ficheros, mejor utilizar el formato `gnuplot'.

   * *mgnuplot*

     Mgnuplot es una interfaz para Gnuplot basada en Tk. Se incluye en
     la distribución de Maxima. Mgnuplot ofrece una interface gráfica de
     usuario rudimentaria para gnuplot, pero tiene algunas mejoras
     respecto de la interface propia de gnuplot. Mgnuplot requiere de
     una instalación externa de Gnuplot y de Tcl/Tk.

   * *xmaxima*

     Xmaxima es un interfaz gráfico Tcl/Tk de Maxima, que también se
     puede utilizar para representar gráficos cuando Maxima se ejecuta
     desde la consola o desde otros interfaces. Para utilizar este
     formato, debe estar instalado junto con Maxima. Si Maxima se
     ejecuta desde el propio Xmaxima, las instrucciones gráficas y los
     datos se envían por el mismo canal de comunicación que se
     establece entre Maxima y Xmaxima (un  socket). Cuando Maxima se
     ejecuta desde una consola o desde otro interfaz, las instrucciones
     gráficas y los datos se almacenan en un fichero de nombre
     `maxout.xmaxima', que le es pasado a Xmaxima como argumento

     En versiones anteriores, este formato se llamaba `openmath', cuyo
     nombre se sigue aceptando como sinónimo de `xmaxima'.


File: maxima.info,  Node: Funciones y variables para gráficos,  Next: Opciones gráficas,  Prev: Formatos gráficos,  Up: Gráficos

12.3 Funciones y variables para gráficos
========================================

 -- Función: contour_plot (<expr>, <x_range>, <y_range>, <options>, ...)
     Dibuja las curvas de nivel <expr> en el rectángulo <x_range> por
     <y_range>.  Cualesquiera otros argumentos adicionales se tratan
     como en `plot3d'.

     `contour_plot' sólo trabaja cuando se utilizan `gnuplot' o
     `gnuplot_pipes'.

     Véase también `implicit_plot'.

     Ejemplos:

          (%i1) contour_plot (x^2 + y^2, [x, -4, 4], [y, -4, 4])$

          (%i1) F(x, y) := x^3 + y^2;
                                             3    2
          (%o1)                  F(x, y) := x  + y
          (%i2) contour_plot (F, [u, -4, 4], [v, -4, 4])$

     Se pueden añadir cualesquiera opciones que acepte `plot3d'; por
     ejemplo, la opción `legend' con un valor `false', para eliminar la
     leyenda. Gnuplot muestra por defecto tres líneas de contorno, pero
     para aumentar el número de niveles es necesario añadir algún
     código nativo de Gnuplot:

          (%i1) contour_plot (u^3 + v^2, [u, -4, 4], [v, -4, 4],
                              [legend,false],
                              [gnuplot_preamble, "set cntrparam levels 12"])$


 -- Función: get_plot_option (<keyword>, <index>)
     Devuelve el valor actual de la opción <keyword> almacenada en la
     variable global `plot_options'. Si <index> toma el valor 1,
     devuelve el propio valor de <keyword>; si vale 2 le añade el
     primer parámetro, y así sucesivamente.

     Véanse también `plot_options', `set_plot_option' y la sección
     Opciones gráficas.


 -- Función: make_transform ([<var1>, <var2>, <var3>], <fx>, <fy>, <fz>)
     Devuelve una función que se puede utilizar con la opción
     `transform_xy' de `plot3d'. Las tres variables ficticias <var1>,
     <var2> y <var3> representan las tres variables de la función
     `plot3d', las dos primeras independientes y la tercera
     dependiente. Las tres funciones <fx>, <fy> y <fz> deben depender
     solo de las tres variables anteriores y retornar las
     correspondientes x, y, z que se deben dibujar. Hay dos
     transformaciones predefinidas: `polar_to_xy' y `spherical_to_xyz'.

     Véanse `polar_to_xy' y `spherical_to_xyz'.


 -- Símbolo del sistema: polar_to_xy
     Cuando a la opción `transform_xy' de `plot3d' se le pasa el valor
     `polar_to_xy', se interpretarán las dos primeras variables
     independientes como polares, transformándolas luego a coordenadas
     cartesianas.


 -- Función: plot2d (<plot>, <x_range>, ..., <options>, ...)
 -- Función: plot2d ([<plot_1>, ..., <plot_n>], ..., <options>, ...)
 -- Función: plot2d ([<plot_1>, ..., <plot_n>], <x_range>, ...,
          <options>, ...)
     Donde <plot>, <plot_1>, ..., <plot_n> pueden ser expresiones,
     nombres de funciones o una lista de cualquiera de las siguientes
     formas: `[discrete, [<x1>, ..., <xn>], [<y1>, ..., <yn>]]',
     `[discrete, [[<x1>, <y1>], ..., [<xn>, ..., <yn>]]' o
     `[parametric, <x_expr>, <y_expr>, <t_range>]'.

     Muestra un gráfico de una o más expresiones como función de una
     variable.

     La función `plot2d' representa uno o más gráficos en dos
     dimensiones. Las expresiones o nombres de funciones que se
     utilicen para definir curvas deben depender todas ellas de una
     única variable <var>, siendo obligatorio utilizar <x_range> para
     nombrar la variable y darle sus valores mínimo y máximo usando la
     siguiente sintaxis: `[<variable>, <min>, <max>]'.

     Un gráfico también se puede definir de forma discreta o
     paramétrica.  La forma discreta se utiliza para dibujar un
     conjunto de puntos de coordenadas dadas. Un gráfico discreto se
     define como una lista que empiezan con la palabra clave <discrete>
     seguida de una o dos listas de valores numéricos. Cuando haya dos
     listas, ambas deben ser de igual longitud, la primera se
     interpreta como la de abscisas y la segunda de ordenadas. Cuando
     haya una lista siguiendo la clave <discrete>, cada uno de sus
     elementos debe ser a su vez una lista de solo dos valores,
     correspondientes a las coordenadas x e y.

     Un gráfico paramétrico se define como una lista que empieza con la
     palabra clave <parametric>, seguida de dos expresiones o nombres de
     funciones y un rango paramétrico. El rango paramétrico debe ser una
     lista formada con el nombre del parámetro seguido de sus valores
     mínimo y máximo: `[<param>, <min>, <max>]'. El gráfico se formará
     con los puntos cuyas coordenadas devuelvan las dos expresiones o
     funciones, según <param> aumente desde <min> hasta <max>.

     La especificación del rango para el eje vertical es opcional y
     toma la forma `[y, <min>, <max>]' (<y> se utiliza siempre para el
     eje vertical). En caso de utilizar esta opción, el gráfico
     mostrará exactamente ese rango vertical, independientemente de los
     valores alcanzados por los elementos gráficos. Si no se especifica
     el rango vertical, se ajustará a los valores extremos alcanzados
     por las ordenadas de los puntos que aparezcan en el gráfico.

     Cualesquiera otras opciones deben ser listas, comenzando con el
     nombre de la opción seguido de uno o más valores. Véase
     `plot_options'.

     Si hay varias expresiones para ser dibujadas, se mostrará una
     leyenda que identifique a cada una de ellas. Las etiquetas a
     utilizar pueden especificarse con la opción <legend>. Si no se
     utiliza esta opción, Maxima creará etiquetas a partir de las
     expresiones o nombres de funciones.

     Ejemplos:

     Dibujando la función sinusoidal:

          (%i1) plot2d (sin(x), [x, -%pi, %pi])$

     Si la función crece rápidamente puede ser necesario limitar los
     valores del eje vertical:

          (%i1) plot2d (sec(x), [x, -2, 2], [y, -20, 20])$
          plot2d: some values were clipped.

     El aspecto del gráfico puede ser diferente dependiendo del programa
     gráfico utilizado. Por ejemplo, cuando se desactiva el marco,
     Xmaxima dibuja los ejes como flechas:

          (%i1) plot2d ( x^2-1, [x, -3, 3], [y, -2, 10],
                                [box, false], [plot_format, xmaxima])$

     Gráfico con escala logarítmica:

          (%i1) plot2d (exp(3*s), [s, -2, 2], [logy])$

     Dibujando funciones especificadas por su nombre:

          (%i1) F(x) := x^2 $
          (%i2) :lisp (defun |$g| (x) (m* x x x))
          $g
          (%i2) H(x) := if x < 0 then x^4 - 1 else 1 - x^5 $
          (%i3) plot2d ([F, G, H], [u, -1, 1], [y, -1.5, 1.5])$

     Ejemplo de función paramétrica. Curva de la mariposa:

          (%i1) r: (exp(cos(t))-2*cos(4*t)-sin(t/12)^5)$
          (%i2) plot2d([parametric, r*sin(t), r*cos(t),
                       [t, -8*%pi, 8*%pi], [nticks, 2000]])$

     Una circunferencia de dos vueltas y solo siete puntos:

          (%i1) plot2d ([parametric, cos(t), sin(t),
                        [t, -2*%pi, 2*%pi], [nticks, 8]])$

     Dibujo de una función junto con la representación paramétrica de
     una circunferencia. El tamaño del gráfico se ha ajustado con las
     opciones x e y para que la circunferencia no se vea como una
     elipse. Estos valores son aceptables para el terminal Postscript
     utilizado para producir este gráfico, y puede seer necesario
     adaptar los valores para otros terminales:

          (%i1) plot2d([[parametric, cos(t), sin(t),
                        [t,0,2*%pi], [nticks, 80]],
                  abs(x)], [x,-2,2], [y, -1.5, 1.5])$
          plot2d: some values were clipped.

     Puntos discretos definiendo separadamente las coordenadas x e y:

          (%i1) plot2d ([discrete, [10, 20, 30, 40, 50],
                                   [.6, .9, 1.1, 1.3, 1.4]])$

     Los mismos puntos del ejemplo anterior, pero definiendo una a una
     las coordenadas y sin segmentos que unan los puntos:

          (%i1) plot2d([discrete, [[10, .6], [20, .9], [30, 1.1],
                                   [40, 1.3], [50, 1.4]]],
                                  [style, points])$

     En este ejemplo, se guarda una tabla de tres columnas en el
     archivo `data.txt', que luego será leído para representar las dos
     últimas columnas:

          (%i1) with_stdout ("data.txt", for x:0 thru 10 do
                                             print (x, x^2, x^3))$
          (%i2) data: read_matrix ("data.txt")$
          (%i3) plot2d ([discrete, transpose(data)[2], transpose(data)[3]],
            [style,points], [point_type,diamond], [color,red])$

     Un gráfico de datos empíricos junto con su modelo teórico:

          (%i1) xy: [[10, .6], [20, .9], [30, 1.1], [40, 1.3], [50, 1.4]]$
          (%i2) plot2d([[discrete, xy], 2*%pi*sqrt(l/980)], [l,0,50],
                  [style, points, lines], [color, red, blue],
                  [point_type, asterisk],
                  [legend, "experiment", "theory"],
                  [xlabel, "pendulum's length (cm)"],
                  [ylabel, "period (s)"])$


 -- Función: plot3d (<expr>, <x_range>, <y_range>, ..., <options>, ...)
 -- Función: plot3d ([<expr_1>, ..., <expr_n>], <x_range>, <y_range>,
          ..., <options>, ...)
     Dibuja una o más superficies definidas como funciones de dos
     variables o en forma paramétrica

     Las funciones a dibujar se pueden especificar como expresiones o
     nombres de funciones.  Puede utilizarse el ratón para hacer girar
     el gráfico y observarlo desde distintos ángulos.

     Ejemplos:

     Representación de una función:

          (%i1) plot3d (2^(-u^2 + v^2), [u, -3, 3], [v, -2, 2])$

     Uso de la opción z para acotar una función que tiende a infinito
     (en este caso, la función tiende a menos infinito en los ejes x e
     y):

          (%i1) plot3d ( log ( x^2*y^2 ), [x, -2, 2], [y, -2, 2], [z, -8, 4],
                         [palette, false], [color, magenta, blue])$

     Los valores infinitos de z se pueden obviar eligiendo una retícula
     que no coincida con las asíntotas; este ejemplo también muestra
     cómo seleccionar las paletas predefinidas, en este caso la número
     4:

          (%i1) plot3d (log (x^2*y^2), [x, -2, 2], [y, -2, 2],
                   [grid, 29, 29],
                   [palette, get_plot_option(palette,5)])$

     Dos superficies en el mismo gráfico, compartiendo el mismo
     dominio; en Gnuplot, ambas superfifies comparten la misma paleta:

          (%i1) plot3d ([2^(-x^2 + y^2), 4*sin(3*(x^2+y^2))/(x^2+y^2),
                        [x, -3, 3], [y, -2, 2]])$

     Las mismas superficies, pero con diferentes dominios; en Xmaxima
     cada superficies usa una paleta diferente, elegida de la lista
     definida por la opción `palette':

          (%i1) plot3d ([[2^(-x^2 + y^2),[x,-2,2],[y,-2,2]],
                   4*sin(3*(x^2+y^2))/(x^2+y^2),
                   [x, -3, 3], [y, -2, 2]], [plot_format,xmaxima])$

     La botella de Klein, definida paramétricamente:

          (%i1) expr_1:5*cos(x)*(cos(x/2)*cos(y)+sin(x/2)*sin(2*y)+3.0)-10.0$
          (%i2) expr_2:-5*sin(x)*(cos(x/2)*cos(y) + sin(x/2)*sin(2*y) + 3.0)$
          (%i3) expr_3: 5*(-sin(x/2)*cos(y) + cos(x/2)*sin(2*y))$
          (%i4) plot3d ([expr_1, expr_2, expr_3], [x, -%pi, %pi],
                  [y, -%pi, %pi], [grid, 40, 40])$

     Gráfico de un armónico esférico, utilizando las transformaciones
     predefinidas `spherical_to_xyz':

          (%i1) plot3d (sin(2*theta)*cos(phi), [theta, 0, %pi],
                        [phi, 0, 2*%pi],
                        [transform_xy, spherical_to_xyz], [grid,30,60])$

     Uso de la transformación predefinida `polar_to_xy'. Este ejemplo
     también muestra cómo eliminar el marco y la leyenda:

          (%i1) plot3d (r^.33*cos(th/3), [r, 0, 1], [th, 0, 6*%pi],
                   [grid, 12, 80],
                   [transform_xy, polar_to_xy], [box, false],
                   [legend,false])$

     Dibujo de una esfera utilizando la transformación esférica. En
     Xmaxima, los tres ejes utilizan escalas proporcionales, manteniendo
     la forma simétrica de la esfera. Se utiliza una paleta con color
     degradado:

          (%i1) plot3d ( 5, [theta, 0, %pi], [phi, 0, 2*%pi],
                   [plot_format,xmaxima],
                   [transform_xy, spherical_to_xyz],
                   [palette,[value,0.65,0.7,0.1,0.9]])$

     Definición de una función con dos variables utilizando una matriz.
     Nótese la comilla simple en la definición de la función para
     prevenir que `plot3d' falle al detectar que la matriz necesita
     índices enteros:

          (%i1) M: matrix([1, 2, 3, 4], [1, 2, 3, 2], [1, 2, 3, 4],
                          [1, 2, 3, 3])$
          (%i2) f(x, y) := float('M [round(x), round(y)])$
          (%i3) plot3d (f(x,y), [x, 1, 4], [y, 1, 4], [grid, 4, 4])$
          apply: subscript must be an integer; found: round(x)

     Asignando a la opción `elevation' el valor cero, una superficie
     puede verse como una aplicación en la que cada color representa un
     nivel diferente. La opción `colorbox' se utiliza para mostrar la
     correspondencia entre colores y niveles; las líneas de la retícula
     se desactivan para facilitar la visualización de los colores:

          (%i1) plot3d (cos (-x^2 + y^3/4), [x, -4, 4], [y, -4, 4],
                  [mesh_lines_color, false], [elevation, 0], [azimuth, 0],
                  [colorbox, true], [grid, 150, 150])$

     Véase también la sección Opciones gráficas.


 -- Variable global: plot_options
     Los elementos de esta lista establecen las opciones por defecto
     para los gráficos.  Si una opción está presente en una llamada a
     `plot2d' o a `plot3d', este valor adquiere prevalencia sobre las
     opciones por defecto.  En otro caso se utilizará el valor que
     tenga en `plot_options'.  Las opciones por defecto se asignan
     mediante la función `set_plot_option'.

     Cada elemento de `plot_options' es una lista de dos o más
     elementos, el primero de los cuales es el nombre de la opción,
     siendo los siguientes los valores que toma. En algunos casos el
     valor asignado es a su vez una lista, que puede contener varios
     elementos.

     Véanse también `set_plot_option', `get_option' y la sección
     Opciones gráficas.


 -- Función: set_plot_option (<option>)
     Acepta la mayor parte de opciones listadas en la sección Opciones
     gráficas y las almacena en la variable global `plot_options'.

     La función `set_plot_option' evalúa su argumento y devuelve la
     lista completa `plot_options' tal como queda después de la
     actualización.

     Véanse también `plot_options', `get_option' y la sección Opciones
     gráficas.

     Ejemplos:

     Modificación de los valores para `grid'.

          (%i1) set_plot_option ([grid, 30, 40]);
          (%o1) [[t, - 3, 3], [grid, 30, 40], [transform_xy, false],
          [run_viewer, true], [axes, true], [plot_format, gnuplot_pipes],
          [color, blue, red, green, magenta, black, cyan],
          [point_type, bullet, circle, plus, times, asterisk, box, square,
          triangle, delta, wedge, nabla, diamond, lozenge],
          [palette, [hue, 0.25, 0.7, 0.8, 0.5],
          [hue, 0.65, 0.8, 0.9, 0.55], [hue, 0.55, 0.8, 0.9, 0.4],
          [hue, 0.95, 0.7, 0.8, 0.5]], [gnuplot_term, default],
          [gnuplot_out_file, false], [nticks, 29], [adapt_depth, 5],
          [gnuplot_preamble, ], [gnuplot_default_term_command,
          set term pop], [gnuplot_dumb_term_command, set term dumb 79 22],
          [gnuplot_ps_term_command, set size 1.5, 1.5;set term postscript \
          eps enhanced color solid 24], [plot_realpart, false]]


 -- Símbolo del sistema: spherical_to_xyz
     Cuando a la opción `transform_xy' de `plot3d' se le pasa el valor
     `spherical_to_xyz', se interpretarán las variables independientes
     como esféricas, transformándolas luego a coordenadas cartesianas.



File: maxima.info,  Node: Opciones gráficas,  Next: Opciones para Gnuplot,  Prev: Funciones y variables para gráficos,  Up: Gráficos

12.4 Opciones gráficas
======================

Todas las opciones consisten en una lista que comienza con una palabra
clave seguida de uno o más valores. La mayor parte de las opciones
pueden utilizarse con cualquiera de las funciones gráficas <plot2d>,
<plot3d>, <contour_plot> y <implicit_plot>, o en la función
<set_plot_option>. Las excepciones se indican en la lista siguiente.

 -- Opción para plot: adapt_depth [adapt_depth, <integer>]
     Valor por defecto: 5

     Número máximo de particiones utilizado por el algoritmo adaptativo
     de representación gráfica.


 -- Opción para plot: axes [axes, <symbol>]
     Valor por defecto: `true'

     El argumento <symbol> puede valer `true', `false', `x' o `y'. Si
     vale `false', no se mostrarán los ejes; si es igual a `x' o `y',
     solo ese eje será el que se representa; si vale `true', se
     mostrarán ambos ejes.

     Esta opción solo es relevante para `plot2d' y `implicit_plot'.


 -- Opción para plot: azimuth [azimuth, <number>]
     Valor por defecto: 30

     Un gráfico `plot3d' se puede interpretar como comenzando
     horizontalmente en el plano xy; a partir de ahí, la coordenada z
     se eleva perpendicularmente al papel. El eje z gira entonces
     alrededor del eje x un ángulo igual a `elevation', luego gira el
     plano xy alrededor del nuevo eje z un ángulo `azimuth'.  Esta
     opción establece el valor para `azimuth' en grados sexagesimales.

     Véase también `elevation'.


 -- Opción para plot: box [box, <symbol>]
     Valor por defecto: `true'

     Si vale `true', se representará el marco para el gráfico; si vale
     `false', no.


 -- Opción para plot: color [color, <color_1>, ..., <color_n>]
     Valor por defecto: blue, red, green, magenta, black, cyan

     Define el color para las curvas en `plot2d' y `implicit_plot'. En
     `plot3d' define los colores para el enrejado de las superficies si
     no se utiliza la paleta; una cara de la superficie tendrá <color_1>
     y la otra <color_2>, o el mismo color si se especifica solo uno.

     Si hay más curvas o superficies que caras, los colores se repetirán
     secuencialmente. Con Gnuplot, los colores pueden ser: azul, rojo,
     verde, magenta, negro y cián; con Xmaxima, los colores pueden ser
     esos mismos, o una cadena de texto que comienza con el carácter
     `#' seguido de seis dígitos hexadecimales: dos para la componente
     roja, otros dos para la verde y otros dos para la azul. Si se
     introduce un nombre de color no reconocido, en su lugar se
     utilizará el negro.


 -- Opción para plot: colorbox [colorbox, <symbol>]
     Valor por defecto: `false'

     El argumento <symbol> puede valer `true' o `false'.  Si vale
     `true' y `plot3d' utiliza la paleta de colores para representar
     diferentes valores de z, se dibujará un rectángulo en la parte
     derecha, indicando los colores utilizados para los diferentes
     valores de z. Esta opción no funciona en Xmaxima.


 -- Opción para plot: elevation [elevation, <number>]
     Valor por defecto: 60

     Un gráfico `plot3d' se puede interpretar como comenzando
     horizontalmente en el plano xy; a partir de ahí, la coordenada z
     se eleva perpendicularmente al papel. El eje z gira entonces
     alrededor del eje x un ángulo igual a `elevation', luego gira el
     plano xy alrededor del nuevo eje z un ángulo `azimuth'.  Esta
     opción establece el valor para `elevation' en grados sexagesimales.

     Véase también  `azimuth'.


 -- Opción para plot: grid [grid, <integer>, <integer>]
     Valor por defecto: 30, 30

     Establece el número de puntos para los puntos de la rejilla en las
     direcciones x e y en escenas 3D.


 -- Opción para plot: legend [legend, <string_1>, ..., <string_n>]
 -- Opción para plot: legend [legend, <false>]
     Especifica las etiquetas para los gráficos en los que aparecen
     varios objetos.  Si hay más expresiones que etiquetas, éstas se
     repetirán.  Con el valor `false' no se mostrarán etiquetas.  Por
     defecto se pasarán los nombres de las expresiones o funciones, o
     las palabras `discrete1', `discrete2', ..., para gráficos de
     puntos.  Esta opción no se puede utilizar con <set_plot_option>.


 -- Opción para plot: logx [logx]
     Hace que el eje de abscisas se dibuje en la escala logarítmica.
     Esta opción no se puede utilizar con <set_plot_option>.


 -- Opción para plot: logy [logy]
     Hace que el eje de ordenadas se dibuje en la escala logarítmica.
     Esta opción no se puede utilizar con <set_plot_option>.


 -- Opción para plot: mesh_lines_color [mesh_lines_color, <color>]
     Valor por defecto: `black'

     Establece el color del enrejado en los gráficos creados por
     `plot3d' cuando se utiliza una paleta. Acepta los mismos colores
     que la opción `color'. También se le puede dar el valor `false'
     para eliminar el enrejado.


 -- Opción para plot: nticks [nticks, <integer>]
     Valor por defecto: 29

     Cuando se dibujan funciones con `plot2d', establece el número
     inicial de puntos utilizado por la rutina gráfica adaptativa.
     Cuando se dibujan funciones con `plot3d' o paramétricas con
     `plot2d', su valor es igual al número de puntos que se
     representarán en el gráfico.


 -- Opción para plot: palette [palette, [<palette_1>], ...,
          [<palette_n>]]
 -- Opción para plot: palette [palette, <false>]
     Valor por defecto: [hue, 0.25, 0.7, 0.8, 0.5], [hue, 0.65, 0.8,
     0.9, 0.55], [hue, 0.55, 0.8, 0.9, 0.4], [hue, 0.95, 0.7, 0.8, 0.5]

     Puede consistir en una paleta o en una lista de varias paletas.
     Cada paleta es una lista con una palabra clave seguida de cuatro
     números.  Los tres primeros números, que deben tomar valores entre
     0 y 1, definen el matiz, la saturación y el valor de un color
     básico a asignar al mínimo valor de z. La palabra clave especifica
     cuál de los tres atributos (`hue', `saturation' o `value')
     incrementará de acuerdo con los valores de z. El último número se
     corresponde con el incremento del máximo valor de z. Este último
     número puede ser mayor que 1 o negativo.

     Gnuplot solo utiliza la primera paleta de la lista; Xmaxima
     utilizará las paletas de la lista secuencialmente cuando haya que
     representar varias superficies conjuntamente; si el número de
     paletas no es suficiente, se repetirán también de forma secuencial.

     El color del enrrejado de la superficie se establece con
     `mesh_lines_color'.  Si `palette' tiene el valor `false', las
     superficies se representan solo con el enrrejado; en tal caso, el
     color de las líneas será el determinado por `color'.


 -- Opción para plot: plot_format [plot_format, <format>]
     Valor por defecto: en sistemas Windows, `gnuplot'; en otros,
     `gnuplot_pipes'

     Establece el formato a utlizar por las rutinas gráficas.

     Debe tomar uno de los siguientes valores: `gnuplot', `xmaxima',
     `mgnuplot' o `gnuplot_pipes'.


 -- Opción para plot: plot_realpart [plot_realpart, <symbol>]
     Valor por defecto: `false'

     Cuando vale `true', se representa gráficamente la parte real de
     las funciones; equivale a ejecutar `realpart(<función>)'.  Si vale
     `false', no se representa nada cuando la función no devuelva un
     valor real. Por ejemplo, si `x' es negativo, `log(x)' devuelve un
     valor negativo cuya parte real es `log(abs(x))'; en tal caso, si
     `plot_realpart' vale `true', `log(-5)' se representa como
     `log(5)', mientras que no se representa nada si `plot_realpart'
     vale `false'.


 -- Opción para plot: point_type [point_type, <type_1>, ..., <type_n>]
     Valor por defecto: `bullet', `circle', `plus', `times', `asterisk',
     `box', `square', `triangle', `delta', `wedge', `nabla', `diamond',
     `lozenge'

     En Gnuplot, cada conjunto de puntos que vaya a ser representado
     con los estilos `points' o `linespoints' se hará con objetos
     tomados de esta lista en orden secuencial. Si hay más conjuntos de
     puntos que objetos en la lista, se irán repitiendo de forma
     secuencial. Los objetos que pueden ser utilizados son: `bullet',
     `circle', `plus', `times', `asterisk', `box', `square', `triangle',
     `delta', `wedge', `nabla', `diamond' o `lozenge'


 -- Opción para plot: psfile [psfile, <string>]
     Guarda el gráfico en formato Postscript con nombre <string> en
     lugar de mostrarlo en pantalla. Por defecto, el fichero se creará
     en la carpeta definida en la variable <maxima_tempdir>, cuyo valor
     se podrá cambiar para almacenar el fichero en otra carpeta.


 -- Opción para plot: run_viewer [run_viewer, <symbol>]
     Valor por defecto: `true'

     Controla si el visor apropiado para la salida gráfica debe
     ejecutarse o no.


 -- Opción para plot: style [style, <type_1>, ..., <type1_n>]
 -- Opción para plot: style [style, [<style_1>], ..., [<style_n>]]
     Valor por defecto: <lines> (dibuja todos los puntos unidos por
     líneas de ancho 1 y con el primer color de la lista de la opción
     `color').

     Estilos a utilizar para las funciones o conjuntos de datos en
     gráficos 2d. A la palabra `style' debe seguirle uno o más estilos.
     Si hay más funciones o conjuntos de datos que estilos, éstos se
     repetirán. Los estilos que se admiten son: <lines> para segmentos
     lineales, <points> para puntos aislados, <linespoints> para
     segmentos y puntos, <dots> para pequeños puntos aislados. Gnuplot
     también acepta el estilo <impulses>.

     Los estilos se pueden escribir como elementos de una lista, junto
     con algunos parámetros adicionales. <lines> acepta uno o dos
     números: el ancho de la línea y un entero que identifica el color.
     Los códigos de color por defecto son: 1, azul; 2, rojo; 3,
     magenta; 4, naranja; 5, marrón; 6, verde lima; 7, aguamarina.  En
     caso de utilizar Gnuplot con un terminal diferente de X11, estos
     colores pueden cambiar; por ejemplo, bajo la opción
     [<gnuplot_term>,<ps>], el índice 4 se corresponde con el negro en
     lugar del naranja.

     <points> acepta uno, dos o tres parámetros; el primer parámetro es
     el radio de los puntos, el segundo es un entero para seleccionar
     el color, con igual codificación que en <lines> y el tercer
     parámetro sólo es utilizado por Gnuplot y hace referencia a varios
     objetos para representar los puntos. Los tipos de objetos
     disponibles son: 1, círculos rellenos; 2, circunferencias; 3, +;
     4, x; 5, *; 6, cuadrados rellenos; 7, cuadrados huecos; 8,
     triángulos rellenos; 9, triángulos huecos; 10, triángulos rellenos
     invertidos; 11, triángulos huecos invertidos; 12, rombos rellenos;
     13, rombos huecos.

     <linesdots> acepta hasta cuatro parámetros: ancho de línea, radio
     de los puntos, color y tipo de objetos para representar puntos.

     Véanse también `color' y `point_type'.


 -- Opción para plot: transform_xy [transform_xy, <symbol>]
     Valor por defecto: `false'

     La variable <symbol> puede ser `false' o el resultado devuelto por
     la función `transform_xy'. Si es distinto de `false', se utiliza
     para transformar las tres coordenadas en `plot3d'.

     Véanse `make_transform', `polar_to_xy' y `spherical_to_xyz'.


 -- Opción para plot: x [x, <min>, <max>]
     Cuando se utiliza como primera opción en una instrucción para un
     gráfico 2D (o cualquiera de las dos primeras en un gráfico 3D),
     indica que su primera variable independiente es x y ajusta su
     rango.  También se puede utilizar después de la primera opción (o
     después de la segunda opción en un gráfico 3D) para definir el
     dominio horizontal que se representará en el gráfico.


 -- Opción para plot: xlabel [xlabel, <string>]
     Especifica la etiqueta para el primer eje. Si no se utiliza esta
     opción, la etquieta será el nombre de la variable independiente,
     cuando se utilicen `plot2d' o `implicit_plot', o el nombre de la
     primera variable cuando se utilicen `plot3d' o `contour_plot', o
     la primera expresión en el caso de una curva paramétrica.  No
     puede utilizarse con <set_plot_option>.


 -- Opción para plot: y [y, <min>, <max>]
     Cuando se utiliza como una de las dos primeras opciones en
     `plot3d', indica que una de las variables independientes es "y" y
     ajusta su rango. En otro caso, define el dominio de la segunda
     variable que se mostrará en el gráfico.


 -- Opción para plot: ylabel [ylabel, <string>]
     Especifica la etiqueta para el segundo eje. Si no se utiliza esta
     opción, la etiqueta será "y", cuando se utilicen `plot2d' o
     `implicit_plot', o el nombre de la segunda variable cuando se
     utilicen `plot3d' o `contour_plot', o la segunda expresión en el
     caso de una curva paramétrica.  No puede utilizarse con
     <set_plot_option>.


 -- Opción para plot: z [z, <min>, <max>]
     Se utiliza en `plot3d' para ajustar el rango de valores de z que se
     mostrará en el gáfico.


 -- Opción para plot: zlabel [zlabel, <string>]
     Especifica la etiqueta para el tercer eje cuando se utiliza
     `plot3d'.  Si no se utiliza esta opción, la etiqueta será "z" en
     el caso de superficies, o la tercera expresión en el caso de una
     curva paramétrica.  No puede utilizarse con <set_plot_option> y se
     ignora en `plot2d' y `implicit_plot'.



File: maxima.info,  Node: Opciones para Gnuplot,  Next: Funciones para el formato Gnuplot_pipes,  Prev: Opciones gráficas,  Up: Gráficos

12.5 Opciones para Gnuplot
==========================

Hay varias opciones gráficas que son específicas de Gnuplot.  Algunas
de ellas son comandos propios de Gnuplot que se especifican como
cadenas de texto.  Consúltese la documentación de Gnuplot para más
detalles.

 -- Opción para plot: gnuplot_term
     Establece el terminal de salida para Gnuplot.

        * *default* (valor por defecto)

          Gnuplot muestra el gráfico en una ventana gráfica.

        * *dumb*

          Gnuplot muestra el gráfico en la consola de Maxima en estilo
          ASCII artístico.

        * *ps*

          Gnuplot genera código en lenguaje PostScript.  Si a la opción
          `gnuplot_out_file' se le da el valor <filename>, Gnuplot
          escribe el código PostScript en <filename>. En caso
          contrario, se guarda en el archivo `maxplot.ps'.

        * Cualquier otro terminal admitido por Gnuplot.

          Gnuplot puede generar gráficos en otros muchos formatos,
          tales como png, jpeg, svg etc. Para crear gráficos en
          cualquera de estos formatos, a la opción `gnuplot_term' se le
          puede asignar cualquiera de los terminales admitidos por
          Gnuplot, bien por su nombre (símbolo) bien con la
          especificación completa del terminal (cadena). Por ejemplo,
          `[gnuplot_term,png]' guarda el gráfico en formato PNG
          (Portable Network Graphics), mientras que `[gnuplot_term,"png
          size 1000,1000"]' lo hace con dimensiones 1000x1000 píxeles.
          Si a la opción `gnuplot_out_file' se le da el valor
          <filename>, Gnuplot escribe el código PostScript en
          <filename>. En caso contrario, se guarda en el archivo
          `maxplot.<term>', siendo <term> el nombre del terminal.



 -- Opción para plot: gnuplot_out_file
     Cuando se utiliza conjuntamente con la opción `gnuplot_term',
     puede utilizarse para almacenar el gráfico en un fichero en uno de
     los formatos aceptados por Gnuplot. Si se quiere crear un fichero
     Postscript se puede utilizar la opción `psfile', que también
     funciona con Openmath.

          [gnuplot_term, png], [gnuplot_out_file, "graph3.png"]


 -- Opción para plot: gnuplot_pm3d
     Controla la utilización del modo PM3D, que tiene capacidades
     avanzadas para gráficos tridimensionales. PM3D sólo está
     disponible en versiones de Gnuplot posteriores a la 3.7. El valor
     por defecto de `gnuplot_pm3d' es `false'.


 -- Opción para plot: gnuplot_preamble
     Introduce instrucciones de Gnuplot antes de que se haga el gráfico.
     Puede utilizarse cualquier comando válido de Gnuplot. Si interesa
     introducir varios comandos se separarán con punto y coma. El valor
     por defecto de `gnuplot_preamble' es la cadena vacía `""'.


 -- Opción para plot: gnuplot_curve_titles
     Opción obsoleta que ha sido sustituida por `legend'.


 -- Opción para plot: gnuplot_curve_styles
     Opción obsoleta que ha sido sustituida por `style'.


 -- Opción para plot: gnuplot_default_term_command
     Comando de Gnuplot para establecer el tipo de terminal por defecto.
     El valor por defecto es `set term pop'.


 -- Opción para plot: gnuplot_dumb_term_command
     Comando de Gnuplot para establecer el tipo de terminal para el
     terminal oculto. El valor por defecto es `"set term dumb 79 22"',
     que da una salida de texto de 79 por 22 caracteres.


 -- Opción para plot: gnuplot_ps_term_command
     Comando de Gnuplot para establecer el tipo de terminal para el
     terminal PostScript. El valor por defecto es `"set size 1.5,
     1.5;set term postscript eps enhanced color solid 24"', que
     establece un tamaño de 1.5 veces el valor por defecto de gnuplot,
     junto con un tamaño de fuente de 24, entre otras cosas. Consúltese
     la documentación de gnuplot para más información sobre `set term
     postscript'.



File: maxima.info,  Node: Funciones para el formato Gnuplot_pipes,  Prev: Opciones para Gnuplot,  Up: Gráficos

12.6 Funciones para el formato Gnuplot_pipes
============================================

 -- Función: gnuplot_start ()
     Inicializa una tubería hacia Gnuplot, con el fin de ser utilizada
     para utilizar el formato `gnuplot_pipes'.  No es necesario
     inicializarla manualmente antes de hacer gráficos.


 -- Función: gnuplot_close ()
     Cierra la tubería hacia Gnuplot que haya sido utilizada para hacer
     gráficos.


 -- Función: gnuplot_restart ()
     Cierra la tubería hacia Gnuplot que haya sido utilizada para hacer
     gráficos e inicializa una nueva.


 -- Función: gnuplot_replot ()
 -- Función: gnuplot_replot (<s>)
     Actualiza la ventana de Gnuplot. Si `gnuplot_replot' es invocada
     con un comando de Gnuplot en la cadena <s>, entonces <s> es
     enviada a Gnuplot antes de redibujar la ventana.


 -- Función: gnuplot_reset ()
     Resetea Gnuplot cuando se utiliza el formato `gnuplot_pipes'.
     Para actualizar la ventana de Gnuplot invóquese a `gnuplot_replot'
     después de `gnuplot_reset'.



File: maxima.info,  Node: Lectura y escritura,  Next: Polinomios,  Prev: Gráficos,  Up: Top

13 Lectura y escritura
**********************

* Menu:

* Comentarios::
* Archivos::
* Funciones y variables para lectura y escritura::
* Funciones y variables para salida TeX::
* Funciones y variables para salida Fortran::


File: maxima.info,  Node: Comentarios,  Next: Archivos,  Prev: Lectura y escritura,  Up: Lectura y escritura

13.1 Comentarios
================

En Maxima, un comentario es cualquier texto encerrado entre las marcas
`/*' y `*/'.

   El analizador sintáctico de Maxima trata los comentarios como
espacios en blanco a efectos de encontrar tokens en el flujo de
entrada. Una entrada tal como `a/* foo */b' contiene dos tokens, `a' y
`b', no un único token `ab'.  En cualquier otro contexto, los
comentarios son ignorados por Maxima; no se almacenan ni sus contenidos
ni sus localizaciones.

   Los comentarios pueden anidarse hasta una profundidad arbitraria.
Las marcas  `/*' y `*/' deben emparejarse y debe haber igual número de
ambos.

   Ejemplos:

     (%i1) /* aa is a variable of interest */  aa : 1234;
     (%o1)                         1234
     (%i2) /* Value of bb depends on aa */  bb : aa^2;
     (%o2)                        1522756
     (%i3) /* User-defined infix operator */  infix ("b");
     (%o3)                           b
     (%i4) /* Parses same as a b c, not abc */  a/* foo */b/* bar */c;
     (%o4)                         a b c
     (%i5) /* Comments /* can be nested /* to any depth */ */ */  1 + xyz;
     (%o5)                        xyz + 1


File: maxima.info,  Node: Archivos,  Next: Funciones y variables para lectura y escritura,  Prev: Comentarios,  Up: Lectura y escritura

13.2 Archivos
=============

Un archivo no es más que una área de un cierto dispositivo de
almacenamiento que contiene datos o texto.  Los archivos se agrupan en
los discos en "directorios", que son listas de archivos.  Instrucciones
que operan con archivos son:

        appendfile           batch                 batchload
        closefile            file_output_append    filename_merge
        file_search          file_search_maxima    file_search_lisp
        file_search_demo     file_search_usage     file_search_tests
        file_type            file_type_lisp        file_type_maxima
        load                 load_pathname         loadfile
        loadprint            pathname_directory    pathname_name
        pathname_type        printfile             save
        stringout            with_stdout           writefile

   Cuando el nombre de un fichero se pasa a funciones como `plot2d',
`save' o `writefile' y en él no se incluye la ruta de acceso, Maxima
almacena el fichero en la carpeta de trabajo actual. La ubicación de la
carpeta de trabajo depende del sistema operativo y de la instalación.


File: maxima.info,  Node: Funciones y variables para lectura y escritura,  Next: Funciones y variables para salida TeX,  Prev: Archivos,  Up: Lectura y escritura

13.3 Funciones y variables para lectura y escritura
===================================================

 -- Función: appendfile (<filename>)
     Añade información de la consola a <filename>, de igual manera que
     lo hace `writefile', pero con la salvedad de que si el archivo ya
     existe la información queda añadida al final de su contenido.

     La función `closefile' cierra los archivos abiertos por
     `appendfile' o `writefile'.


 -- Función: batch (<filename>)
 -- Function: batch (<filename>, `option')
     `batch(<filename>)' lee expresiones de Maxima desde <filename> y
     las evalúa. La función `batch' busca <filename> en la lista
     `file_search_maxima'. Véase `file_search'.

     `batch(<filename>, `test')' es como `run_testsuite' con la opción
     `display_all=true'. En este caso `batch' busca <filename> en la
     lista `file_search_maxima' y no en `file_search_tests' como hace
     `run_testsuite'. Además, `run_testsuite' ejecuta tests que están
     en la lista `testsuite_files'. Con `batch' es posible ejecutar
     cualquier fichero que se encuentre en `file_search_maxima' en modo
     de prueba.

     El contenido de <filename> debe ser una secuencia de expresiones
     de Maxima, cada una de las cuales termina en `;' o `$'.  La
     variable especial `%' y la función `%th' se refieren a resultados
     previos dentro del archivo.  El archivo puede incluir
     construcciones del tipo `:lisp'.  Espacios, tabulaciones y saltos
     de línea en el archivo se ignoran.  Un archivo de entrada válido
     puede crearse con un editor de texto o con la función `stringout'.

     La función `batch' lee las expresiones del archivo <filename>,
     muestra las entradas en la consola, realiza los cálculos
     solicitados y muestra las expresiones de los resultados.  A las
     expresiones de entrada se les asignan etiquetas, así como a las de
     salida. La función `batch' evalúa todas las expresiones de entrada
     del archivo a menos que se produzca un error. Si se le solicita
     información al usuario (con `asksign' o `askinteger', por ejemplo)
     `batch' se detiene para leer la nueva información para luego
     continuar.

     Es posible detener  `batch' tecleando `control-C' desde la consola.
     El efecto de `control-C' depende del entorno Lisp instalado.

     La función `batch' tiene diversas aplicaciones, tales como servir
     de almacén de código escrito por el usuario, suministrar
     demostraciones libres de errores o ayudar a organizar el trabajo
     del usuario en la resolución de problemas complejos.

     La función `batch' evalúa su argumento y devuelve la ruta hacia
     <filename> en formato cadena cuando es invocada sin segundo
     argumento o con la opción `demo'. Cuando es llamada con la opción
     `test', devuelve la lista vacía `[]' o una lista con <filename> y
     los números de tests que han fallado.

     Véanse también  `load', `batchload' y `demo'.


 -- Función: batchload (<filename>)
     Lee expresiones de Maxima desde <filename> y las evalúa sin
     mostrar las entradas ni las salidas y sin asignarles etiquetas.
     Sin embargo, las salidas producidas por  `print' o `describe' sí
     se muestran.

     La variable especial `%' y la función `%th' se refieren a
     resultados previos del intérprete interactivo, no a los del propio
     archivo. El archivo no puede incluir construcciones del tipo
     `:lisp'.

     La función `batchload' devuelve la ruta de <filename> en formato
     de cadena.

     La función `batchload' evalúa sus argumentos.

     Véanse también `batch' y `load'.


 -- Función: closefile ()
     La función `closefile' cierra los archivos abiertos por
     `appendfile' o `writefile'.


 -- Variable opcional: file_output_append
     Valor por defecto: `false'

     La variable `file_output_append' controla si las funciones de
     escritura de ficheros añaden información o sustituyen el fichero
     de salida. Cuando `file_output_append' toma el valor `true', estas
     funciones amplían el contenido de sus ficheros de salida; en otro
     caso, sustituyen el fichero anterior de igual nombre por otro con
     el nuevo contenido.

     Las funciones `save', `stringout' y `with_stdout' se ven afectadas
     por el valor que tome la variable `file_output_append'. Otras
     funciones que también escriben en ficheros de salida no tienen en
     cuenta este valor; en concreto, las funciones para la
     representación de gráficos y las de traducción siempre sustituyen
     el fichero anterior por uno nuevo de igual nombre, mientras que
     las funciones `tex' y `appendfile' siempre añaden información al
     fichero de salida sin eliminar la información anterior.


 -- Función: filename_merge (<path>, <filename>)
     Construye una ruta modificada a partir de <path> y <filename>.  Si
     la componente final de <path> es de la forma `###.<something>', la
     componente se reemplaza con `<filename>.<something>'.  En otro
     caso, la componente final se reemplaza simplemente por <filename>.

     El resultado es un objeto Lisp de tipo pathname.

 -- Función: file_search (<filename>)
 -- Función: file_search (<filename>, <pathlist>)
     La función `file_search' busca el archivo <filename> y devuelve su
     ruta como una cadena; si no lo encuentra,  `file_search' devuelve
     `false'. La llamada `file_search (<filename>)' busca en los
     directorios de búsqueda por defecto, que son los especificados por
     las variables `file_search_maxima', `file_search_lisp' y
     `file_search_demo'.

     La función `file_search' analiza primero si el nombre del
     argumento existe antes de hacerlo coincidir con los comodines de
     los patrones de búsqueda de archivos.  Véase `file_search_maxima'
     para más información sobre patrones de búsqueda de archivos.

     El argumento <filename> puede ser una ruta con nombre de archivo,
     o simplemente el nombre del archivo, o, si el directorio de
     búsqueda de archivo incluye un patrón de búsqueda, es suficiente
     con el nombre de archivo sin extensión.  Por ejemplo,

          file_search ("/home/wfs/special/zeta.mac");
          file_search ("zeta.mac");
          file_search ("zeta");

     todos buscan el mismo archivo, dando por hecho que el archivo
     existe y que `/home/wfs/special/###.mac' está en
     `file_search_maxima'.

     La llamada `file_search (<filename>, <pathlist>)' busca solamente
     en los directorios especificados por <pathlist>, que es una lista
     de cadenas.  El argumento <pathlist> ignora los directorios de
     búsqueda por defecto, de manera que si se da la lista de rutas,
     `file_search' busca solamente en ellas y no en los directorios por
     defecto.  Incluso si hay un único directorio en <pathlist>, debe
     ser suministrado como una lista de un único elemento.

     El usuario puede modificar los directorios de búsqueda por
     defecto; véase para ello See `file_search_maxima'.

     La función `file_search' es llamada por `load' con los directorios
     de búsqueda `file_search_maxima' y `file_search_lisp'.

 -- Variable opcional: file_search_maxima
 -- Variable opcional: file_search_lisp
 -- Variable opcional: file_search_demo
 -- Variable opcional: file_search_usage
 -- Variable opcional: file_search_tests
     Estas variables especifican listas de directorios en los que deben
     buscar la funciones  `load', `demo' y algunas otras. Los valores
     por defecto de estas variables nombran directorios de la
     instalación de Maxima.

     El usuario puede modificar estas variables, bien reemplazando los
     valores por defecto, bien añadiendo nuevos directorios.  Por
     ejemplo,

          file_search_maxima: ["/usr/local/foo/###.mac",
              "/usr/local/bar/###.mac"]$

     reemplaza el valor por defecto de `file_search_maxima', mintras que

          file_search_maxima: append (file_search_maxima,
              ["/usr/local/foo/###.mac", "/usr/local/bar/###.mac"])$

     añade dos directorios más. Puede ser conveniente colocar una
     expresión como esta en el archivo `maxima-init.mac', de manera que
     la ruta de búsqueda de ficheros se asigne automáticamente cada vez
     que arranca Maxima.

     Se pueden especificar varias extensiones de archivos y rutas con
     comodines especiales.  La cadena `###' representa el nombre del
     archivo buscado y una lista separada de comas y encerrada entre
     llaves,  `{foo,bar,baz}' representa múltiples cadenas.  Por
     ejemplo, suponiendo que se busca el nombre `neumann',

          "/home/{wfs,gcj}/###.{lisp,mac}"

     se interpreta como `/home/wfs/neumann.lisp',
     `/home/gcj/neumann.lisp', `/home/wfs/neumann.mac' y
     `/home/gcj/neumann.mac'.

 -- Función: file_type (<filename>)
     Devuelve una descripción del contenido de <filename> basada en la
     extensión, sin intentar abrir el archivo para inspeccionar su
     contenido.

     El valor devuelto es un símbolo `object', `lisp' o `maxima'. Si la
     extensión es "mac", "mc", "demo", "dem", "dm1", "dm2", "dm3" o
     "dmt", `file_type' devuelve `maxima'. Si la extensión es "l",
     "lsp" o "lisp", `file_type' devuelve `lisp'. Si la extensión no es
     ninguna de las anteriores, `file_type' devuelve `object'.

     Véase también `pathname_type'.

     Ejemplos:

          (%i2) map('file_type,["test.lisp", "test.mac", "test.dem", "test.txt"]);
          (%o2)            [lisp, maxima, maxima, object]

 -- Variable opcional: file_type_lisp
     Valor por defecto:  `[l, lsp, lisp]'

     `file_type_lisp' es una lista con extensiones de ficheros que
     Maxima reconoce como fuente de Lisp.

     Véase también `file_type'

 -- Variable opcional: file_type_maxima
     Valor por defecto:  `[mac, mc, demo, dem, dm1, dm2, dm3, dmt]'

     `file_type_maxima' es una lista con extensiones de ficheros que
     Maxima reconoce como fuente de Maxima.

     Véase también `file_type'

 -- Función: load (<filename>)
     Evalúa las expresiones del archivo <filename>, trayendo variables,
     funciones y otros objetos a Maxima. Una asignación hecha
     previamente a una variable en Maxima será destruida por otra
     asignación que se le haga en <filename>. Para encontrar el
     fichero, `load' llama a `file_search' con `file_search_maxima' y
     `file_search_lisp' como directorios de búsqueda. Si la llamada a
     `load' funciona correctamente, devuelve el nombre del fichero; en
     caso contrario, `load' muestra un mensaje de error.

     La función `load' trabaja indistintamente con código Lisp y Maxima.
     Los ficheros creados con `save', `translate_file' y `compile_file',
     que crea código Lisp, y `stringout', que crea código Maxima, todos
     ellos pueden ser procesados por `load'. La función `load' llama a
     `loadfile' para cargar archivos en Lisp y a  `batchload' para
     cargar archivos en Maxima.

     La función `load' no reconoce las construcciones de tipo `:lisp' en
     ficheros de Maxima. Además, mientras se está procesando <filename>,
     las variables globales `_', `__', `%' y `%th' mantienen los
     valores que tenían cuando se realizó la llamada a `load'.

     Véanse también `loadfile', `batch', `batchload' y `demo';
     `loadfile' procesa archivos en Lisp; `batch', `batchload' y `demo'
     procesan archivos en Maxima.

     Véase `file_search' para más detalles sobre el mecanismo de
     búsqueda de archivos.

     La función `load' evalúa sus argumentos.


 -- Variable del sistema: load_pathname
     Valor por defecto: `false'

     Cuando se carga un fichero con las funciones `load', `loadfile' o
     `batchload', a la variable `load_pathname' se le asigna la ruta al
     fichero en cuestión.

     Se puede acceder a la variable `load_pathname' mientras se está
     cargando el fichero.

     Ejemplo:

     Supóngase que se tiene el fichero `test.mac' en la carpeta
     `"/home/usuario/workspace/mymaxima/temp/"' con las siguientes
     instrucciones:

          print("The value of load_pathname is: ", load_pathname)$
          print("End of batchfile")$

     Entonces se obtiene el siguiente resultado:

          (%i1) load("/home/usuario/workspace/mymaxima/temp/test.mac")$
          The value of load_pathname is:
                             /home/usuario/workspace/mymaxima/temp/test.mac
          End of batchfile

 -- Función: loadfile (<filename>)
     Evalúa las expresiones Lisp del archivo <filename>. La función
     `loadfile' no llama a `file_search', de manera que `filename' debe
     incluir la extensión del archivo y su ruta completa.

     La función `loadfile' puede procesar ficheros creados por  `save',
     `translate_file' y `compile_file'.  Puede ser más conveniente
     utilizar `load' en lugar de `loadfile'.

 -- Variable opcional: loadprint
     Valor por defecto: `true'

     La variable `loadprint' indica si mostrar un mensaje cuando se
     carga un archivo.

        * Si `loadprint' vale `true', se muestra siempre un mensaje.

        * Si `loadprint' vale `'loadfile', muestra un mensaje sólo si
          el archivo es cargado con la función `loadfile'.

        * Si `loadprint' vale `'autoload', muestra un mensaje sólo
          cuandi un archivo se carga automáticamente. Véase
          `setup_autoload'.

        * Si `loadprint' vale `false', nunca mostrará mensajes.


 -- Variable opcional: packagefile
     Valor por defecto: `false'

     Los desarrolladores de paquetes que utilizan `save' o `translate'
     para crear paquetes (ficheros) que van a ser utilizados por
     terceros pueden hacer `packagefile: true' para evitar que se añada
     información a la listas de información de Maxima, como `values' o
     `functions'.

 -- Función: pathname_directory (<pathname>)
 -- Función: pathname_name (<pathname>)
 -- Función: pathname_type (<pathname>)
     Estas funciones devuelven las componentes de <pathname>.

     Ejemplos:

          (%i1) pathname_directory("/home/usuario/maxima/changelog.txt");
          (%o1)                 /home/usuario/maxima/
          (%i2) pathname_name("/home/usuario/maxima/changelog.txt");
          (%o2)                       changelog
          (%i3) pathname_type("/home/usuario/maxima/changelog.txt");
          (%o3)                          txt


 -- Función: printfile (<path>)
     Envía el fichero al que hace referncia la ruta <path> a la
     consola. <path> puede ser una cadena o un símbolo, en cuyo caso se
     convertirá en una cadena.

     Si <path> hace referencia a un fichero accesible desde el
     directorio actual de trabajo, entonces se enviará a la consola; en
     caso contrario, `printfile' intentará localizar el fichero
     añadiéndole <path> a cada uno de los elementos de
     `file_search_usage' a través de `filename_merge'.

     `printfile' devuelve la ruta del fichero encontado.


 -- Función: save (<filename>, <name_1>, <name_2>, <name_3>, ...)
 -- Función: save (<filename>, values, functions, labels, ...)
 -- Función: save (<filename>, [<m>, <n>])
 -- Función: save (<filename>, <name_1>=<expr_1>, ...)
 -- Función: save (<filename>, all)
 -- Función: save (<filename>, <name_1>=<expr_1>, <name_2>=<expr_2>,
          ...)
     Alamacena los valores actuales de <name_1>, <name_2>, <name_3>,
     ..., en el archivo <filename>. Los argumentos son nombres de
     variables, funciones u otros objetos. Si un nombre no tiene un
     valor o una función asociado a él, entonces se ignora.

     La función `save' devuelve <filename>.

     La función `save' almacena datos en forma de expresiones Lisp.
     Los datos almacenados por `save' pueden recuperarse con `load
     (<filename>)'.  El resultado de ejecutar  `save' cuando <filename>
     ya existe depende del soporte Lisp implementado; el archivo puede
     ser sobreescrito o que `save' envíe un mesaje de error.

     La llamada `save (<filename>, values, functions, labels, ...)'
     almacena los elementos cuyos nombres son `values', `functions',
     `labels', etc. Los nombres pueden ser cualesquiera de los
     especificados por la variable `infolists'; `values' incluye todas
     las variables definidas por el usuario.

     La llamada `save (<filename>, [<m>, <n>])' almacena los valores de
     las etiquetas de entrada y salida desde <m> hasta <n>. Nótese que
     <m> y <n> deben ser números. Las etiquetas de entrada y salida
     también se pueden almacenar una a una, por ejemplo, `save
     ("foo.1", %i42, %o42)'.  La llamada `save (<filename>, labels)'
     almacena todas las etiquetas de entrada y salida. Cuando las
     etiquetas almacenadas en el archivo sean posteriormente
     recuperadas, se sobreescribirán las activas en ese momento.

     La llamada `save (<filename>, <name_1>=<expr_1>,
     <name_2>=<expr_2>, ...)' almacena los valores de <expr_1>,
     <expr_2>, ..., con los nombres <name_1>, <name_2>, ....  Es útil
     hacer este tipo de llamada para con etiquetas de entrada y salida,
     por ejemplo, `save ("foo.1", aa=%o88)'.  El miembro derecho de la
     igualdad puede ser cualquier expresión, que será evaluada.  Esta
     llamada a la función `save' no incorpora nuevos nombres a la
     sesión actual de Maxima, simplemente los almacena en el archivo
     <filename>.

     Todas estas formas de llamar a la función `save' se pueden
     combinar a voluntad.  Por ejemplo, `save (<filename>, aa, bb,
     cc=42, functions, [11, 17])'.

     La llamada `save (<filename>, all)' almacena el estado actual de
     Maxima, lo que incluye todas las variables definidas por el
     usuario, funciones, arreglos, etc., así como algunos objetos
     definidos automáticamente.  Los elementos almacenados incluyen
     variables del sistema, como `file_search_maxima' o `showtime', si
     han sido modificadas por el usuario. Véase `myoptions'.

     `save' evalúa <filename> pero no el resto de argumentos.

 -- Función: stringout (<filename>, <expr_1>, <expr_2>, <expr_3>, ...)
 -- Función: stringout (<filename>, [<m>, <n>])
 -- Función: stringout (<filename>, input)
 -- Función: stringout (<filename>, functions)
 -- Función: stringout (<filename>, values)
     La función `stringout' escribe expresiones en un archivo de la
     misma forma en que se escribirían como expresiones de entrada. El
     archivo puede ser utilizado entonces como entrada a las funciones
     `batch' o `demo', y puede ser editado para cualquier otro
     propósito.

     La forma general de `stringout' escribe los valores de una o más
     expresiones en el archivo de salida. Nótese que si una expresión
     es una variable, solamente se escribirá el valor de la variable y
     no el nombre de ésta. Como caso especial, y muy útil en algunas
     ocasiones, las expresiones pueden ser etiquetas de entrada (`%i1',
     `%i2', `%i3', ...) o de salida (`%o1', `%o2', `%o3', ...).

     Si `grind' vale `true', `stringout' formatea la salida utilizando
     `grind'.  En caso contrario, se utilizará el formato `string'.
     Véanse `grind' y `string'.

     La forma especial `stringout (<filename>, [<m>, <n>])' escribe los
     valores de las etiquetas de entrada desde la m hasta la n, ambas
     inclusive.

     La forma especial `stringout (<filename>, input)' escribe todas
     las etiquetas de entrada en el archivo.

     La forma especial `stringout (<filename>, functions)' escribe
     todas las funciones definidas por el usuario, contenidas en la
     lista global `functions', en el archivo.

     La forma especial `stringout (<filename>, values)' escribe todas
     las variables asignadas por el usuario, contenidas en la lista
     global `values', en el archivo.  Cada variable se escribe como una
     sentencia de asignación, con el nombre de la variable seguida de
     dos puntos y a continuación su valor. Nótese que la forma general
     de `stringout' no escribe las variables como sentencias de
     asignación.

 -- Función: with_stdout (<f>, <expr_1>, <expr_2>, <expr_3>, ...)
 -- Función: with_stdout (<s>, <expr_1>, <expr_2>, <expr_3>, ...)
     Evalúa  <expr_1>, <expr_2>, <expr_3>, ...  y escribe los
     resultados en el fichero <f> o flujo de salida <s>.  Las
     expresiones que se evalúan no se escriben. La salida puede
     generarse por medio de `print', `display', `grind' entre otras
     funciones.

     La variable global `file_output_append' controla si `with_stdout'
     añade o reinicia el contenido del fichero de salida <f>.  Si
     `file_output_append' vale `true', `with_stdout' añade contenido al
     fichero de salida. En cualquier caso, `with_stdout' crea el
     fichero si éste no existe.

     La función `with_stdout' devuelve el valor de su último argumento.

     Véase también `writefile'.

          (%i1) with_stdout ("tmp.out",
                             for i:5 thru 10 do print (i, "! yields", i!))$
          (%i2) printfile ("tmp.out")$
          5 ! yields 120
          6 ! yields 720
          7 ! yields 5040
          8 ! yields 40320
          9 ! yields 362880
          10 ! yields 3628800

 -- Función: writefile (<filename>)
     Comienza escribiendo una transcripción de la sesión de Maxima en
     el archivo <filename>.  Cualquier interacción entre Maxima y el
     usuario se almacena también en este archivo, tal como aparece en
     la consola.

     Puesto que la transcripción se escribe en el formato de salida a
     la consola, su contenido no es interpretable por Maxima.  Para
     hacer un archivo que contenga expresiones que puedan ser
     nuevamente cargadas en Maxima, véanse `save' y `stringout'; la
     función `save' almacena expresiones en formato Lisp, mientras que
     `stringout' lo hace en formato Maxima.

     El resultado de ejecutar `writefile' cuando el archivo <filename>
     ya existe depende del entorno Lisp operativo; el contenido
     anterior puede ser sobreescrito o ampliado con la sesión actual.
     La función `appendfile' siempre añade la sesión al contenido
     actual.

     Puede ser útil ejecutar `playback' después de `writefile' para
     guardar las interacciones previas de la sesión. Puesto que
     `playback' muestra solamente las variables de entrada y salida
     (`%i1', `%o1', etc.), cualquier salida generada por una sentencia
     de impresión desde dentro de una función no es mostrada por
     `playback'.

     La función `closefile' cierra los archivos abiertos por
     `writefile' o `appendfile'.


File: maxima.info,  Node: Funciones y variables para salida TeX,  Next: Funciones y variables para salida Fortran,  Prev: Funciones y variables para lectura y escritura,  Up: Lectura y escritura

13.4 Funciones y variables para salida TeX
==========================================

 -- Función: tex (<expr>)
 -- Función: tex (<expr>, <destination>)
 -- Función: tex (<expr>, false)
 -- Función: tex (<label>)
 -- Función: tex (<label>, <destination>)
 -- Función: tex (<label>, false)
     Devuelve la expresión en un formato apropiado para para ser
     incorporado a un documento basado en TeX. El resultado que se
     obtiene es un fragmento de código que puede incluirse en un
     documento mayor, pero que no puede ser procesado aisladamente.

     La instrucción `tex (<expr>)' imprime en la consola la
     representación en TeX de <expr>.

     La instrucción `tex (<label>)' imprime en la consola la
     representación en TeX de la expresión a la que hace referencia la
     etiqueta <label>, asignándole a su vez una etiqueta de ecuación
     que será mostrada al lado izquierdo de la misma. La etiqueta de la
     expresión en TeX es la misma que la de Maxima.

     <destination> puede ser tanto un flujo de salida como el nombre de
     un fichero.

     Si <destination> es el nombre de un fichero, `tex' añade la salida
     al fichero.  Las funciones `openw' y `opena' crean flujos de
     salida.

     Las instrucciones `tex (<expr>, false)' y `tex (<label>, false)'
     devuelven el código TeX en formato de cadena.

     La función `tex' evalúa su primer argumento tras comprobar si se
     trata de una etiqueta. La doble comilla simple `''' fuerza la
     evaluación del argumento, anulando la comprobación sobre la
     etiqueta.

     Véase también `texput'.

     Ejemplos:

          (%i1) integrate (1/(1+x^3), x);
                                              2 x - 1
                            2            atan(-------)
                       log(x  - x + 1)        sqrt(3)    log(x + 1)
          (%o1)      - --------------- + ------------- + ----------
                              6             sqrt(3)          3
          (%i2) tex (%o1);
          $$-{{\log \left(x^2-x+1\right)}\over{6}}+{{\arctan \left({{2\,x-1
           }\over{\sqrt{3}}}\right)}\over{\sqrt{3}}}+{{\log \left(x+1\right)
           }\over{3}}\leqno{\tt (\%o1)}$$
          (%o2)                          (\%o1)
          (%i3) tex (integrate (sin(x), x));
          $$-\cos x$$
          (%o3)                           false
          (%i4) tex (%o1, "foo.tex");
          (%o4)                          (\%o1)

     `tex (<expr>, false)' devuelve el código TeX en formato de cadena.

          (%i1) S : tex (x * y * z, false);
          (%o1) $$x\,y\,z$$
          (%i2) S;
          (%o2) $$x\,y\,z$$

 -- Función: tex1 (<e>)
     Devuelve una cadena con el código TeX de la expresión <e>.  El
     código TeX no se encierra entre delimitadores para una ecuación ni
     cualesquiera otros entornos.

     Ejemplo:

          (%i1) tex1 (sin(x) + cos(x));
          (%o1)                     \sin x+\cos x

 -- Función: texput (<a>, <s>)
 -- Función: texput (<a>, <f>)
 -- Función: texput (<a>, <s>, <operator_type>)
 -- Función: texput (<a>, [<s_1>, <s_2>], matchfix)
 -- Función: texput (<a>, [<s_1>, <s_2>, <s_3>], matchfix)
     Establece el formato en TeX del átomo <a>, el cual puede ser un
     símbolo o el nombre de un operador.

     La instrucción `texput (<a>, <s>)' hace que la función `tex'
     introduzca <s> en la salida TeX en el lugar de <a>.

     La instrucción `texput (<a>, <f>)' hace que `tex' llame a la
     función <f> para que genere código TeX. La función <f> debe
     aceptar un único argumento, el cual es una expresión que tenga como
     operador <a> y que devuelva una cadena con el código TeX. Esta
     función puede llamar a `tex1' para generar el código TeX para los
     argumentos de la expresión de entrada.

     La instrucción `texput (<a>, <s>, <operator_type>)', en la que
     <operator_type> es `prefix', `infix' o `postfix', `nary' o
     `nofix',hace que la función `tex' introduzca <s> en la salida TeX
     en el lugar de <a>, colocándolo en el lugar correcto.

     La instrucción `texput (<a>, [<s_1>, <s_2>], matchfix)' hace que
     la función `tex' introduzca <s_1> y <s_2> en la salida TeX a los
     lados de los argumentos de <a>. Si son más de uno, los argumentos
     se separan por comas.

     La instrucción `texput (<a>, [<s_1>, <s_2>, <s_3>], matchfix)'
     hace que la función `tex' introduzca <s_1> y <s_2> en la salida
     TeX a los lados de los argumentos de <a>, con <s_3> separando los
     argumentos.

     Ejemplos:

     Asigna código TeX para una variable.

     Llama a una función que genera código TeX.

          (%i1) texfoo (e) := block ([a, b], [a, b] : args (e),
            concat ("\\left[\\stackrel{", tex1 (b),
                    "}{", tex1 (a), "}\\right]"))$
          (%i2) texput (foo, texfoo);
          (%o2)                        texfoo
          (%i3) tex (foo (2^x, %pi));
          $$\left[\stackrel{\pi}{2^{x}}\right]$$
          (%o3)                         false

          (%i1) texput (me,"\\mu_e");
          (%o1)                         \mu_e
          (%i2) tex (me);
          $$\mu_e$$
          (%o2)                         false

     Asigna código TeX para una función ordinaria (no para un operador).

          (%i1) texput (lcm, "\\mathrm{lcm}");
          (%o1)                     \mathrm{lcm}
          (%i2) tex (lcm (a, b));
          $$\mathrm{lcm}\left(a , b\right)$$
          (%o2)                         false

     Asigna código TeX para un operador prefijo.

          (%i1) prefix ("grad");
          (%o1)                         grad
          (%i2) texput ("grad", " \\nabla ", prefix);
          (%o2)                        \nabla
          (%i3) tex (grad f);
          $$ \nabla f$$
          (%o3)                         false

     Asigna código TeX para un operador infijo.

          (%i1) infix ("~");
          (%o1)                           ~
          (%i2) texput ("~", " \\times ", infix);
          (%o2)                        \times
          (%i3) tex (a ~ b);
          $$a \times b$$
          (%o3)                         false

     Asigna código TeX para un operador postfijo..

          (%i1) postfix ("##");
          (%o1)                          ##
          (%i2) texput ("##", "!!", postfix);
          (%o2)                          !!
          (%i3) tex (x ##);
          $$x!!$$
          (%o3)                         false

     Asigna código TeX para un operador n-ario.

          (%i1) nary ("@@");
          (%o1)                          @@
          (%i2) texput ("@@", " \\circ ", nary);
          (%o2)                         \circ
          (%i3) tex (a @@ b @@ c @@ d);
          $$a \circ b \circ c \circ d$$
          (%o3)                         false

     Asigna código TeX para un operador "no-fijo".

          (%i1) nofix ("foo");
          (%o1)                          foo
          (%i2) texput ("foo", "\\mathsc{foo}", nofix);
          (%o2)                     \mathsc{foo}
          (%i3) tex (foo);
          $$\mathsc{foo}$$
          (%o3)                         false

     Asigna código TeX para un operador "bi-fijo" (matchfix).

          (%i1) matchfix ("<<", ">>");
          (%o1)                          <<
          (%i2) texput ("<<", [" \\langle ", " \\rangle "], matchfix);
          (%o2)                [ \langle ,  \rangle ]
          (%i3) tex (<<a>>);
          $$ \langle a \rangle $$
          (%o3)                         false
          (%i4) tex (<<a, b>>);
          $$ \langle a , b \rangle $$
          (%o4)                         false
          (%i5) texput ("<<", [" \\langle ", " \\rangle ", " \\, | \\,"],
                matchfix);
          (%o5)           [ \langle ,  \rangle ,  \, | \,]
          (%i6) tex (<<a>>);
          $$ \langle a \rangle $$
          (%o6)                         false
          (%i7) tex (<<a, b>>);
          $$ \langle a \, | \,b \rangle $$
          (%o7)                         false

 -- Función: get_tex_environment (<op>)
 -- Función: set_tex_environment (<op>, <before>, <after>)
     Gestiona el entorno de las salidas TeX que se obtienen de la
     función `tex'.  El entorno TeX está formado por dos cadenas: una
     que se escribe antes que cualquier salida en TeX, y otra que se
     escribe después.

     `get_tex_environment' devuelve el entorno TeX que se aplica al
     operador <op>.  Si no se ha asignado ningún entorno, devolverá el
     que tenga por defecto.

     `set_tex_environment' asigna el entorno TeX al operador <op>.

     Ejemplos:

          (%i1) get_tex_environment (":=");
          (%o1) [
          \begin{verbatim}
          , ;
          \end{verbatim}
          ]
          (%i2) tex (f (x) := 1 - x);

          \begin{verbatim}
          f(x):=1-x;
          \end{verbatim}

          (%o2)                         false
          (%i3) set_tex_environment (":=", "$$", "$$");
          (%o3)                       [$$, $$]
          (%i4) tex (f (x) := 1 - x);
          $$f(x):=1-x$$
          (%o4)                         false

 -- Función: get_tex_environment_default ()
 -- Función: set_tex_environment_default (<before>, <after>)
     Gestiona el entorno de las salidas TeX que se obtienen de la
     función `tex'.  El entorno TeX está formado por dos cadenas: una
     que se escribe antes que cualquier salida en TeX, y otra que se
     escribe después.

     `get_tex_environment_default' devuelve el entorno TeX que se aplica
     a expresiones para las cuales el operador de mayor rango no tiene
     entorno TeX asignado (mediante `set_tex_environment').

     `set_tex_environment_default' asigna el entorno TeX por defecto.

     Ejemplos:

          (%i1) get_tex_environment_default ();
          (%o1)                       [$$, $$]
          (%i2) tex (f(x) + g(x));
          $$g\left(x\right)+f\left(x\right)$$
          (%o2)                         false
          (%i3) set_tex_environment_default ("\\begin{equation}
          ", "
          \\end{equation}");
          (%o3) [\begin{equation}
          ,
          \end{equation}]
          (%i4) tex (f(x) + g(x));
          \begin{equation}
          g\left(x\right)+f\left(x\right)
          \end{equation}
          (%o4)                         false


File: maxima.info,  Node: Funciones y variables para salida Fortran,  Prev: Funciones y variables para salida TeX,  Up: Lectura y escritura

13.5 Funciones y variables para salida Fortran
==============================================

 -- Variable opcional: fortindent
     Valor por defecto: 0

     La variable `fortindent' controla el margen izquierdo de las
     expresiones que escribe la instrucción `fortran'.  El valor 0
     escribe con un margen normal de 6 espacios; valores positivos
     harán que las expresiones se escriban más a la derecha.

 -- Función: fortran (<expr>)
     Escribe <expr> en código Fortran. La salida se escribe con
     márgenes, y si ésta es demasiado larga `fortran' sigue escribiendo
     en líneas sucesivas. La función `fortran' escribe el operador de
     exponenciación `^' como `**', e imprime un número complejo `a + b
     %i' como `(a,b)'.

     El argumento <expr> puede ser una ecuación. En tal caso, `fortran'
     escribe una sentencia de asignación, dándole el valor del miembro
     derecho de la expresión al miembro izquierdo. En particular, si el
     miembro derecho de <expr> es el nombre de una matriz, entonces
     `fortran' escribe una sentencia de asignación para cada elemento
     de la matriz.

     Si <expr> no es reconozida por `fortran', la expresión se escribe
     en formato `grind' sin avisos. La función `fortran' no reconoce
     listas, arreglos ni funciones.

     La variable `fortindent' controla el margen izquierdo de las
     expresiones que escribe la instrucción `fortran'.  El valor 0
     escribe con un margen normal de 6 espacios; valores positivos
     harán que las expresiones se escriban más a la derecha.

     Si `fortspaces' vale `true', `fortran' rellena las líneas con
     espacios de 80 columnas.

     La función `fortran' evalúa sus argumentos; un argumento precedido
     de apóstrofo previene de la evaluación.  La función `fortran'
     siempre devuelve `done'.

     Ejemplos:

     (%i1) expr: (a + b)^12$
     (%i2) fortran (expr);
           (b+a)**12
     (%o2)                         done
     (%i3) fortran ('x=expr);
           x = (b+a)**12
     (%o3)                         done
     (%i4) fortran ('x=expand (expr));
           x = b**12+12*a*b**11+66*a**2*b**10+220*a**3*b**9+495*a**4*b**8+792
          1   *a**5*b**7+924*a**6*b**6+792*a**7*b**5+495*a**8*b**4+220*a**9*b
          2   **3+66*a**10*b**2+12*a**11*b+a**12
     (%o4)                         done
     (%i5) fortran ('x=7+5*%i);
           x = (7,5)
     (%o5)                         done
     (%i6) fortran ('x=[1,2,3,4]);
           x = [1,2,3,4]
     (%o6)                         done
     (%i7) f(x) := x^2$
     (%i8) fortran (f);
           f
     (%o8)                         done

 -- Variable opcional: fortspaces
     Valor por defecto: `false'

     Si `fortspaces' vale `true', `fortran' rellena las líneas con
     espacios de 80 columnas.


File: maxima.info,  Node: Polinomios,  Next: Funciones Especiales,  Prev: Lectura y escritura,  Up: Top

14 Polinomios
*************

* Menu:

* Introducción a los polinomios::
* Funciones y variables para polinomios::


File: maxima.info,  Node: Introducción a los polinomios,  Next: Funciones y variables para polinomios,  Prev: Polinomios,  Up: Polinomios

14.1 Introducción a los polinomios
==================================

Los polinomios se almacenan en Maxima, bien en un formato general, bien
en una forma conocida como canónica (Cannonical Rational Expressions,
CRE). La última corresponde al formato estándar y se utiliza
internamente para realizar operaciones como `factor', `ratsimp' y demás.

   Las Expresiones Racionales Canónicas (CRE) constituyen un tipo de
representación que es especialmente apropiado para expandir polinomios
y funciones racionales (así como para polinomios parcialmente
factorizados y funciones racionales cuando a la variable `ratfac' se le
asigna el valor `true'). En esta forma CRE las variables se ordenan de
mayor a menor. Los polinomios se representan recursivamente como una
lista compuesta por la variable principal seguida por una serie de
pares de expresiones, una por cada término del polinomio. El primer
miembro de cada par es el exponente de la variable principal en ese
término y el segundo miembro es el coeficiente de ese término, el cual
puede ser un número o un polinomio en otra variable representado
también de esta forma. Así, la parte principal de la forma CRE de
3*X^2-1 es (X 2 3 0 -1) y la de 2*X*Y+X-3 es (Y 1 (X 1 2) 0 (X 1 1 0
-3)) asumiendo que Y es la variable principal, y será (X 1 (Y 1 2 0 1)
0 -3) si se asume que la variable principal es X. Qué variable se
considera "principal" se determinada en orden alfabético inverso.  Las
"variables" de la expresión CRE no son necesariamente atómicas. De hecho
cualquier subexpresión cuyo operador principal no es + - * / ni ^ con
potencia entera puede ser considerada como una "variable" de la
expresión (en forma CRE) en el cual aparezca. Por ejemplo las variables
CRE de la expresión X+SIN(X+1)+2*SQRT(X)+1 son X, SQRT(X)  y SIN(X+1).
Si el usuario no especifica una ordenación de las variables mediante la
función `ratvars' Maxima escogerá una alfabéticamente. En general, laa
CRE representan expresiones racionales, esto es, fracciones de
polinomios, donde el numerador y el denominador  no tienen factores
comunes, siendo el denominador es positivo. La forma interna es
esencialmente un par de polinomios (el numerador y el denominador)
precedida por la lista de variables ordenadas. Si una expresión a ser
mostrada está en la forma CRE o contiene alguna subexpresión en forma
de CRE, el simbolo /R/ será seguido por la etiqueta de la línea de
comando.  Véase la función `rat' para convertir una expresión a la
forma CRE. Una extensión de la forma CRE se utiliza para la
representación de las series de Taylor. La noción de una expresión
racional se extiende de manera que los exponentes de las variables
pueden ser números racionales positivos o negativos y no sólo enteros
positivos y los coeficientes pueden ser también expresiones racionales
y no sólo polinomios. Estas expresiones se representan internamente por
una forma polinomial recursiva que es similar a la forma CRE, pero que
la generaliza, aportando información adicional como el grado de
truncamiento. Como con la forma CRE, el símbolo /T/ sigue la etiqueta
de línea de comando en la que se encuentra dicha expresión.



Local Variables:
coding: iso-8859-1
End:
