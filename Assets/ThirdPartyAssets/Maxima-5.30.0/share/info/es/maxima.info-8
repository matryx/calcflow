This is maxima.info, produced by makeinfo version 4.13 from maxima.texi.

Ver. 5.30 Este es el Manual de Maxima en versión Texinfo

   Copyright 1994, 2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).  Un sistema de cálculo simbólico
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Funciones y variables para interpol,  Prev: Introducción a interpol,  Up: interpol

58.2 Funciones y variables para interpol
========================================

 -- Función: lagrange (<points>)
 -- Función: lagrange (<points>, <option>)
     Calcula el polinomio de interpolación por el método de Lagrange.
     El argumento <points> debe ser:

        * una matriz de dos columnas, `p:matrix([2,4],[5,6],[9,3])',

        * una lista de pares de números, `p: [[2,4],[5,6],[9,3]]',

        * una lista de números, `p: [4,6,3]', en cuyo caso las abscisas
          se asignarán automáticamente a 1, 2, 3, etc.

     En los dos primeros casos los pares se ordenan con respecto a la
     primera coordenada antes de proceder a los cálculos.

     Mediante el argumento <option> es posible seleccionar el nombre de
     la variable independiente, que por defecto es `'x'; para definir
     otra, escríbase algo como `varname='z'.

     Téngase en cuenta que cuando se trabaja con polinomios de grado
     alto, los cálculos con números decimales en coma flotante pueden
     ser muy inestables.

     Véanse también `linearinterpol', `cspline' y `ratinterpol'.

     Ejemplos:

          (%i1) load(interpol)$
          (%i2) p:[[7,2],[8,2],[1,5],[3,2],[6,7]]$
          (%i3) lagrange(p);
                 (x - 7) (x - 6) (x - 3) (x - 1)
          (%o3)  -------------------------------
                               35
             (x - 8) (x - 6) (x - 3) (x - 1)
           - -------------------------------
                           12
             7 (x - 8) (x - 7) (x - 3) (x - 1)
           + ---------------------------------
                            30
             (x - 8) (x - 7) (x - 6) (x - 1)
           - -------------------------------
                           60
             (x - 8) (x - 7) (x - 6) (x - 3)
           + -------------------------------
                           84
          (%i4) f(x):=''%;
                         (x - 7) (x - 6) (x - 3) (x - 1)
          (%o4)  f(x) := -------------------------------
                                       35
             (x - 8) (x - 6) (x - 3) (x - 1)
           - -------------------------------
                           12
             7 (x - 8) (x - 7) (x - 3) (x - 1)
           + ---------------------------------
                            30
             (x - 8) (x - 7) (x - 6) (x - 1)
           - -------------------------------
                           60
             (x - 8) (x - 7) (x - 6) (x - 3)
           + -------------------------------
                           84
          (%i5) /* Evaluate the polynomial at some points */
                expand(map(f,[2.3,5/7,%pi]));
                                            4          3           2
                              919062  73 %pi    701 %pi    8957 %pi
          (%o5)  [- 1.567535, ------, ------- - -------- + ---------
                              84035     420       210         420
                                                       5288 %pi   186
                                                     - -------- + ---]
                                                         105       5
          (%i6) %,numer;
          (%o6) [- 1.567535, 10.9366573451538, 2.89319655125692]
          (%i7) load(draw)$  /* load draw package */
          (%i8) /* Plot the polynomial together with points */
                draw2d(
                  color      = red,
                  key        = "Lagrange polynomial",
                  explicit(f(x),x,0,10),
                  point_size = 3,
                  color      = blue,
                  key        = "Sample points",
                  points(p))$
          (%i9) /* Change variable name */
                lagrange(p, varname=w);
                 (w - 7) (w - 6) (w - 3) (w - 1)
          (%o9)  -------------------------------
                               35
             (w - 8) (w - 6) (w - 3) (w - 1)
           - -------------------------------
                           12
             7 (w - 8) (w - 7) (w - 3) (w - 1)
           + ---------------------------------
                            30
             (w - 8) (w - 7) (w - 6) (w - 1)
           - -------------------------------
                           60
             (w - 8) (w - 7) (w - 6) (w - 3)
           + -------------------------------
                           84


 -- Función: charfun2 (<x>, <a>, <b>)
     Devuelve `true' si el número <x> pertenece al intervalo [a, b), y
     `false' en caso contrario.

 -- Función: linearinterpol (<points>)
 -- Función: linearinterpol (<points>, <option>)
     Calcula rectas de interpolación. El argumento <points> debe ser:

        * una matriz de dos columnas, `p:matrix([2,4],[5,6],[9,3])',

        * una lista de pares de números, `p: [[2,4],[5,6],[9,3]]',

        * una lista de números, `p: [4,6,3]', en cuyo caso las abscisas
          se asignarán automáticamente a 1, 2, 3, etc.

     En los dos primeros casos los pares se ordenan con respecto a la
     primera coordenada antes de proceder a los cálculos.

     Mediante el argumento <option> es posible seleccionar el nombre de
     la variable independiente, que por defecto es `'x'; para definir
     otra, escríbase algo como `varname='z'.

     Véanse también `lagrange', `cspline' y `ratinterpol'.

     Ejemplos:

          (%i1) load(interpol)$
          (%i2) p: matrix([7,2],[8,3],[1,5],[3,2],[6,7])$
          (%i3) linearinterpol(p);
                  13   3 x
          (%o3)  (-- - ---) charfun2(x, minf, 3)
                  2     2
           + (x - 5) charfun2(x, 7, inf) + (37 - 5 x) charfun2(x, 6, 7)
              5 x
           + (--- - 3) charfun2(x, 3, 6)
               3

          (%i4) f(x):=''%;
                          13   3 x
          (%o4)  f(x) := (-- - ---) charfun2(x, minf, 3)
                          2     2
           + (x - 5) charfun2(x, 7, inf) + (37 - 5 x) charfun2(x, 6, 7)
              5 x
           + (--- - 3) charfun2(x, 3, 6)
               3
          (%i5)  /* Evaluate the polynomial at some points */
                 map(f,[7.3,25/7,%pi]);
                                      62  5 %pi
          (%o5)                 [2.3, --, ----- - 3]
                                      21    3
          (%i6) %,numer;
          (%o6)  [2.3, 2.952380952380953, 2.235987755982989]
          (%i7) load(draw)$  /* load draw package */
          (%i8)  /* Plot the polynomial together with points */
                 draw2d(
                   color      = red,
                   key        = "Linear interpolator",
                   explicit(f(x),x,-5,20),
                   point_size = 3,
                   color      = blue,
                   key        = "Sample points",
                   points(args(p)))$
          (%i9)  /* Change variable name */
                 linearinterpol(p, varname='s);
                 13   3 s
          (%o9) (-- - ---) charfun2(s, minf, 3)
                 2     2
           + (s - 5) charfun2(s, 7, inf) + (37 - 5 s) charfun2(s, 6, 7)
              5 s
           + (--- - 3) charfun2(s, 3, 6)
               3


 -- Función: cspline (<points>)
 -- Función: cspline (<points>, <option1>, <option2>, ...)
     Calcula el polinomio de interpolación por el método de los splines
     cúbicos. El argumento <points> debe ser:

        * una matriz de dos columnas, `p:matrix([2,4],[5,6],[9,3])',

        * una lista de pares de números, `p: [[2,4],[5,6],[9,3]]',

        * una lista de números, `p: [4,6,3]', en cuyo caso las abscisas
          se asignarán automáticamente a 1, 2, 3, etc.

     En los dos primeros casos los pares se ordenan con respecto a la
     primera coordenada antes de proceder a los cálculos.

     Esta función dispone de tres opciones para acomodarse a
     necesidades concretas:

        * `'d1', por defecto `'unknown', es la primera derivada en x_1;
          si toma el valor `'unknown', la segunda derivada en x_1 se
          iguala a 0 (spline cúbico natural); en caso de tomar un valor
          numérico, la segunda derivada se calcula en base a este
          número.

        * `'dn', por defecto `'unknown', es la primera derivada en x_n;
          si toma el valor `'unknown', la segunda derivada en x_n se
          iguala a 0 (spline cúbico natural); en caso de tomar un valor
          numérico, la segunda derivada se calcula en base a este
          número.

        * `'varname', por defecto `'x', es el nombre de la variable
          independiente.

     Véanse también `lagrange', `linearinterpol' y `ratinterpol'.

     Ejemplos:

          (%i1) load(interpol)$
          (%i2) p:[[7,2],[8,2],[1,5],[3,2],[6,7]]$
          (%i3) /* Unknown first derivatives at the extremes
                   is equivalent to natural cubic splines */
                cspline(p);
                        3         2
                  1159 x    1159 x    6091 x   8283
          (%o3)  (------- - ------- - ------ + ----) charfun2(x, minf, 3)
                   3288      1096      3288    1096
                      3         2
                2587 x    5174 x    494117 x   108928
           + (- ------- + ------- - -------- + ------) charfun2(x, 7, inf)
                 1644       137       1644      137
                    3          2
              4715 x    15209 x    579277 x   199575
           + (------- - -------- + -------- - ------) charfun2(x, 6, 7)
               1644       274        1644      274
                      3         2
                3287 x    2223 x    48275 x   9609
           + (- ------- + ------- - ------- + ----) charfun2(x, 3, 6)
                 4932       274      1644     274

          (%i4) f(x):=''%$
          (%i5) /* Some evaluations */
                map(f,[2.3,5/7,%pi]), numer;
          (%o5) [1.991460766423356, 5.823200187269903, 2.227405312429507]
          (%i6) load(draw)$  /* load draw package */
          (%i7) /* Plotting interpolating function */
                draw2d(
                  color      = red,
                  key        = "Cubic splines",
                  explicit(f(x),x,0,10),
                  point_size = 3,
                  color      = blue,
                  key        = "Sample points",
                  points(p))$
          (%i8) /* New call, but giving values at the derivatives */
                cspline(p,d1=0,dn=0);
                        3          2
                  1949 x    11437 x    17027 x   1247
          (%o8)  (------- - -------- + ------- + ----) charfun2(x, minf, 3)
                   2256       2256      2256     752
                      3          2
                1547 x    35581 x    68068 x   173546
           + (- ------- + -------- - ------- + ------) charfun2(x, 7, inf)
                  564       564        141      141
                   3          2
              607 x    35147 x    55706 x   38420
           + (------ - -------- + ------- - -----) charfun2(x, 6, 7)
               188       564        141      47
                      3         2
                3895 x    1807 x    5146 x   2148
           + (- ------- + ------- - ------ + ----) charfun2(x, 3, 6)
                 5076       188      141      47
          (%i8) /* Defining new interpolating function */
                g(x):=''%$
          (%i9) /* Plotting both functions together */
                draw2d(
                  color      = black,
                  key        = "Cubic splines (default)",
                  explicit(f(x),x,0,10),
                  color      = red,
                  key        = "Cubic splines (d1=0,dn=0)",
                  explicit(g(x),x,0,10),
                  point_size = 3,
                  color      = blue,
                  key        = "Sample points",
                  points(p))$

 -- Función: ratinterpol (<points>, <numdeg>)
 -- Función: ratinterpol (<points>, <numdeg>, <option1>)
     Genera el interpolador racional para los datos dados por <points>
     y con grado <numdeg> en el numerador; el grado del denominador se
     calcula automáticamente. El argumento <points> debe ser:

        * una matriz de dos columnas, `p:matrix([2,4],[5,6],[9,3])',

        * una lista de pares de números, `p: [[2,4],[5,6],[9,3]]',

        * una lista de números, `p: [4,6,3]', en cuyo caso las abscisas
          se asignarán automáticamente a 1, 2, 3, etc.

     En los dos primeros casos los pares se ordenan con respecto a la
     primera coordenada antes de proceder a los cálculos.

     Esta función dispone de una opción para acomodarse a necesidades
     concretas:
        * `'varname', por defecto `'x', es el nombre de la variable
          independiente.

     Véanse también `lagrange', `linearinterpol', `cspline',
     `minpack_lsquares' y `lbfgs'.

     Ejemplos:

          (%i1) load(interpol)$
          (%i2) load(draw)$
          (%i3) p:[[7.2,2.5],[8.5,2.1],[1.6,5.1],[3.4,2.4],[6.7,7.9]]$
          (%i4) for k:0 thru length(p)-1 do
                  draw2d(
                    explicit(ratinterpol(p,k),x,0,9),
                    point_size = 3,
                    points(p),
                    title = concat("Grado del numerador = ",k),
                    yrange=[0,10])$


File: maxima.info,  Node: lapack,  Next: lbfgs,  Prev: interpol,  Up: Top

59 lapack
*********

* Menu:

* Introducción a lapack::
* Funciones y variables para lapack::


File: maxima.info,  Node: Introducción a lapack,  Next: Funciones y variables para lapack,  Prev: lapack,  Up: lapack

59.1 Introducción a lapack
==========================

`lapack' es una traducción automática a Common Lisp (con el programa
`f2c') de la librería LAPACK escrita en Fortran.


File: maxima.info,  Node: Funciones y variables para lapack,  Prev: Introducción a lapack,  Up: lapack

59.2 Funciones y variables para lapack
======================================

 -- Función: dgeev (<A>)
 -- Función: dgeev (<A>, <right_p>, <left_p>)
     Calcula los autovalores y, opcionalmente, también los autovectores
     de la matriz <A>.  Todos los elementos de <A> deben ser enteros o
     números decimales en coma flotante.  Además, <A> debe ser cuadrada
     (igual número de filas que de columnas) y puede ser o no simétrica.

     `dgeev(<A>)' calcula sólo los autovalores de <A>.  `dgeev(<A>,
     <right_p>, <left_p>)' calcula los autovalores de <A> y los
     autovectores por la derecha cuando <right_p> = `true', y los
     autovectores por la izquierda cuando <left_p> = `true'.

     La función devuelve una lista de tres elementos.  El primer
     elemento es una lista con los autovalores.  El segundo elemento es
     `false' o la matriz de autovectores por la derecha.  El tercer
     elemento es `false' o la matriz de autovectores por la izquierda.

     El autovector por la derecha v(j) (la j-ésima columna de la matriz
     de autovectores por la derecha) satisface

     A . v(j) = lambda(j) . v(j)

     donde lambda(j) es su autovalor asociado.

     El autovector por la izquierda u(j) (la j-ésima columna de la
     matriz de autovectores por la izquierda) satisface

     u(j)**H . A = lambda(j) . u(j)**H

     donde u(j)**H denota la transpuesta conjugada de u(j).

     La función de Maxima `ctranspose' calcula la transpuesta conjugada.

     Los autovectores calculados están normalizados para que su norma
     euclídea valga 1 y su componente mayor tenga su parte imaginaria
     igual a cero.

     Ejemplo:

          (%i1) load (lapack)$
          (%i2) fpprintprec : 6;
          (%o2)                           6
          (%i3) M : matrix ([9.5, 1.75], [3.25, 10.45]);
                                   [ 9.5   1.75  ]
          (%o3)                    [             ]
                                   [ 3.25  10.45 ]
          (%i4) dgeev (M);
          (%o4)          [[7.54331, 12.4067], false, false]
          (%i5) [L, v, u] : dgeev (M, true, true);
                                     [ - .666642  - .515792 ]
          (%o5) [[7.54331, 12.4067], [                      ],
                                     [  .745378   - .856714 ]
                                                  [ - .856714  - .745378 ]
                                                  [                      ]]
                                                  [  .515792   - .666642 ]
          (%i6) D : apply (diag_matrix, L);
                                [ 7.54331     0    ]
          (%o6)                 [                  ]
                                [    0     12.4067 ]
          (%i7) M . v - v . D;
                          [      0.0       - 8.88178E-16 ]
          (%o7)           [                              ]
                          [ - 8.88178E-16       0.0      ]
          (%i8) transpose (u) . M - D . transpose (u);
                               [ 0.0  - 4.44089E-16 ]
          (%o8)                [                    ]
                               [ 0.0       0.0      ]

 -- Función: dgeqrf (<A>)
     Calcula la descomposición QR de la matriz <A>.  Todos los
     elementos de <A> deben ser enteros o números reales. No es
     necesario que <A> tenga el mismo número de filas que de columnas.

     La función devuelve una lista con dos elementos; el primero es la
     matriz cuadrada ortonormal <Q>, con el mismo número de filas que
     <A>, y el segundo es la matriz triangular superior <R>, de iguales
     dimensiones que <A>. El producto `<Q> . <R>', siendo "." el
     operador de la multiplicación matricial, es igual a <A>, ignorando
     errores de redondeo.

          (%i1) load (lapack) $
          (%i2) fpprintprec : 6 $
          (%i3) M : matrix ([1, -3.2, 8], [-11, 2.7, 5.9]) $
          (%i4) [q, r] : dgeqrf (M);
                 [ - .0905357  .995893  ]
          (%o4) [[                      ],
                 [  .995893    .0905357 ]
                                         [ - 11.0454   2.97863   5.15148 ]
                                         [                               ]]
                                         [     0      - 2.94241  8.50131 ]
          (%i5) q . r - M;
                   [ - 7.77156E-16   1.77636E-15   - 8.88178E-16 ]
          (%o5)    [                                             ]
                   [      0.0       - 1.33227E-15   8.88178E-16  ]
          (%i6) mat_norm (%, 1);
          (%o6)                      3.10862E-15


 -- Función: dgesv (<A>, <b>)
     Calcula la solución <x> de la ecuación <A> <x> = <b>, siendo <A>
     una matriz cuadrada y <b> otra matriz con el mismo número de filas
     que <A> y un número arbitrario de columnas. Las dimensiones de la
     solución <x> son las mismas de <b>.

     Los elementos de <A> y <b> deben ser reducibles a números decimales
     si se les aplica la función `float', por lo que tales elementos
     pueden en principio ser de cualquier tipo numérico, constantes
     numéricas simbólicas o cualesquiera expresiones reducibles a un
     número decimal.  Los elementos de <x> son siempre números
     decimales. Todas las operaciones aritméticas se realizan en coma
     flotante.

     `dgesv' calcula la solución mediante la descomposición LU de <A>.

     Ejemplos:

     `dgesv' calcula la solución <x> de la ecuación <A> <x> = <b>.

          (%i1) A : matrix ([1, -2.5], [0.375, 5]);
                                         [   1    - 2.5 ]
          (%o1)                          [              ]
                                         [ 0.375    5   ]
          (%i2) b : matrix ([1.75], [-0.625]);
                                            [  1.75   ]
          (%o2)                             [         ]
                                            [ - 0.625 ]
          (%i3) x : dgesv (A, b);
                                      [  1.210526315789474  ]
          (%o3)                       [                     ]
                                      [ - 0.215789473684211 ]
          (%i4) dlange (inf_norm, b - A.x);
          (%o4)                                 0.0

     <b> una matriz con el mismo número de filas que <A> y un número
     arbitrario de columnas. Las dimensiones de <x> son las mismas de
     <b>.

          (%o0)                                done
          (%i1) A : matrix ([1, -0.15], [1.82, 2]);
                                         [  1    - 0.15 ]
          (%o1)                          [              ]
                                         [ 1.82    2    ]
          (%i2) b : matrix ([3.7, 1, 8], [-2.3, 5, -3.9]);
                                        [  3.7   1    8   ]
          (%o2)                         [                 ]
                                        [ - 2.3  5  - 3.9 ]
          (%i3) x : dgesv (A, b);
                  [  3.103827540695117   1.20985481742191    6.781786185657722  ]
          (%o3)   [                                                             ]
                  [ - 3.974483062032557  1.399032116146062  - 8.121425428948527 ]
          (%i4) dlange (inf_norm, b - A . x);
          (%o4)                       1.1102230246251565E-15

     Los elementos de <A> y <b> deben ser reducibles a números
     decimales.

          (%i1) A : matrix ([5, -%pi], [1b0, 11/17]);
                                         [   5    - %pi ]
                                         [              ]
          (%o1)                          [         11   ]
                                         [ 1.0b0   --   ]
                                         [         17   ]
          (%i2) b : matrix ([%e], [sin(1)]);
                                            [   %e   ]
          (%o2)                             [        ]
                                            [ sin(1) ]
          (%i3) x : dgesv (A, b);
                                       [ 0.690375643155986 ]
          (%o3)                        [                   ]
                                       [ 0.233510982552952 ]
          (%i4) dlange (inf_norm, b - A . x);
          (%o4)                        2.220446049250313E-16


 -- Función: dgesvd (<A>)
 -- Función: dgesvd (<A>, <left_p>, <right_p>)
     Calcula la descomposición singular (SVD, en inglés) de la matriz
     <A>, que contiene los valores singulares y, opcionalmente, los
     vectores singulares por la derecha o por la izquierda. Todos los
     elementos de <A> deben ser enteros o números decimales en coma
     flotante. La matriz <A> puede ser cuadrada o no (igual número de
     filas que de columnas).

     Sea m el número de filas y n el de columnas de <A>.  La
     descomposición singular de <A> consiste en calcular tres matrices:
     <U>, <Sigma> y <V^T>, tales que

     <A> = <U> . <Sigma> . <V>^T

     donde <U> es una matriz unitaria m-por-m, <Sigma> es una matriz
     diagonal m-por-n y <V^T> es una matriz unitaria n-por-n.

     Sea sigma[i] un elemento diagonal de Sigma, esto es, <Sigma>[i, i]
     = <sigma>[i]. Los elementos sigma[i] se llaman valores singulares
     de <A>, los cuales son reales y no negativos, siendo devueltos por
     la función `dgesvd' en orden descendente.

     Las primeras min(m, n) columnas de <U> y <V> son los vectores
     singulares izquierdo y derecho de <A>. Nótese que `dgesvd'
     devuelve la transpuesta de <V>, no la propia matriz <V>.

     `dgesvd(<A>)' calcula únicamente los valores singulares de <A>.
     `dgesvd(<A>, <left_p>, <right_p>)' calcula los valores singulares
     de <A> y los vectores sigulares por la izquierda cuando <left_p> =
     `true', y los vectores sigulares por la derecha cuando <right_p> =
     `true'.

     La función devuelve una lista de tres elementos.  El primer
     elemento es una lista con los valores singulares.  El segundo
     elemento es `false' o la matriz de vectores singulares por la
     izquierda.  El tercer elemento es `false' o la matriz de vectores
     singulares por la derecha.

     Ejemplo:

          (%i1) load (lapack)$
          (%i2) fpprintprec : 6;
          (%o2)                           6
          (%i3) M: matrix([1, 2, 3], [3.5, 0.5, 8], [-1, 2, -3], [4, 9, 7]);
                                  [  1    2    3  ]
                                  [               ]
                                  [ 3.5  0.5   8  ]
          (%o3)                   [               ]
                                  [ - 1   2   - 3 ]
                                  [               ]
                                  [  4    9    7  ]
          (%i4) dgesvd (M);
          (%o4)      [[14.4744, 6.38637, .452547], false, false]
          (%i5) [sigma, U, VT] : dgesvd (M, true, true);
          (%o5) [[14.4744, 6.38637, .452547],
          [ - .256731  .00816168   .959029    - .119523 ]
          [                                             ]
          [ - .526456   .672116   - .206236   - .478091 ]
          [                                             ],
          [  .107997   - .532278  - .0708315  - 0.83666 ]
          [                                             ]
          [ - .803287  - .514659  - .180867    .239046  ]
          [ - .374486  - .538209  - .755044 ]
          [                                 ]
          [  .130623   - .836799   0.5317   ]]
          [                                 ]
          [ - .917986   .100488    .383672  ]
          (%i6) m : length (U);
          (%o6)                           4
          (%i7) n : length (VT);
          (%o7)                           3
          (%i8) Sigma:
                  genmatrix(lambda ([i, j], if i=j then sigma[i] else 0),
                            m, n);
                            [ 14.4744     0        0    ]
                            [                           ]
                            [    0     6.38637     0    ]
          (%o8)             [                           ]
                            [    0        0     .452547 ]
                            [                           ]
                            [    0        0        0    ]
          (%i9) U . Sigma . VT - M;
                    [  1.11022E-15        0.0       1.77636E-15 ]
                    [                                           ]
                    [  1.33227E-15    1.66533E-15       0.0     ]
          (%o9)     [                                           ]
                    [ - 4.44089E-16  - 8.88178E-16  4.44089E-16 ]
                    [                                           ]
                    [  8.88178E-16    1.77636E-15   8.88178E-16 ]
          (%i10) transpose (U) . U;
                 [     1.0      5.55112E-17    2.498E-16     2.77556E-17  ]
                 [                                                        ]
                 [ 5.55112E-17      1.0       5.55112E-17    4.16334E-17  ]
          (%o10) [                                                        ]
                 [  2.498E-16   5.55112E-17       1.0       - 2.08167E-16 ]
                 [                                                        ]
                 [ 2.77556E-17  4.16334E-17  - 2.08167E-16       1.0      ]
          (%i11) VT . transpose (VT);
                    [      1.0           0.0      - 5.55112E-17 ]
                    [                                           ]
          (%o11)    [      0.0           1.0       5.55112E-17  ]
                    [                                           ]
                    [ - 5.55112E-17  5.55112E-17       1.0      ]


 -- Función: dlange (<norm>, <A>)
 -- Función: zlange (<norm>, <A>)
     Calcula una norma o seudonorma de la matriz <A>.

    `max'
          Calcula max(abs(A(i, j))), siendo i y j números de filas y
          columnas, respectivamente, de <A>.  Nótese que esta función
          no es una norma matricial.

    `one_norm'
          Calcula la norma L[1] de <A>, esto es, el máximo de la suma
          de los valores absolutos de los elementos de cada columna.

    `inf_norm'
          Calcula la norma L[inf] de <A>, esto es, el máximo de la suma
          de los valores absolutos de los elementos de cada fila.

    `frobenius'
          Calcula la norma de Frobenius de <A>, esto es, la raíz
          cuadrada de la suma de los cuadrados de los elementos de la
          matriz.

 -- Función: dgemm (<A>, <B>)
 -- Función: dgemm (<A>, <B>, <options>)
     Calcula el producto de dos matrices y, opcionalmente, suma este
     producto con una tercera matriz.

     En su forma más simple, `dgemm(<A>, <B>)' calcula el producto de
     las matrices reales <A> y <B>.

     En la segunda forma, `dgemm' calcula <alpha> * <A> * <B> + <beta>
     * <C>, donde <A>, <B> y <C> son matrices reales de dimensiones
     apropiadas, siendo <alpha> y <beta> números reales. De forma
     opcional, tanto <A> como <B> pueden transponerse antes de calcular
     su producto. Los parámetros adicionales se pueden especificar en
     cualquier orden, siendo su sintaxis de la forma `clave=valor'. Las
     claves reconocidas son:

    <C>
          La matriz <C> que debe ser sumada. El valor por defecto es
          `false', lo que significa que no se sumará ninguna matriz.

    <alpha>
          El producto de <A> por <B> se multiplicará por este vaalor.
          El valor por defecto es 1.

    <beta>
          Si se da la matriz <C>, se multiplicará por este valor antes
          de ser sumada.  El valor por defecto es 0, lo que significa
          que <C> no se suma, incluso estando presente. Por lo tanto,
          téngase cuidado en especificar un valor no nulo para <beta>.

    <transpose_a>
          Si toma el valor `true', se utilizará la transpuesta de <A>,
          en lugar de la propia matriz <A>, en el producto. El valor
          por defecto es `false'.

    <transpose_b>
          Si toma el valor `true', se utilizará la transpuesta de <B>,
          en lugar de la propia matriz <B>, en el producto. El valor
          por defecto es `false'.

          (%i1) load (lapack)$
          (%i2) A : matrix([1,2,3],[4,5,6],[7,8,9]);
                                            [ 1  2  3 ]
                                            [         ]
          (%o2)                             [ 4  5  6 ]
                                            [         ]
                                            [ 7  8  9 ]
          (%i3) B : matrix([-1,-2,-3],[-4,-5,-6],[-7,-8,-9]);
                                         [ - 1  - 2  - 3 ]
                                         [               ]
          (%o3)                          [ - 4  - 5  - 6 ]
                                         [               ]
                                         [ - 7  - 8  - 9 ]
          (%i4) C : matrix([3,2,1],[6,5,4],[9,8,7]);
                                            [ 3  2  1 ]
                                            [         ]
          (%o4)                             [ 6  5  4 ]
                                            [         ]
                                            [ 9  8  7 ]
          (%i5) dgemm(A,B);
                                   [ - 30.0   - 36.0   - 42.0  ]
                                   [                           ]
          (%o5)                    [ - 66.0   - 81.0   - 96.0  ]
                                   [                           ]
                                   [ - 102.0  - 126.0  - 150.0 ]
          (%i6) A . B;
                                      [ - 30   - 36   - 42  ]
                                      [                     ]
          (%o6)                       [ - 66   - 81   - 96  ]
                                      [                     ]
                                      [ - 102  - 126  - 150 ]
          (%i7) dgemm(A,B,transpose_a=true);
                                   [ - 66.0  - 78.0   - 90.0  ]
                                   [                          ]
          (%o7)                    [ - 78.0  - 93.0   - 108.0 ]
                                   [                          ]
                                   [ - 90.0  - 108.0  - 126.0 ]
          (%i8) transpose(A) . B;
                                     [ - 66  - 78   - 90  ]
                                     [                    ]
          (%o8)                      [ - 78  - 93   - 108 ]
                                     [                    ]
                                     [ - 90  - 108  - 126 ]
          (%i9) dgemm(A,B,c=C,beta=1);
                                   [ - 27.0  - 34.0   - 41.0  ]
                                   [                          ]
          (%o9)                    [ - 60.0  - 76.0   - 92.0  ]
                                   [                          ]
                                   [ - 93.0  - 118.0  - 143.0 ]
          (%i10) A . B + C;
                                      [ - 27  - 34   - 41  ]
                                      [                    ]
          (%o10)                      [ - 60  - 76   - 92  ]
                                      [                    ]
                                      [ - 93  - 118  - 143 ]
          (%i11) dgemm(A,B,c=C,beta=1, alpha=-1);
                                      [ 33.0   38.0   43.0  ]
                                      [                     ]
          (%o11)                      [ 72.0   86.0   100.0 ]
                                      [                     ]
                                      [ 111.0  134.0  157.0 ]
          (%i12) -A . B + C;
                                         [ 33   38   43  ]
                                         [               ]
          (%o12)                         [ 72   86   100 ]
                                         [               ]
                                         [ 111  134  157 ]


File: maxima.info,  Node: lbfgs,  Next: lindstedt,  Prev: lapack,  Up: Top

60 lbfgs
********

* Menu:

* Introducción a lbfgs::
* Funciones y variables para lbfgs::


File: maxima.info,  Node: Introducción a lbfgs,  Next: Funciones y variables para lbfgs,  Prev: Top,  Up: Top

60.1 Introducción a lbfgs
=========================

La función `lbfgs' implementa el llamado algoritmo L-BFGS [1] para
resolver problemas de minimización sin restricciones mediante una
técnica cuasi-Newton con memoria limitada (BFGS). El término memoria
limitada procede del hecho de que se almacena una aproximación de rango
bajo de la inversa de la matriz hessiana, en lugar de la matriz
completa. El programa fue originalmente escrito en Fortran [2] por
Jorge Nocedal, incorporando algunas funciones escritas originalmente
por Jorge J. Moré y David J. Thuente, traducidas posteriormente a Lisp
automáticamente con el programa `f2cl'. El paquete `lbfgs' contiene el
código traducido, junto con una función interfaz que para controlar
ciertos detalles.

   Referencias:

   [1] D. Liu and J. Nocedal. "On the limited memory BFGS method for
large scale optimization". Mathematical Programming B 45:503-528 (1989)

   [2] `http://netlib.org/opt/lbfgs_um.shar'


File: maxima.info,  Node: Funciones y variables para lbfgs,  Prev: Introducción a lbfgs,  Up: Top

60.2 Funciones y variables para lbfgs
=====================================

 -- Función: lbfgs (<FOM>, <X>, <X0>, <epsilon>, <iprint>)
 -- Function: lbfgs ([<FOM>, <grad>] <X>, <X0>, <epsilon>, <iprint>)
     Encuentra una solución aproximada para el problema de minimización
     sin restricciones de la función objetivo <FOM> para la lista de
     variables <X>, partiendo de los estimadores iniciales <X0>, de tal
     manera que norm(grad(FOM)) < epsilon*max(1, norm(X)).

     El argumento <grad> es el gradiente de <FOM> respecto de las
     variables <X>. <grad> es una lista con el mismo número de
     elementos que <X>. Si no se pasa este argumento, el gradiente se
     calcula automáticamente mediante derivación simbólica.

     El algoritmo utilizado es una técnica cuasi-Newton con memoria
     limitada (BFGS) [1]. El término memoria limitada procede del hecho
     de que se almacena una aproximación de rango bajo de la inversa de
     la matriz hessiana, en lugar de la matriz completa.  Cada
     iteración del algoritmo es una búsqueda a lo largo de una recta,
     cuya dirección se calcula a partir de la matriz inversa aproximada
     del hessiano. La función objetivo decrece siempre tras cada
     búsqueda exitosa a lo largo de la recta; además, casi siempre
     decrece también el módulo del gradiente de la función.

     El argumento <iprint> controla los mensajes de progreso que envía
     la función `lbfgs'.

    `iprint[1]'
          `<iprint>[1]' controla la frecuencia con la que se emiten los
          mensajes.
         `iprint[1] < 0'
               No se envían mensajes.

         `iprint[1] = 0'
               Mensajes únicamente en la primera y última iteraciones.

         `iprint[1] > 0'
               Imprime un mensaje cada `<iprint>[1]' iteraciones.

    `iprint[2]'
          `<iprint>[2]' controla la cantidad de información contenida
          en los mensajes.
         `iprint[2] = 0'
               Imprime contador de iteraciones, número de evaluaciones
               de <FOM>, valor de <FOM>, módulo del gradiente de <FOM>
               y amplitud del paso.

         `iprint[2] = 1'
               Igual que `<iprint>[2] = 0', incluyendo <X0> y el
               gradiente de <FOM> evaluado en <X0>.

         `iprint[2] = 2'
               Igual que `<iprint>[2] = 1', incluyendo los valores de
               <X> en cada iteración.

         `iprint[2] = 3'
               Igual que `<iprint>[2] = 2', incluyendo el gradiente de
               <FOM> en cada iteración.

     Las columnas devueltas por `lbfgs' son las siguientes:

    `I'
          Número de iteraciones. Se incremente tras cada búsqueda a lo
          largo de una recta.

    `NFN'
          Número de evaluaciones de la función objetivo.

    `FUNC'
          Valor de la función objetivo al final de cada iteración.

    `GNORM'
          Módulo del gradiente de la función objetivo al final de cada
          iteración.

    `STEPLENGTH'
          Un parámetro interno del algoritmo de búsqueda.

     Para más información sobre el algoritmo se puede acudir a los
     comentarios en el código original en Fortran [2].

     Véanse también `lbfgs_nfeval_max' y `lbfgs_ncorrections'.

     Referencias:

     [1] D. Liu and J. Nocedal. "On the limited memory BFGS method for
     large scale optimization". Mathematical Programming B 45:503-528
     (1989)

     [2] `http://netlib.org/opt/lbfgs_um.shar'

     Ejemplos:

     La misma función objetivo utilizada por FGCOMPUTE en el programa
     sdrive.f del paquete LBFGS de Netlib. Nótese que las variables en
     cuestión están subindicadas. La función objetivo tiene un mínimo
     exacto igual a cero en u[k] = 1, para k = 1, ..., 8.
          (%i1) load (lbfgs);
          (%o1)   /usr/share/maxima/5.10.0cvs/share/lbfgs/lbfgs.mac
          (%i2) t1[j] := 1 - u[j];
          (%o2)                     t1  := 1 - u
                                      j         j
          (%i3) t2[j] := 10*(u[j + 1] - u[j]^2);
                                                    2
          (%o3)                t2  := 10 (u      - u )
                                 j         j + 1    j
          (%i4) n : 8;
          (%o4)                           8
          (%i5) FOM : sum (t1[2*j - 1]^2 + t2[2*j - 1]^2, j, 1, n/2);
                           2 2           2              2 2           2
          (%o5) 100 (u  - u )  + (1 - u )  + 100 (u  - u )  + (1 - u )
                      8    7           7           6    5           5
                               2 2           2              2 2           2
                  + 100 (u  - u )  + (1 - u )  + 100 (u  - u )  + (1 - u )
                          4    3           3           2    1           1
          (%i6) lbfgs (FOM, '[u[1],u[2],u[3],u[4],u[5],u[6],u[7],u[8]],
                 [-1.2, 1, -1.2, 1, -1.2, 1, -1.2, 1], 1e-3, [1, 0]);
          *************************************************
            N=    8   NUMBER OF CORRECTIONS=25
                 INITIAL VALUES
           F=  9.680000000000000D+01   GNORM=  4.657353755084532D+02
          *************************************************

           I NFN   FUNC                    GNORM                   STEPLENGTH

           1   3   1.651479526340304D+01   4.324359291335977D+00   7.926153934390631D-04
           2   4   1.650209316638371D+01   3.575788161060007D+00   1.000000000000000D+00
           3   5   1.645461701312851D+01   6.230869903601577D+00   1.000000000000000D+00
           4   6   1.636867301275588D+01   1.177589920974980D+01   1.000000000000000D+00
           5   7   1.612153014409201D+01   2.292797147151288D+01   1.000000000000000D+00
           6   8   1.569118407390628D+01   3.687447158775571D+01   1.000000000000000D+00
           7   9   1.510361958398942D+01   4.501931728123680D+01   1.000000000000000D+00
           8  10   1.391077875774294D+01   4.526061463810632D+01   1.000000000000000D+00
           9  11   1.165625686278198D+01   2.748348965356917D+01   1.000000000000000D+00
          10  12   9.859422687859137D+00   2.111494974231644D+01   1.000000000000000D+00
          11  13   7.815442521732281D+00   6.110762325766556D+00   1.000000000000000D+00
          12  15   7.346380905773160D+00   2.165281166714631D+01   1.285316401779533D-01
          13  16   6.330460634066370D+00   1.401220851762050D+01   1.000000000000000D+00
          14  17   5.238763939851439D+00   1.702473787613255D+01   1.000000000000000D+00
          15  18   3.754016790406701D+00   7.981845727704576D+00   1.000000000000000D+00
          16  20   3.001238402309352D+00   3.925482944716691D+00   2.333129631296807D-01
          17  22   2.794390709718290D+00   8.243329982546473D+00   2.503577283782332D-01
          18  23   2.563783562918759D+00   1.035413426521790D+01   1.000000000000000D+00
          19  24   2.019429976377856D+00   1.065187312346769D+01   1.000000000000000D+00
          20  25   1.428003167670903D+00   2.475962450826961D+00   1.000000000000000D+00
          21  27   1.197874264861340D+00   8.441707983493810D+00   4.303451060808756D-01
          22  28   9.023848941942773D-01   1.113189216635162D+01   1.000000000000000D+00
          23  29   5.508226405863770D-01   2.380830600326308D+00   1.000000000000000D+00
          24  31   3.902893258815567D-01   5.625595816584421D+00   4.834988416524465D-01
          25  32   3.207542206990315D-01   1.149444645416472D+01   1.000000000000000D+00
          26  33   1.874468266362791D-01   3.632482152880997D+00   1.000000000000000D+00
          27  34   9.575763380706598D-02   4.816497446154354D+00   1.000000000000000D+00
          28  35   4.085145107543406D-02   2.087009350166495D+00   1.000000000000000D+00
          29  36   1.931106001379290D-02   3.886818608498966D+00   1.000000000000000D+00
          30  37   6.894000721499670D-03   3.198505796342214D+00   1.000000000000000D+00
          31  38   1.443296033051864D-03   1.590265471025043D+00   1.000000000000000D+00
          32  39   1.571766603154336D-04   3.098257063980634D-01   1.000000000000000D+00
          33  40   1.288011776581970D-05   1.207784183577257D-02   1.000000000000000D+00
          34  41   1.806140173752971D-06   4.587890233385193D-02   1.000000000000000D+00
          35  42   1.769004645459358D-07   1.790537375052208D-02   1.000000000000000D+00
          36  43   3.312164100763217D-10   6.782068426119681D-04   1.000000000000000D+00


           THE MINIMIZATION TERMINATED WITHOUT DETECTING ERRORS.
           IFLAG = 0
          (%o6) [u  = 1.000005339815974, u  = 1.000009942839805,
                  1                       2
          u  = 1.000005339815974, u  = 1.000009942839805,
           3                       4
          u  = 1.000005339815974, u  = 1.000009942839805,
           5                       6
          u  = 1.000005339815974, u  = 1.000009942839805]
           7                       8

     Un problema de regresión. La función objetivo es el cuadrado medio
     de la diferencia entre la predicción F(X[i]) y el valor observado
     Y[i]. La función F es monótona y acotada (llamada en ocasiones
     "sigmoidal"). En este ejemplo, `lbfgs' calcula valores aproximados
     para los parámetros de F y `plot2d' hace una representación gráfica
     comparativa de F junto con los datos observados.

          (%i1) load (lbfgs);
          (%o1)   /usr/share/maxima/5.10.0cvs/share/lbfgs/lbfgs.mac
          (%i2) FOM : '((1/length(X))*sum((F(X[i]) - Y[i])^2, i, 1,
                                                          length(X)));
                                         2
                         sum((F(X ) - Y ) , i, 1, length(X))
                                 i     i
          (%o2)          -----------------------------------
                                      length(X)
          (%i3) X : [1, 2, 3, 4, 5];
          (%o3)                    [1, 2, 3, 4, 5]
          (%i4) Y : [0, 0.5, 1, 1.25, 1.5];
          (%o4)                [0, 0.5, 1, 1.25, 1.5]
          (%i5) F(x) := A/(1 + exp(-B*(x - C)));
                                             A
          (%o5)            F(x) := ----------------------
                                   1 + exp((- B) (x - C))
          (%i6) ''FOM;
                          A               2            A                2
          (%o6) ((----------------- - 1.5)  + (----------------- - 1.25)
                    - B (5 - C)                  - B (4 - C)
                  %e            + 1            %e            + 1
                      A             2            A               2
           + (----------------- - 1)  + (----------------- - 0.5)
                - B (3 - C)                - B (2 - C)
              %e            + 1          %e            + 1
                       2
                      A
           + --------------------)/5
                - B (1 - C)     2
             (%e            + 1)
          (%i7) estimates : lbfgs (FOM, '[A, B, C], [1, 1, 1], 1e-4, [1, 0]);
          *************************************************
            N=    3   NUMBER OF CORRECTIONS=25
                 INITIAL VALUES
           F=  1.348738534246918D-01   GNORM=  2.000215531936760D-01
          *************************************************

          I  NFN  FUNC                    GNORM                   STEPLENGTH
          1    3  1.177820636622582D-01   9.893138394953992D-02   8.554435968992371D-01
          2    6  2.302653892214013D-02   1.180098521565904D-01   2.100000000000000D+01
          3    8  1.496348495303005D-02   9.611201567691633D-02   5.257340567840707D-01
          4    9  7.900460841091139D-03   1.325041647391314D-02   1.000000000000000D+00
          5   10  7.314495451266917D-03   1.510670810312237D-02   1.000000000000000D+00
          6   11  6.750147275936680D-03   1.914964958023047D-02   1.000000000000000D+00
          7   12  5.850716021108205D-03   1.028089194579363D-02   1.000000000000000D+00
          8   13  5.778664230657791D-03   3.676866074530332D-04   1.000000000000000D+00
          9   14  5.777818823650782D-03   3.010740179797255D-04   1.000000000000000D+00


           THE MINIMIZATION TERMINATED WITHOUT DETECTING ERRORS.
           IFLAG = 0
          (%o7) [A = 1.461933911464101, B = 1.601593973254802,
                                                     C = 2.528933072164854]
          (%i8) plot2d ([F(x), [discrete, X, Y]], [x, -1, 6]), ''estimates;
          (%o8)

     Especificando el gradiente de la función objetivo en lugar de
     calcularlo simbólicamente.

          (%i1) load (lbfgs)$
          (%i2) F(a, b, c) := (a - 5)^2 + (b - 3)^4 + (c - 2)^6;
                                         2          4          6
          (%o2)     F(a, b, c) := (a - 5)  + (b - 3)  + (c - 2)
          (%i3) F_grad : map (lambda ([x], diff (F(a, b, c), x)), [a, b, c]);
                                              3           5
          (%o3)          [2 (a - 5), 4 (b - 3) , 6 (c - 2) ]
          (%i4) estimates : lbfgs ([F(a, b, c), F_grad],
                                   [a, b, c], [0, 0, 0], 1e-4, [1, 0]);
          *************************************************
            N=    3   NUMBER OF CORRECTIONS=25
                 INITIAL VALUES
           F=  1.700000000000000D+02   GNORM=  2.205175729958953D+02
          *************************************************

             I  NFN     FUNC                    GNORM                   STEPLENGTH

             1    2     6.632967565917638D+01   6.498411132518770D+01   4.534785987412505D-03
             2    3     4.368890936228036D+01   3.784147651974131D+01   1.000000000000000D+00
             3    4     2.685298972775190D+01   1.640262125898521D+01   1.000000000000000D+00
             4    5     1.909064767659852D+01   9.733664001790506D+00   1.000000000000000D+00
             5    6     1.006493272061515D+01   6.344808151880209D+00   1.000000000000000D+00
             6    7     1.215263596054294D+00   2.204727876126879D+00   1.000000000000000D+00
             7    8     1.080252896385334D-02   1.431637116951849D-01   1.000000000000000D+00
             8    9     8.407195124830908D-03   1.126344579730013D-01   1.000000000000000D+00
             9   10     5.022091686198527D-03   7.750731829225274D-02   1.000000000000000D+00
            10   11     2.277152808939775D-03   5.032810859286795D-02   1.000000000000000D+00
            11   12     6.489384688303218D-04   1.932007150271008D-02   1.000000000000000D+00
            12   13     2.075791943844548D-04   6.964319310814364D-03   1.000000000000000D+00
            13   14     7.349472666162257D-05   4.017449067849554D-03   1.000000000000000D+00
            14   15     2.293617477985237D-05   1.334590390856715D-03   1.000000000000000D+00
            15   16     7.683645404048675D-06   6.011057038099201D-04   1.000000000000000D+00


           THE MINIMIZATION TERMINATED WITHOUT DETECTING ERRORS.
           IFLAG = 0
          (%o4) [a = 5.000086823042934, b = 3.05239542970518,
                                                     c = 1.927980629919583]


 -- Variable: lbfgs_nfeval_max
     Valor por defecto: 100

     La variable `lbfgs_nfeval_max' almacena el número máximo de
     evaluaciones de la función objetivo en `lbfgs'. Cuando se alcanza
     el valor `lbfgs_nfeval_max', `lbfgs' devuelve el resultado logrado
     en la última iteración exitosa.


 -- Variable: lbfgs_ncorrections
     Valor por defecto: 25

     La variable `lbfgs_ncorrections' almacena el número de correcciones
     aplicadas a la matriz inversa aproximada del hessiano, la cual es
     gestionada por `lbfgs'.



File: maxima.info,  Node: lindstedt,  Next: linearalgebra,  Prev: lbfgs,  Up: Top

61 lindstedt
************

* Menu:

* Funciones y variables para lindstedt::


File: maxima.info,  Node: Funciones y variables para lindstedt,  Prev: lindstedt,  Up: lindstedt

61.1 Funciones y variables para lindstedt
=========================================

 -- Función: Lindstedt (<eq>,<pvar>,<torder>,<ic>)
     Este es el primer paso hacia un programa para resolver ecuaciones
     de Lindstedt.  Puede resolver problemas con condiciones iniciales,
     las cuales pueden ser constantes arbitrarias (no pueden usarse
     <%k1> ni <%k2>) donde las condiciones iniciales sobre las
     ecuaciones de perturbación son z[i]=0, z'[i]=0 para i>0.  El
     argumento <ic> es la lista de condiciones iniciales.

     Ejemplo:
          (%i1) load("makeOrders")$

          (%i2) load("lindstedt")$

          (%i3) Lindstedt('diff(x,t,2)+x-(e*x^3)/6,e,2,[1,0]);
                    2
                   e  (cos(5 T) - 24 cos(3 T) + 23 cos(T))
          (%o3) [[[---------------------------------------
                                    36864
             e (cos(3 T) - cos(T))
           - --------------------- + cos(T)],
                      192
                    2
                 7 e    e
          T = (- ---- - -- + 1) t]]
                 3072   16

     Antes de hacer uso de esta función ejecútense
     `load("makeOrders")' y `load("lindstedt")'.


File: maxima.info,  Node: linearalgebra,  Next: lsquares,  Prev: lindstedt,  Up: Top

62 linearalgebra
****************

* Menu:

* Introducción a linearalgebra::
* Funciones y variables para linearalgebra::


File: maxima.info,  Node: Introducción a linearalgebra,  Next: Funciones y variables para linearalgebra,  Prev: linearalgebra,  Up: linearalgebra

62.1 Introducción a linearalgebra
=================================

El paquete `linearalgebra' contiene una batería de funciones para
álgebra lineal.

   Ejemplo:

     (%i1) M : matrix ([1, 2], [1, 2]);
                                 [ 1  2 ]
     (%o1)                       [      ]
                                 [ 1  2 ]
     (%i2) nullspace (M);
                                    [  1  ]
                                    [     ]
     (%o2)                     span([   1 ])
                                    [ - - ]
                                    [   2 ]
     (%i3) columnspace (M);
                                     [ 1 ]
     (%o3)                      span([   ])
                                     [ 1 ]
     (%i4) ptriangularize (M - z*ident(2), z);
                              [ 1   2 - z   ]
     (%o4)                    [             ]
                              [           2 ]
                              [ 0  3 z - z  ]
     (%i5) M : matrix ([1, 2, 3], [4, 5, 6], [7, 8, 9]) - z*ident(3);
                          [ 1 - z    2      3   ]
                          [                     ]
     (%o5)                [   4    5 - z    6   ]
                          [                     ]
                          [   7      8    9 - z ]
     (%i6) MM : ptriangularize (M, z);
                   [ 4  5 - z            6            ]
                   [                                  ]
                   [                2                 ]
                   [     66        z    102 z   132   ]
                   [ 0   --      - -- + ----- + ---   ]
     (%o6)         [     49        7     49     49    ]
                   [                                  ]
                   [               3        2         ]
                   [           49 z    245 z    147 z ]
                   [ 0    0    ----- - ------ - ----- ]
                   [            264      88      44   ]
     (%i7) algebraic : true;
     (%o7)                         true
     (%i8) tellrat (MM [3, 3]);
                              3       2
     (%o8)                  [z  - 15 z  - 18 z]
     (%i9) MM : ratsimp (MM);
                    [ 4  5 - z           6           ]
                    [                                ]
                    [                2               ]
     (%o9)          [     66      7 z  - 102 z - 132 ]
                    [ 0   --    - ------------------ ]
                    [     49              49         ]
                    [                                ]
                    [ 0    0             0           ]
     (%i10) nullspace (MM);
                             [        1         ]
                             [                  ]
                             [   2              ]
                             [  z  - 14 z - 16  ]
                             [  --------------  ]
     (%o10)             span([        8         ])
                             [                  ]
                             [    2             ]
                             [   z  - 18 z - 12 ]
                             [ - -------------- ]
                             [         12       ]
     (%i11) M : matrix ([1, 2, 3, 4], [5, 6, 7, 8],
                        [9, 10, 11, 12], [13, 14, 15, 16]);
                            [ 1   2   3   4  ]
                            [                ]
                            [ 5   6   7   8  ]
     (%o11)                 [                ]
                            [ 9   10  11  12 ]
                            [                ]
                            [ 13  14  15  16 ]
     (%i12) columnspace (M);
                                [ 1  ]  [ 2  ]
                                [    ]  [    ]
                                [ 5  ]  [ 6  ]
     (%o12)                span([    ], [    ])
                                [ 9  ]  [ 10 ]
                                [    ]  [    ]
                                [ 13 ]  [ 14 ]
     (%i13) apply ('orthogonal_complement, args (nullspace (transpose (M))));
                                [ 0 ]  [  1  ]
                                [   ]  [     ]
                                [ 1 ]  [  0  ]
     (%o13)                span([   ], [     ])
                                [ 2 ]  [ - 1 ]
                                [   ]  [     ]
                                [ 3 ]  [ - 2 ]


File: maxima.info,  Node: Funciones y variables para linearalgebra,  Prev: Introducción a linearalgebra,  Up: linearalgebra

62.2 Funciones y variables para linearalgebra
=============================================

 -- Función: addmatrices (<f>, <M_1>, ..., <M_n>)
     Utiliza la función <f> como una función aditiva, devolviendo la
     suma de las matrices <M_1>, ..., <M_n>. La función <f> debe ser
     tal que acepte un número arbitrario de argumentos; en otras
     palabras, será una función n-aria de Maxima.

     Ejemplos:

          (%i1) m1 : matrix([1,2],[3,4])$
          (%i2) m2 : matrix([7,8],[9,10])$
          (%i3) addmatrices('max,m1,m2);
          (%o3) matrix([7,8],[9,10])
          (%i4) addmatrices('max,m1,m2,5*m1);
          (%o4) matrix([7,10],[15,20])


 -- Función: blockmatrixp (<M>)
     Devuelve el valor `true' si y solo si <M> es una matriz cuyos
     elementos son a su vez matrices.


 -- Función: columnop (<M>, <i>, <j>, <theta>)
     Si <M> es una matriz, devuelve la matriz que resulta de hacer la
     operación columna `C_i <- C_i - <theta> * C_j'. Si <M> carece de
     cualquiera de las filas <i> o <j>, devuelve un mensaje de error.


 -- Función: columnswap (<M>, <i>, <j>)
     Si <M> es una matriz, intercambia las columnas <i> y <j>.  Si <M>
     carece de cualquiera de las filas <i> o <j>, devuelve un mensaje
     de error.


 -- Función: columnspace (<M>)
     Si <M> es una matriz, devuelve `span (v_1, ..., v_n)', donde el
     conjunto `{v_1, ..., v_n}' es la base del espacio generado por las
     columnas de <M>.


 -- Función: copy (<e>)
     Devuelve una copia de la expresión <e> de Maxima. Aunque <e> puede
     ser cualquier expresión de Maxima, la función `copy' es
     especialmente útil cuando <e> es una lista o una matriz.
     Considérese el siguiente ejemplo:

          (%i1) m : [1,[2,3]]$
          (%i2) mm : m$
          (%i3) mm[2][1] : x$
          (%i4) m;
          (%o4)                      [1,[x,3]]
          (%i5) mm;
          (%o5)                      [1,[x,3]]
     Veamos el mismo ejemplo siendo ahora <mm> una copia de <m>
          (%i6) m : [1,[2,3]]$
          (%i7) mm : copy(m)$
          (%i8) mm[2][1] : x$
          (%i9) m;
          (%o9)                     [1,[2,3]]
          (%i10) mm;
          (%o10)                    [1,[x,3]]
     En esta ocasión, la asignación a <mm> no cambia el valor de <m>.


 -- Función: cholesky (<M>)
 -- Función: cholesky (<M>, <field>)
     Devuelve la factorización de Cholesky de la matriz autoadjunta (o
     hermítica) <M>. El valor por defecto del segundo argumento es
     `generalring'. Para una descripción de los posibles valores para
     <field>, véase `lu_factor'.


 -- Función: ctranspose (<M>)
     Devuelve la transpuesta compleja conjugada de la matriz <M>. La
     función `ctranspose' utiliza `matrix_element_transpose' para
     transponer cada elemento de la matriz.


 -- Función: diag_matrix (<d_1>, <d_2>, ..., <d_n>)
     Devuelve una matriz diagonal con los elementos de la diagonal
     iguales a <d_1>, <d_2>, ..., <d_n>; cuando éstos son matrices, los
     elementos nulos de la matriz devuelta son matrices nulas de tamaño
     apropiado. Por ejemplo:

          (%i1) diag_matrix(diag_matrix(1,2),diag_matrix(3,4));

                                      [ [ 1  0 ]  [ 0  0 ] ]
                                      [ [      ]  [      ] ]
                                      [ [ 0  2 ]  [ 0  0 ] ]
          (%o1)                       [                    ]
                                      [ [ 0  0 ]  [ 3  0 ] ]
                                      [ [      ]  [      ] ]
                                      [ [ 0  0 ]  [ 0  4 ] ]
          (%i2) diag_matrix(p,q);

                                             [ p  0 ]
          (%o2)                              [      ]
                                             [ 0  q ]

 -- Función: dotproduct (<u>, <v>)
     Devuelve el producto escalar de los vectores <u> y <v>. Equivale a
     `conjugate (transpose (<u>)) . <v>'. Los argumentos <u> y <v>
     deben ser vectores columna.


 -- Función: eigens_by_jacobi (<A>)
 -- Función: eigens_by_jacobi (<A>, <field_type>)
     Calcula los valores y vectores propios de <A> por el método de las
     rotaciones de Jacobi. <A> debe ser una matriz simétrica (aunque no
     necesariamente definida o semidefinida positiva).  El argumento
     <field_type> indica el tipo numérico sobre el que se realizan los
     cálculos, que puede ser tanto `floatfield' como `bigfloatfield'.
     En caso de que no se especifique <field_type>, su valor por
     defecto será `floatfield'.

     Los elementos de <A> deben ser números o expresiones reducibles a
     números mediante la ejecución de `float' o `bfloat', según sea el
     valor de <field_type>.

     Ejemplos:

          (%i1) S : matrix ([1/sqrt(2), 1/sqrt(2)], [- 1/sqrt(2), 1/sqrt(2)]);
                               [     1         1    ]
                               [  -------   ------- ]
                               [  sqrt(2)   sqrt(2) ]
          (%o1)                [                    ]
                               [      1        1    ]
                               [ - -------  ------- ]
                               [   sqrt(2)  sqrt(2) ]
          (%i2) L : matrix ([sqrt(3), 0], [0, sqrt(5)]);
                                [ sqrt(3)     0    ]
          (%o2)                 [                  ]
                                [    0     sqrt(5) ]
          (%i3) M : S . L . transpose (S);
                      [ sqrt(5)   sqrt(3)  sqrt(5)   sqrt(3) ]
                      [ ------- + -------  ------- - ------- ]
                      [    2         2        2         2    ]
          (%o3)       [                                      ]
                      [ sqrt(5)   sqrt(3)  sqrt(5)   sqrt(3) ]
                      [ ------- - -------  ------- + ------- ]
                      [    2         2        2         2    ]
          (%i4) eigens_by_jacobi (M);
          The largest percent change was 0.1454972243679
          The largest percent change was 0.0
          number of sweeps: 2
          number of rotations: 1
          (%o4) [[1.732050807568877, 2.23606797749979],
                                  [  0.70710678118655   0.70710678118655 ]
                                  [                                      ]]
                                  [ - 0.70710678118655  0.70710678118655 ]
          (%i5) float ([[sqrt(3), sqrt(5)], S]);
          (%o5) [[1.732050807568877, 2.23606797749979],
                                  [  0.70710678118655   0.70710678118655 ]
                                  [                                      ]]
                                  [ - 0.70710678118655  0.70710678118655 ]
          (%i6) eigens_by_jacobi (M, bigfloatfield);
          The largest percent change was 1.454972243679028b-1
          The largest percent change was 0.0b0
          number of sweeps: 2
          number of rotations: 1
          (%o6) [[1.732050807568877b0, 2.23606797749979b0],
                          [  7.071067811865475b-1   7.071067811865475b-1 ]
                          [                                              ]]
                          [ - 7.071067811865475b-1  7.071067811865475b-1 ]


 -- Función: get_lu_factors (<x>)
     Cuando `<x> = lu_factor (<A>)', entonces `get_lu_factors' devuelve
     una lista de la forma `[P, L, U]', donde <P> es una matriz
     permutación, <L> es triangular inferior con unos en la diagonal y
     <U> es triangular superior, verificándose que `<A> = <P> <L> <U>'.


 -- Función: hankel (<col>)
 -- Función: hankel (<col>, <row>)
     Devuelve la matriz de Hankel <H>. La primera columna de <H>
     coincide con <col>, excepto en el primer elemento, la última fila
     de <H> es <row>. El valor por defecto para <row> es el vector nulo
     con igual número de elementos que <col>.


 -- Función: hessian (<f>, <x>)
     Devuelve la matriz hessiana de <f> con respecto de la lista de
     variables <x>. El elemento `(i, j)'-ésimo de la matriz hessiana es
     `diff(<f>, <x>[i], 1, <x>[j], 1)'.

     Ejemplos:

          (%i1) hessian (x * sin (y), [x, y]);
                               [   0       cos(y)   ]
          (%o1)                [                    ]
                               [ cos(y)  - x sin(y) ]
          (%i2) depends (F, [a, b]);
          (%o2)                       [F(a, b)]
          (%i3) hessian (F, [a, b]);
                                  [   2      2   ]
                                  [  d F    d F  ]
                                  [  ---   ----- ]
                                  [    2   da db ]
                                  [  da          ]
          (%o3)                   [              ]
                                  [   2      2   ]
                                  [  d F    d F  ]
                                  [ -----   ---  ]
                                  [ da db     2  ]
                                  [         db   ]

 -- Función: hilbert_matrix (<n>)
     Devuelve la matriz de Hilbert <n> por <n>. Si <n> no es un entero
     positivo, emite un mensaje de error.


 -- Función: identfor (<M>)
 -- Función: identfor (<M>, <fld>)
     Devuelve una matriz identidad con la misma forma que la matriz
     <M>. Los elementos de la diagonal de la matriz identidad son la
     identidad multiplicativa del campo <fld>; el valor por defecto
     para <fld> es <generalring>.

     El primer argumento <M> debe ser una matriz cuadrada o no ser
     matriz en absoluto. Si <M> es una matriz, sus elementos pueden ser
     matrices cuadradas. La matriz puede tener bloques a cualquier nivel
     finito de profundidad.

     Véase también `zerofor'


 -- Función: invert_by_lu (<M>, <(rng generalring)>)
     Invierte la matriz <M> mediante la factorización LU, la cual se
     hace utilizando el anillo <rng>.


 -- Función: jacobian (<f>, <x>)
     Devuelve la matriz jacobiana de la lista de funciones <f> respecto
     de la lista de variables <x>. El elemento `(i, j)'-ésimo de la
     matriz jacobiana es `diff(<f>[i], <x>[j])'.

     Ejemplos:

          (%i1) jacobian ([sin (u - v), sin (u * v)], [u, v]);
                            [ cos(v - u)  - cos(v - u) ]
          (%o1)             [                          ]
                            [ v cos(u v)   u cos(u v)  ]
          (%i2) depends ([F, G], [y, z]);
          (%o2)                  [F(y, z), G(y, z)]
          (%i3) jacobian ([F, G], [y, z]);
                                     [ dF  dF ]
                                     [ --  -- ]
                                     [ dy  dz ]
          (%o3)                      [        ]
                                     [ dG  dG ]
                                     [ --  -- ]
                                     [ dy  dz ]

 -- Función: kronecker_product (<A>, <B>)
     Devuelve el producto de Kroneckerde las matrices <A> y <B>.


 -- Función: listp (<e>, <p>)
 -- Función: listp (<e>)
     Dado el argumento opcional <p>, devuelve `true' si <e> es una
     lista de Maxima y <p> toma el valor `true' al aplicarlo a cada
     elemento de la lista. Si a `listp' no se le suministra el
     argumento opcional, devuelve `true' si <e> es una lista de Maxima.
     En cualquier otro caso, el resultado es `false'.


 -- Función: locate_matrix_entry (<M>, <r_1>, <c_1>, <r_2>, <c_2>, <f>,
          <rel>)
     El primer argumento debe ser una matriz, mientras que los
     argumentos desde <r_1> hasta <c_2> determinan la submatriz de <M>
     tomando las filas desde <r_1> hasta <r_2> y las columnas desde
     <c_1> hasta <c_2>.

     La función `locate_matrix_entry' busca en la submatriz de <M> un
     elemento que satisfaga cierta propiedad. hay tres posibilidades:

     (1) `<rel> = 'bool' y <f> es un predicado:

     Rastrea la submatriz de izquierda a derecha y de arriba hacia
     abajo, devolviendo el índice del primer elemento que satisface el
     predicado <f>; si ningún elemento lo satisface, el resultado es
     `false'.

     (2) `<rel> = 'max' y <f> una función real:

     Rastrea la submatriz buscando el elemento que maximice <f>,
     devolviendo el índice correspondiente.

     (3) `<rel> = 'min' y <f> una función real:

     Rastrea la submatriz buscando el elemento que minimice <f>,
     devolviendo el índice correspondiente.


 -- Función: lu_backsub (<M>, <b>)
     Si `<M> = lu_factor (<A>, <field>)', entonces `lu_backsub (<M>,
     <b>)' resuelve el sistema de ecuaciones lineales `<A> <x> = <b>'.


 -- Función: lu_factor (<M>, <field>)
     Devuelve una lista de la forma `[<LU>, <perm>, <fld>]', o `[<LU>,
     <perm>, <fld>, <lower-cnd> <upper-cnd>]', donde

        * La matriz <LU> contiene la factorización de <M> de forma
          empaquetada, lo que significa tres cosas. En primer lugar,
          que las filas de <LU> están permutadas de acuerdo con la
          lista <perm>; por ejemplo, si <perm> es la lista `[3,2,1]',
          la primera fila de la factorización <LU> es la tercera fila
          de la matriz <LU>.  En segundo lugar, el factor triangular
          inferior de <M> es la parte triangular inferior de <LU> con
          los elementos de la diagonal sustituidos por unos. Por
          último, el factor triangular superior de <M> es la parte
          triangular superior de <LU>.

        * Si el campo es `floatfield' o `complexfield', los números
          <lower-cnd> y <upper-cnd> son las cotas inferior y superior
          del número de condición de la norma infinita de <M>. El
          número de condición no se puede estimar para todos los campos,
          en cuyo caso `lu_factor' devuelve una lista de dos elementos.
          Tanto la cota inferior como la superior pueden diferir de sus
          valores verdaderos. Véase también `mat_cond'.


     El argumento <M> debe ser una matriz cuadrada.

     El argumento opcional <fld> debe ser un símbolo que determine un
     anillo o un campo. Los anillos y campos predefinidos son:

       a. `generalring' - el anillo de las expresiones de Maxima

       b. `floatfield' - el campo de los números decimales en coma
          flotante de doble precisión

       c. `complexfield' - el campo de los números complejos decimales
          en coma flotante de doble precisión

       d. `crering'  - el anillo de las expresiones canónicas
          racionales (Canonical Rational Expression o CRE) de Maxima

       e. `rationalfield' - el campo de los números racionales

       f. `runningerror' - controla los errores de redondeo de las
          operaciones en coma flotante

       g. `noncommutingring' - el anillo de las expresiones de Maxima
          en las que el producto es el operador no conmutativo "."


     Si el campo es `floatfield', `complexfield' o `runningerror', el
     algoritmo utiliza pivoteo parcial; para los demás campos, las
     filas se cambian cuando se necesita evitar pivotes nulos.

     La suma aritmética en coma flotante no es asociativa, por lo que el
     significado de 'campo' no coincide exactamente con su definición
     matemática.

     Un elemento del campo `runningerror' consiste en una lista de
     Maxima de la forma `[x,n]', donde <x> es un número decimal en coma
     flotante y `n' un enetro. La diferencia relativa entre el valor
     real de `x' y `x' está aproximadamente acotado por el valor
     epsilon de la máquina multiplicado por `n'.

     No es posible la definición de un nuevo campo por parte del
     usuario, a menos que éste tenga conocimientos de Common Lisp. Para
     hacerlo, el usuario debe definir funciones para las operaciones
     aritméticas y para convertir de la representación del campo a
     Maxima y al revés. Además, en los campos ordenados, donde se hace
     uso del pivoteo parcial, el usuario debe definir funciones para el
     módulo y para comparar números del campo. Después de lo anterior,
     tan solo queda definir una estructura Common Lisp `mring'. El
     fichero `mring' tiene muchos ejemplos.

     Para calcular la factorización, la primera tarea consiste en
     convertir cada elemento de la matriz a un elemento del campo
     especificado. Si la conversión no es posible, la factorización se
     detiene con un mensaje de error. Los elementos del campo no
     necesitan ser expresiones de Maxima; por ejemplo, los elementos de
     `complexfield' son números complejos de Common Lisp. Tras la
     factorización, los elementos de la matriz deben convertirse
     nuevamente a expresiones de Maxima.

     Véase también  `get_lu_factors'.

     Ejemplos:

          (%i1) w[i,j] := random (1.0) + %i * random (1.0);
          (%o1)          w     := random(1.) + %i random(1.)
                          i, j
          (%i2) showtime : true$
          Evaluation took 0.00 seconds (0.00 elapsed)
          (%i3) M : genmatrix (w, 100, 100)$
          Evaluation took 7.40 seconds (8.23 elapsed)
          (%i4) lu_factor (M, complexfield)$
          Evaluation took 28.71 seconds (35.00 elapsed)
          (%i5) lu_factor (M, generalring)$
          Evaluation took 109.24 seconds (152.10 elapsed)
          (%i6) showtime : false$

          (%i7) M : matrix ([1 - z, 3], [3, 8 - z]);
                                  [ 1 - z    3   ]
          (%o7)                   [              ]
                                  [   3    8 - z ]
          (%i8) lu_factor (M, generalring);
                    [ 1 - z         3        ]
                    [                        ]
          (%o8)    [[   3            9       ], [1, 2], generalring]
                    [ -----  - z - ----- + 8 ]
                    [ 1 - z        1 - z     ]
          (%i9) get_lu_factors (%);
                            [   1    0 ]  [ 1 - z         3        ]
                  [ 1  0 ]  [          ]  [                        ]
          (%o9)  [[      ], [   3      ], [                9       ]]
                  [ 0  1 ]  [ -----  1 ]  [   0    - z - ----- + 8 ]
                            [ 1 - z    ]  [              1 - z     ]
          (%i10) %[1] . %[2] . %[3];
                                  [ 1 - z    3   ]
          (%o10)                  [              ]
                                  [   3    8 - z ]


 -- Función: mat_cond (<M>, 1)
 -- Función: mat_cond (<M>, inf)
     Devuelve el número de condición de la <p>-norma de la matriz <M>.
     Los valores admisibles para  <p> son 1 y <inf>. Esta función
     utiliza la factorización LU para invertir la matriz <M>, por lo
     que el tiempo de ejecución de `mat_cond' es proporcional al cubo
     del tamaño de la matriz; `lu_factor' determina las cotas inferior
     y superior para el número de condición de la norma infinita en un
     tiempo proporcional al cuadrado del tamaño de la matriz.


 -- Función: mat_norm (<M>, 1)
 -- Función: mat_norm (<M>, inf)
 -- Función: mat_norm (<M>, frobenius)
     Devuelve la <p>-norma de la matriz <M>. Los valores admisibles
     para <p> son 1, `inf' y `frobenius' (la norma matricial de
     Frobenius).  La matriz <M> no debe contener bloques.

 -- Función: matrixp (<e>, <p>)
 -- Función: matrixp (<e>)
     Dado el argumento opcional <p>, devuelve `true' si <e> es una
     matriz y <p> toma el valor `true' al aplicarlo a cada elemento de
     la matriz. Si a `matrixp' no se le suministra el argumento
     opcional, devuelve `true' si <e> es una matriz.  En cualquier otro
     caso, el resultado es `false'.

     Véase también `blockmatrixp'


 -- Función: matrix_size (<M>)
     Devuelve una lista con el número de filas y columnas de la matriz
     <M>.


 -- Función: mat_fullunblocker (<M>)
     Si <M> es una matriz de bloques, transforma la matriz llevando
     todos los elementos de los bloques al primer nivel. Si <M> es una
     matriz, devuelve <M>; en cualquier otro caso, envía un mensaje de
     error.


 -- Función: mat_trace (<M>)
     Calcula la traza de la matriz <M>. Si <M> no es una matriz,
     devuelve una forma nominal. Si <M> es una matriz de bloques,
     `mat_trace(M)' calcula el mismo valor que
     `mat_trace(mat_unblocker(m))'.


 -- Función: mat_unblocker (<M>)
     Si <M> es una matriz de bloques, deshace los bloques de un nivel.
     Si <M> es una matriz, `mat_unblocker (M)' devuelve <M>; en
     cualquier otro caso, envía un mensaje de error.

     Si todos los elementos de <M> son matrices, `mat_unblocker (M)'
     devuelve una matriz sin bloques, pero si los elementos de <M> son
     a su vez matrices de bloques, `mat_unblocker (M)' devuelve una
     matriz con el nivel de bloques disminuido en uno.

     En caso de trabajar con matrices de bloques, quizás sea
     conveniente darle a `matrix_element_mult' el valor `"."' y a
     `matrix_element_transpose' el valor `'transpose'. Véase también
     `mat_fullunblocker'.

     Ejemplo:

          (%i1) A : matrix ([1, 2], [3, 4]);
                                      [ 1  2 ]
          (%o1)                       [      ]
                                      [ 3  4 ]
          (%i2) B : matrix ([7, 8], [9, 10]);
                                      [ 7  8  ]
          (%o2)                       [       ]
                                      [ 9  10 ]
          (%i3) matrix ([A, B]);
                               [ [ 1  2 ]  [ 7  8  ] ]
          (%o3)                [ [      ]  [       ] ]
                               [ [ 3  4 ]  [ 9  10 ] ]
          (%i4) mat_unblocker (%);
                                   [ 1  2  7  8  ]
          (%o4)                    [             ]
                                   [ 3  4  9  10 ]


 -- Función: nullspace (<M>)
     Si <M> es una matriz, devuelve `span (v_1, ..., v_n)', siendo
     `{v_1, ..., v_n}' la base del espacio nulo de <M>. Si el espacio
     nulo contiene un único elemento, devuelve `span ()'.


 -- Función: nullity (<M>)
     Si <M> es una matriz, devuelve la dimensión del espacio nulo de
     <M>.


 -- Función: orthogonal_complement (<v_1>, ..., <v_n>)
     Devuelve `span (u_1, ..., u_m)', siendo `{u_1, ..., u_m}' la base
     del complemento ortogonal del conjunto `(v_1, ..., v_n)', cuyos
     elementos deben ser vectores columna.


 -- Función: polynomialp (<p>, <L>, <coeffp>, <exponp>)
 -- Función: polynomialp (<p>, <L>, <coeffp>)
 -- Función: polynomialp (<p>, <L>)
     Devuelve `true' si <p> es un polinomio cuyas variables son las de
     la lista <L>, el predicado <coeffp> toma el valor `true' al
     aplicarlo a cada coeficiente y el predicado <exponp> también
     alcanza el valor `true' al ser aplicado a los exponentes de las
     variables listadas en <L>. En caso de necesitar que <exponp> no
     sea un predicado por defecto, se deberá especificar también el
     predicado <coeffp>, aunque aquí se desee su comportamiento por
     defecto.

     La instrucción `polynomialp (<p>, <L>, <coeffp>)' equivale a
     `polynomialp (<p>, <L>, <coeffp>, 'nonnegintegerp)', al tiempo que
     `polynomialp (<p>, <L>)' equivale a `polynomialp (<p>, L<,>
     'constantp, 'nonnegintegerp)'.

     No es necesario expandir el polinomio:

          (%i1) polynomialp ((x + 1)*(x + 2), [x]);
          (%o1)                         true
          (%i2) polynomialp ((x + 1)*(x + 2)^a, [x]);
          (%o2)                         false

     Un ejemplo utilizando valores distintos a los utilizados por
     defecto en <coeffp> y en <exponp>:

          (%i1) polynomialp ((x + 1)*(x + 2)^(3/2), [x],
                             numberp, numberp);
          (%o1)                         true
          (%i2) polynomialp ((x^(1/2) + 1)*(x + 2)^(3/2), [x],
                             numberp, numberp);
          (%o2)                         true

     Polinomios con dos variables:

          (%i1) polynomialp (x^2 + 5*x*y + y^2, [x]);
          (%o1)                         false
          (%i2) polynomialp (x^2 + 5*x*y + y^2, [x, y]);
          (%o2)                         true


 -- Función: polytocompanion (<p>, <x>)
     Si <p> es un polinomio en <x>, devuelve la matriz compañera de
     <p>. Para un polinomio mónico <p> de grado <n> se tiene `<p> =
     (-1)^<n> charpoly (polytocompanion (<p>, <x>))'.

     Si <p> no es un polinomio en  <x>, se devuelve un mensaje de error.


 -- Función: ptriangularize (<M>, <v>)
     Si <M> es una matriz en la que sus elementos son polinomios en <v>,
     devuelve una matriz <M2> tal que

       1. <M2> es triangular superior,

       2. `<M2> = <E_n> ... <E_1> <M>', donde <E_1>, ..., <E_n> son
          matrices elementales cuyos elementos son polinomios en <v>,

       3. `|det (<M>)| = |det (<M2>)|',

     Nota: esta función no comprueba si los elementos de la matriz son
     polinomios en <v>.

 -- Función: rowop (<M>, <i>, <j>, <theta>)
     Si <M> es una matriz, devuelve la matriz que resulta de relizar la
     transformación `R_i <- R_i - theta * R_j' con las filas `R_i' y
     `R_j'. Si <M> no tiene estas filas, devuelve un mensaje de error.


 -- Función: rank (<M>)
     Calcula el rango de la matriz <M>. El rango es la dimensión del
     espacio columna. Ejemplo:
          (%i1) rank(matrix([1,2],[2,4]));
          (%o1)                                  1
          (%i2) rank(matrix([1,b],[c,d]));
          Proviso:  {d - b c # 0}
          (%o2)                                  2


 -- Función: rowswap (<M>, <i>, <j>)
     Si <M> es una matriz, intercambia las filas  <i> y <j>. Si <M>
     carece de estas filas, devuelve un mensaje de error.


 -- Función: toeplitz (<col>)
 -- Función: toeplitz (<col>, <row>)
     Devuelve una  matriz de Toeplitz <T>. La primera columna de <T> es
     <col>, excepto su primer elemento. La primera fila de <T> es
     <row>. El valor por defecto para <row> es el complejo conjugado de
     <col>. Ejemplo:
          (%i1)  toeplitz([1,2,3],[x,y,z]);
                                            [ 1  y  z ]
                                            [         ]
          (%o1)                             [ 2  1  y ]
                                            [         ]
                                            [ 3  2  1 ]
          (%i2)  toeplitz([1,1+%i]);

                                        [   1     1 - %I ]
          (%o2)                         [                ]
                                        [ %I + 1    1    ]


 -- Función: vandermonde_matrix ([<x_1>, ..., <x_n>])
     Devuelve una matriz <n> por <n>, cuya <i>-ésima fila es `[1,
     <x_i>, <x_i>^2, ... <x_i>^(<n>-1)]'.


 -- Función: zerofor (<M>)
 -- Función: zerofor (<M>, <fld>)
     Devuelve la matriz nula con la misma estructura que la matriz <M>.
     Cada elemento de la matriz nula es la identidad aditiva del campo
     <fld>; el valor por defecto de <fld> es <generalring>.

     El primer argumento de <M> debe ser una matriz cuadrada o no ser
     matriz en absoluto. Si <M> es una matriz, cada uno de sus
     elementos puede ser una matriz cuadrada, por lo que <M> puede ser
     una matriz de Maxima definida por bloques.

     Véase también `identfor'.


 -- Función: zeromatrixp (<M>)
     Si <M> no es una matriz definida por bloques, devuelve `true' si
     `is (equal (<e>, 0))' es verdadero para todo elemento <e> de <M>.
     Si <M> es una matriz por bloques, devuelve `true' si `zeromatrixp'
     devuelve a su vez `true' para cada elemento de <e>.



File: maxima.info,  Node: lsquares,  Next: makeOrders,  Prev: linearalgebra,  Up: Top

63 lsquares
***********

* Menu:

* Funciones y variables para lsquares::


File: maxima.info,  Node: Funciones y variables para lsquares,  Prev: lsquares,  Up: lsquares

63.1 Funciones y variables para lsquares
========================================

 -- Función: lsquares_estimates (<D>, <x>, <e>, <a>)
 -- Función: lsquares_estimates (<D>, <x>, <e>, <a>, initial = <L>, tol
          = <t>)
     Estima los parámetros <a> que mejor se ajusten a la ecuación <e>
     de variables <x> y <a> a los datos <D> por el método de los
     mínimos cuadrados. La función `lsquares_estimates' busca primero
     una solución exacta, y si no la encuentra, buscará una aproximada.

     El resultado es una lista de listas de ecuaciones de la forma `[a
     = ..., b = ..., c = ...]'. Cada elemento de la lista es un mínimo
     diferente de error cuadrático medio.

     Los datos deben darse en formato matricial. Cada fila es un dato
     (el cual suele denominarse `registro' o `caso' en ciertos
     contextos), y las columnas contienen los valores para cada una de
     las variables. La lista de variables <x> asigna un nombre a cada
     una de las columnas de <D>, incluso a aquellas que no intervienen
     en el análisis. La lista <a> asigna nombres a los parámetros cuyas
     estimaciones se buscan. El argumento <e> es una expresión o
     ecuación de variables <x> y <a>; si <e> no es una ecuación (es
     decir, carece de igualdad), se trata como si fuese  `<e> = 0'.

     Se pueden dar argumentos adicionales a `lsquares_estimates' en
     forma de ecuaciones, las cuales se pasan tal cual a la función
     `lbfgs', que es la que se encarga de calcular las estimaciones por
     el método numérico cuando no encuentra una solución exacta.

     Cuando se pueda encontrar una solución exacta, mediante `solve',
     los datos en <D> pueden contener valores no numéricos. Sin
     embargo, cuando no exista solución exacta, todos los elementos de
     <D> deben ser necesariamente numéricos, lo cual incluye constantes
     numéricas tales como `%pi' o `%e' y números literales (enteros,
     racionales y decimales en coma flotante, tanto los de doble
     precisión como los de precisión arbitraria).  Los cálculos
     numéricos se realizan en doble precisión con aritmética de punto
     flotante, por lo que números de cualesquiera otro tipo son
     convenientemente convertidos antes de proceder con los cálculos.

     Antes de utilizar esta función ejecútese `load(lsquares)'.

     Véanse también `lsquares_estimates_exact',
     `lsquares_estimates_approximate', `lsquares_mse',
     `lsquares_residuals' y `lsquares_residual_mse'.

     Ejemplos:

     Un problema con solución exacta.

          (%i1) load (lsquares)$
          (%i2) M : matrix (
                  [1,1,1], [3/2,1,2], [9/4,2,1], [3,2,2], [2,2,1]);
                                            [ 1  1  1 ]
                                            [         ]
                                            [ 3       ]
                                            [ -  1  2 ]
                                            [ 2       ]
                                            [         ]
          (%o2)                             [ 9       ]
                                            [ -  2  1 ]
                                            [ 4       ]
                                            [         ]
                                            [ 3  2  2 ]
                                            [         ]
                                            [ 2  2  1 ]
          (%i3) lsquares_estimates (
                   M, [z,x,y], (z+D)^2 = A*x+B*y+C, [A,B,C,D]);
                                   59        27      10921        107
          (%o3)            [[A = - --, B = - --, C = -----, D = - ---]]
                                   16        16      1024         32

     un problema para el que no se encuentra solución exacta, por lo
     que `lsquares_estimates' recurre a la aproximación numérica.

          (%i1) load (lsquares)$
          (%i2) M : matrix ([1, 1], [2, 7/4], [3, 11/4], [4, 13/4]);
                                             [ 1  1  ]
                                             [       ]
                                             [    7  ]
                                             [ 2  -  ]
                                             [    4  ]
                                             [       ]
          (%o2)                              [    11 ]
                                             [ 3  -- ]
                                             [    4  ]
                                             [       ]
                                             [    13 ]
                                             [ 4  -- ]
                                             [    4  ]
          (%i3) lsquares_estimates (
            M, [x,y], y=a*x^b+c, [a,b,c], initial=[3,3,3], iprint=[-1,0]);
          (%o3) [[a = 1.387365874920637, b = .7110956639593767,
                                                  c = - .4142705622439105]]


 -- Función: lsquares_estimates_exact (<MSE>, <a>)
     Estima los valores de los parámetros <a> que minimizan el error
     cuadrático medio <MSE> mediante un sistema de ecuaciones que
     intentará resolver simbólicamente con `solve'. El error cuadrático
     medio es una expresión con parámetros <a>, como los devueltos por
     `lsquares_mse'.

     El valor devuelto por la función es una lista de listas de
     ecuaciones de la forma `[a = ..., b = ..., c = ...]'. El resultado
     puede contener cero, uno o más elementos. Cuando la respuesta
     contiene más de una solución, todas ellas representan mínimos del
     error cuadrático medio.

     Véanse también `lsquares_estimates',
     `lsquares_estimates_approximate', `lsquares_mse',
     `lsquares_residuals' y `lsquares_residual_mse'.

     Ejemplo:

          (%i1) load (lsquares)$
          (%i2) M : matrix (
                   [1,1,1], [3/2,1,2], [9/4,2,1], [3,2,2], [2,2,1]);
                                     [ 1  1  1 ]
                                     [         ]
                                     [ 3       ]
                                     [ -  1  2 ]
                                     [ 2       ]
                                     [         ]
          (%o2)                      [ 9       ]
                                     [ -  2  1 ]
                                     [ 4       ]
                                     [         ]
                                     [ 3  2  2 ]
                                     [         ]
                                     [ 2  2  1 ]
          (%i3) mse : lsquares_mse (M, [z, x, y], (z + D)^2 = A*x + B*y + C);
                     5
                    ====
                    \                 2                         2
                     >    ((D + M    )  - C - M     B - M     A)
                    /            i, 1          i, 3      i, 2
                    ====
                    i = 1
          (%o3)     ---------------------------------------------
                                          5
          (%i4) lsquares_estimates_exact (mse, [A, B, C, D]);
                            59        27      10921        107
          (%o4)     [[A = - --, B = - --, C = -----, D = - ---]]
                            16        16      1024         32


 -- Función: lsquares_estimates_approximate (<MSE>, <a>, initial = <L>,
          tol = <t>)
     Estima los valores de los parámetros <a> que minimizan el error
     cuadrático medio <MSE> mediante el algoritmo numérico `lbfgs'.  El
     error cuadrático medio es una expresión con parámetros <a>, como
     los devueltos por `lsquares_mse'.

     La solución devuelta por la función es un mínimo local
     (posiblemente global) del error cuadrático medio.

     Por consistencia con `lsquares_estimates_exact', el valor devuelto
     es una lista anidada con un único elemento, consistente en una
     lista de ecuaciones de la forma `[a = ..., b = ..., c = ...]'.

     Los argumentos adicionales de `lsquares_estimates_approximate' se
     especifican como ecuaciones y se pasan de esta forma a la función
     `lbfgs'.

     <MSE> debe devolver un número cuando a sus parámetros se les
     asignen valores numéricos, lo cual implica que los datos a partir
     de los cuales se ha generado <MSE> contengan únicamente constantes
     numéricas tales como `%pi' o `%e' y números literales (enteros,
     racionales y decimales en coma flotante, tanto los de doble
     precisión como los de precisión arbitraria).  Los cálculos
     numéricos se realizan en doble precisión con aritmética de punto
     flotante, por lo que números de cualesquiera otro tipo son
     convenientemente convertidos antes de proceder con los cálculos.

     Antes de utilizar esta función ejecútese `load(lsquares)'.

     Véanse también `lsquares_estimates', `lsquares_estimates_exact',
     `lsquares_mse', `lsquares_residuals' y `lsquares_residual_mse'.

     Ejemplo:

          (%i1) load (lsquares)$
          (%i2) M : matrix (
                   [1,1,1], [3/2,1,2], [9/4,2,1], [3,2,2], [2,2,1]);
                                     [ 1  1  1 ]
                                     [         ]
                                     [ 3       ]
                                     [ -  1  2 ]
                                     [ 2       ]
                                     [         ]
          (%o2)                      [ 9       ]
                                     [ -  2  1 ]
                                     [ 4       ]
                                     [         ]
                                     [ 3  2  2 ]
                                     [         ]
                                     [ 2  2  1 ]
          (%i3) mse : lsquares_mse (M, [z, x, y], (z + D)^2 = A*x + B*y + C);
                     5
                    ====
                    \                 2                         2
                     >    ((D + M    )  - C - M     B - M     A)
                    /            i, 1          i, 3      i, 2
                    ====
                    i = 1
          (%o3)     ---------------------------------------------
                                          5
          (%i4) lsquares_estimates_approximate (
                        mse, [A, B, C, D], iprint = [-1, 0]);
          (%o4) [[A = - 3.67850494740174, B = - 1.683070351177813,
                           C = 10.63469950148635, D = - 3.340357993175206]]


 -- Función: lsquares_mse (<D>, <x>, <e>)
     Devuelve el error medio cuadrático (MSE) para la ecuación <e> de
     variables <x> respecto de los datos <D>. El resultado devuelto es
     una suma, definida como

                              n
                             ====
                         1   \                        2
                         -    >    (lhs(e ) - rhs(e ))
                         n   /           i         i
                             ====
                             i = 1

     siendo <n> el número de datos y `<e>[i]' es la ecuación <e>
     evaluada cuando a sus variables <x> se le asignan los valores
     asociados al dato `i'-ésimo `<D>[i]'.

     Antes de utilizar esta función ejecútese `load(lsquares)'.

     Ejemplo:

          (%i1) load (lsquares)$
          (%i2) M : matrix (
                   [1,1,1], [3/2,1,2], [9/4,2,1], [3,2,2], [2,2,1]);
                                     [ 1  1  1 ]
                                     [         ]
                                     [ 3       ]
                                     [ -  1  2 ]
                                     [ 2       ]
                                     [         ]
          (%o2)                      [ 9       ]
                                     [ -  2  1 ]
                                     [ 4       ]
                                     [         ]
                                     [ 3  2  2 ]
                                     [         ]
                                     [ 2  2  1 ]
          (%i3) mse : lsquares_mse (M, [z, x, y], (z + D)^2 = A*x + B*y + C);
                     5
                    ====
                    \                 2                         2
                     >    ((D + M    )  - C - M     B - M     A)
                    /            i, 1          i, 3      i, 2
                    ====
                    i = 1
          (%o3)     ---------------------------------------------
                                          5
          (%i4) diff (mse, D);
                   5
                  ====
                  \                             2
                4  >    (D + M    ) ((D + M    )  - C - M     B - M     A)
                  /           i, 1         i, 1          i, 3      i, 2
                  ====
                  i = 1
          (%o4) ----------------------------------------------------------
                                            5
          (%i5) ''mse, nouns;
                         2                 2         9 2               2
          (%o5) (((D + 3)  - C - 2 B - 2 A)  + ((D + -)  - C - B - 2 A)
                                                     4
                     2               2         3 2               2
           + ((D + 2)  - C - B - 2 A)  + ((D + -)  - C - 2 B - A)
                                               2
                     2             2
           + ((D + 1)  - C - B - A) )/5


 -- Función: lsquares_residuals (<D>, <x>, <e>, <a>)
     Devuelve los residuos para la ecuación <e> de parámetros <a> y
     datos <D>.

     <D> es una matriz, <x> una lista de variables y <e> es una ecuación
     o expresión general; si <e> no es una ecuación (es decir, carece
     de igualdad), se trata como si fuese  `<e> = 0'. La lista <a>
     contiene ecuaciones que especifican valores para cualesquiera
     parámetros de <e> que no estén en <x>.

     Los residuos se definen como

                                  lhs(e ) - rhs(e )
                                       i         i

     siendo `<e>[i]' la ecuación <e> evaluada cuando las variables <x>
     toman los valores asociados al dato `i'-ésimo `<D>[i]', y haciendo
     las asignaciones indicadas en <a> al resto de variables.

     Antes de utilizar esta función ejecútese `load(lsquares)'.

     Ejemplo:

          (%i1) load (lsquares)$
          (%i2) M : matrix (
                   [1,1,1], [3/2,1,2], [9/4,2,1], [3,2,2], [2,2,1]);
                                            [ 1  1  1 ]
                                            [         ]
                                            [ 3       ]
                                            [ -  1  2 ]
                                            [ 2       ]
                                            [         ]
          (%o2)                             [ 9       ]
                                            [ -  2  1 ]
                                            [ 4       ]
                                            [         ]
                                            [ 3  2  2 ]
                                            [         ]
                                            [ 2  2  1 ]
          (%i3) a : lsquares_estimates (
                    M, [z,x,y], (z+D)^2 = A*x+B*y+C, [A,B,C,D]);
                                   59        27      10921        107
          (%o3)            [[A = - --, B = - --, C = -----, D = - ---]]
                                   16        16      1024         32
          (%i4) lsquares_residuals (
                    M, [z,x,y], (z+D)^2 = A*x+B*y+C, first(a));
                                      13    13    13  13  13
          (%o4)                      [--, - --, - --, --, --]
                                      64    64    32  64  64


 -- Función: lsquares_residual_mse (<D>, <x>, <e>, <a>)
     Devuelve el residuo del error cuadrático medio (MSE) de la
     ecuación <e> para los valores parámetricos <a> y datos <D>.

     El residuo del error cuadrático medio (MSE) se define como

                              n
                             ====
                         1   \                        2
                         -    >    (lhs(e ) - rhs(e ))
                         n   /           i         i
                             ====
                             i = 1

     siendo `<e>[i]' la ecuación <e> evaluada cuando las variables <x>
     toman los valores asociados al dato `i'-ésimo `<D>[i]', y haciendo
     las asignaciones indicadas en <a> al resto de variables.

     Antes de utilizar esta función ejecútese `load(lsquares)'.

     Ejemplo:

          (%i1) load (lsquares)$
          (%i2) M : matrix (
                   [1,1,1], [3/2,1,2], [9/4,2,1], [3,2,2], [2,2,1]);
                                     [ 1  1  1 ]
                                     [         ]
                                     [ 3       ]
                                     [ -  1  2 ]
                                     [ 2       ]
                                     [         ]
          (%o2)                      [ 9       ]
                                     [ -  2  1 ]
                                     [ 4       ]
                                     [         ]
                                     [ 3  2  2 ]
                                     [         ]
                                     [ 2  2  1 ]
          (%i3) a : lsquares_estimates (
                       M, [z,x,y], (z+D)^2 = A*x+B*y+C, [A,B,C,D]);

                            59        27      10921        107
          (%o3)     [[A = - --, B = - --, C = -----, D = - ---]]
                            16        16      1024         32
          (%i4) lsquares_residual_mse (
                       M, [z,x,y], (z + D)^2 = A*x + B*y + C, first (a));
                                        169
          (%o4)                         ----
                                        2560


 -- Función: plsquares (<Mat>,<VarList>,<depvars>)
 -- Función: plsquares (<Mat>,<VarList>,<depvars>,<maxexpon>)
 -- Función: plsquares
          (<Mat>,<VarList>,<depvars>,<maxexpon>,<maxdegree>)
     Ajuste de una función polinómica multivariante a una tabla de
     datos por el método de los mínimos cuadrados. <Mat> es la matriz
     con los datos empíricos, <VarList> es la lista con los nombres de
     las variables (una por cada columna de <Mat>, pero puede usarse
     `-' en lugar de los nombres de variables para ignorar las columnas
     de <Mat>), <depvars> es el nombre de la variable dependiente o una
     lista con uno o más nombres de variables dependientes (cuyos
     nombres deben estar también en <VarList>), <maxexpon> es un
     argumento opcional para indicar el máximo exponente para cada una
     de las variables independientes (1 por defecto) y  <maxdegree> es
     otro argumento opcional para el grado del polinomio (<maxexpon>
     por defecto); nótese que la suma de exponentes de cada término
     debe ser igual o menor que <maxdegree>. Si `maxdgree = 0' entonces
     no se aplicará ningún límite.

     Si <depvars> es el nombre de una variable dependiente (no en una
     lista), `plsquares' devuelve el polinomio ajustado. Si <depvars>
     es una lista de una o más variables dependientes, `plsquares'
     devuelve una lista con los polinomios ajustados. Los coeficientes
     de determinación se muestran en su orden correspondiente para
     informar sobre la bondad del ajuste. Estos valores se almacenan
     también en la variable global <DETCOEF> en un formato de lista si
     <depvars> es a su vez una lista.

     Un ejemplo sencillo de ajuste lineal multivariante:

          (%i1) load("plsquares")$

          (%i2) plsquares(matrix([1,2,0],[3,5,4],[4,7,9],[5,8,10]),
                          [x,y,z],z);
               Determination Coefficient for z = .9897039897039897
                                 11 y - 9 x - 14
          (%o2)              z = ---------------
                                        3

     El mismo ejemplo sin restricciones en el grado:

          (%i3) plsquares(matrix([1,2,0],[3,5,4],[4,7,9],[5,8,10]),
                          [x,y,z],z,1,0);
               Determination Coefficient for z = 1.0
                              x y + 23 y - 29 x - 19
          (%o3)           z = ----------------------
                                        6

     Cálculo del número de diagonales de un polígono de N lados

          (%i4) plsquares(matrix([3,0],[4,2],[5,5],[6,9],[7,14],[8,20]),
                          [N,diagonals],diagonals,5);
               Determination Coefficient for diagonals = 1.0
                                          2
                                         N  - 3 N
          (%o4)              diagonals = --------
                                            2
          (%i5) ev(%, N=9);   /* Testing for a 9 sides polygon */
          (%o5)                 diagonals = 27

     Cálculo del número de formas de colocar dos reinas en un tablero n
     x n de manera que no se amenacen.

          (%i6) plsquares(matrix([0,0],[1,0],[2,0],[3,8],[4,44]),
                          [n,positions],[positions],4);
               Determination Coefficient for [positions] = [1.0]
                                   4       3      2
                                3 n  - 10 n  + 9 n  - 2 n
          (%o6)    [positions = -------------------------]
                                            6
          (%i7) ev(%[1], n=8); /* Testing for a (8 x 8) chessboard */
          (%o7)                positions = 1288

     Un ejemplo con seis variables dependientes:

          (%i8) mtrx:matrix([0,0,0,0,0,1,1,1],[0,1,0,1,1,1,0,0],
                            [1,0,0,1,1,1,0,0],[1,1,1,1,0,0,0,1])$
          (%i8) plsquares(mtrx,[a,b,_And,_Or,_Xor,_Nand,_Nor,_Nxor],
                               [_And,_Or,_Xor,_Nand,_Nor,_Nxor],1,0);
                Determination Coefficient for
          [_And, _Or, _Xor, _Nand, _Nor, _Nxor] =
          [1.0, 1.0, 1.0, 1.0, 1.0, 1.0]
          (%o2) [_And = a b, _Or = - a b + b + a,
          _Xor = - 2 a b + b + a, _Nand = 1 - a b,
          _Nor = a b - b - a + 1, _Nxor = 2 a b - b - a + 1]

     Antes de hacer uso de esta función ejecútese  `load("plsquares")'.


File: maxima.info,  Node: makeOrders,  Next: minpack,  Prev: lsquares,  Up: Top

64 makeOrders
*************

* Menu:

* Funciones y variables para makeOrders::


File: maxima.info,  Node: Funciones y variables para makeOrders,  Prev: makeOrders,  Up: makeOrders

64.1 Funciones y variables para makeOrders
==========================================

 -- Función: makeOrders (<indvarlist>,<orderlist>)
     Devuelve una lista con las potencias de las variables de un
     polinomio término a término.

          (%i1) load("makeOrders")$

          (%i2) makeOrders([a,b],[2,3]);
          (%o2) [[0, 0], [0, 1], [0, 2], [0, 3], [1, 0], [1, 1],
                      [1, 2], [1, 3], [2, 0], [2, 1], [2, 2], [2, 3]]
          (%i3) expand((1+a+a^2)*(1+b+b^2+b^3));
                 2  3      3    3    2  2      2    2    2
          (%o3) a  b  + a b  + b  + a  b  + a b  + b  + a  b + a b
                                                            2
                                                     + b + a  + a + 1
     donde `[0, 1]' se asocia al término b y `[2, 3]' a a^2 b^3.

     Antes de hacer uso de esta función ejecútese `load("makeOrders")'.


File: maxima.info,  Node: minpack,  Next: mnewton,  Prev: makeOrders,  Up: Top

65 minpack
**********

* Menu:

* Introducción a minpack::
* Funciones y variables para minpack::


File: maxima.info,  Node: Introducción a minpack,  Next: Funciones y variables para minpack,  Up: minpack

65.1 Introducción a minpack
===========================

`Minpack' es una traducción a Common Lisp (via `f2cl') de la librería
MINPACK escrita en Fortran, tal como se puede obtener de Netlib.


File: maxima.info,  Node: Funciones y variables para minpack,  Prev: Introducción a minpack,  Up: minpack

65.2 Funciones y variables para minpack
=======================================

 -- Función: minpack_lsquares (<flist>, <varlist>, <guess> [,
          <tolerance>, <jacobian>])
     Calcula el punto `x' que minimiza la suma de los cuadrados de las
     funciones de la lista <flist>. Las variables se escriben en la
     lista `varlist'. El argumento <guess> debe guardar una estimación
     inicial del punto óptimo.

     Los argumentos opcionales <tolerance> y <jacobian> permiten
     mantener cierto control sobre el algoritmo; <tolerance> es el
     error relativo estimado que se desea en la suma de cuadrados,
     mientras que <jacobian> puede utilizarse para especificar el
     jacobiano. Si <jacobian> no se suministra, o se le da el valor
     `true', el que ya tiene por defecto, el jacobiano se calcula a
     partir de <flist>. Si <jacobian> vale `false', se utilizará una
     aproximación numérica.

     `minpack_lsquares' devuelve una lista, siendo su primer elemento
     la solución estimada, el segundo la suma de cuadrados y el tercero
     indica la bondad del algoritmo, siendo sus posibles valores los
     siguientes:

    `0'
          Número incorrecto de parámetros.

    `1'
          El algoritmo estima que el error relativo de la suma de
          cuadrados es, como mucho, igual a `tolerance'.

    `2'
          El algoritmo estima que el error relativo entre <x> y la
          solución es, como mucho, igual a `tolerance'.

    `3'
          Las dos condiciones anteriores se cumplen.

    `4'
          El vector formado por las funciones evaluadas en el punto <x>
          es ortogonal a las columnas del jacobiano dentro de la
          precisión de la máquina.

    `5'
          El número de llamadas a las funciones ha alcanzado 100*(n+1),
          siendo n el número de variables.

    `6'
          La tolerancia es demasiado pequeña, no siendo posible reducir
          más la suma de cuadrados.

    `7'
          La tolerancia es demasiado pequeña, no siendo posible mejorar
          la solución aproximada <x>.

          /* Problem 6: Powell singular function */
          (%i1) powell(x1,x2,x3,x4) :=
                   [x1+10*x2, sqrt(5)*(x3-x4), (x2-2*x3)^2,
                        sqrt(10)*(x1-x4)^2]$
          (%i2) minpack_lsquares(powell(x1,x2,x3,x4), [x1,x2,x3,x4],
                                 [3,-1,0,1]);
          (%o2) [[1.652117596168394e-17, - 1.652117596168393e-18,
                  2.643388153869468e-18, 2.643388153869468e-18],
                 6.109327859207777e-34, 4]

          /* Same problem but use numerical approximation to Jacobian */
          (%i3) minpack_lsquares(powell(x1,x2,x3,x4), [x1,x2,x3,x4],
                                 [3,-1,0,1], jacobian = false);
          (%o3) [[5.060282149485331e-11, - 5.060282149491206e-12,
                  2.179447843547218e-11, 2.179447843547218e-11],
                 3.534491794847031e-21, 5]

 -- Función: minpack_solve (<flist>, <varlist>, <guess> [, <tolerance>,
          <jacobian>])
     Resuelve un sistema de `n' ecuaciones con `n' incógnitas.  Las `n'
     ecuaciones forman la lista <flist>, estando la lista <varlist>
     formada por las incógnitas. El argumento <guess> es una estimación
     inicial de la solución.

     Los argumentos opcionales <tolerance> y <jacobian> permiten
     mantener cierto control sobre el algoritmo; <tolerance> es el
     error relativo estimado que se desea en la suma de cuadrados,
     mientras que <jacobian> puede utilizarse para especificar el
     jacobiano. Si <jacobian> no se suministra, o se le da el valor
     `true', el que ya tiene por defecto, el jacobiano se calcula a
     partir de <flist>. Si <jacobian> vale `false', se utilizará una
     aproximación numérica.

     `minpack_solve' devuelve una lista, siendo su primer elemento la
     solución estimada, el segundo la suma de cuadrados y el tercero
     indica la bondad del algoritmo, siendo sus posibles valores los
     siguientes:

    `0'
          Número incorrecto de parámetros.

    `1'
          El algoritmo estima que el error relativo de la suma de
          cuadrados es, como mucho, igual a `tolerance'.

    `2'
          El número de llamadas a las funciones ha alcanzado 100*(n+1),
          siendo n el número de incógnitas.

    `3'
          La tolerancia es demasiado pequeña, no siendo posible reducir
          más la suma de cuadrados.

    `4'
          El algoritmo no progresa adecuadamente.


File: maxima.info,  Node: mnewton,  Next: numericalio,  Prev: minpack,  Up: Top

66 mnewton
**********

* Menu:

* Funciones y variables para mnewton::


File: maxima.info,  Node: Funciones y variables para mnewton,  Prev: mnewton,  Up: mnewton

66.1 Funciones y variables para mnewton
=======================================

 -- Variable opcional: newtonepsilon
     Valor por defecto:  `10.0^(-fpprec/2)'

     Precisión que determina cuando la función `mnewton' ha conseguido
     una convergencia aceptable. Si `newtonepsilon' es un número
     decimal de precisión arbitraria (bigfloat), entonces `mnewton'
     realiza los cálculos en ese formato.

     Véase también `mnewton'.

 -- Variable opcional: newtonmaxiter
     Valor por defecto:  `50'

     Número máximo de iteraciones para la función `mnewton' en caso de
     que no se produzca convergencia, o de que ésta se haga muy lenta.

     Véase también `mnewton'.

 -- Función: mnewton (<FuncList>,<VarList>,<GuessList>)
     Resolución de sistemas de ecuaciones no lineales por el método de
     Newton.  <FuncList> es la lista de ecuaciones a resolver,
     <VarList> es la lista con los nombres de las incógnitas y
     <GuessList> es la lista de aproximaciones iniciales.

     La solución se devuelve en el mismo formato que lo hace la función
     `solve()'.  Si no se le encuentra solución al sistema, se obtiene
     `[]' como respuesta.

     Esta función se controla con las variables globales
     `newtonepsilon' y `newtonmaxiter'.

          (%i1) load("mnewton")$

          (%i2) mnewton([x1+3*log(x1)-x2^2, 2*x1^2-x1*x2-5*x1+1],
                        [x1, x2], [5, 5]);
          (%o2) [[x1 = 3.756834008012769, x2 = 2.779849592817897]]
          (%i3) mnewton([2*a^a-5],[a],[1]);
          (%o3)             [[a = 1.70927556786144]]
          (%i4) mnewton([2*3^u-v/u-5, u+2^v-4], [u, v], [2, 2]);
          (%o4) [[u = 1.066618389595407, v = 1.552564766841786]]

     La variable `newtonepsilon' controla la precisión de las
     aproximaciones. También controla si los cálculos se realizan con
     precisión doble o arbitraria (bigfloats).

          (%i1) load(mnewton)$

          (%i2) (fpprec : 25, newtonepsilon : bfloat(10^(-fpprec+5)))$

          (%i3) mnewton([2*3^u-v/u-5, u+2^v-4], [u, v], [2, 2]);
          (%o3) [[u = 1.066618389595406772591173b0,
                                         v = 1.552564766841786450100418b0]]

     Antes de hacer uso de esta función ejecútese  `load("mnewton")'.
     Véanse también `newtonepsilon' y `newtonmaxiter'.


File: maxima.info,  Node: numericalio,  Next: opsubst,  Prev: mnewton,  Up: Top

67 numericalio
**************

* Menu:

* Introducción a numericalio::
* Funciones y variables para entrada y salida en formato texto::
* Funciones y variables para entrada y salida en formato binario::


File: maxima.info,  Node: Introducción a numericalio,  Next: Funciones y variables para entrada y salida en formato texto,  Prev: numericalio,  Up: numericalio

67.1 Introducción a numericalio
===============================

El paquete `numericalio' define funciones para leer y escribir ficheros
de datos y flujos. Las funciones de entrada y salida en formato texto
pueden leer y escribir números (enteros, decimales o decimales
grandes), símbolos y cadenas.  Las funciones de entrada y salida en
formato binario sólo pueden leer y escribir números decimales.

   Si ya existe una lista, matriz o array para almacenar los datos de
entrada, las funciones de entrada de `numericalio' pueden escribir los
datos directamente en estos objetos. En caso contrario, `numericalio'
tratará de generar el objeto apropiado para almacenar estos datos.

67.1.1 Entrada y salida en formato texto
----------------------------------------

In plain-text input and output, it is assumed that each item to read or
write is an atom:

   En la entrada y salida de datos en formato texto se supone que cada
dato es un átomo: un número entero, decimal, decimal grande, una cadena
o un símbolo; no se admiten fracciones, números complejos o cualquier
otra expresión no atómica. Estas funciones pueden llegar a realizar
operaciones válidas con expresiones no atómicas, pero estos resultados
no se documentan y están sujetos a cambios ulteriores.

   Los átomos, tanto en los ficheros de entrada como en los de salida,
tienen el mismo formato que en los ficheros por lotes de Maxima o en la
consola interactiva. En particular, las cadenas deben encerrarse entre
comillas dobles, la barra invertida `\' evita cualquier interpretación
especial del carácter siguiente, y el símbolo de interrogación `?' se
reconoce como el comienzo de un símbolo de Lisp. No se reconoce ningún
carácter de continuación de línea interrumpida.

67.1.2 Separadores válidos para lectura
---------------------------------------

Las funciones para la entrada y salida de datos en formato texto tiene
un argumento opcional, <separator_flag>, para indicar qué carácter se
utiliza como separador.

   Para la entrada de texto se reconocen los siguientes valores de la
variable <separator_flag>: `comma' para los valores separados por
comas, `pipe' para los valores separados por el carácter de la barra
vertical `|', `semicolon' para los valores separados por punto y coma
`;', y `space' para cuando los valores se separan por espacios o
tabulaciones. Si el nombre del fichero tiene extensión `.csv' y no se
especifica el argumento <separator_flag>, se tomará por defecto `comma'.
Si el fichero tiene cualquier otra extensión diferente de `.csv' y no se
especifica `separator_flag', se usará por defecto `space'.

   En la entrada de texto, varios espacios y tabulaciones sucesivos
cuentan como un único separador. Sin embargo, varias comas, barras
verticales o punto y comas sucesivos se interpretan que tienen el
símbolo `false' entre ellos; por ejemplo, `1234,,Foo' se interpreta lo
mismo que si fuese `1234,false,Foo'. En la salida, los átomos `false'
deben escribirse explícitamente, por lo que la lista `[1234, false,
Foo]' debe escribirse `1234,false,Foo'.

67.1.3 Separadores válidos para escritura
-----------------------------------------

Para la entrada de texto se acepta `tab' como valor de <separator_flag>
para datos separados por tabuladores, así como `comma', `pipe',
`semicolon' y `space'.

   En la escritura de texto, el átomo`false' se escribe tal cual y una
lista `[1234, false, Foo]' se escribe `1234,false,Foo'.

67.1.4 Entrada y salida de decimales en formato binario
-------------------------------------------------------

Las funciones de `numericalio' pueden leer y escribir números decimales
en coma flotante de 8 bytes del estándar IEEE 754. Estos números se
pueden escribir empezando por el byte menos significativo o por el más
significativo, según lo indique la variable global
`assume_external_byte_order'. Por defecto, `numericalio' los almacena
con el byte más significativo primero.

   Cualesquiera otros tipos de decimales son transformados a 8 bytes.
El paquete `numericalio' no puede leer ni escribir datos binarios no
numéricos.

   Ciertos entornos Lisp no reconocen valores especiales del estándar
IEEE 754 (más o menos infinito, valores no numéricos, valores no
normales). El efecto que pueda producir la lectura de tales valores por
parte de `numericalio' es imprevisible.

   `numericalio' incluye funciones para abrir un flujo de lectura o
escritura de flujos de bytes.


File: maxima.info,  Node: Funciones y variables para entrada y salida en formato texto,  Next: Funciones y variables para entrada y salida en formato binario,  Prev: Introducción a numericalio,  Up: numericalio

67.2 Funciones y variables para entrada y salida en formato texto
=================================================================

 -- Función: read_matrix (<S>)
 -- Función: read_matrix (<S>, <M>)
 -- Función: read_matrix (<S>, <separator_flag>)
 -- Función: read_matrix (<S>, <M>, <separator_flag>)
     `read_matrix(<S>)' lee la fuente <S> y devuelve su contenido
     completo en forma de matriz. El tamaño de la matriz se deduce de
     los datos de entrada: cada fila del fichero forma una fila de la
     matriz. Si hay filas con diferente número de elementos,
     `read_matrix' emite un mensaje de error.

     `read_matrix(<S>, <M>)' lee la fuente <S> y va almacenando su
     contenido en la matriz <M>, hasta que <M> esté llena o hasta que
     se consuma la fuente.  Los datos se almacenan fila a fila. Los
     datos de entrada no necesitan tener el mismo número de filas y
     columnas que <M>.

     La fuente <S> puede ser el nombre de un fichero o de un flujo.

     Los valores aceptados para <separator_flag> son: `comma', `pipe',
     `semicolon' y `space'.  Si no se especifica un valor para
     <separator_flag>, se supone que los datos están separados por
     espacios.


 -- Función: read_array (<S>, <A>)
 -- Función: read_array (<S>, <A>, <separator_flag>)
     Guarda el contenido de la fuente <S> en el array <A>, hasta que
     <A> esté lleno o hasta que se consuma la fuente.  Los datos se
     almacenan fila a fila. Los datos de entrada no necesitan tener el
     mismo número de filas y columnas que <A>.

     La fuente <S> puede ser el nombre de un fichero o de un flujo.

     Los valores aceptados para <separator_flag> son: `comma', `pipe',
     `semicolon' y `space'.  Si no se especifica un valor para
     <separator_flag>, se supone que los datos están separados por
     espacios.


 -- Función: read_hashed_array (<S>, <A>)
 -- Función: read_hashed_array (<S>, <A>, <separator_flag>)
     Lee la fuente <S> y devuelve su contenido completo en forma de
     array de claves.  La fuente <S> puede ser el nombre de un fichero
     o de un flujo.

     `read_hashed_array' interpreta el primer elemento de cada fila
     como una clave, asociando el resto de la fila, en formato de
     lista, a la clave. Por ejemplo, la secuencia `567 12 17 32 55'
     equivale a `A[567]: [12, 17, 32, 55]$'.  Las filas no necesitan
     tener todas ellas el mismo número de elementos.

     Los valores aceptados para <separator_flag> son: `comma', `pipe',
     `semicolon' y `space'.  Si no se especifica un valor para
     <separator_flag>, se supone que los datos están separados por
     espacios.

 -- Función: read_nested_list (<S>)
 -- Función: read_nested_list (<S>, <separator_flag>)
     Lee la fuente <S> y devuelve su contenido completo en forma de
     lista anidada.  La fuente <S> puede ser el nombre de un fichero o
     de un flujo.

     `read_nested_list' devuelve una lista que tiene una sublista por
     cada fila de entrada. Los filas de entrada no necesitan tener
     todas ellas el mismo número de elementos. Las filas en blanco no
     se ignoran, sino que se convierten en listas vacías

     Los valores aceptados para <separator_flag> son: `comma', `pipe',
     `semicolon' y `space'.  Si no se especifica un valor para
     <separator_flag>, se supone que los datos están separados por
     espacios.

 -- Función: read_list (<S>)
 -- Función: read_list (<S>, <L>)
 -- Función: read_list (<S>, <separator_flag>)
 -- Función: read_list (<S>, <L>, <separator_flag>)
     `read_list(<S>)' lee la fuente <S> y devuelve su contenido como
     una lista simple.

     `read_list(<S>, <L>)' guarda el contenido de la fuente <S> en la
     lista <L>, hasta que <L> esté llena o hasta que se consuma la
     fuente.

     La fuente <S> puede ser el nombre de un fichero o de un flujo.

     Los valores aceptados para <separator_flag> son: `comma', `pipe',
     `semicolon' y `space'.  Si no se especifica un valor para
     <separator_flag>, se supone que los datos están separados por
     espacios.

 -- Función: write_data (<X>, <D>)
 -- Función: write_data (<X>, <D>, <separator_flag>)
     Escribe el objeto <X> en el destino <D>.

     `write_data' escribe una matriz fila a fila; cada línea de entrada
     se corresponde con una fila.

     `write_data' escribe un array creado por `array' o `make_array'
     fila a fila, con una nueva línea al final de cada bloque de datos.
     Los bloques de mayores dimensiones se separan con líneas
     adicionales.

     `write_data' escribe un array de claves con cada clave seguida de
     su lista asociada en una sola línea.

     `write_data' escribe una lista anidada con una sublista por línea.

     `write_data' escribe una lista simple en una única fila.

     El destino <D> puede ser el nombre de un fichero o un flujo; en el
     primer caso, la variable global `file_output_append' controla si
     el fichero de salida es ampliado con la nueva información o si se
     borra antes; en el segundo caso, no se realiza ningún tipo de
     acción por parte de `write_data' después de que se hayan escrito
     los datos; en particular, el flujo se mantiene abierto.

     Los valores aceptados para <separator_flag> son: `comma', `pipe',
     `semicolon' y `space'.  Si no se especifica un valor para
     <separator_flag>, se supone que los datos están separados por
     espacios.


File: maxima.info,  Node: Funciones y variables para entrada y salida en formato binario,  Prev: Funciones y variables para entrada y salida en formato texto,  Up: numericalio

67.3 Funciones y variables para entrada y salida en formato binario
===================================================================

 -- Función: assume_external_byte_order (<byte_order_flag>)
     Le indica a `numericalio' el orden de los bytes en que debe leer y
     escribir los datos.  Los valores que reconoce <byte_order_flag>
     son dos: `lsb', que indica que el byte menos significativo debe
     ser el primero, y `msb', que indica que el byte más significativo
     es el que debe ir en primer lugar.

     En caso de no hacer ninguna selección, `numericalio' interpreta
     que es el byte más significativo el que se debe leer o escribir
     primero.

 -- Función: openr_binary (<file_name>)
     Devuelve un flujo de entrada de bytes no signados para la lectura
     del fichero de nombre <file_name>.


 -- Función: openw_binary (<file_name>)
     Devuelve un flujo de entrada de bytes no signados para la
     escritura en el fichero de nombre <file_name>.


 -- Función: opena_binary (<file_name>)
     Devuelve un flujo de entrada de bytes no signados para añadir
     datos al fichero de nombre <file_name>.


 -- Función: read_binary_matrix (<S>, <M>)
     Lee números decimales en coma flotante de 8 bytes desde la fuente
     <S> y los va almacenando en la matriz <M>, bien hasta que <M> se
     llene, o bien hasta que la fuente se haya consumido. La matriz <M>
     se rellena fila a fila.

     La fuente <S> puede ser el nombre de un fichero o un flujo.

     El orden de los bytes de los datos procedentes de la fuente se
     especifican mediante `assume_external_byte_order'.


 -- Función: read_binary_array (<S>, <A>)
     Lee números decimales en coma flotante de 8 bytes desde la fuente
     <S> y los va almacenando en el array <A>, bien hasta que <A> se
     llene, o bien hasta que la fuente se haya consumido. <A> debe ser
     un array creado por `array' o por `make_array'. El array <A> se
     rellena fila a fila.

     La fuente <S> puede ser el nombre de un fichero o un flujo.

     El orden de los bytes de los datos procedentes de la fuente se
     especifican mediante `assume_external_byte_order'.


 -- Función: read_binary_list (<S>)
 -- Función: read_binary_list (<S>, <L>)
     `read_binary_list(<S>)' lee el contenido completo de la fuente de
     datos <S> como una secuencia de números decimales en coma flotante
     de 8 bytes en formato binario, devolviéndolos en forma de lista.

     La fuente <S> puede ser el nombre de un fichero o un flujo.

     `read_binary_list(<S>, <L>)' lee números decimales en coma
     flotante de 8 bytes en formato binario desde la fuente <S> y los
     almacena en la lista <L>, bien hasta que ésta esté llena, o bien
     hasta que se consuman los datos de la fuente.

     El orden de los bytes de los datos procedentes de la fuente se
     especifican mediante `assume_external_byte_order'.

 -- Función: write_binary_data (<X>, <D>)
     Escribe el objeto <X>, que contiene números decimales en coma
     flotante de 8 bytes del estándar IEEE 754, en el destino <D>.
     Cualesquiera otros tipos de decimales son transformados a 8 bytes.
     `write_binary_data' no puede escribir datos no numéricos.

     El objeto <X> puede ser una lista, una lista anidada, una matriz,
     o un array creado con `array' o `make_array'; <X> no puede ser ni
     un array no declarado ni cualquier otro tipo de objeto distinto a
     los citados.  `write_binary_data' escribe las listas anidadas, las
     matrices y los arrays fila a fila.

     El destino <D> puede ser el nombre de un fichero o un flujo; en el
     primer caso, la variable global `file_output_append' controla si
     el fichero de salida es ampliado con la nueva información o si se
     borra antes; en el segundo caso, no se realiza ningún tipo de
     acción por parte de `write_binary_data' después de que se hayan
     escrito los datos; en particular, el flujo se mantiene abierto.

     El orden de los bytes de los datos procedentes de la fuente se
     especifican mediante `assume_external_byte_order'.



File: maxima.info,  Node: opsubst,  Next: orthopoly,  Prev: numericalio,  Up: Top

68 opsubst
**********

* Menu:

* Funciones y variables para opsubst::


File: maxima.info,  Node: Funciones y variables para opsubst,  Prev: opsubst,  Up: opsubst

68.1 Funciones y variables para opsubst
=======================================

 -- Función: opsubst (<f>,<g>,<e>)
 -- Función: opsubst (<g>=<f>,<e>)
 -- Función: opsubst ([<g1>=<f1>,<g2>=<f2>,..., <gn>=<fn>],<e>)
     La función `opsubst' es similar a la función `subst', excepto por
     el hecho de que `opsubst'  tan solo hace sustituciones de
     operadores en las expresiones. En general, si <f> es un operador en
     la expresión <e>, lo cambia por <g> en la expresión <e>.

     Para determinar el operador, `opsubst' asigna a `inflag' el valor
     `true', lo cual significa que `opsubst' sustituye el operador
     interno de la expresión, no el mostrado en la salida formateada.

     Ejemplo:
          (%i1) load (opsubst)$

          (%i2) opsubst(f,g,g(g(x)));
          (%o2)                     f(f(x))
          (%i3) opsubst(f,g,g(g));
          (%o3)                       f(g)
          (%i4) opsubst(f,g[x],g[x](z));
          (%o4)                       f(z)
          (%i5) opsubst(g[x],f, f(z));
          (%o5)                      g (z)
                                      x
          (%i6) opsubst(tan, sin, sin(sin));
          (%o6)                     tan(sin)
          (%i7) opsubst([f=g,g=h],f(x));
          (%o7)                       h(x)

     Internamente, Maxima no hace uso de los operadores de negación
     unaria, de división ni de la resta, por lo que:
          (%i8) opsubst("+","-",a-b);
          (%o8)                     a - b
          (%i9) opsubst("f","-",-a);
          (%o9)                      - a
          (%i10) opsubst("^^","/",a/b);
                                       a
          (%o10)                       -
                                       b

     La representación interna de -a*b es *(-1,a,b), de modo que
          (%i11) opsubst("[","*", -a*b);
          (%o11)                  [- 1, a, b]

     Si alguno de los operadores no es un símbolo de Maxima, se emitirá
     un mensaje de error:
          (%i12) opsubst(a+b,f, f(x));

          Improper name or value in functional position:
          b + a
           -- an error.  Quitting.  To debug this try debugmode(true);

     Sin embargo se permiten operadores subindicados:
          (%i13) opsubst(g[5],f, f(x));
          (%o13)                     g (x)
                                      5

     Antes de hacer uso de esta función ejecútese  `load("opsubst")'.


File: maxima.info,  Node: orthopoly,  Next: plotdf,  Prev: opsubst,  Up: Top

69 orthopoly
************

* Menu:

* Introducción a polinomios ortogonales::
* Funciones y variables para polinomios ortogonales::


File: maxima.info,  Node: Introducción a polinomios ortogonales,  Next: Funciones y variables para polinomios ortogonales,  Prev: orthopoly,  Up: orthopoly

69.1 Introducción a polinomios ortogonales
==========================================

El paquete `orthopoly' contiene funciones para la evaluación simbólica
y numérica de diversos tipos de polinomios ortogonales, como los de
Chebyshev, Laguerre, Hermite, Jacobi, Legendre y ultraesféricos
(Gegenbauer). Además, `orthopoly' soporta las funciones esféricas de
Bessel, Hankel y armónicas.

   Referencias:
   * Abramowitz y Stegun, Handbook of Mathematical Functions, (1972,
     décima reimpresión, capítulo 22)

   * Gradshteyn y Ryzhik, Table of Integrals, Series y  Products,
     (1980, edición corregida y ampliada)

   * Eugen Merzbacher, Quantum Mechanics, (1970, segunda edición)


   El paquete `orthopoly', junto con su documentación, fue escrito por
Barton Willis de la Universidad de Nebraska en Kearney. El paquete se
distribuye con la licencia GNU General Public License (GPL).

69.1.1 Iniciándose con orthopoly
--------------------------------

`load (orthopoly)' carga el paquete `orthopoly'.

   Para obtener el polinomio de Legendre de tercer orden,

     (%i1) legendre_p (3, x);
                           3             2
                  5 (1 - x)    15 (1 - x)
     (%o1)      - ---------- + ----------- - 6 (1 - x) + 1
                      2             2

   Para expresarlo como una suma de potencias de <x>, aplíquese
<ratsimp> o <rat> al resultado.

     (%i2) [ratsimp (%), rat (%)];
                             3           3
                          5 x  - 3 x  5 x  - 3 x
     (%o2)/R/            [----------, ----------]
                              2           2

   De forma alternativa, conviértase el segundo argumento de to
`legendre_p' (su variable  "principal") a una expresión racional
canónica (canonical rational expression, CRE)).

     (%i1) legendre_p (3, rat (x));
                                   3
                                5 x  - 3 x
     (%o1)/R/                   ----------
                                    2

   Para la evaluación numérica,  `orthopoly' hace uso del análisis de
error de ejecución para estimar una cota superior del error. Por
ejemplo,

     (%i1) jacobi_p (150, 2, 3, 0.2);
     (%o1) interval(- 0.062017037936715, 1.533267919277521E-11)

   Los intervalos tienen la forma `interval (<c>, <r>)', donde <c> es
el centro y <r> el radio del intervalo. Puesto que Maxima no soporta
aritmética de intervalos, en algunas situaciones, como en los gráficos,
puede ser necesario ignorar el error y utilizar el centro del
intervalo. Para conseguirlo conviene asignar a la variable
`orthopoly_returns_intervals' el valor `false'.

     (%i1) orthopoly_returns_intervals : false;
     (%o1)                         false
     (%i2) jacobi_p (150, 2, 3, 0.2);
     (%o2)                  - 0.062017037936715

   Véase la sección Evaluación numérica para más información.

   La mayor parte de las funciones de `orthopoly' tienen una propiedad
`gradef'; así,

     (%i1) diff (hermite (n, x), x);
     (%o1)                     2 n H     (x)
                                    n - 1
     (%i2) diff (gen_laguerre (n, a, x), x);
                   (a)               (a)
                n L   (x) - (n + a) L     (x) unit_step(n)
                   n                 n - 1
     (%o2)      ------------------------------------------
                                    x

   La función `unit_step' del segundo ejemplo evita el error que
aparecería al evaluar la expresión con <n> igual a 0.

     (%i3) ev (%, n = 0);
     (%o3)                           0

   La propiedad "gradef" sólo se aplica a la variable principal;
derivadas respecto de las otras variables darán lugar normalmente a
mensajes de error; por ejemplo,

     (%i1) diff (hermite (n, x), x);
     (%o1)                     2 n H     (x)
                                    n - 1
     (%i2) diff (hermite (n, x), n);

     Maxima doesn't know the derivative of hermite with
     respect the first argument
      -- an error.  Quitting.  To debug this try debugmode(true);

   Generalmente, las funciones de `orthopoly' se distribuyen sobre
listas y matrices. Al objeto de que la evaluación se realice
completamente, las variables opcionales `doallmxops' y `listarith'
deben valer ambas `true', que es el valor por defecto. Para ilustrar la
distribución sobre matrices sirve el siguiente ejemplo

     (%i1) hermite (2, x);
                                          2
     (%o1)                    - 2 (1 - 2 x )
     (%i2) m : matrix ([0, x], [y, 0]);
                                 [ 0  x ]
     (%o2)                       [      ]
                                 [ y  0 ]
     (%i3) hermite (2, m);
                    [                             2  ]
                    [      - 2        - 2 (1 - 2 x ) ]
     (%o3)          [                                ]
                    [             2                  ]
                    [ - 2 (1 - 2 y )       - 2       ]

   En el segundo ejemplo, el elemento `i, j'-ésimo es `hermite (2,
m[i,j])', que no es lo mismo que calcular `-2 + 4 m . m', según se ve
en el siguiente ejemplo.

     (%i4) -2 * matrix ([1, 0], [0, 1]) + 4 * m . m;
                         [ 4 x y - 2      0     ]
     (%o4)               [                      ]
                         [     0      4 x y - 2 ]

   Si se evalúa una función en un punto fuera de su dominio de
definición, generalmente `orthopoly' devolverá la función sin evaluar.
Por ejemplo,

     (%i1) legendre_p (2/3, x);
     (%o1)                        P   (x)
                                   2/3

   `orthopoly' da soporte a la traducción de expresiones al formato TeX
y la representación bidimensional en el terminal.

     (%i1) spherical_harmonic (l, m, theta, phi);
                               m
     (%o1)                    Y (theta, phi)
                               l
     (%i2) tex (%);
     $$Y_{l}^{m}\left(\vartheta,\varphi\right)$$
     (%o2)                         false
     (%i3) jacobi_p (n, a, a - b, x/2);
                               (a, a - b) x
     (%o3)                    P          (-)
                               n          2
     (%i4) tex (%);
     $$P_{n}^{\left(a,a-b\right)}\left({{x}\over{2}}\right)$$
     (%o4)                         false

69.1.2 Limitaciones
-------------------

Cuando una expresión contenga varios polinomios ortogonales con órdenes
simbólicos, es posible que aunque la expresión sea nula, Maxima sea
incapaz de simplificarla a cero, por lo que si se divide por esta
cantidad, aparecerán problemas. Por ejemplo, la siguiente expressión se
anula para enteros <n> mayores que 1, no pudiendo Maxima reducirla a
cero.

     (%i1) (2*n - 1) * legendre_p (n - 1, x) * x - n * legendre_p (n, x)
                     + (1 - n) * legendre_p (n - 2, x);
     (%o1)  (2 n - 1) P     (x) x - n P (x) + (1 - n) P     (x)
                       n - 1           n               n - 2

   Para un valor específico de <n> se puede reducir la expresión a cero.

     (%i2) ev (% ,n = 10, ratsimp);
     (%o2)                           0

   Generalmente, la forma polinomial de un polinomio ortogonal no es la
más apropiada para su evaluación numérica. Aquí un ejemplo.

     (%i1) p : jacobi_p (100, 2, 3, x)$
     (%i2) subst (0.2, x, p);
     (%o2)                3.4442767023833592E+35
     (%i3) jacobi_p (100, 2, 3, 0.2);
     (%o3)  interval(0.18413609135169, 6.8990300925815987E-12)
     (%i4) float(jacobi_p (100, 2, 3, 2/10));
     (%o4)                   0.18413609135169

   Este resultado se puede mejorar expandiendo el polinomio y evaluando
a continuación, lo que da una aproximación mejor.
     (%i5) p : expand(p)$
     (%i6) subst (0.2, x, p);
     (%o6) 0.18413609766122982

   Sin embargo esto no vale como regla general; la expansión del
polinomio no siempre da como resultado una expresión más fácil de
evaluar numéricamente. Sin duda, la mejor manera de hacer la evaluación
numérica consiste en hacer que uno o más de los argumentos de la
función sean decimales en coma flotante; de esta forma se utilizarán
algoritmos decimales especializados para hacer la evaluación.

   La función `float' de Maxima trabaja de forma indiscriminada; si se
aplica `float' a una expresión que contenga un polinomio ortogonal con
el grado u orden simbólico, éstos se pueden transformar en decimales y
la expresión no ser evaluada de forma completa. Considérese

     (%i1) assoc_legendre_p (n, 1, x);
                                    1
     (%o1)                         P (x)
                                    n
     (%i2) float (%);
                                   1.0
     (%o2)                        P   (x)
                                   n
     (%i3) ev (%, n=2, x=0.9);
                                  1.0
     (%o3)                       P   (0.9)
                                  2

   La expresión en `(%o3)' no da como resultado un decimal en coma
flotante; `orthopoly' no reconoce decimales donde espera que haya
enteros. De forma semejante, la evaluación numérica de la función
`pochhammer' para órdenes que excedan `pochhammer_max_index' puede ser
problemática; considérese

     (%i1) x :  pochhammer (1, 10), pochhammer_max_index : 5;
     (%o1)                         (1)
                                      10

   Aplicando `float' no da para <x> un valor decimal

     (%i2) float (x);
     (%o2)                       (1.0)
                                      10.0

   A fin de evaluar <x> como decimal, es necesario asignar a
`pochhammer_max_index' en valor 11 o mayor y aplicar `float' a <x>.

     (%i3) float (x), pochhammer_max_index : 11;
     (%o3)                       3628800.0

   El valor por defecto de `pochhammer_max_index' es 100; cámbiese este
valor tras cargar el paquete `orthopoly'.

   Por último, téngase en cuenta que las referencias bibliográficas no
coinciden a la hora de definir los polinomios ortogonales; en
`orthopoly' se han utilizado normalmente las convenciones seguidas por
Abramowitz y Stegun.

   Cuando se sospeche de un fallo en `orthopoly', compruébense algunos
casos especiales a fin de determinar si las definiciones de las que el
usuario parte coinciden con las utilizadas por el paquete `orthopoly'.
A veces las definiciones difieren por un factor de normalización;
algunos autores utilizan versiones que hacen que las familias sean
ortogonales en otros intervalos diferentes de (-1, 1). Así por ejemplo,
para definir un polinomio de Legendre ortogonal en (0, 1) defínase

     (%i1) shifted_legendre_p (n, x) := legendre_p (n, 2*x - 1)$

     (%i2) shifted_legendre_p (2, rat (x));
                                 2
     (%o2)/R/                 6 x  - 6 x + 1
     (%i3) legendre_p (2, rat (x));
                                    2
                                 3 x  - 1
     (%o3)/R/                    --------
                                    2

69.1.3 Evaluación numérica
--------------------------

La mayor parte de las funciones de `orthopoly' realizan análisis de
errores en tiempo de ejecución para estimar el error en la evaluación
decimal, a excepción de las funciones esféricas de Bessel y los
polinomios asociados de Legendre de segunda especie. Para la evaluación
numérica, las funciones esféricas de Bessel hacen uso de funciones
SLATEC. No se lleva a cabo ningún método especial de evaluación
numérica para los polinomios asociados de Legendre de segunda especie.

   Es posible, aunque improbable, que el error obtenido en las
evaluaciones numéricas exceda al error estimado.

   Los intervalos tienen la forma `interval (<c>, <r>)', siendo <c> el
centro del intervalo y <r> su radio. El centro del intervalo puede ser
un número complejo, pero el radio será siempre un número real positivo.

   He aquí un ejemplo:

     (%i1) fpprec : 50$
     (%i2) y0 : jacobi_p (100, 2, 3, 0.2);
     (%o2) interval(0.1841360913516871, 6.8990300925815987E-12)
     (%i3) y1 : bfloat (jacobi_p (100, 2, 3, 1/5));
     (%o3) 1.8413609135168563091370224958913493690868904463668b-1

   Se comprueba que el error es menor que el estimado

     (%i4) is (abs (part (y0, 1) - y1) < part (y0, 2));
     (%o4)                         true

   En este ejemplo el error estimado es una cota superior para el error
verdadero.

   Maxima no da soporte a la aritmética de intervalos.

     (%i1) legendre_p (7, 0.1) + legendre_p (8, 0.1);
     (%o1) interval(0.18032072148437508, 3.1477135311021797E-15)
             + interval(- 0.19949294375000004, 3.3769353084291579E-15)

   El usuario puede definir operadores aritméticos para los intervalos.
Para definir la suma de intervalos se puede hacer

     (%i1) infix ("@+")$

     (%i2) "@+"(x,y) := interval (part (x, 1) + part (y, 1),
                                   part (x, 2) + part (y, 2))$
     (%i3) legendre_p (7, 0.1) @+ legendre_p (8, 0.1);
     (%o3) interval(- 0.019172222265624955, 6.5246488395313372E-15)

   Las rutinas especiales para cálculo numérico son llamadas cuando los
argumentos son complejos. Por ejemplo,

     (%i1) legendre_p (10, 2 + 3.0*%i);
     (%o1) interval(- 3.876378825E+7 %i - 6.0787748E+7,
                                                1.2089173052721777E-6)

   Compárese con el valor verdadero.

     (%i1) float (expand (legendre_p (10, 2 + 3*%i)));
     (%o1)          - 3.876378825E+7 %i - 6.0787748E+7

   Además, cuando los argumentos son números decimales grandes (big
floats), se realizan llamadas a las rutinas numéricas especiales; sin
embargo, los decimales grandes se convierten previamente a doble
precisión y de este tipo serán también los resultados.

     (%i1) ultraspherical (150, 0.5b0, 0.9b0);
     (%o1) interval(- 0.043009481257265, 3.3750051301228864E-14)

69.1.4 Gráficos y orthopoly
---------------------------

Para representar gráficamente expresiones que contengan polinomios
ortogonales se deben hacer dos cosas:
  1. Asignar a la variable opcional `orthopoly_returns_intervals' el
     valor `false',

  2. Comentar (con apóstrofo) las llamadas a las funciones de
     `orthopoly'.
        Si las llamadas a las funciones no se comentan, Maxima las
evalúa a polinomios antes de hacer el gráfico, por lo que el código
especializado en el cálculo numérico no es llamado. Aquí hay un ejemplo
de cómo se debe hacer para representar gráficamente una expresión que
contiene un polinomio de Legendre:

     (%i1) plot2d ('(legendre_p (5, x)), [x, 0, 1]),
           orthopoly_returns_intervals : false;
     (%o1)

   La expresión `legendre_p (5, x)' se comenta completamente, que no es
lo mismo que comentar el nombre de la función, como en `'legendre_p (5,
<x>)'.

69.1.5 Miscelánea de funciones
------------------------------

El paquete `orthopoly' define el símbolo de Pochhammer y la función de
escalón unidad en sentencias gradef.

   Para convertir los símbolos de Pochhammer en cocientes o funciones
gamma, hágase uso de `makegamma'.

     (%i1) makegamma (pochhammer (x, n));
                               gamma(x + n)
     (%o1)                     ------------
                                 gamma(x)
     (%i2) makegamma (pochhammer (1/2, 1/2));
                                     1
     (%o2)                       ---------
                                 sqrt(%pi)

   Las derivadas del símbolo de Pochhammer se dan en términos de la
función `psi'.

     (%i1) diff (pochhammer (x, n), x);
     (%o1)             (x)  (psi (x + n) - psi (x))
                          n     0             0
     (%i2) diff (pochhammer (x, n), n);
     (%o2)                   (x)  psi (x + n)
                                n    0

   Es necesario tener cuidado con la expresión en `(%o1)', pues la
diferencia de las funciones `psi' tiene polos cuando `<x> = -1, -2, ..,
-<n>'.  Estos polos se cancelan con factores de `pochhammer (<x>, <n>)'
haciendo que la derivada sea un polinomio de grado `<n> - 1' si <n> es
entero positivo.

   El símbolo de Pochhammer se define para órdenes negativos a través
de su representación como cociente de funciones gamma. Considérese

     (%i1) q : makegamma (pochhammer (x, n));
                               gamma(x + n)
     (%o1)                     ------------
                                 gamma(x)
     (%i2) sublis ([x=11/3, n= -6], q);
                                    729
     (%o2)                        - ----
                                    2240

   De forma alternativa, es posible llegar a este resultado
directamente.

     (%i1) pochhammer (11/3, -6);
                                    729
     (%o1)                        - ----
                                    2240

   La función de escalón unidad es continua por la izquierda; así,

     (%i1) [unit_step (-1/10), unit_step (0), unit_step (1/10)];
     (%o1)                       [0, 0, 1]

   En caso de ser necesaria una función escalón unidad que no sea
continua ni por la izquierda ni por la derecha en el origen, se puede
definir haciendo uso de `signum'; por ejemplo,

     (%i1) xunit_step (x) := (1 + signum (x))/2$

     (%i2) [xunit_step (-1/10), xunit_step (0), xunit_step (1/10)];
                                     1
     (%o2)                       [0, -, 1]
                                     2

   No se debe redefinir la función `unit_step', ya que parte del código
de `orthopoly' requiere que la función escalón sea continua por la
izquierda.

69.1.6 Algoritmos
-----------------

En general, el paquete `orthopoly' gestiona la evaluación simbólica a
través de la representación hipergeométrica de los polinomios
ortogonales. Las funciones hipergeométricas se evalúan utilizando las
funciones (no documentadas) `hypergeo11' y `hypergeo21'. Excepciones
son las funciones de Bessel de índice semi-entero y las funciones
asociadas de Legendre de segunda especie; las funciones de Bessel de
índice semi-entero se evalúan utilizando una representación explícita,
mientras que la función asociada de Legendre de segunda especie se
evalúa recursivamente.

   En cuanto a la evaluación numérica, la mayor parte de las funciones
se convierten a su forma hipergeométrica, evaluándolas mediante
recursión.  Además, las excepciones son las funciones de Bessel de
índice semi-entero y las funciones asociadas de Legendre de segunda
especie.  Las funciones de Bessel de índice semi-entero se evalúan
numéricamente con código SLATEC.


File: maxima.info,  Node: Funciones y variables para polinomios ortogonales,  Prev: Introducción a polinomios ortogonales,  Up: orthopoly

69.2 Funciones y variables para polinomios ortogonales
======================================================

 -- Función: assoc_legendre_p (<n>, <m>, <x>)
     Función asociada de Legendre de primera especie de grado <n> y
     orden <m>.

     Referencia: Abramowitz y Stegun, ecuaciones 22.5.37, página 779,
     8.6.6 (segunda ecuación), página 334 y  8.2.5, página 333.

 -- Función: assoc_legendre_q (<n>, <m>, <x>)
     Función asociada de Legendre de segunda especie de grado <n> y
     orden <m>.

     Referencia: Abramowitz y Stegun, ecuaciones 8.5.3 y 8.1.8.

 -- Función: chebyshev_t (<n>, <x>)
     Función de Chebyshev de primera especie.

     Referencia: Abramowitz y Stegun, ecuación 22.5.47, página 779.

 -- Función: chebyshev_u (<n>, <x>)
     Función de Chebyshev de segunda especie.

     Referencia: Abramowitz y Stegun, ecuación 22.5.48, página 779.

 -- Función: gen_laguerre (<n>, <a>, <x>)
     Polinomio de Laguerre generalizado de grado <n>.

     Referencia: Abramowitz y Stegun, ecuación 22.5.54, página 780.

 -- Función: hermite (<n>, <x>)
     Polinomio de Hermite.

     Referencia: Abramowitz y Stegun, ecuación 22.5.55, página 780.

 -- Función: intervalp (<e>)
     Devuelve `true' si la entrada es un intervalo y `false' en caso
     contrario.

 -- Función: jacobi_p (<n>, <a>, <b>, <x>)
     Polinomio de Jacobi.

     Los polinomios de Jacobi están definidos para todo <a> y <b>; sin
     embargo, el peso `(1 - <x>)^<a> (1 + <x>)^<b>' no es integrable
     para `<a> <= -1' o `<b> <= -1'.

     Referencia: Abramowitz y Stegun, ecuación 22.5.42, página 779.

 -- Función: laguerre (<n>, <x>)
     Polinomio de Laguerre.

     Referencia: Abramowitz y Stegun, ecuaciones 22.5.16 y 22.5.54,
     página 780.

 -- Función: legendre_p (<n>, <x>)
     Polinomio de Legendre de primera especie.

     Referencia: Abramowitz y Stegun, ecuaciones 22.5.50 y 22.5.51,
     página 779.

 -- Función: legendre_q (<n>, <x>)
     Polinomio de Legendre de segunda especie.

     Referencia: Abramowitz y Stegun, ecuaciones 8.5.3 y 8.1.8.

 -- Función: orthopoly_recur (<f>, <args>)
     Devuelve una relación recursiva para la familia de funciones
     ortogonales <f> con argumentos <args>. La recursión se hace con
     respecto al grado del polinomio.

          (%i1) orthopoly_recur (legendre_p, [n, x]);
                              (2 n + 1) P (x) x - n P     (x)
                                         n           n - 1
          (%o1)   P     (x) = -------------------------------
                   n + 1                   n + 1

     El segundo argumento de `orthopoly_recur' debe ser una lista con
     el número correcto de argumentos para la función <f>; si no lo es,
     Maxima emite un mensaje de error.

          (%i1) orthopoly_recur (jacobi_p, [n, x]);

          Function jacobi_p needs 4 arguments, instead it received 2
           -- an error.  Quitting.  To debug this try debugmode(true);

     Además, si <f> no es el nombre de ninguna de las familias de
     polinomios ortogonales, se emite otro mensaje de error.

          (%i1) orthopoly_recur (foo, [n, x]);

          A recursion relation for foo isn't known to Maxima
           -- an error.  Quitting.  To debug this try debugmode(true);

 -- Variable opcional: orthopoly_returns_intervals
     Valor por defecto: `true'

     Si `orthopoly_returns_intervals' vale `true', los números
     decimales en coma flotante se retornan con el formato `interval
     (<c>, <r>)', donde <c> es el centro del intervalo y <r> su radio.
     El centro puede ser un número complejo, en cuyo caso el intervalo
     es un disco en el plano complejo.

 -- Función: orthopoly_weight (<f>, <args>)
     Devuelve una lista con tres elementos; el primer elemento es la
     fórmula del peso para la familia de polinomios ortogonales <f> con
     los argumentos dados por la lista <args>; el segundo y tercer
     elementos son los extremos inferior y superior del intervalo de
     ortogonalidad. Por ejemplo,

          (%i1) w : orthopoly_weight (hermite, [n, x]);
                                      2
                                   - x
          (%o1)                 [%e    , - inf, inf]
          (%i2) integrate (w[1] * hermite (3, x) * hermite (2, x), x, w[2], w[3]);
          (%o2)                           0

     La variable principal de <f> debe ser un símbolo, en caso
     contrario Maxima emite un mensaje de error.

 -- Función: pochhammer (<n>, <x>)
     Símbolo de Pochhammer. Para enteros no negativos <n> con `<n> <=
     pochhammer_max_index', la expresión `pochhammer (<x>, <n>)' se
     evalúa como el producto `<x> (<x> + 1) (<x> + 2) ... (<x> + n -
     1)' si `<n> > 0' y como 1 si `<n> = 0'. Para <n> negativo,
     `pochhammer (<x>, <n>)' se define como `(-1)^<n> / pochhammer (1 -
     <x>, -<n>)'.  Así por ejemplo,

          (%i1) pochhammer (x, 3);
          (%o1)                   x (x + 1) (x + 2)
          (%i2) pochhammer (x, -3);
                                           1
          (%o2)               - -----------------------
                                (1 - x) (2 - x) (3 - x)

     A fin de convertir el símbolo de Pochhammer en un cociente de
     funciones gamma (véase Abramowitz y Stegun, ecuación 6.1.22),
     hágase uso de `makegamma'. Por ejemplo,

          (%i1) makegamma (pochhammer (x, n));
                                    gamma(x + n)
          (%o1)                     ------------
                                      gamma(x)

     Si <n> es mayor que `pochhammer_max_index' o si <n> es simbólico,
     `pochhammer' devuelve una forma nominal.

          (%i1) pochhammer (x, n);
          (%o1)                         (x)
                                           n

 -- Variable opcional: pochhammer_max_index
     Valor por defecto: 100

     `pochhammer (<n>, <x>)' se evalúa como un producto si y sólo si
     `<n> <= pochhammer_max_index'.

     Ejemplos:

          (%i1) pochhammer (x, 3), pochhammer_max_index : 3;
          (%o1)                   x (x + 1) (x + 2)
          (%i2) pochhammer (x, 4), pochhammer_max_index : 3;
          (%o2)                         (x)
                                           4

     Referencia: Abramowitz y Stegun, ecuación 6.1.16, página 256.

 -- Función: spherical_bessel_j (<n>, <x>)
     Función de Bessel esférica de primera especie.

     Referencia: Abramowitz y Stegun, ecuaciones 10.1.8, página 437 y
     10.1.15, página 439.

 -- Función: spherical_bessel_y (<n>, <x>)
     Función de Bessel esférica de segunda especie.

     Referencia: Abramowitz y Stegun, ecuaciones 10.1.9, página 437 y
     10.1.15, página 439.

 -- Función: spherical_hankel1 (<n>, <x>)
     Función esférica de Hankel de primera especie.

     Referencia: Abramowitz y Stegun, ecuación 10.1.36, página 439.

 -- Función: spherical_hankel2 (<n>, <x>)
     Función esférica de Hankel de segunda especie.

     Referencia: Abramowitz y Stegun, ecuación 10.1.17, página 439.

 -- Función: spherical_harmonic (<n>, <m>, <x>, <y>)
     Función armónica esférica.

     Referencia: Merzbacher 9.64.

 -- Función: unit_step (<x>)
     Función de escalón unidad continua por la izquierda, definida de
     tal forma que `unit_step (<x>)' se anula para `<x> <= 0' y es
     igual a 1 para `<x> > 0'.

     En caso de ser necesaria una función escalón unidad que tome el
     valor 1/2 en el origen, utilícese `(1 + signum (<x>))/2'.

 -- Función: ultraspherical (<n>, <a>, <x>)
     Polinomio ultraesférico o de Gegenbauer.

     Referencia: Abramowitz y Stegun, ecuación 22.5.46, página 779.


File: maxima.info,  Node: plotdf,  Next: romberg,  Prev: orthopoly,  Up: Top

70 plotdf
*********

* Menu:

* Introducción a plotdf::
* Funciones y variables para plotdf::


File: maxima.info,  Node: Introducción a plotdf,  Next: Funciones y variables para plotdf,  Prev: plotdf,  Up: plotdf

70.1 Introducción a plotdf
==========================

La función `plotdf' crea un gráfico del campo de direcciones para una
Ecuación Diferencial Ordinaria (EDO) de primer orden, o para un sistema
de dos EDO's autónomas, de primer orden.

   Como se trata de un paquete adicional, para poder usarlo debe
cargarlo primero con el comando `load("plotdf")'. También es necesario
que Xmaxima esté instalado, a pesar de que ejecute Maxima desde otra
interface diferente.

   Para dibujar el campo de direcciones de una única EDO, esa ecuación
deberá escribirse en la forma siguiente:
            dy
            -- = F(x,y)
            dx

   y la función <F> será dada como argumento para el comando `plotdf'.
La variable independiente tiene que ser siempre <x> y la variable
dependiente <y>. A esas dos variables no podrá estar asociado ningún
valor numérico.

   Para dibujar el campo de direcciones de un sistema autónomo de dos
EDO's, Las dos ecuaciones deben ser escritas en la forma siguiente
            dx             dy
            -- = G(x,y)    -- = F(x,y)
            dt             dt

   y el argumento para el comando `plotdf' será una lista con dos
expresiones para las funciones <F> y <G>.

   Cuando se trabaja con una única ecuación, `plotdf' asume
implícitamente que `x=t' y `G(x,y)=1', transformando la ecuación en un
sistema autónomo con dos ecuaciones.


File: maxima.info,  Node: Funciones y variables para plotdf,  Prev: Introducción a plotdf,  Up: plotdf

70.2 Funciones y variables para plotdf
======================================

 -- Function: plotdf (<dydx>,...opciones...)
 -- Function: plotdf (`['<dxdt>,<dydt>`]',...opciones...)
     Dibuja un campo de direcciones en dos dimensiones <x> y <y>.

     <dydx>, <dxdt> y <dydt> son expresiones que dependen de <x> y <y>.
     Además de esas dos variables, las dos expresiones pueden depender
     de un conjunto de parámetros, con valores numéricos que son dados
     por medio de la opción `parameters' (la sintaxis de esa opción se
     explica mas al frente), o con un rango de posibles valores
     definidos con la opción <sliders>.

     Varias otras opciones se pueden incluir dentro del comando, o
     seleccionadas en el menú.  Haciendo click en un punto del gráfico
     se puede hacer que sea dibujada la curva integral que pasa por ese
     punto; lo mismo puede ser hecho dando las coordenadas del punto
     con la opción `trajectory_at' dentro del comando plotdf. La
     dirección de integración se puede controlar con la opción
     `direction', que acepta valores de _forward_, _backward_ ou
     _both_. El número de pasos realizado en la integración numérica se
     controla con la opción `nsteps' y el incremento del tiempo en cada
     paso con la opción `tstep'. Se usa el método de Adams Moulton para
     hacer la integración numérica; también es posible cambiar para el
     método de Runge-Kutta de cuarto orden con ajuste de pasos.

     Menú de la ventana del gráfico:

     El menú de la ventana gráfica dispone de las siguientes opciones:
     _Zoom_, que permite cambiar el comportamiento del ratón, de manera
     que hará posible el hacer zoom en la región del gráfico haciendo
     clic con el botón izquierdo. Cada clic agranda la imagen
     manteniendo como centro de la misma el punto sobre el cual se ha
     hecho clic. Manteniendo pulsada la tecla <Shift> mientras se hace
     clic, retrocede al tamaño anterior. Para reanudar el cálculo de las
     trayectorias cuando se hace clic, seleccine la opción _Integrate_
     del menú.

     La opción _Config_ del menú se puede utilizar para cambiar la(s)
     EDO(S) y algunos otros ajustes. Después de hacer los cambios, se
     debe utilizar la opción _Replot_ para activar los nuevos ajustes.
     Si en el campo _Trajectory at_ del menú de diálogo de _Config_ se
     introducen un par de coordenadas y luego se pulsa la tecla
     <retorno>, se mostrará una nueva curva integral, además de las ya
     dibujadas.  Si se selecciona la opción _Replot_, sólo se mostrará
     la última curva integral seleccionada.

     Manteniendo pulsado el botón derecho del ratón mientras se mueve el
     cursor, se puede arrastrar el gráfico horizontal y verticalmente.
     Otros parámetros, como pueden ser el número de pasos, el valor
     inicial de <t>, las coordenadas del centro y el radio, pueden
     cambiarse en el submenú de la opción _Config_.

     Con la opción _Save_, se puede obtener una copia del gráfico en
     una impresora Postscript o guardarlo en un fichero Postscript. Para
     optar entre la impresión o guardar en fichero, se debe seleccionar
     _Print Options_ en la ventana de diálogo de _Config_. Una vez
     cubiertos los campos de la ventana de diálogo de _Save_, será
     necesario seleccionar la opción _Save_ del primer menú para crear
     el fichero o imprimir el gráfico.

     Opciones gráficas:

     La función `plotdf' admite varias opciones, cada una de las cuales
     es una lista de dos o más elementos. El primer elemento es el
     nombre de la opción, y el resto está formado por el valor o
     valores asignados a dicha opción.

     La función `plotdf' reconoce las siguientes opciones:

        * "tstep" establece la amplitud de los incrementos en la
          variable independiente <t>, utilizados para calcular la curva
          integral. Si se aporta sólo una expresión <dydx>, la variable
          <x> será directamente proporcional a <t>.  El valor por
          defecto es 0.1.

        * "nsteps" establece el número de pasos de longitud `tstep' que
          se utilizarán en la variable independiente para calcular la
          curva integral.  El valor por defecto es 100.

        * "direction" establece la dirección de la variable
          independiente que será seguida para calcular una curva
          integral.  Valores posibles son: `forward', para hacer que la
          variable independiente aumente `nsteps' veces, con
          incrementos `tstep'; `backward', para hacer que la variable
          independiente disminuya; `both', para extender la curva
          integral `nsteps' pasos hacia adelante y `nsteps' pasos hacia
          atrás.  Las palabras `right' y `left' se pueden utilizar como
          sinónimos de `forward' y `backward'.  El valor por defecto es
          `both'.

        * "tinitial" establece el valor inicial de la variable <t>
          utilizado para calcular curvas integrales. Puesto que las
          ecuaciones diferenciales son autónomas, esta opción sólo
          aparecerá en los gráficos de las curvas como funciones de <t>.
          El valor por defecto es 0.

        * "versus_t" se utiliza para crear una segunda ventana gráfica,
          con el gráfico de una curva integral, como dos funciones <x>,
          <y>, de variable independiente <t>. Si se le da a `versus_t'
          cualquier valor diferente de 0, se mostrará la segunda
          ventana gráfica, la cual incluye otro menú, similar al de la
          ventana principal.  El valor por defecto es 0.

        * "trajectory_at" establece las coordenadas <xinitial> y
          <yinitial> para el extremo inicial de la curva integral.  No
          tiene asignado valor por defecto.

        * "parameters" establece una lista de parámetros, junto con sus
          valores numéricos, que son utilizados en la definición de la
          ecuación diferencial. Los nombres de los parámetros y sus
          valores deben escribirse en formato de cadena de caracteres
          como una secuencia de pares `nombre=valor' separados por
          comas.

        * "sliders" establece una lista de parámetros que se cambiarán
          interactivamente utilizando barras de deslizamiento, así como
          los rangos de variación de dichos parámetros.  Los nombres de
          los parámetros y sus rangos deben escribirse en formato de
          cadena de caracteres como una secuencia de pares
          `nombre=min:max' separados por comas.

        * "xfun" establece una cadena de caracteres con funciones de
          <x> separadas por puntos y comas para ser representadas por
          encima del campo de direcciones. Estas funciones serán
          interpretadas por Tcl, no por Maxima.

        * "xradius" es la mitad de la longitud del rango de valores a
          representar en la dirección x.  El valor por defecto es 10.

        * "yradius" es la mitad de la longitud del rango de valores a
          representar en la dirección y.  El valor por defecto es 10.

        * "xcenter" es la coordenada x del punto situado en el centro
          del gráfico.  El valor por defecto es 0.

        * "ycenter" es la coordenada y del punto situado en el centro
          del gráfico.  El valor por defecto es 0.

        * "width" establece el ancho de la ventana gráfica en píxeles.
          El valor por defecto es 500.

        * "height" establece la altura de la ventana gráfica en píxeles.
          El valor por defecto es 500.


     Ejemplos:

     NOTA: Dependiendo de la interface que se use para Maxima, las
     funciones que usan `openmath', incluida `plotdf', pueden
     desencadenar un fallo si terminan en punto y coma, en vez del
     símbolo de dólar. Para evitar problemas, se usará el símbolo de
     dólar en todos ejemplos.

        * Para mostrar el campo de direcciones de la ecuación
          diferencial y' = exp(-x) + y y la solución que pasa por (2,
          -0.1):
               (%i1) load("plotdf")$

               (%i2) plotdf(exp(-x)+y,[trajectory_at,2,-0.1]);

        * Para mostrar el campo de direcciones de la ecuación diff(y,x)
          = x - y^2 y la solución de condición inicial y(-1) = 3, se
          puede utilizar la sentencia:
               (%i3) plotdf(x-y^2,[xfun,"sqrt(x);-sqrt(x)"],
                         [trajectory_at,-1,3], [direction,forward],
                         [yradius,5],[xcenter,6]);
          El gráfico también muestra la función y = sqrt(x).

        * El siguiente ejemplo muestra el campo de direcciones de un
          oscilador armónico, definido por las ecuaciones dx/dt = y y
          dy/dt = -k*x/m, y la curva integral que pasa por (x,y) =
          (6,0), con una barra de deslizamiento que permitirá cambiar
          el valor de m interactivamente (k permanece fijo a 2):
               (%i4) plotdf([y,-k*x/m],[parameters,"m=2,k=2"],
                           [sliders,"m=1:5"], [trajectory_at,6,0]);

        * Para representar el campo de direcciones de la ecuación de
          Duffing, m*x"+c*x'+k*x+b*x^3 = 0, se introduce la variable
          y=x' y se hace:
               (%i5) plotdf([y,-(k*x + c*y + b*x^3)/m],
                             [parameters,"k=-1,m=1.0,c=0,b=1"],
                             [sliders,"k=-2:2,m=-1:1"],[tstep,0.1]);

        * El campo de direcciones de un péndulo amortiguado, incluyendo
          la solución para condiciones iniciales dadas, con una barra
          de deslizamiento que se puede utilizar para cambiar el valor
          de la masa, m, y con el gráfico de las dos variables de
          estado como funciones del tiempo:

               (%i6) plotdf([y,-g*sin(x)/l - b*y/m/l],
                        [parameters,"g=9.8,l=0.5,m=0.3,b=0.05"],
                        [trajectory_at,1.05,-9],[tstep,0.01],
                        [xradius,6],[yradius,14],
                        [xcenter,-4],[direction,forward],[nsteps,300],
                        [sliders,"m=0.1:1"], [versus_t,1]);




File: maxima.info,  Node: romberg,  Next: simplex,  Prev: plotdf,  Up: Top

71 romberg
**********

* Menu:

* Funciones y variables para romberg::


File: maxima.info,  Node: Funciones y variables para romberg,  Prev: Top,  Up: Top

71.1 Funciones y variables para romberg
=======================================

 -- Función: romberg (<expr>, <x>, <a>, <b>)
 -- Función: romberg (<F>, <a>, <b>)
     Integra numéricamente por el método de Romberg.

     La llamada `romberg(<expr>, <x>, <a>, <b>)' devuelve una
     estimación de la integral `integrate(<expr>, <x>, <a>, <b>)'.  El
     argumento <expr> debe ser una expresión reducible a un valor
     decimal en coma flotante cuando <x> es a su vez un número decimal.

     La llamada `romberg(<F>, <a>, <b>)' devuelve una estimación de la
     integral `integrate(<F>(x), x, <a>, <b>)', siendo `x' el único
     argumento de <F>. El argumento <F> debe ser una función en Lisp o
     en Maxima que devuelva un valor decimal en coma flotante cuando
     <x> es a su vez un número decimal; <F> puede ser el nombre de una
     función de Maxima traducida o compilada.

     La exactitud de `romberg' se controla con las variables globales
     `rombergabs' y `rombergtol'. La función `romberg' termina con
     éxito su cálculo cuando la diferencia absoluta entre sucesivas
     aproximaciones es menor que `rombergabs', o cuando la diferencia
     relativa de sucesivas aproximaciones es menor que `rombergtol'.
     Así, cuando `rombergabs' vale 0.0 (su valor por defecto) sólo
     tiene efecto el test del error relativo basado en `romberg'.

     La función `romberg' reduce a mitades sucesivas la amplitud del
     paso un máximo de `rombergit' veces antes de abandonar el cómputo;
     el número máximo de evaluaciones del integrando es, por
     consiguiente, igual a `2^rombergit'.  De no satisfacerse el
     criterio de error establecido por `rombergabs' y `rombergtol',
     `romberg' devuelve un mensaje de error.  La función `romberg' hace
     siempre al menos `rombergmin' iteraciones; se trata de una
     heurística para evitar la finalización prematura cuando el
     integrando oscila mucho.

     La función `romberg' evalúa el integrando repetidamente tras
     asignarle a la variable de integración un valor específico. Este
     criterio permite anidar llamadas a `romberg' para calcular
     integrales múltiples.  Sin embargo, los errores de cálculo no
     tienen en cuenta los errores de las integraciones anidadas, por lo
     que tales errores pueden subestimarse.  Por otro lado, métodos
     especialmente desarrollados para integraciones múltiples pueden
     dar la misma exactitud con menos evaluaciones del integrando.

     Para hacer uso de esta función ejecútese primero `load(romberg)'.

     Véase también `QUADPACK', un conjunto de funciones para
     integración numérica.

     Ejemplos:

     Una integración unidimensional.

          (%i1) load (romberg);
          (%o1)    /usr/share/maxima/5.11.0/share/numeric/romberg.lisp
          (%i2) f(x) := 1/((x - 1)^2 + 1/100) + 1/((x - 2)^2 + 1/1000)
                          + 1/((x - 3)^2 + 1/200);
                              1                 1                1
          (%o2) f(x) := -------------- + --------------- + --------------
                               2    1           2    1            2    1
                        (x - 1)  + ---   (x - 2)  + ----   (x - 3)  + ---
                                   100              1000              200
          (%i3) rombergtol : 1e-6;
          (%o3)                 9.9999999999999995E-7
          (%i4) rombergit : 15;
          (%o4)                          15
          (%i5) estimate : romberg (f(x), x, -5, 5);
          (%o5)                   173.6730736617464
          (%i6) exact : integrate (f(x), x, -5, 5);
          (%o6) 10 sqrt(10) atan(70 sqrt(10))
           + 10 sqrt(10) atan(30 sqrt(10)) + 10 sqrt(2) atan(80 sqrt(2))
           + 10 sqrt(2) atan(20 sqrt(2)) + 10 atan(60) + 10 atan(40)
          (%i7) abs (estimate - exact) / exact, numer;
          (%o7)                7.5527060865060088E-11

     Una integración bidimensional, implementada mediante llamadas
     anidadas a `romberg'.

          (%i1) load (romberg);
          (%o1)    /usr/share/maxima/5.11.0/share/numeric/romberg.lisp
          (%i2) g(x, y) := x*y / (x + y);
                                              x y
          (%o2)                   g(x, y) := -----
                                             x + y
          (%i3) rombergtol : 1e-6;
          (%o3)                 9.9999999999999995E-7
          (%i4) estimate : romberg (romberg (g(x, y), y, 0, x/2), x, 1, 3);
          (%o4)                   0.81930239628356
          (%i5) assume (x > 0);
          (%o5)                        [x > 0]
          (%i6) integrate (integrate (g(x, y), y, 0, x/2), x, 1, 3);
                                                    3
                                              2 log(-) - 1
                              9                     2        9
          (%o6)       - 9 log(-) + 9 log(3) + ------------ + -
                              2                    6         2
          (%i7) exact : radcan (%);
                              26 log(3) - 26 log(2) - 13
          (%o7)             - --------------------------
                                          3
          (%i8) abs (estimate - exact) / exact, numer;
          (%o8)                1.3711979871851024E-10


 -- Variable opcional: rombergabs
     Valor por defecto: 0.0

     La exactitud de `romberg' se controla con las variables globales
     `rombergabs' y `rombergtol'. La función `romberg' termina con
     éxito su cálculo cuando la diferencia absoluta entre sucesivas
     aproximaciones es menor que `rombergabs', o cuando la diferencia
     relativa de sucesivas aproximaciones es menor que `rombergtol'.
     Así, cuando `rombergabs' vale 0.0 (su valor por defecto) sólo
     tiene efecto el test del error relativo basado en `romberg'.

     Véanse también `rombergit' y `rombergmin'.


 -- Variable opcional: rombergit
     Valor por defecto: 11

     La función `romberg' reduce a mitades sucesivas la amplitud del
     paso un máximo de `rombergit' veces antes de abandonar el cómputo;
     el número máximo de evaluaciones del integrando es, por
     consiguiente, igual a `2^rombergit'.  La función `romberg' hace
     siempre al menos `rombergmin' iteraciones; se trata de una
     heurística para evitar la finalización prematura cuando el
     integrando oscila mucho.

     Véanse también `rombergabs' y `rombergtol'.


 -- Variable opcional: rombergmin
     Valor por defecto: 0

     La función `romberg' hace siempre al menos `rombergmin'
     iteraciones; se trata de una heurística para evitar la
     finalización prematura cuando el integrando oscila mucho.

     Véanse también `rombergit', `rombergabs' y `rombergtol'.


 -- Variable opcional: rombergtol
     Valor por defecto: 1e-4

     La exactitud de `romberg' se controla con las variables globales
     `rombergabs' y `rombergtol'. La función `romberg' termina con
     éxito su cálculo cuando la diferencia absoluta entre sucesivas
     aproximaciones es menor que `rombergabs', o cuando la diferencia
     relativa de sucesivas aproximaciones es menor que `rombergtol'.
     Así, cuando `rombergabs' vale 0.0 (su valor por defecto) sólo
     tiene efecto el test del error relativo basado en `romberg'.

     Véanse también `rombergit' y `rombergmin'.



File: maxima.info,  Node: simplex,  Next: simplification,  Prev: romberg,  Up: Top

72 simplex
**********

* Menu:

* Introducción a simplex::
* Funciones y variables para simplex::


File: maxima.info,  Node: Introducción a simplex,  Next: Funciones y variables para simplex,  Prev: simplex,  Up: simplex

72.1 Introducción a simplex
===========================

El paquete `simplex' utiliza el algoritmo simplex para programación
lineal.

   Ejemplo:

     (%i1) load("simplex")$
     (%i2) minimize_lp(x+y, [3*x+2*y>2, x+4*y>3]);
                            9        7       1
     (%o2)                 [--, [y = --, x = -]]
                            10       10      5


File: maxima.info,  Node: Funciones y variables para simplex,  Prev: Introducción a simplex,  Up: simplex

72.2 Funciones y variables para simplex
=======================================

 -- Variable opcional: epsilon_lp
     Valor por defecto: `10^-8'

     Error epsilon utilizado en los cálculos numéricos de
     `linear_program'.

     Véase también `linear_program'.


 -- Función: linear_program (<A>, <b>, <c>)
     La función `linear_program' es una implementación del algoritmo
     simplex. La instrucción `linear_program(A, b, c)' calcula un
     vector <x> tal que minimiza `c.x' bajo las restricciones `A.x = b'
     y `x >= 0'. El argumento <A> es una matriz y los argumentos <b> y
     <c> son listas.

     La función `linear_program' devuelve una lista que contiene el
     vector solución <x> y el valor mínimo de `c.x'.  Si el problema no
     está acotado, devuelve el mensaje "Problem not bounded!"  y si el
     problema no es factible, devuelve el mensaje "Problem not
     feasible!".

     Para usar esta función, cárguese primero el paquete con la
     instrucción `load(simplex);'.

     Ejemplo:

          (%i2) A: matrix([1,1,-1,0], [2,-3,0,-1], [4,-5,0,0])$
          (%i3) b: [1,1,6]$
          (%i4) c: [1,-2,0,0]$
          (%i5) linear_program(A, b, c);
                             13     19        3
          (%o5)            [[--, 4, --, 0], - -]
                             2      2         2

     Véanse también `minimize_lp', `scale_lp' y `epsilon_lp'.


 -- Función: maximize_lp (<obj>, <cond>, [<pos>])
     Maximiza la función objetivo lineal <obj> sujeta a ciertas
     restricciones lineales <cond>. Véase `minimize_lp' para una
     descripción detallada de los argumentos y de la respuesta dada por
     esta función.


 -- Función: minimize_lp (<obj>, <cond>, [<pos>])
     Minimiza la función objetivo lineal <obj> sujeta a ciertas
     restricciones lineales <cond>, siendo ésta una lista de ecuaciones
     o inecuaciones lineales.  En las inecuaciones estrictas se
     reemplaza `>' por `>=' y `<' por `<='. El argumento opcional <pos>
     es una lista de variables de decisión que se suponen positivas.

     Si el mínimo existe, `minimize_lp' devuelve una lista que contiene
     el valor mínimo de la función objetivo y una lista de valores para
     las variables de decisión con los que se alcanza el mínimo.  Si el
     problema no está acotado, devuelve el mensaje "Problem not
     bounded!"  y si el problema no es factible, devuelve el mensaje
     "Problem not feasible!".

     Las variables de decisión no se suponen no negativas. Si todas las
     variables de decisión son no negativas, asígnese el valor `true' a
     la variable `nonegative_lp'. Si sólo algunas de las variables de
     decisión son positivas, lístense en el argumento opcional <pos>,
     lo cual es más eficiente que añadir restricciones.

     La función `minimize_lp' utiliza el algoritmo simplex implementado
     en la función `linear_program' de Maxima.

     Para usar esta función, cárguese primero el paquete con la
     instrucción `load(simplex);'.

     Ejemplos:

          (%i1) minimize_lp(x+y, [3*x+y=0, x+2*y>2]);
                                4       6        2
          (%o1)                [-, [y = -, x = - -]]
                                5       5        5
          (%i2) minimize_lp(x+y, [3*x+y>0, x+2*y>2]), nonegative_lp=true;
          (%o2)                [1, [y = 1, x = 0]]
          (%i3) minimize_lp(x+y, [3*x+y=0, x+2*y>2]), nonegative_lp=true;
          (%o3)                Problem not feasible!
          (%i4) minimize_lp(x+y, [3*x+y>0]);
          (%o4)                Problem not bounded!

     Véanse también `maximize_lp', `nonegative_lp' y `epsilon_lp'.


 -- Variable opcional: nonegative_lp
     Valor por defecto: `false'

     Si `nonegative_lp' vale `true' todas las variables de decisión
     pasadas a `minimize_lp' y a `maximize_lp' se suponen positivas.

     Véase también `minimize_lp'.



File: maxima.info,  Node: simplification,  Next: solve_rec,  Prev: simplex,  Up: Top

73 simplification
*****************

* Menu:

* Introducción a simplification::
* Paquete absimp::
* Paquete facexp::
* Paquete functs::
* Paquete ineq::
* Paquete rducon::
* Paquete scifac::
* Paquete sqdnst::


File: maxima.info,  Node: Introducción a simplification,  Next: Paquete absimp,  Prev: simplification,  Up: simplification

73.1 Introducción a simplification
==================================

El directorio `maxima/share/simplification' contiene programas que
implementan algunas reglas y funciones para simplificar expresiones,
así como ciertas funciones no relacionadas con la simplificación.


File: maxima.info,  Node: Paquete absimp,  Next: Paquete facexp,  Prev: Introducción a simplification,  Up: simplification

73.2 Paquete absimp
===================

El paquete `absimp' contiene reglas para aplicar patrones que extienden
el sistema de reglas nativo de Maxima para las funciones `abs' y
`signum', respetando las relaciones establecidas con la función
`assume' o con declaraciones tales como `modedeclare (m, even, n, odd)'
para enteros pares o impares.

   En el paquete `absimp' se definen las funciones `unitramp' y
`unitstep' en términos de `abs' y `signum'.

   La instrucción `load (absimp)' carga este paquete y `demo (absimp)'
desarrolla una demostración sobre el uso del mismo.

   Ejemplos:

     (%i1) load (absimp)$
     (%i2) (abs (x))^2;
                                            2
     (%o2)                                 x
     (%i3) diff (abs (x), x);
                                           x
     (%o3)                               ------
                                         abs(x)
     (%i4) cosh (abs (x));
     (%o4)                               cosh(x)


File: maxima.info,  Node: Paquete facexp,  Next: Paquete functs,  Prev: Paquete absimp,  Up: simplification

73.3 Paquete facexp
===================

El paquete `facexp' contiene varias funciones que le aportan al usuario
la posibilidad de estructurar expresiones controlando su expansión.
Esta capacidad es especialmente útil cuando la expresión contiene
variables con significado físico, ya que se suele dar el caso de que la
forma más sencilla para estas expresiones se obtiene cuando se expanden
respecto de estas variables y luego se factoriza respecto de sus
coeficientes. Si bien es cierto que este procedimiento no es difícil de
llevar a cabo con las funciones estándar de Maxima, pueden ser
necesarios algunos retoques adicionales que sí pueden ser más difíciles
de hacer.

   La función `facsum' y sus formas relacionadas proporcionan un método
para controlar la estructura de expresiones. La función `collectterms'
puede usarse para añadir dos o más expresiones que ya hayan sido
simplificadas de la forma indicada, sin necesidad de volver a
simplificar la expresión completa.  Esta función puede ser útil cuando
las expresiones sean largas.

   La instrucción `load (facexp)' carga este paquete y `demo (facexp)'
hace una demostración sobre su uso.

 -- Función: facsum (<expr>, <arg_1>, ..., <arg_n>)
     Devuelve una expresión equivalente a <expr>, la cual depende de
     los argumentos <arg_1>, ..., <arg_n>, y éstos pueden ser de
     cualquiera de las formas aceptables para `ratvars', o listas de
     estas formas. Si los argumentos no son listas, la forma devuelta
     se expande completamente con respecto de los argumentos, siendo los
     coeficientes de tales argumentos factorizados. Estos coeficientes
     no contienen a ninguno de los argumentos, excepto quizás de una
     forma no racional.

     En caso de que cualquiera de los argumentos sea una lista, entonces
     todos ellos se combinan en una única lista, y en lugar de llamar a
     `factor' para los coeficientes de los argumentos, `facsum' se
     llama a sí misma utilizando esta nueva lista única como lista de
     argumentos.

     Es posible que se quiera utilizar `facsum' con respecto a
     expresiones más complicadas, tales como `log (x + y)'. Estos
     argumentos son también admisibles.

     En ocasiones puede ser necesario obtener cualquiera de las formas
     anteriores especificadas por sus operadores principales. Por
     ejemplo, se puede querer aplicar `facsum' con respecto a todos los
     `log'; en este caso, se puede incluir entre los argumentos bien
     los `log' específicos que se quieran tratar de esta manera, bien
     la expresión `operator (log)' o `'operator (log)'.  Si se quiere
     aplicar `facsum' a <expr> con respecto a los operadores <op_1>,
     ..., <op_n>, se debe evaluar `facsum (<expr>, operator (<op_1>,
     ..., <op_n>))'.  La forma `operator' puede aparecer también dentro
     de las listas de argumentos.

     Además, dándole valores a las variables opcionales `facsum_combine'
     y `nextlayerfactor' se puede controlar el resultado de `facsum'.

 -- Variable global: nextlayerfactor
     Valor por defecto: `false'

     Si `nextlayerfactor' vale `true', las llamadas recursivas de
     `facsum' se aplican a los factores de la forma factorizada de los
     coeficientes de los argumentos.

     Si vale `false', `facsum' se aplica a cada coeficiente como un
     todo cada vez que se efectúen llamadas recursivas a `facsum'.

     La inclusión del átomo `nextlayerfactor' en la lista de argumentos
     de `facsum' tiene el mismo efecto que `nextlayerfactor: true',
     pero solamente para el siguiente nivel de la expresión. Puesto que
     `nextlayerfactor' toma siempre uno de los valores `true' o
     `false', debe aparecer comentado (comilla simple) cada vez que
     aparezca en la lista de argumentos de `facsum'.

 -- Variable global: facsum_combine
     Valor por defecto: `true'

     La variable `facsum_combine' controla la forma del resultado final
     devuelto por `facsum' si su argumento es un cociente de polinomios.
     Si `facsum_combine' vale `false', el resultado será una suma
     completamente expandida, pero si vale `true', la expresión devuelta
     es un cociente de polinomios.


 -- Función: factorfacsum (<expr>, <arg_1>, ... <arg_n>)
     Devuelve una expresión equivalente a <expr> obtenida aplicando
     `facsum' a los factores de <expr>, de argumentos <arg_1>, ...
     <arg_n>. Si alguno de los factores de <expr> se eleva a una
     potencia, tanto el factor como el exponente se procesarán de esta
     manera.

 -- Función: collectterms (<expr>, <arg_1>, ..., <arg_n>)
     Si algunas expresiones fueron ya simplificadas con `facsum',
     `factorfacsum', `factenexpand',  `facexpten' o `factorfacexpten',
     debiendo ser luego sumadas, puede ser conveniente combinarlas
     utilizando la función `collecterms', la cual admite como
     argumentos todos aquéllos que se puedan pasar a las anteriormente
     citadas funciones, con la excepción de `nextlayerfactor', que no
     tiene efecto alguno sobre `collectterms'.  La ventaja de
     `collectterms' es que devuelve una forma similar a la de `facsum',
     pero debido a que suma expresiones que ya han sido previamente
     procesadas, no necesita repetir esta operación, lo cual resulta
     ser especialmente útil cuando las expresiones a sumar son muy
     grandes.


File: maxima.info,  Node: Paquete functs,  Next: Paquete ineq,  Prev: Paquete facexp,  Up: simplification

73.4 Paquete functs
===================

 -- Función: rempart (<expr>, <n>)
     Elimina la parte <n> de la expresión <expr>.

     Si <n> es una lista de la forma `[<l>, <m>]', entonces las partes
     desde <l> a <m> serán eliminadas.

     Para hacer uso de esta función ejecutar `load(functs)'.

 -- Función: wronskian ([<f_1>, ..., <f_n>], <x>)
     Devuelve la matriz wronskiana de las expresiones <f_1>, ..., <f_n>
     dependeientes de la variable <x>.  El determinante de la matriz
     wronskiana es el determinante wronskiano de la lista de
     expresiones.

     Para hacer uso de esta función ejecutar `load(functs)'.

     Ejemplo:

          (%i1) load(functs)$
          (%i2) wronskian([f(x), g(x)],x);
          (%o2) matrix([f(x),g(x)],['diff(f(x),x,1),'diff(g(x),x,1)])

 -- Función: tracematrix (<M>)
     Devuelve la traza (suma de los elementos de la diagonal) de la
     matriz <M>.

     Para hacer uso de esta función ejecutar `load(functs)'.

 -- Función: rational (<z>)
     Multiplica el numerador y denominador de <z> por el complejo
     conjugado del denominador, racionalizando así el denominador.
     Devuelve la expresión canónica racional (canonical rational
     expression, CRE) si el argumento <z> es de esta forma, en caso
     contrario devuelve una expresión en formato común.

     Para hacer uso de esta función ejecutar `load(functs)'.

 -- Función: logand (<x>,<y>)
     Devuelve el "y" lógico binario de los argumentos <x> e <y>.

     Para hacer uso de esta función ejecutar `load(functs)'.

 -- Función: logor (<x>,<y>)
     Devuelve el "o" lógico binario de los argumentos <x> e <y>.

     Para hacer uso de esta función ejecutar `load(functs)'.

 -- Función: logxor (<x>,<y>)
     Devuelve el "o-excusivo" lógico binario de los argumentos <x> e
     <y>.

     Para hacer uso de esta función ejecutar `load(functs)'.

 -- Función: nonzeroandfreeof (<x>, <expr>)
     Devuelve `true' si <expr> es diferente de cero y `freeof (<x>,
     <expr>)' devuelve `true'.  En caso contrario devuelve `false'.

     Para hacer uso de esta función ejecutar `load(functs)'.

 -- Función: linear (<expr>, <x>)
     Si <expr> es una expresión lineal respecto de la variable <x>,
     `linear' devuelve `<a>*<x> + <b>', siendo <a> no nula y, junto con
     <b>, no incluye a <x>. En otro caso, `linear' devuelve <expr>.

     Para hacer uso de esta función ejecutar `load(functs)'.

 -- Función: gcdivide (<p>, <q>)
     Si `takegcd' vale `true', que es su valor por defecto, `gcdivide'
     divide los polinomios <p> y <q> por su máximo común divisor y
     devuelve el cociente de los resultados.  `gcdivide' hace una
     llamada a la función `ezgcd' para dividir los polinomios por su
     máximo común divisor.

     Si `takegcd' vale `false', `gcdivide' devuelve el cociente
     `<p>/<q>'.

     Para hacer uso de esta función ejecutar `load(functs)'.

     Véanse también  `ezgcd', `gcd', `gcdex' y `poly_gcd'.

     Ejemplos:

          (%i1) load(functs)$

          (%i2) p1:6*x^3+19*x^2+19*x+6;
                                  3       2
          (%o2)                6 x  + 19 x  + 19 x + 6
          (%i3) p2:6*x^5+13*x^4+12*x^3+13*x^2+6*x;
                            5       4       3       2
          (%o3)          6 x  + 13 x  + 12 x  + 13 x  + 6 x
          (%i4) gcdivide(p1, p2);
                                       x + 1
          (%o4)                        ------
                                        3
                                       x  + x
          (%i5) takegcd:false;
          (%o5)                         false
          (%i6) gcdivide(p1, p2);
                                 3       2
                              6 x  + 19 x  + 19 x + 6
          (%o6)          ----------------------------------
                            5       4       3       2
                         6 x  + 13 x  + 12 x  + 13 x  + 6 x
          (%i7) ratsimp(%);
                                       x + 1
          (%o7)                        ------
                                        3
                                       x  + x

 -- Función: arithmetic (<a>, <d>, <n>)
     Devuelve el <n>-ésimo término de la progresión aritmética `<a>,
     <a> + <d>, <a> + 2*<d>, ..., <a> + (<n> - 1)*<d>'.

     Para hacer uso de esta función ejecutar `load(functs)'.

 -- Función: geometric (<a>, <r>, <n>)
     Devuelve el <n>-ésimo término de la progresión geométrica `<a>,
     <a>*<r>, <a>*<r>^2, ..., <a>*<r>^(<n> - 1)'.

     Para hacer uso de esta función ejecutar `load(functs)'.

 -- Función: harmonic (<a>, <b>, <c>, <n>)
     Devuelve el <n>-ésimo término de la progresión armónica `<a>/<b>,
     <a>/(<b> + <c>), <a>/(<b> + 2*<c>), ..., <a>/(<b> + (<n> -
     1)*<c>)'.

     Para hacer uso de esta función ejecutar `load(functs)'.

 -- Función: arithsum (<a>, <d>, <n>)
     Devuelve la suma de la progresión aritmética desde hasta el
     <n>-ésimo término.

     Para hacer uso de esta función ejecutar `load(functs)'.

 -- Función: geosum (<a>, <r>, <n>)
     Devuelve la suma de la sucesión geométrica hasta el <n>-ésimo
     término.  Si <n> es infinito (`inf') la suma será finita sólo si
     el valor absoluto de <r> es menor que 1.

     Para hacer uso de esta función ejecutar `load(functs)'.

 -- Función: gaussprob (<x>)
     Devuelve la función de densidad de probabilidad, normal
     `%e^(-<x>^2/2) / sqrt(2*%pi)'.

     Para hacer uso de esta función ejecutar `load(functs)'.

 -- Función: gd (<x>)
     Devuelve la función de Gudermann, `2*atan(%e^x)-%pi/2'.

     Para hacer uso de esta función ejecutar `load(functs)'.

 -- Función: agd (<x>)
     Devuelve la inversa de la función de Gudermann, `log (tan (%pi/4 +
     x/2)))'.

     Para hacer uso de esta función ejecutar `load(functs)'.

 -- Función: vers (<x>)
     Devuelve `1 - cos (x)'.

     Para hacer uso de esta función ejecutar `load(functs)'.

 -- Función: covers (<x>)
     Devuelve `1 - sin (<x>)'.

     Para hacer uso de esta función ejecutar `load(functs)'.

 -- Función: exsec (<x>)
     Devuelve `sec (<x>) - 1'.

     Para hacer uso de esta función ejecutar `load(functs)'.

 -- Función: hav (<x>)
     Devuelve `(1 - cos(x))/2'.

     Para hacer uso de esta función ejecutar `load(functs)'.

 -- Función: combination (<n>, <r>)
     Calcula el número de combinaciones de <n> objetos tomados de <r>
     en <r>.

     Para hacer uso de esta función ejecutar `load(functs)'.

 -- Función: permutation (<n>, <r>)
     Calcula el número de permutaciones de <r>, seleccionados de un
     conjunto de <n>.

     Para hacer uso de esta función ejecutar `load(functs)'.


File: maxima.info,  Node: Paquete ineq,  Next: Paquete rducon,  Prev: Paquete functs,  Up: simplification

73.5 Paquete ineq
=================

El paquete `ineq' contiene reglas de simplificación para desigualdades

   Una sesión de ejemplo:

     (%i1) load(ineq)$
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     (%i2) a>=4;  /* a sample inequality */
     (%o2)                               a >= 4
     (%i3) (b>c)+%; /* add a second, strict inequality */
     (%o3)                            b + a > c + 4
     (%i4) 7*(x<y); /* multiply by a positive number */
     (%o4)                              7 x < 7 y
     (%i5) -2*(x>=3*z); /* multiply by a negative number */
     (%o5)                           - 2 x <= - 6 z
     (%i6) (1+a^2)*(1/(1+a^2)<=1); /* Maxima knows that 1+a^2 > 0 */
                                             2
     (%o6)                             1 <= a  + 1
     (%i7) assume(x>0)$ x*(2<3); /* assuming x>0 */
     (%o7)                              2 x < 3 x
     (%i8) a>=b; /* another inequality */
     (%o8)                               a >= b
     (%i9) 3+%; /* add something */
     (%o9)                           a + 3 >= b + 3
     (%i10) %-3; /* subtract it out */
     (%o10)                              a >= b
     (%i11) a>=c-b; /* yet another inequality */
     (%o11)                            a >= c - b
     (%i12) b+%; /* add b to both sides */
     (%o12)                            b + a >= c
     (%i13) %-c; /* subtract c from both sides */
     (%o13)                         - c + b + a >= 0
     (%i14) -%;  /* multiply by -1 */
     (%o14)                          c - b - a <= 0
     (%i15) (z-1)^2>-2*z; /* determining truth of assertion */
                                           2
     (%o15)                         (z - 1)  > - 2 z
     (%i16) expand(%)+2*z; /* expand this and add 2*z to both sides */
                                        2
     (%o16)                            z  + 1 > 0
     (%i17) %,pred;
     (%o17)                               true

   Debe tenerse cuidado con el uso de paréntesis que incluyan
desigualdades; si se escribe `(A > B) + (C = 5)' el resultado es `A + C
> B + 5', pero `A > B + C = 5' es un error sintáctico y `(A > B + C) =
5' es una cosa completamente diferente.

   Ejecútese `disprule (all)' para ver la lista completa de las reglas
definidas.

   Maxima preguntará al usuario cuando desconozca el signo de una
cantidad que multiplica a una desigualdad.

   Los fallos más comunes son:

     eq: a > b;
     2*eq;
     % - eq;

   Otro problema es el producto de una desigualdad por cero.  Si se
escribe `x*<some_inequality>' y Maxima pregunta por el signo de `x' y
se responde que vale `zero' (o `z'), el programa devuelve
`x*<some_inequality>' sin hacer uso de la información de que `x' es 0.
En tal caso se debería escribir `ev (%, x: 0)', ya que la base de datos
sólo será utilizada para fines comparativos y no para evaluar `x'.

   El usuario puede apreciar que las respuestas son más lentas al
cargarse este paquete, ya que el simplificador deberá examinar más
reglas que cuando no se hace uso del paquete, por lo que puede ser
conveniente borrar estas reglas cuando ya no se haga uso de ellas.
Ejecútese `kill (rules)' para eliminar todas las reglas (incluidas las
definidas por el usuario); también es posible eliminar parte de ellas o
utilizar `remrule' sobre una reglas específica.

   Nótese que si se carga este paquete después de haber definido otras
reglas de igual nombre,se borrarán las antiguas. Las reglas de este
paquete son: `*rule1', ..., `*rule8', `+rule1', ..., `+rule18',
debiéndose encerrar entre comillas el nombre de la reglas para
referenciarse a ellas, como en `remrule ("+", "+rule1")' para eliminar
la primera regla sobre `"+"', o `disprule ("*rule2")' para mostrar la
definición de la segunda regla multiplicativa.


File: maxima.info,  Node: Paquete rducon,  Next: Paquete scifac,  Prev: Paquete ineq,  Up: simplification

73.6 Paquete rducon
===================

 -- Función: reduce_consts (<expr>)
     Sustituye subexpresiones constantes de <expr> por átomos,
     guardando la definición de todos ellos en la lista de ecuaciones
     `const_eqns' y devolviendo el expresión <expr> ya modificada. Se
     consideran partes constantes de <expr> aquellas que devuelven
     `true' cuando se les aplica la función `constantp', por lo que
     antes de llamar a `reduce_consts' se debe ejecutar

          declare ([<objetos a los que se quiera dar la propiedad de ser constantes>], constant)$

     para crear la base de datos de las cantidades constantes presentes
     en la expresión.

     Si se pretende generar código Fortran después de estos cálculos
     simbólicos, una de las primeras secciones del código debe ser el
     cálculo de las constantes. Para generar este segmento de código
     hacer

          map ('fortran, const_eqns)$

     Junto a `const_eqns', otras variables que afectan a
     `reduce_consts' son:

     `const_prefix' (Valor por defecto: `xx') es la cadena de
     caracteres utilizada como prefijo para todos los símbolos
     generados por `reduce_consts' para representar subexpresiones
     constantes.

     `const_counter' (Valor por defecto: 1) es el índice entero
     utilizado para generar los símbolos que representen a las
     subexpresiones constantes encontradas por `reduce_consts'.

     La instrucción `load (rducon)' carga esta función y `demo (rducon)'
     hace una demostración sobre su uso.


File: maxima.info,  Node: Paquete scifac,  Next: Paquete sqdnst,  Prev: Paquete rducon,  Up: simplification

73.7 Paquete scifac
===================

 -- Función: gcfac (<expr>)
     Es una función de factorización que intenta aplicar la misma
     heurística que los humanos cuando tratan de hacer las expresiones
     más simples, limitándose a la factorización de monomios. En caso
     de sumas, `gcfac' hace lo siguiente:

       1. Factoriza los enteros.

       2. Factoriza las potencias mayores de los términos que aparecen
          como coeficientes, independientemente de su complejidad.

       3. Utiliza (1) y (2) en la factorización de pares de términos
          adyacentes.

       4. Aplica estas técnicas repetida y recursivamente hasta que la
          expresión deje de sufrir cambios.

     En general, el apartado (3) no hace una factorización óptima
     debido a la naturaleza combinatoria y compleja de encontrar cuál
     de todas las ordenaciones posibles de los pares da lugar a la
     expresión más compacta.

     La instrucción `load (scifac)' carga esta función y `demo (scifac)'
     hace una demostración sobre su uso.


File: maxima.info,  Node: Paquete sqdnst,  Prev: Paquete scifac,  Up: simplification

73.8 Paquete sqdnst
===================

 -- Función: sqrtdenest (<expr>)
     Reduce expresiones en las que se encuentren raíces cuadradas
     anidadas, siempre que sea posible

     Ejemplo:

          (%i1) load (sqdnst)$
          (%i2) sqrt(sqrt(3)/2+1)/sqrt(11*sqrt(2)-12);
                                              sqrt(3)
                                         sqrt(------- + 1)
                                                 2
          (%o2)                        ---------------------
                                       sqrt(11 sqrt(2) - 12)
          (%i3) sqrtdenest(%);
                                            sqrt(3)   1
                                            ------- + -
                                               2      2
          (%o3)                            -------------
                                              1/4    3/4
                                           3 2    - 2

     A veces conviene aplicar `sqrtdenest' más de una vez, como en el
     caso `(19601-13860 sqrt(2))^(7/4)'.

     La sentencia `load (sqdnst)' carga esta función.


File: maxima.info,  Node: solve_rec,  Next: stats,  Prev: simplification,  Up: Top

74 solve_rec
************

* Menu:

* Introducción a solve_rec::
* Funciones y variables para solve_rec::


File: maxima.info,  Node: Introducción a solve_rec,  Next: Funciones y variables para solve_rec,  Prev: solve_rec,  Up: solve_rec

74.1 Introducción a solve_rec
=============================

El paquete `solve_rec' resuelve expresiones recurrentes lineales con
coeficientes polinomiales.

   Ejecútese `demo(solve_rec);' para ver una demostración sobre la
utilización de este paquete.

   Ejemplo:

     (%i1) load("solve_rec")$
     (%i2) solve_rec((n+4)*s[n+2] + s[n+1] - (n+1)*s[n], s[n]);
                                         n
                      %k  (2 n + 3) (- 1)          %k
                        1                            2
     (%o2)       s  = -------------------- + ---------------
                  n     (n + 1) (n + 2)      (n + 1) (n + 2)


File: maxima.info,  Node: Funciones y variables para solve_rec,  Prev: Introducción a solve_rec,  Up: solve_rec

74.2 Funciones y variables para solve_rec
=========================================

 -- Función: reduce_order (<rec>, <sol>, <var>)
     Reduce el orden de la expresión recurrente lineal <rec> cuando se
     conoce una solución particular <sol>. La recurrencia reducida
     puede utilizarse para obterner más soluciones.

     Ejemplo:

          (%i3) rec: x[n+2] = x[n+1] + x[n]/n;
                                                x
                                                 n
          (%o3)               x      = x      + --
                               n + 2    n + 1   n
          (%i4) solve_rec(rec, x[n]);
          WARNING: found some hypergeometrical solutions!
          (%o4)                    x  = %k  n
                                    n     1
          (%i5) reduce_order(rec, n, x[n]);
          (%t5)                    x  = n %z
                                    n       n

                                     n - 1
                                     ====
                                     \
          (%t6)                %z  =  >     %u
                                 n   /        %j
                                     ====
                                     %j = 0

          (%o6)             (- n - 2) %u     - %u
                                        n + 1     n
          (%i6) solve_rec((n+2)*%u[n+1] + %u[n], %u[n]);
                                               n
                                      %k  (- 1)
                                        1
          (%o6)                 %u  = ----------
                                  n    (n + 1)!

          So the general solution is

                       n - 1
                       ====        j
                       \      (- 1)
                 %k  n  >    -------- + %k  n
                   2   /     (j + 1)!     1
                       ====
                       j = 0


 -- Variable opcional: simplify_products
     Valor por defecto: `true'

     Si `simplify_products' vale `true', `solve_rec' intentará
     simplificar los productos del resultado.

     Véase también `solve_rec'.


 -- Función: simplify_sum (<expr>)
     Intenta reducir todas las sumas que aparecen en <expr> a una forma
     cerrada.

     Para utilizar esta función cárguese previamente el paquete
     `simplify_sum' ejecutando la instrucción `load(simplify_sum)'.

     Ejemplo:

          (%i1) load("simplify_sum")$
          (%i2) sum(binomial(n+k,k)/2^k,k,1,n)+sum(binomial(2*n,2*k),k,1,n);
                  n                          n
                 ====                       ====
                 \     binomial(n + k, k)   \
          (%o2)   >    ------------------ +  >    binomial(2 n, 2 k)
                 /              k           /
                 ====          2            ====
                 k = 1                      k = 1
          (%i3) simplify_sum(%);

                                   2 n - 1    n
          (%o3)                   2        + 2  - 2


 -- Función: solve_rec (<eqn>, <var>, [<init>])
     Obtiene las soluciones hipergeométricas de la expresión recurrente
     <eqn> con coeficientes lineales en la variable <var>. Los
     argumentos opcionales <init> son condiciones iniciales.

     La función `solve_rec' puede resolver expresiones recurrentes con
     coeficientes constantes, encuentra soluciones hipergeométricas de
     expresiones recurrentes lineales homogéneas con coeficientes
     polinomiales, obtiene soluciones racionales de expresiones
     recurrentes lineales con coeficientes lineales y resuelve también
     expresiones recurrentes de Ricatti.

     Nótese que el tiempo de ejecución del algoritmo para encontrar
     soluciones hipergeométricas es exponencial respecto del grado del
     coeficiente principal.

     Para hacer uso de esta función ejecútese previamente
     `load(solve_rec);'.

     Ejemplo de recurrencia lineal con coeficientes constantes:

          (%i2) solve_rec(a[n]=a[n-1]+a[n-2]+n/2^n, a[n]);
                                  n          n
                     (sqrt(5) - 1)  %k  (- 1)
                                      1           n
          (%o2) a  = ------------------------- - ----
                 n               n                  n
                                2                5 2
                                                          n
                                             (sqrt(5) + 1)  %k
                                                              2    2
                                           + ------------------ - ----
                                                      n              n
                                                     2            5 2

     Ejemplo de recurrencia lineal con coeficientes polinomiales:

          (%i7) 2*x*(x+1)*y[x] - (x^2+3*x-2)*y[x+1] + (x-1)*y[x+2];
                                   2
          (%o7) (x - 1) y      - (x  + 3 x - 2) y      + 2 x (x + 1) y
                         x + 2                   x + 1                x
          (%i8) solve_rec(%, y[x], y[1]=1, y[3]=3);
                                        x
                                     3 2    x!
          (%o9)                 y  = ---- - --
                                 x    4     2

     Ejemplo de recurrencia de Ricatti:

          (%i2) x*y[x+1]*y[x] - y[x+1]/(x+2) + y[x]/(x-1) = 0;
                                      y         y
                                       x + 1     x
          (%o2)         x y  y      - ------ + ----- = 0
                           x  x + 1   x + 2    x - 1
          (%i3) solve_rec(%, y[x], y[3]=5)$
          (%i4) ratsimp(minfactorial(factcomb(%)));
                                             3
                                         30 x  - 30 x
          (%o4) y  = - -------------------------------------------------
                 x        6      5       4       3       2
                       5 x  - 3 x  - 25 x  + 15 x  + 20 x  - 12 x - 1584

     Véanse también `solve_rec_rat', `simplify_products' y
     `product_use_gamma'.


 -- Función: solve_rec_rat (<eqn>, <var>, [<init>])
     Calcula las soluciones racionales de las expresiones recurrentes
     lineales.  Véase `solve_rec' para la descripción de sus argumentos.

     Para hacer uso de esta función ejecútese previamente
     `load(solve_rec);'.

     Ejemplo:

          (%i1) (x+4)*a[x+3] + (x+3)*a[x+2] - x*a[x+1] + (x^2-1)*a[x];
          (%o1)  (x + 4) a      + (x + 3) a      - x a
                          x + 3            x + 2      x + 1
                                                             2
                                                         + (x  - 1) a
                                                                      x
          (%i2) solve_rec_rat(% = (x+2)/(x+1), a[x]);
                                 1
          (%o2)      a  = ---------------
                      x   (x - 1) (x + 1)

     Véase también `solve_rec'.


 -- Variable opcional: product_use_gamma
     Valor por defecto:`true'

     Si `product_use_gamma' vale `true',  `solve_rec' introduce la
     función gamma en la expresión del resultado cuando se simplifican
     productos.

     Véanse también `simplify_products' y `solve_rec'.


 -- Función: summand_to_rec (<summand>, <k>, <n>)
     Devuelve la expresión recurrente que satisface la suma

              inf
              ====
              \
               >     sumando
              /
              ====
            k = minf

     donde el sumando es hipergeométrico en  <k> y <n>.

     Para hacer uso de esta función deben cargarse previamente los
     paquetes `zeilberger' y `solve_rec' mediante la ejecución de las
     sentencias `load(solve_rec)' y `load(zeilberger)'.

          (%i17) load("zeilberger")$
          (%i18) summand: binom(3*k+1,k)*binom(3*(n-k),n-k)/(3*k+1)$
          (%i19) summand_to_rec(summand, k, n);
          Dependent equations eliminated:  (3 2)
          (%o19) - 4 (n + 2) (2 n + 3) (2 n + 5) sm
                                                   n + 2
                              2
           + 12 (2 n + 3) (9 n  + 27 n + 22) sm
                                               n + 1
           - 81 (n + 1) (3 n + 2) (3 n + 4) sm
                                              n
          (%i21) sum(''summand, k, 0, n), n=0;
          (%o21)                       1
          (%i22) sum(''summand, k, 0, n), n=1;
          (%o22)                       4
          (%i23) product_use_gamma: false$
          (%i24) solve_rec(%o19, sm[n], sm[0]=1, sm[1]=4);
                        n - 1               n - 1
                        /===\               /===\
                         ! !                 ! !                n
                       ( ! !   (3 %j + 2)) ( ! !   (3 %j + 4)) 3
                         ! !                 ! !
                        %j = 0              %j = 0
          (%o24) sm  = ------------------------------------------
                   n            n - 1
                                /===\
                                 ! !                n
                               ( ! !   (2 %j + 3)) 2  n!
                                 ! !
                                %j = 0



File: maxima.info,  Node: stats,  Next: stirling,  Prev: solve_rec,  Up: Top

75 stats
********

* Menu:

* Introducción a stats::
* Funciones y variables para inference_result::
* Funciones y variables para stats::
* Funciones y variables para distribuciones especiales::


File: maxima.info,  Node: Introducción a stats,  Next: Funciones y variables para inference_result,  Prev: Top,  Up: Top

75.1 Introducción a stats
=========================

El paquete `stats' contiene procedimientos clásicos sobre inferencia
estadística y contraste de hipótesis.

   Todas estas funciones devuelven un objeto Maxima de tipo
`inference_result', el cual contiene los resultados necesarios para
hacer inferencias sobre la población y toma de decisiones.

   La variable global `stats_numer' controla si los resultados deben
darse en formato decimal o simbólico y racional; su valor por defecto
es `true', por lo que el formato de salida es decimal.

   El paquete `descriptive' contiene algunas utilidades para manipular
estructuras de datos (listas y matrices); por ejemplo para extraer
submuestras.  También contiene algunos ejemplos sobre cómo utilizar el
paquete `numericalio' para leer datos de ficheros en texto plano. Véanse
`descriptive' y `numericalio' para más detalles.

   El paquete `stats' carga en memoria los paquetes `descriptive',
`distrib' y `inference_result'.

   Para comentarios, errores o sugerencias, contáctese con el autor en

   <'mario ARROBA edu PUNTO xunta PUNTO es'>.


File: maxima.info,  Node: Funciones y variables para inference_result,  Next: Funciones y variables para stats,  Prev: Introducción a stats,  Up: Top

75.2 Funciones y variables para inference_result
================================================

 -- Función: inference_result (<title>, <values>, <numbers>)
     Construye un objeto `inference_result' del tipo devuelto por las
     funciones estadísticas. El argumento <title> es una cadena con el
     nombre del procedimiento; <values> es una lista con elementos de la
     forma `symbol = value' y <numbers> es una lista con enteros
     positivos desde uno hasta `length(<values>)', que indican qué
     valores serán mostrados por defecto.

     Ejemplo:

     Este es un ejemplo que muestra los resultados asociados a un
     rectángulo. El título de este objeto es la cadena `"Rectangle"',
     el cual almacena cinco resultados, a saber, `'base', `'height',
     `'diagonal', `'area' y `'perimeter', pero sólo muestra el primero,
     segundo, quinto y cuarto. El resultado `'diagonal' también se
     almacena en este objeto, pero no se muestra por defecto; para
     tener acceso a este valor, hágase uso de la función
     `take_inference'.

          (%i1) load(inference_result)$
          (%i2) b: 3$ h: 2$
          (%i3) inference_result("Rectangle",
                                  ['base=b,
                                   'height=h,
                                   'diagonal=sqrt(b^2+h^2),
                                   'area=b*h,
                                   'perimeter=2*(b+h)],
                                  [1,2,5,4] );
                                  |   Rectangle
                                  |
                                  |    base = 3
                                  |
          (%o3)                   |   height = 2
                                  |
                                  | perimeter = 10
                                  |
                                  |    area = 6
          (%i4) take_inference('diagonal,%);
          (%o4)                        sqrt(13)

     Véase también `take_inference'.

 -- Función: inferencep (<obj>)
     Devuelve `true' o `false', dependiendo de que <obj> sea un objeto
     de tipo `inference_result' o no.


 -- Función: items_inference (<obj>)
     Devuelve una lista con los nombres de los elementos almacenados en
     <obj>, el cual debe ser un objeto de tipo `inference_result'.

     Ejemplo:

     El objeto `inference_result' almacena dos valores, cuyos nombres
     son `'pi' y `'e', pero sólo se muestra el segundo. La función
     `items_inference' devuelve los nombres de todos los elementos
     almacenados, independientemente de que sean mostrados o no.

          (%i1) load(inference_result)$
          (%i2) inference_result("Hi", ['pi=%pi,'e=%e],[2]);
                                      |   Hi
          (%o2)                       |
                                      | e = %e
          (%i3) items_inference(%);
          (%o3)                        [pi, e]

 -- Función: take_inference (<n>, <obj>)
 -- Función: take_inference (<name>, <obj>)
 -- Función: take_inference (<list>, <obj>)
     Si <n> es un entero positivo, devuelve el <n>-ésimo valor
     almacenado en <obj>; si el símbolo <name> es el nombre de uno de
     los elementos almacenados, también devuelve su valor. Si el primer
     elemento es una lista de números y/o símbolos, la función
     `take_inference' devuelve una lista con los resultados
     correspondientes.

     Ejemplo:

     Dado un objeto `inference_result', la función `take_inference' es
     invocada para extraer cierta información almacenada en él.

          (%i1) load(inference_result)$
          (%i2) b: 3$ h: 2$
          (%i3) sol: inference_result("Rectangle",
                                      ['base=b,
                                       'height=h,
                                       'diagonal=sqrt(b^2+h^2),
                                       'area=b*h,
                                       'perimeter=2*(b+h)],
                                      [1,2,5,4] );
                                  |   Rectangle
                                  |
                                  |    base = 3
                                  |
          (%o3)                   |   height = 2
                                  |
                                  | perimeter = 10
                                  |
                                  |    area = 6
          (%i4) take_inference('base,sol);
          (%o4)                           3
          (%i5) take_inference(5,sol);
          (%o5)                          10
          (%i6) take_inference([1,'diagonal],sol);
          (%o6)                     [3, sqrt(13)]
          (%i7) take_inference(items_inference(sol),sol);
          (%o7)                [3, 2, sqrt(13), 6, 10]

     Véanse también `inference_result' y `take_inference'.


File: maxima.info,  Node: Funciones y variables para stats,  Next: Funciones y variables para distribuciones especiales,  Prev: Funciones y variables para inference_result,  Up: Top

75.3 Funciones y variables para stats
=====================================

 -- Variable opcional: stats_numer
     Valor por defecto: `true'

     Cuando `stats_numer' vale `true', las funciones de inferencia
     estadística devuelven sus resultados en formato decimal de coma
     flotante. Cuando vale `false', los resultados se devuelven en
     formato simbólico y racional.

 -- Función: test_mean (<x>)
 -- Función: test_mean (<x>, <options> ...)
     Es el test <t> de la media. El argumento <x> es una lista o matriz
     columna con los datos de una muestra unidimensional. También
     realiza el test asintótico basado en el Teorema Central del límite
     si se le asigna a la opción `'asymptotic' el valor `true'.

     Opciones:

        * `'mean', valor por defecto `0', es el valor de la media a
          contrastar.

        * `'alternative', valor por defecto `'twosided', es la
          hipótesis alternativa; valores válidos son: `'twosided',
          `'greater' y `'less'.

        * `'dev', valor por defecto `'unknown', este es el valor de la
          desviación típica cuando se conoce; valores válidos son:
          `'unknown' o una expresión con valor positivo.

        * `'conflevel', valor por defecto `95/100', nivel de confianza
          para el intervalo de confianza; debe ser una expresión que
          tome un valor en el intervalo (0,1).

        * `'asymptotic', valor por defecto `false', indica si debe
          realizar el test exacto basado en la <t> de Student, o el
          asintótico basado en el Teorema Central del límite; valores
          válidos son `true' y `false'.


     El resultado devuelto por la función  `test_mean' es un objeto
     `inference_result' con los siguientes apartados:

       1. `'mean_estimate': la media muestral.

       2. `'conf_level': nivel de confianza seleccionado por el usuario.

       3. `'conf_interval': intervalo de confianza para la media
          poblacional.

       4. `'method': procedimiento de inferencia.

       5. `'hypotheses': hipótesis nula y alternativa a ser contrastada.

       6. `'statistic': valor del estadístico de contraste utilizado
          para probar la hipótesis.

       7. `'distribution': distribución del estadístico de contraste,
          junto con su(s) parámetro(s).

       8. `'p_value': p-valor del test.


     Ejemplos:

     Realiza el contraste exacto <t> con varianza desconocida. La
     hipótesis nula es H_0: mean=50, frente a la alternativa unilátera
     H_1: mean<50; de acuerdo con los resultados, no hay evidencia para
     rechazar H_0, pues el p-valor es muy grande.

          (%i1) load("stats")$
          (%i2) data: [78,64,35,45,45,75,43,74,42,42]$
          (%i3) test_mean(data,'conflevel=0.9,'alternative='less,'mean=50);
                    |                 MEAN TEST
                    |
                    |            mean_estimate = 54.3
                    |
                    |              conf_level = 0.9
                    |
                    | conf_interval = [minf, 61.51314273502712]
                    |
          (%o3)     |  method = Exact t-test. Unknown variance.
                    |
                    | hypotheses = H0: mean = 50 , H1: mean < 50
                    |
                    |       statistic = .8244705235071678
                    |
                    |       distribution = [student_t, 9]
                    |
                    |        p_value = .7845100411786889

     En esta ocasión Maxima realiza un test asintótico. La hipótesis
     nula es H_0: equal(mean, 50) frente a la alternativa bilátera H_1:
     not equal(mean, 50); de acuerdo con los resultados, H_0 debe
     rechazarse en favor de la alternativa H_1, pues el p-valor es muy
     pequeño.  Nótese que, tal como indica la componente `Method', este
     procedimiento sólo puede aplicarse en muestras grandes.

          (%i1) load("stats")$
          (%i2) test_mean([36,118,52,87,35,256,56,178,57,57,89,34,25,98,35,
                        98,41,45,198,54,79,63,35,45,44,75,42,75,45,45,
                        45,51,123,54,151],
                        'asymptotic=true,'mean=50);
                    |                       MEAN TEST
                    |
                    |           mean_estimate = 74.88571428571429
                    |
                    |                   conf_level = 0.95
                    |
                    | conf_interval = [57.72848600856194, 92.04294256286663]
                    |
          (%o2)     |    method = Large sample z-test. Unknown variance.
                    |
                    |       hypotheses = H0: mean = 50 , H1: mean # 50
                    |
                    |             statistic = 2.842831192874313
                    |
                    |             distribution = [normal, 0, 1]
                    |
                    |             p_value = .004471474652002261


 -- Función: test_means_difference (<x1>, <x2>)
 -- Función: test_means_difference (<x1>, <x2>, <options> ...)
     Este es el test <t> para la diferencia de medias con muestras.
     Los argumentos <x1> y <x2> son listas o matrices columna que
     contienen dos muestras independientes. En caso de varianzas
     diferentes y desconocidas (véanse las opciones `'dev1', `'dev2' y
     `'varequal' más abajo) los grados de libertad se calculan mediante
     la aproximación de Welch.  También realiza el test asintótico
     basado en el Teorema Central del límite si se le asigna a la
     opción `'asymptotic' el valor `true'.

     Opciones:

        *        * `'alternative', valor por defecto `'twosided', es la
          hipótesis alternativa; valores válidos son: `'twosided',
          `'greater' y `'less'.

        * `'dev1', valor por defecto `'unknown', es el valor de la
          desviación típica de la muestra <x1> cuando se conoce;
          valores válidos son: `'unknown' o una expresión positiva.

        * `'dev2', valor por defecto `'unknown', es el valor de la
          desviación típica de la muestra <x2> cuando se conoce;
          valores válidos son: `'unknown' o una expresión positiva.

        * `'varequal', valor por defecto `false', indica si las
          varianzas deben considerarse iguales o no; esta opción sólo
          toma efecto cuando `'dev1' y/o `'dev2' tienen el valor
          `'unknown'.

        * `'conflevel', valor por defecto `95/100', nivel de confianza
          para el intervalo de confianza; debe ser una expresión que
          tome un valor en el intervalo (0,1).

        * `'asymptotic', valor por defecto `false', indica si debe
          realizar el test exacto basado en la <t> de Student, o el
          asintótico basado en el Teorema Central del límite; valores
          válidos son `true' y `false'.


     El resultado devuelto por la función  `test_means_difference' es
     un objeto `inference_result' con los siguientes apartados:

       1. `'diff_estimate': el estimador de la diferencia de medias.

       2. `'conf_level': nivel de confianza seleccionado por el usuario.

       3. `'conf_interval': intervalo de confianza para la diferencia
          de medias.

       4. `'method': procedimiento de inferencia.

       5. `'hypotheses': hipótesis nula y alternativa a ser contrastada.

       6. `'statistic': valor del estadístico de contraste utilizado
          para probar la hipótesis.

       7. `'distribution': distribución del estadístico de contraste,
          junto con su(s) parámetro(s).

       8. `'p_value': p-valor del test.


     Ejemplos:

     La igualdad de medias se contrasta con dos pequeñas muestras <x> y
     <y>, contra la alternativa H_1: m_1>m_2, siendo m_1 y m_2 las
     medias poblacionales; las varianzas son desconocidas y se supone
     que diferentes.

          (%i1) load("stats")$
          (%i2) x: [20.4,62.5,61.3,44.2,11.1,23.7]$
          (%i3) y: [1.2,6.9,38.7,20.4,17.2]$
          (%i4) test_means_difference(x,y,'alternative='greater);
                      |              DIFFERENCE OF MEANS TEST
                      |
                      |         diff_estimate = 20.31999999999999
                      |
                      |                 conf_level = 0.95
                      |
                      |    conf_interval = [- .04597417812882298, inf]
                      |
          (%o4)       |        method = Exact t-test. Welch approx.
                      |
                      | hypotheses = H0: mean1 = mean2 , H1: mean1 > mean2
                      |
                      |           statistic = 1.838004300728477
                      |
                      |    distribution = [student_t, 8.62758740184604]
                      |
                      |            p_value = .05032746527991905

     El mismo test que antes, pero ahora se suponen las varianzas
     iguales.

          (%i1) load("stats")$
          (%i2) x: [20.4,62.5,61.3,44.2,11.1,23.7]$
          (%i3) y: matrix([1.2],[6.9],[38.7],[20.4],[17.2])$
          (%i4) test_means_difference(x,y,
                                      'alternative='greater,
                                      'varequal=true);
                      |              DIFFERENCE OF MEANS TEST
                      |
                      |         diff_estimate = 20.31999999999999
                      |
                      |                 conf_level = 0.95
                      |
                      |     conf_interval = [- .7722627696897568, inf]
                      |
          (%o4)       |   method = Exact t-test. Unknown equal variances
                      |
                      | hypotheses = H0: mean1 = mean2 , H1: mean1 > mean2
                      |
                      |           statistic = 1.765996124515009
                      |
                      |           distribution = [student_t, 9]
                      |
                      |            p_value = .05560320992529344


 -- Función: test_variance (<x>)
 -- Función: test_variance (<x>, <options> ...)
     Este es el test <chi^2> de la varianza. El argumento <x> es una
     lista o matriz columna con los datos de una muestra unidimensional
     extraída de una población normal.

     Opciones:

        * `'mean', valor por defecto `'unknown', es la media de la
          población, si se conoce.

        * `'alternative', valor por defecto `'twosided', es la
          hipótesis alternativa; valores válidos son: `'twosided',
          `'greater' y `'less'.

        * `'variance', valor por defecto `1', este es el valor
          (positivo) de la varianza a contrastar.

        * `'conflevel', valor por defecto `95/100', nivel de confianza
          para el intervalo de confianza; debe ser una expresión que
          tome un valor en el intervalo (0,1).


     El resultado devuelto por la función  `test_variance' es un objeto
     `inference_result' con los siguientes apartados:

       1. `'var_estimate': la varianza muestral.

       2. `'conf_level': nivel de confianza seleccionado por el usuario.

       3. `'conf_interval': intervalo de confianza para la varianza
          poblacional.

       4. `'method': procedimiento de inferencia.

       5. `'hypotheses': hipótesis nula y alternativa a ser contrastada.

       6. `'statistic': valor del estadístico de contraste utilizado
          para probar la hipótesis.

       7. `'distribution': distribución del estadístico de contraste,
          junto con su parámetro.

       8. `'p_value': p-valor del test.


     Ejemplos:

     Se contrasta si la varianza de una población de media desconocida
     es igual o mayor que 200.

          (%i1) load("stats")$
          (%i2) x: [203,229,215,220,223,233,208,228,209]$
          (%i3) test_variance(x,'alternative='greater,'variance=200);
                       |                  VARIANCE TEST
                       |
                       |              var_estimate = 110.75
                       |
                       |                conf_level = 0.95
                       |
                       |     conf_interval = [57.13433376937479, inf]
                       |
          (%o3)        | method = Variance Chi-square test. Unknown mean.
                       |
                       |    hypotheses = H0: var = 200 , H1: var > 200
                       |
                       |                 statistic = 4.43
                       |
                       |             distribution = [chi2, 8]
                       |
                       |           p_value = .8163948512777689


 -- Función: test_variance_ratio (<x1>, <x2>)
 -- Función: test_variance_ratio (<x1>, <x2>, <options> ...)
     Este es el test <F> del cociente de las varianzas para dos
     poblaciones normales. Los argumentos <x1> y <x2> son listas o
     matrices columna que contienen los datos de dos muestras
     independientes.

     Opciones:

        * `'alternative', valor por defecto `'twosided', es la
          hipótesis alternativa; valores válidos son: `'twosided',
          `'greater' y `'less'.

        * `'mean1', valor por defecto `'unknown', es la media de la
          población de la que procede <x1> cuando se conoce.

        * `'mean2', valor por defecto `'unknown', es la media de la
          población de la que procede <x2> cuando se conoce.

        * `'conflevel', valor por defecto `95/100', nivel de confianza
          para el intervalo de confianza del cociente; debe ser una
          expresión que tome un valor en el intervalo (0,1).


     El resultado devuelto por la función  `test_variance_ratio' es un
     objeto `inference_result' con los siguientes resultados

       1. `'ratio_estimate': el cociente de varianzas muestral.

       2. `'conf_level': nivel de confianza seleccionado por el usuario.

       3. `'conf_interval': intervalo de confianza para el cociente de
          varianzas.

       4. `'method': procedimiento de inferencia.

       5. `'hypotheses': hipótesis nula y alternativa a ser contrastada.

       6. `'statistic': valor del estadístico de contraste utilizado
          para probar la hipótesis.

       7. `'distribution': distribución del estadístico de contraste,
          junto con sus parámetros.

       8. `'p_value': p-valor del test.


     Ejemplos:

     Se contrasta la igualdad de varianzas de dos poblaciones normales
     frente a la alternativa de que la primera es mayor que la segunda.

          (%i1) load("stats")$
          (%i2) x: [20.4,62.5,61.3,44.2,11.1,23.7]$
          (%i3) y: [1.2,6.9,38.7,20.4,17.2]$
          (%i4) test_variance_ratio(x,y,'alternative='greater);
                        |              VARIANCE RATIO TEST
                        |
                        |       ratio_estimate = 2.316933391522034
                        |
                        |               conf_level = 0.95
                        |
                        |    conf_interval = [.3703504689507268, inf]
                        |
          (%o4)         | method = Variance ratio F-test. Unknown means.
                        |
                        | hypotheses = H0: var1 = var2 , H1: var1 > var2
                        |
                        |         statistic = 2.316933391522034
                        |
                        |            distribution = [f, 5, 4]
                        |
                        |          p_value = .2179269692254457


 -- Función: test_proportion (<x>, <n>)
 -- Función: test_proportion (<x>, <n>, <options> ...)
     Inferencias sobre una proporción. El argumento <x> es el número de
     éxitos observados en <n> pruebas de Bernoulli con probabilidad
     desconocida.

     Opciones:

        * `'proportion', valor por defecto `1/2', es el valor de la
          probabilidad a contrastar.

        * `'alternative', valor por defecto `'twosided', es la
          hipótesis alternativa; valores válidos son: `'twosided',
          `'greater' y `'less'.

        * `'conflevel', valor por defecto `95/100', nivel de confianza
          para el intervalo de confianza; debe ser una expresión que
          tome un valor en el intervalo (0,1).

        * `'asymptotic', valor por defecto `false', indica si debe
          realizar el test exacto basado en la binomial, o el
          asintótico basado en el Teorema Central del límite; valores
          válidos son `true' y `false'.

        * `'correct', valor por defecto `true', indica si se aplica o
          no la corrección de Yates.


     El resultado devuelto por la función `test_proportion' es un objeto
     `inference_result' con los siguientes apartados:

       1. `'sample_proportion': proporción muestral.

       2. `'conf_level': nivel de confianza seleccionado.

       3. `'conf_interval': intervalo de confianza de Wilson para la
          proporción.

       4. `'method': procedimiento de inferencia.

       5. `'hypotheses': hipótesis nula y alternativa a ser contrastada.

       6. `'statistic': valor del estadístico de contraste utilizado
          para probar la hipótesis.

       7. `'distribution': distribución del estadístico de contraste,
          junto con sus parámetros.

       8. `'p_value': p-valor del test.


     Ejemplos:

     Realiza un contraste exacto. La hipótesis nula es H_0: p=1/2 y la
     alternativa unilátera es H_1: p<1/2.

          (%i1) load("stats")$
          (%i2) test_proportion(45, 103, alternative = less);
                   |            PROPORTION TEST
                   |
                   | sample_proportion = .4368932038834951
                   |
                   |           conf_level = 0.95
                   |
                   | conf_interval = [0, 0.522714149150231]
                   |
          (%o2)    |     method = Exact binomial test.
                   |
                   | hypotheses = H0: p = 0.5 , H1: p < 0.5
                   |
                   |             statistic = 45
                   |
                   |  distribution = [binomial, 103, 0.5]
                   |
                   |      p_value = .1184509388901454

     Un contraste asintótico bilátero. El nivel de confianza es 99/100.

          (%i1) load("stats")$
          (%i2) fpprintprec:7$
          (%i3) test_proportion(45, 103,
                            conflevel = 99/100, asymptotic=true);
                |                 PROPORTION TEST
                |
                |           sample_proportion = .43689
                |
                |                conf_level = 0.99
                |
                |        conf_interval = [.31422, .56749]
                |
          (%o3) | method = Asympthotic test with Yates correction.
                |
                |     hypotheses = H0: p = 0.5 , H1: p # 0.5
                |
                |               statistic = .43689
                |
                |      distribution = [normal, 0.5, .048872]
                |
                |                p_value = .19662


 -- Función: test_proportions_difference (<x1>, <n1>, <x2>, <n2>)
 -- Función: test_proportions_difference (<x1>, <n1>, <x2>, <n2>,
          <options> ...)
     Inferencias sobre la diferencia de dos proporciones. El argumento
     <x1> es el número de éxitos en <n1> experimentos de Bernoulli en la
     primera población y <x2> y <n2> son los valores correspondientes
     para la segunda población. Las muestras son independientes y el
     contraste es asintótico.

     Opciones:

        * `'alternative', valor por defecto `'twosided', es la
          hipótesis alternativa; valores válidos son:: `'twosided' (`p1
          # p2'), `'greater' (`p1 > p2') and `'less' (`p1 < p2').

        * `'conflevel', valor por defecto `95/100', nivel de confianza
          para el intervalo de confianza; debe ser una expresión que
          tome un valor en el intervalo (0,1).

        * `'correct', valor por defecto `true', indica si se aplica o
          no la corrección de Yates.


     El resultado devuelto por la función `test_proportions_difference'
     es un objeto `inference_result' con los siguientes apartados:

       1. `'proportions': lista con las dos proporciones muestrales.

       2. `'conf_level': nivel de confianza seleccionado.

       3. `'conf_interval': intervalo de confianza para la diferencia
          de proporciones `p1 - p2'.

       4. `'method': procedimiento de inferencia y mensaje de aviso en
          caso de que alguno de los tamaños muestrales sea menor de 10.

       5. `'hypotheses': hipótesis nula y alternativa a ser contrastada.

       6. `'statistic': valor del estadístico de contraste utilizado
          para probar la hipótesis.

       7. `'distribution': distribución del estadístico de contraste,
          junto con sus parámetros.

       8. `'p_value': p-valor del test.


     Ejemplos:

     Una máquina produce 10 piezas defectuosas en un lote de 250.
     Después de ciertas tareas de mantenimiento, produce 4 piezas
     defectuosas de un lote de 150. A fin de saber si la tarea de
     mantenimiento produjo alguna mejora, se contrasta la hipótesis
     nula `H0:p1=p2' contra la alternativa `H0:p1>p2', donde `p1' y
     `p2' son las probabilidades de que un artículo producido por la
     máquina sea defectuoso, antes y después de la reparación. De
     acuerdo con el p valor, no hay evidencia suficiente para aceptar
     la alternativa.

          (%i1) load("stats")$
          (%i2) fpprintprec:7$
          (%i3) test_proportions_difference(10, 250, 4, 150,
                                          alternative = greater);
                |       DIFFERENCE OF PROPORTIONS TEST
                |
                |       proportions = [0.04, .02666667]
                |
                |              conf_level = 0.95
                |
                |      conf_interval = [- .02172761, 1]
                |
          (%o3) | method = Asymptotic test. Yates correction.
                |
                |   hypotheses = H0: p1 = p2 , H1: p1 > p2
                |
                |            statistic = .01333333
                |
                |    distribution = [normal, 0, .01898069]
                |
                |             p_value = .2411936

     Desviación típica exacta de la distribución normal asintótica con
     datos desconocidos.

          (%i1) load("stats")$
          (%i2) stats_numer: false$
          (%i3) sol: test_proportions_difference(x1,n1,x2,n2)$
          (%i4) last(take_inference('distribution,sol));
                         1    1                  x2 + x1
                        (-- + --) (x2 + x1) (1 - -------)
                         n2   n1                 n2 + n1
          (%o4)    sqrt(---------------------------------)
                                     n2 + n1


 -- Función: test_sign (<x>)
 -- Función: test_sign (<x>, <options> ...)
     Este es el test no paramétrico de los signos para contrastes sobre
     la mediana de una población continua. El argumento <x> es una
     lista o matriz columna que contiene los datos de una muestra
     unidimensional.

     Opciones:

        * `'alternative', valor por defecto `'twosided', es la
          hipótesis alternativa; valores válidos son: `'twosided',
          `'greater' y `'less'.

        * `'median', valor por defecto `0', es el valor de la mediana a
          contrastar.


     El resultado devuelto por la función `test_sign' es un objeto
     `inference_result' con los siguientes apartados:

       1. `'med_estimate': la mediana muestral.

       2. `'method': procedimiento de inferencia.

       3. `'hypotheses': hipótesis nula y alternativa a ser contrastada.

       4. `'statistic': valor del estadístico de contraste utilizado
          para probar la hipótesis.

       5. `'distribution': distribución del estadístico de contraste,
          junto con sus parámetros.

       6. `'p_value': p-valor del test.


     Ejemplos:

     Contrasta si la mediana de la población de la que se ha extraido
     la muestra es 6, frente a la alternativa H_1: median > 6.

          (%i1) load("stats")$
          (%i2) x: [2,0.1,7,1.8,4,2.3,5.6,7.4,5.1,6.1,6]$
          (%i3) test_sign(x,'median=6,'alternative='greater);
                         |                  SIGN TEST
                         |
                         |              med_estimate = 5.1
                         |
                         |      method = Non parametric sign test.
                         |
          (%o3)          | hypotheses = H0: median = 6 , H1: median > 6
                         |
                         |                statistic = 7
                         |
                         |      distribution = [binomial, 10, 0.5]
                         |
                         |         p_value = .05468749999999989


 -- Función: test_signed_rank (<x>)
 -- Función: test_signed_rank (<x>, <options> ...)
     Este el test de los rangos signados de Wilcoxon para hacer
     inferencias sobre la mediana de una población continua. El
     argumento <x> es una lista o matriz columna que contiene los datos
     de una muestra unidimensional.  Realiza la aproximación normal si
     el tamaño muestral es mayor que 20, o si en la muestra aparece
     algún cero o hay empates.

     Véanse también `pdf_rank_test' y `cdf_rank_test'.

     Opciones:

        * `'median', valor por defecto `0', es el valor de la mediana a
          ser contrastado.

        * `'alternative', valor por defecto `'twosided', es la
          hipótesis alternativa; valores válidos son: `'twosided',
          `'greater' y `'less'.


     El resultado devuelto por la función  `test_signed_rank' es un
     objeto `inference_result' con los siguientes apartados:

       1. `'med_estimate': la mediana muestral.

       2. `'method': procedimiento de inferencia.

       3. `'hypotheses': hipótesis nula y alternativa a ser contrastada.

       4. `'statistic': valor del estadístico de contraste utilizado
          para probar la hipótesis.

       5. `'distribution': distribución del estadístico de contraste,
          junto con su(s) parámetro(s).

       6. `'p_value': p-valor del test.


     Ejemplos:

     Contrasta la hipótesis nula H_0: median = 15 frente a la
     alternativa H_1: median > 15. Este test es exacto, puesto que no
     hay empates.

          (%i1) load("stats")$
          (%i2) x: [17.1,15.9,13.7,13.4,15.5,17.6]$
          (%i3) test_signed_rank(x,median=15,alternative=greater);
                           |             SIGNED RANK TEST
                           |
                           |           med_estimate = 15.7
                           |
                           |           method = Exact test
                           |
          (%o3)            | hypotheses = H0: med = 15 , H1: med > 15
                           |
                           |              statistic = 14
                           |
                           |     distribution = [signed_rank, 6]
                           |
                           |            p_value = 0.28125

     Contrasta la hipótesis nula H_0: equal(median, 2.5) frente a la
     alternativa H_1: not equal(median, 2.5). Este es un test
     asintótico, debido a la presencia de empates.

          (%i1) load("stats")$
          (%i2) y:[1.9,2.3,2.6,1.9,1.6,3.3,4.2,4,2.4,2.9,1.5,3,2.9,4.2,3.1]$
          (%i3) test_signed_rank(y,median=2.5);
                       |                 SIGNED RANK TEST
                       |
                       |                med_estimate = 2.9
                       |
                       |          method = Asymptotic test. Ties
                       |
          (%o3)        |    hypotheses = H0: med = 2.5 , H1: med # 2.5
                       |
                       |                 statistic = 76.5
                       |
                       | distribution = [normal, 60.5, 17.58195097251724]
                       |
                       |           p_value = .3628097734643669


 -- Función: test_rank_sum (<x1>, <x2>)
 -- Función: test_rank_sum (<x1>, <x2>, <option>)
     Este es el test de Wilcoxon-Mann-Whitney para comparar las medianas
     de dos poblaciones continuas. Los dos primeros argumentos <x1> y
     <x2> son listas o matrices columna con los datos de dos muestras
     independientes. Realiza la aproximación normal si alguna de las
     muestras tiene tamaño mayor que 10, o si hay empates.

     Opción:

        * `'alternative', valor por defecto `'twosided', es la
          hipótesis alternativa; valores válidos son: `'twosided',
          `'greater' y `'less'.


     El resultado devuelto por la función  `test_rank_sum' es un objeto
     `inference_result' con los siguientes apartados:

       1. `'method': procedimiento de inferencia.

       2. `'hypotheses': hipótesis nula y alternativa a ser contrastada.

       3. `'statistic': valor del estadístico de contraste utilizado
          para probar la hipótesis.

       4. `'distribution': distribución del estadístico de contraste,
          junto con sus parámetros.

       5. `'p_value': p-valor del test.


     Ejemplos:

     Contrasta si dos poblaciones tiene medianas similares. Al ser los
     tamaños muestrales pequeños, se realiza el test exacto.

          (%i1) load("stats")$
          (%i2) x:[12,15,17,38,42,10,23,35,28]$
          (%i3) y:[21,18,25,14,52,65,40,43]$
          (%i4) test_rank_sum(x,y);
                        |                 RANK SUM TEST
                        |
                        |              method = Exact test
                        |
                        | hypotheses = H0: med1 = med2 , H1: med1 # med2
          (%o4)         |
                        |                 statistic = 22
                        |
                        |        distribution = [rank_sum, 9, 8]
                        |
                        |          p_value = .1995886466474702

     Ahora, con muestras mayores y empates, el procedimiento realiza la
     aproximación normal. La hipótesis alternativa es H_1: median1 <
     median2.

          (%i1) load("stats")$
          (%i2) x: [39,42,35,13,10,23,15,20,17,27]$
          (%i3) y: [20,52,66,19,41,32,44,25,14,39,43,35,19,56,27,15]$
          (%i4) test_rank_sum(x,y,'alternative='less);
                       |                  RANK SUM TEST
                       |
                       |          method = Asymptotic test. Ties
                       |
                       |  hypotheses = H0: med1 = med2 , H1: med1 < med2
          (%o4)        |
                       |                 statistic = 48.5
                       |
                       | distribution = [normal, 79.5, 18.95419580097078]
                       |
                       |           p_value = .05096985666598441


 -- Función: test_normality (<x>)
     Test de Shapiro-Wilk para el contraste de normalidad. El argumento
     <x> es una lista de números, con tamaño muestral mayor que 2 y
     menor o igual que 5000; bajo cualesquiera otras condiciones, la
     función `test_normality' emite un mensaje de error.

     Referencia:

     [1] Algorithm AS R94, Applied Statistics (1995), vol.44, no.4,
     547-551

     El resultado devuelto por la función `test_normality' es un objeto
     `inference_result' con los siguientes apartados:

       1. `'statistic': valor del estadístico <W>.

       2. `'p_value': p-valor bajo la hipótesis de normalidad.


     Ejemplos:

     Contrasta la normalidad de una población a partir de una muestra
     de tamaño 9.

          (%i1) load("stats")$
          (%i2) x:[12,15,17,38,42,10,23,35,28]$
          (%i3) test_normality(x);
                                 |      SHAPIRO - WILK TEST
                                 |
          (%o3)                  | statistic = .9251055695162436
                                 |
                                 |  p_value = .4361763918860381


 -- Función: linear_regression (<x>)
 -- Función: linear_regression (<x> <option>)
     Regresión lineal múltiple, y_i = b0 + b1*x_1i + b2*x_2i + ... +
     bk*x_ki + u_i, donde u_i son variables aleatorias independientes
     N(0,sigma). El argumento <x> debe ser una matriz con más de una
     columna. La última columna se considera que son las respuestas
     (y_i).

     Opción:

        * `'conflevel', valor por defecto `95/100', nivel de confianza
          para los intervalos de confianza; debe ser una expresión que
          tome un valor en el intervalo (0,1).

     El resultado devuelto por la función `linear_regression' es un
     objeto `inference_result' de Maxima con los siguientes campos:

       1. `'b_estimation': estimadores de los coeficientes de regresión.

       2. `'b_covariances': matriz de covarianzas de los estimadores de
          los coeficientes de regresión.

       3. `b_conf_int': intervalos de confianza para los coeficientes
          de regresión.

       4. `b_statistics': estadísticos para los contrastes de los
          coeficientes.

       5. `b_p_values': p-valores para los contrastes de los
          coeficientes.

       6. `b_distribution': distribución de probabilidad para los
          contrastes de los coeficientes.

       7. `v_estimation': estimador insesgado de la varianza.

       8. `v_conf_int': intervalo de confianza de la varianza.

       9. `v_distribution': distribución de probabilidad para el
          contraste de la varianza.

      10. `residuals': residuos.

      11. `adc': coeficiente de determinación ajustado.

      12. `aic': Criterio de información de Akaike.

      13. `bic': Criterio de información de Bayes.


     Solamente los apartados 1, 4, 5, 6, 7, 8, 9 y 11, en este orden,
     se muestran por defecto. El resto permanecen ocultos hasta que el
     usuario haga uso de las funciones `items_inference' y
     `take_inference'.

     Ejemplo:

     Ajustando un modelo lineal a una muestra tridimensional. La última
     columna se considera que son las respuestas (y_i).

          (%i2) load("stats")$
          (%i3) X:matrix(
              [58,111,64],[84,131,78],[78,158,83],
              [81,147,88],[82,121,89],[102,165,99],
              [85,174,101],[102,169,102])$
          (%i4) fpprintprec: 4$
          (%i5) res: linear_regression(X);
                       |       LINEAR REGRESSION MODEL
                       |
                       | b_estimation = [9.054, .5203, .2397]
                       |
                       | b_statistics = [.6051, 2.246, 1.74]
                       |
                       | b_p_values = [.5715, .07466, .1423]
                       |
          (%o5)        |   b_distribution = [student_t, 5]
                       |
                       |         v_estimation = 35.27
                       |
                       |     v_conf_int = [13.74, 212.2]
                       |
                       |      v_distribution = [chi2, 5]
                       |
                       |             adc = .7922
          (%i6) items_inference(res);
          (%o6) [b_estimation, b_covariances, b_conf_int, b_statistics,
          b_p_values, b_distribution, v_estimation, v_conf_int,
          v_distribution, residuals, adc, aic, bic]
          (%i7) take_inference('b_covariances, res);
                            [  223.9    - 1.12   - .8532  ]
                            [                             ]
          (%o7)             [ - 1.12    .05367   - .02305 ]
                            [                             ]
                            [ - .8532  - .02305   .01898  ]
          (%i8) take_inference('bic, res);
          (%o8)                          30.98
          (%i9) load("draw")$
          (%i10) draw2d(
              points_joined = true,
              grid = true,
              points(take_inference('residuals, res)) )$


File: maxima.info,  Node: Funciones y variables para distribuciones especiales,  Prev: Funciones y variables para stats,  Up: Top

75.4 Funciones y variables para distribuciones especiales
=========================================================

 -- Función: pdf_signed_rank (<x>, <n>)
     Función de densidad de probabilidad de la distribución exacta del
     estadístico de contraste del test de los rangos signados. El
     argumento <x> es un número real y <n> un entero positivo.

     Véase también `test_signed_rank'.

 -- Función: cdf_signed_rank (<x>, <n>)
     Función de probabilidad acumulada de la distribución exacta del
     estadístico de contraste del test de los rangos signados. El
     argumento <x> es un número real y <n> un entero positivo.

     Véase también `test_signed_rank'.

 -- Función: pdf_rank_sum (<x>, <n>, <m>)
     Función de densidad de probabilidad de la distribución exacta del
     estadístico de contraste de Wilcoxon-Mann-Whitney.  El argumento
     <x> es un número real y <n> y <m> son ambos enteros positivos.

     Véase también `test_rank_sum'.

 -- Función: cdf_rank_sum (<x>, <n>, <m>)
     Función de probabilidad acumulada de la distribución exacta del
     estadístico de contraste de Wilcoxon-Mann-Whitney.  El argumento
     <x> es un número real y <n> y <m> son ambos enteros positivos.

     Véase también `test_rank_sum'.


File: maxima.info,  Node: stirling,  Next: stringproc,  Prev: stats,  Up: Top

76 stirling
***********

* Menu:

* Funciones y variables para stirling::


File: maxima.info,  Node: Funciones y variables para stirling,  Prev: stirling,  Up: stirling

76.1 Funciones y variables para stirling
========================================

 -- Función: stirling (<z>,<n>)
 -- Función: stirling (<z>,<n>,<pred>)
     Sustituye `gamma(x)' por la fórmula de Stirling O(1/x^(2n-1)).  Si
     <n> no es un entero no negativo, emite un mensaje de error. Con el
     tercer argumento opcional `pred', la fórmula de Stirling sólo se
     aplica si `pred' vale `true'.

     Referencia: Abramowitz & Stegun, " Handbook of mathematical
     functions", 6.1.40.

     Ejemplos:
          (%i1) load (stirling)$

          (%i2) stirling(gamma(%alpha+x)/gamma(x),1);
                 1/2 - x             x + %alpha - 1/2
          (%o2) x        (x + %alpha)
                                             1           1
                                      --------------- - ---- - %alpha
                                      12 (x + %alpha)   12 x
                                    %e
          (%i3) taylor(%,x,inf,1);
                              %alpha       2    %alpha
                    %alpha   x       %alpha  - x       %alpha
          (%o3)/T/ x       + -------------------------------- + . . .
                                           2 x
          (%i4) map('factor,%);
                                                 %alpha - 1
                   %alpha   (%alpha - 1) %alpha x
          (%o4)   x       + -------------------------------
                                            2

     La función `stirling' conoce la diferencia existente entre la
     variable 'gamma' y la función gamma:

          (%i5) stirling(gamma + gamma(x),0);
                                              x - 1/2   - x
          (%o5)    gamma + sqrt(2) sqrt(%pi) x        %e
          (%i6) stirling(gamma(y) + gamma(x),0);
                                   y - 1/2   - y
          (%o6) sqrt(2) sqrt(%pi) y        %e
                                                        x - 1/2   - x
                                   + sqrt(2) sqrt(%pi) x        %e

     Para aplicar la fórmula de Stirling sólo a aquellos términos que
     contengan la variable `k', hágase uso del tercer argumento
     opcional; por ejemplo,
          (%i7) makegamma(pochhammer(a,k)/pochhammer(b,k));
          (%o7) (gamma(b)*gamma(k+a))/(gamma(a)*gamma(k+b))
          (%i8) stirling(%,1, lambda([s], not(freeof(k,s))));
          (%o8) (%e^(b-a)*gamma(b)*(k+a)^(k+a-1/2)*(k+b)^(-k-b+1/2))/gamma(a)

     Los términos `gamma(a)' y `gamma(b)' no contienen a `k', por lo
     que la fórmula de Stirling no ha sido aplicada a ellos.

     Antes de hacer uso de esta función ejecútese  `load("stirling")'.


File: maxima.info,  Node: stringproc,  Next: to_poly_solve,  Prev: stirling,  Up: Top

77 stringproc
*************

* Menu:

* Introducción al procesamiento de cadenas::
* Funciones y variables para entrada y salida::
* Funciones y variables para caracteres::
* Funciones y variables para cadenas::


File: maxima.info,  Node: Introducción al procesamiento de cadenas,  Next: Funciones y variables para entrada y salida,  Prev: stringproc,  Up: stringproc

77.1 Introducción al procesamiento de cadenas
=============================================

El paquete `stringproc' amplía las capacidades de Maxima para manipular
cadenas de caracteres, al tiempo que añade algunas funciones útiles
para la lectura y escritura de ficheros.

   Para dudas y fallos, por favor contáctese con van.nek at arcor.de .

   En Maxima, una cadena de caracteres se construye fácilmente
escribiéndola entre comillas dobles, como en `"texto"'.  La función
`stringp' comprueba si el argumento es una cadena.

     (%i1) m: "text";
     (%o1)                         text
     (%i2) stringp(m);
     (%o2)                         true

   Los caracteres se representan como cadenas de longitud unidad.  No
se tratan como caracteres Lisp. Se pueden chequear con la función
`charp' (o con `lcharp' para los caracteres Lisp).  La conversión de
caracteres Lisp a caracteres Maxima se realiza con la función `cunlisp'.

     (%i1) c: "e";
     (%o1)                           e
     (%i2) [charp(c),lcharp(c)];
     (%o2)                     [true, false]
     (%i3) supcase(c);
     (%o3)                           E
     (%i4) charp(%);
     (%o4)                         true

   Todos los caracteres devueltos por las funciones de `stringproc' son
caracteres de Maxima. Puesto que los caracteres introducidos son
cadenas de longitud igual a la unidad, se pueden utilizar las funciones
de cadenas también para los caracteres, como se ha hecho con `supcase'
en el anterior ejemplo.

   Es importante tener en cuenta que el primer carácter en una cadena
de Maxima ocupa la posición 1. Esto se ha diseñado así para mantener la
compatibilidad con las listas de Maxima. Véanse las definiciones de
`charat' y `charlist' para ver ejemplos.

   Las funciones de cadena se utilizan frecuentemente cuando se trabaja
con ficheros. El siguiente ejemplo muestra algunas de estas funciones
en acción.

   Ejemplo:

   La función `openw' envía un flujo de salida hacia un fichero,
entonces `printf' permitirá formatera la escritura en este fichero.
Véase `printf' para más detalles.

     (%i1) s: openw("E:/file.txt");
     (%o1)                    #<output stream E:/file.txt>
     (%i2) for n:0 thru 10 do printf( s, "~d ", fib(n) );
     (%o2)                                done
     (%i3) printf( s, "~%~d ~f ~a ~a ~f ~e ~a~%",
                   42,1.234,sqrt(2),%pi,1.0e-2,1.0e-2,1.0b-2 );
     (%o3)                                false
     (%i4) close(s);
     (%o4)                                true

   Una vez cerrado el flujo, se podrá abrir nuevamente. La función
`readline' devuelve el renglón entero como una única cadena. El paquete
`stringproc' dispone de muchas funciones para manipular cadenas. La
separación de palabras se puede hacer con `split' o `tokens'.

     (%i5) s: openr("E:/file.txt");
     (%o5)                     #<input stream E:/file.txt>
     (%i6) readline(s);
     (%o6)                     0 1 1 2 3 5 8 13 21 34 55
     (%i7) line: readline(s);
     (%o7)               42 1.234 sqrt(2) %pi 0.01 1.0E-2 1.0b-2
     (%i8) list: tokens(line);
     (%o8)           [42, 1.234, sqrt(2), %pi, 0.01, 1.0E-2, 1.0b-2]
     (%i9) map( parsetoken, list );
     (%o9)           [42, 1.234, false, false, 0.01, 0.01, false]

   La función `parsetoken' sólo analiza sintácticamente números enteros
y decimales. El análisis de símbolos y números decimales grandes (big
floats) necesita `parse_string', que se cargar automáticamente desde
`eval_string.lisp'.

     (%i5) s: openr("E:/file.txt");
     (%o5)                     #<input stream E:/file.txt>
     (%i6) readline(s);
     (%o6)                     0 1 1 2 3 5 8 13 21 34 55
     (%i7) line: readline(s);
     (%o7)               42 1.234 sqrt(2) %pi 0.01 1.0E-2 1.0b-2
     (%i8) list: tokens(line);
     (%o8)           [42, 1.234, sqrt(2), %pi, 0.01, 1.0E-2, 1.0b-2]
     (%i9) map( parse_string, list );
     (%o9)            [42, 1.234, sqrt(2), %pi, 0.01, 0.01, 1.0b-2]
     (%i10) float(%);
     (%o10) [42.0, 1.234, 1.414213562373095, 3.141592653589793, 0.01,
                                                          0.01, 0.01]
     (%i11) readline(s);
     (%o11)                               false
     (%i12) close(s)$

   La función `readline' devuelve `false' cuando se alcanza el final
del fichero.


File: maxima.info,  Node: Funciones y variables para entrada y salida,  Next: Funciones y variables para caracteres,  Prev: Introducción al procesamiento de cadenas,  Up: stringproc

77.2 Funciones y variables para entrada y salida
================================================

Ejemplo:

     (%i1) s: openw("E:/file.txt");
     (%o1)                     #<output stream E:/file.txt>
     (%i2) control:
     "~2tAn atom: ~20t~a~%~2tand a list: ~20t~{~r ~}~%~2t\
                and an integer: ~20t~d~%"$
     (%i3) printf( s,control, 'true,[1,2,3],42 )$
     (%o3)                                false
     (%i4) close(s);
     (%o4)                                true
     (%i5) s: openr("E:/file.txt");
     (%o5)                     #<input stream E:/file.txt>
     (%i6) while stringp( tmp:readline(s) ) do print(tmp)$
       An atom:          true
       and a list:       one two three
       and an integer:   42
     (%i7) close(s)$

 -- Función: close (<stream>)
     Cierra el flujo de datos <stream> y devuelve `true' si <stream>
     había sido abierto.


 -- Función: flength (<stream>)
     Devuelve el número de elementos en el flujo de datos <stream>.


 -- Función: fposition (<stream>)
 -- Función: fposition (<stream>, <pos>)
     Devuelve la posición actual en el flujo de datos <stream> si no se
     utiliza <pos>.  Si se utiliza <pos>, `fposition' ajusta la
     posición en <stream>.  El argumento <pos> debe ser un número
     positivo, ocupando el primer elemento en <stream> la posición 1.


 -- Función: freshline ()
 -- Función: freshline (<stream>)
     Escribe una nueva línea (en el flujo de datos <stream>) si la
     posición actual no corresponde al inicio de la línea.

     Véase también `newline'.


 -- Función: newline ()
 -- Función: newline (<stream>)
     Escribe una nueva línea (en el flujo de datos  <stream>).

     Véase `sprint' para un ejemplo de uso de `newline()'.

     Nótese que hay algunos casos en los que `newline' no trabaja según
     lo esperado.


 -- Función: opena (<file>)
     Devuelve un flujo de datos al fichero <file>.  Si se abre un
     fichero ya existente, `opena' añade elementos al final del fichero.


 -- Función: openr (<file>)
     Devuelve un flujo de datos de entrada al fichero <file>.  Si
     <file> no existe, será creado.

 -- Función: openw (<file>)
     Devuelve un flujo de datos de salida al fichero <file>.  Si <file>
     no existe, será creado.  Si se abre un fichero ya existente,
     `openw' lo modifica borrando el contenido anterior.

 -- Función: printf (<dest>, <string>)
 -- Función: printf (<dest>, <string>, <expr_1>, ..., <expr_n>)
     Pone al alcance de Maxima la función FORMAT de Common Lisp.

     Véanse las referencias de Lisp para más información.

     La siguiente descripción y los ejemplos pueden dar una idea de
     cómo usar `printf'.

             ~%       nueva línea
             ~&       línea de refresco
             ~t       tabulación
             ~$       moneda
             ~d       entero en base decimal
             ~b       entero en base binaria
             ~o       entero en base octal
             ~x       entero en base hexadecimal
             ~br      entero en base b
             ~r       deletrea un entero
             ~p       plural
             ~f       decimal en coma flotante
             ~e       notación científica
             ~g       ~f o ~e, dependiendo de la magnitud
             ~h       número decimal grande (bigfloat)
             ~a       utiliza la función `string' de Maxima
             ~s       como ~a, pero las cadenas se devuelven entre "comillas dobles"
             ~~       ~
             ~<       justificación, ~> termina
             ~(       conversor mayúscula/minúscula, ~) termina
             ~[       selección, ~] termina
             ~{       iteración, ~} termina

     La directiva `~[' está indexada a partir del cero.  Téngase en
     cuenta que la directiva `~*' no está soportada.

          (%i1) printf( false, "~a ~a ~4f ~a ~@r",
                        "String",sym,bound,sqrt(12),144), bound = 1.234;
          (%o1)                 String sym 1.23 2*sqrt(3) CXLIV
          (%i2) printf( false,"~{~a ~}",["one",2,"THREE"] );
          (%o2)                          one 2 THREE
          (%i3) printf( true,"~{~{~9,1f ~}~%~}",mat ),
                        mat = args( matrix([1.1,2,3.33],[4,5,6],[7,8.88,9]) )$
                1.1       2.0       3.3
                4.0       5.0       6.0
                7.0       8.9       9.0
          (%i4) control: "~:(~r~) bird~p ~[is~;are~] singing."$
          (%i5) printf( false,control, n,n,if n=1 then 0 else 1 ), n=2;
          (%o5)                    Two birds are singing.

     Si <dest> es un flujo de datos o `true', entonces `printf'
     devuelve `false'. En otro caso, `printf' devuelve una cadena con
     la salida.

 -- Función: readline (<stream>)
     Devuelve una cadena con los caracteres desde la posición actual en
     el flujo de datos <stream> hasta el final de la línea, o `false'
     si está al final del fichero.

 -- Función: sprint (<expr_1>, ..., <expr_n>)
     Evalúa y muestra sus argumentos uno tras otro en un renglón
     comenzando por su extremo izquierdo.

     La función `newline()', que se carga automáticamente desde
     `stringproc.lisp', puede ser de utilidad si se quiere intercalar
     un salto de línea.

          (%i1) for n:0 thru 19 do sprint( fib(n) )$
          0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181
          (%i2) for n:0 thru 22 do (
                   sprint(fib(n)), if mod(n,10)=9 then newline() )$
          0 1 1 2 3 5 8 13 21 34
          55 89 144 233 377 610 987 1597 2584 4181
          6765 10946 17711



File: maxima.info,  Node: Funciones y variables para caracteres,  Next: Funciones y variables para cadenas,  Prev: Funciones y variables para entrada y salida,  Up: stringproc

77.3 Funciones y variables para caracteres
==========================================

 -- Función: alphacharp (<char>)
     Devuelve `true' si <char> es una carácter alfabético.

 -- Función: alphanumericp (<char>)
     Devuelve `true' si <char> es una carácter alfabético o un dígito.

 -- Función: ascii (<int>)
     Devuelve el carácter correspondiente al número ASCII <int>,
     debiendo ser -1 < int < 256.

          (%i1) for n from 0 thru 255 do (
            tmp: ascii(n),
            if alphacharp(tmp) then sprint(tmp), if n=96 then newline() )$
          A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
          a b c d e f g h i j k l m n o p q r s t u v w x y z


 -- Función: cequal (<char_1>, <char_2>)
     Devuelve `true' si <char_1> y <char_2> son el mismo carácter.

 -- Función: cequalignore (<char_1>, <char_2>)
     Como `cequal', pero ignora si las letras están en mayúsculas o
     minúsculas.

 -- Función: cgreaterp (<char_1>, <char_2>)
     Devuelve  `true' si el número ASCII de <char_1> es mayor que el de
     <char_2>.

 -- Función: cgreaterpignore (<char_1>, <char_2>)
     Como `cgreaterp', pero ignora si las letras están en mayúsculas o
     minúsculas.

 -- Función: charp (<obj>)
     Devuelve `true' si <obj> es un carácter de Maxima.

 -- Función: cint (<char>)
     Devuelve el número ASCII de <char>.

 -- Función: clessp (<char_1>, <char_2>)
     Devuelve  `true' si el número ASCII de <char_1> es menor que el de
     <char_2>.

 -- Función: clesspignore (<char_1>, <char_2>)
     Como `clessp', pero ignora si las letras están en mayúsculas o
     minúsculas.

 -- Función: constituent (<char>)
     Devuelve `true' si <char> es un carácter gráfico y no el carácter
     espacio. Un carácter gráfico es el que se puede ver y con un
     espacio añadido; `constituent' está definido por Paul Graham, ANSI
     Common Lisp, 1996, page 67.

          (%i1) for n from 0 thru 255 do (
          tmp: ascii(n), if constituent(tmp) then sprint(tmp) )$
          ! " #  %  ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ? @ A B
          C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _ ` a b c
          d e f g h i j k l m n o p q r s t u v w x y z { | } ~


 -- Función: cunlisp (<lisp_char>)
     Convierte un carácter Lisp en uno de Maxima. El uso de esta
     función por parte del usuario no será necesario.

 -- Función: digitcharp (<char>)
     Devuelve `true' si <char> es un dígito.

 -- Función: lcharp (<obj>)
     Devuelve `true' si <obj> es un carácter de Lisp.  El uso de esta
     función por parte del usuario no será necesario.

 -- Función: lowercasep (<char>)
     Devuelve  `true' si <char> es un carácter en minúscula.

 -- Variable: newline
     El carácter de nueva línea.

 -- Variable: space
     El carácter de espacio.

 -- Variable: tab
     El carácter de tabulación.

 -- Función: uppercasep (<char>)
     Devuelve `true' si <char> es un carácter en mayúscula.


File: maxima.info,  Node: Funciones y variables para cadenas,  Prev: Funciones y variables para caracteres,  Up: stringproc

77.4 Funciones y variables para cadenas
=======================================

 -- Función: stringp (<obj>)
     Devuelve `true' si <obj> es una cadena.  Véase un ejemplo en la
     introducción.

 -- Función: charat (<string>, <n>)
     Devuelve el <n>-ésimo carácter de <string>.  Al primer carácter de
     <string> le corresponde <n> = 1.

          (%i1) charat("Lisp",1);
          (%o1)                           L


 -- Función: charlist (<string>)
     Devuelve una lista con todos los caracteres de <string>.

          (%i1) charlist("Lisp");
          (%o1)                     [L, i, s, p]
          (%i2) %[1];
          (%o2)                           L


 -- Función: eval_string (<str>)
     Analiza sintácticamente la cadena <str> como una expresión de
     Maxima y la evalúa. La cadena <str> puede terminar o no con
     cualquiera de los símbolos de final de sentencia (dólar `$' o
     punto y coma `;').  Sólo se analiza la primera expresión si hay
     más de una.

     Se emitirá un mensaje de error si <str> no es una cadena.

     Ejemplos:

          (%i1) eval_string ("foo: 42; bar: foo^2 + baz");
          (%o1)                       42
          (%i2) eval_string ("(foo: 42, bar: foo^2 + baz)");
          (%o2)                   baz + 1764

     Véase también `parse_string'.

 -- Función: parse_string (<str>)
     Analiza sintácticamente la cadena <str> como una expresión de
     Maxima, pero no la evalúa. La cadena <str> puede terminar o no con
     cualquiera de los símbolos de final de sentencia (dólar `$' o
     punto y coma `;').  Sólo se analiza la primera expresión si hay
     más de una.

     Se emitirá un mensaje de error si <str> no es una cadena.

     Ejemplos:

          (%i1) parse_string ("foo: 42; bar: foo^2 + baz");
          (%o1)                    foo : 42
          (%i2) parse_string ("(foo: 42, bar: foo^2 + baz)");
                                             2
          (%o2)          (foo : 42, bar : foo  + baz)

     Véase también `eval_string'.

 -- Función: scopy (<string>)
     Devuelve una copia nueva de la cadena <string>.

 -- Función: sdowncase (<string>)
 -- Función: sdowncase (<string>, <start>)
 -- Función: sdowncase (<string>, <start>, <end>)
     Convierte caracteres en minúscula a mayúscula. Véase también
     `supcase'.

 -- Función: sequal (<string_1>, <string_2>)
     Devuelve `true' si <string_1> y <string_2> son dos cadenas de
     caracteres iguales.


 -- Función: sequalignore (<string_1>, <string_2>)
     Igual que `sequal' pero no diferencia entre minúsculas y
     mayúsculas..


 -- Función: sexplode (<string>)
     El nombre `sexplode' es un seudónimo de la función `charlist'.


 -- Función: simplode (<list>)
 -- Función: simplode (<list>, <delim>)
     La función `simplode' admite como entrada una lista de expresiones
     para luego convertirla en una cadena de caracteres. Si no se
     utiliza la opción <delim> para indicar el delimitador, entonces
     `simplode' no hace uso de ninguno. El valor de <delim> puede ser
     cualquier cadena.

          (%i1) simplode(["xx[",3,"]:",expand((x+y)^3)]);
          (%o1)             xx[3]:y^3+3*x*y^2+3*x^2*y+x^3
          (%i2) simplode( sexplode("stars")," * " );
          (%o2)                   s * t * a * r * s
          (%i3) simplode( ["One","more","coffee."]," " );
          (%o3)                   One more coffee.


 -- Función: sinsert (<seq>, <string>, <pos>)
     Devuelve la concatenación de las cadenas `substring (<string>, 1,
     <pos> - 1)', <seq> y `substring (<string>, <pos>)'.  Nótese que al
     primer carácter de <string> le corresponde la posición 1.

          (%i1) s: "A submarine."$
          (%i2) concat( substring(s,1,3),"yellow ",substring(s,3) );
          (%o2)                  A yellow submarine.
          (%i3) sinsert("hollow ",s,3);
          (%o3)                  A hollow submarine.


 -- Función: sinvertcase (<string>)
 -- Función: sinvertcase (<string>, <start>)
 -- Función: sinvertcase (<string>, <start>, <end>)
     Devuelve la misma cadena <string> pero con todos sus caracteres
     desde la posición <start> hasta <end> invertidos, esto es, las
     mayúsculas se convierten en minúsculas y éstas en mayúsculas.  Si
     no se incluye el argumento <end>, se invierten todos los caracteres
     desde <start> hasta el final de la cadena.

          (%i1) sinvertcase("sInvertCase");
          (%o1)                      SiNVERTcASE


 -- Función: slength (<string>)
     Devuelve el número de caracteres de <string>.


 -- Función: smake (<num>, <char>)
     Construye una cadena de longitud <num> con todos sus caracteres
     iguales a <char>.

          (%i1) smake(3,"w");
          (%o1)                          www


 -- Función: smismatch (<string_1>, <string_2>)
 -- Función: smismatch (<string_1>, <string_2>, <test>)
     Devuelve la posición del primer carácter de <string_1> distinto del
     correpondiente a <string_2>. La respuesta será `false' si no existe
     tal carácter. Por defecto, la función de comparación es `sequal'.
     Si se quiere ignorar la diferencia entre mayúsculas y minúsculas,
     hágase uso de `sequalignore' para el argumento <test>.

          (%i1) smismatch("seven","seventh");
          (%o1)                           6


 -- Función: split (<string>)
 -- Función: split (<string>, <delim>)
 -- Función: split (<string>, <delim>, <multiple>)
     Devuelve la lista de todos los lexemas (tokens) de <string>.  La
     función `split' utiliza <delim> como delimitador, y en caso de no
     ser utilizado este argumento, será utilizado el espacio en blanco
     como delimitador por defecto. El argumento <multiple> es una
     variable booleana con valor `true' por defecto. Los delimitadores
     múltiples se leen como uno solo, lo que resulta de utilidad si las
     tabulaciones son almacenadas como secuencias de espacios en
     blanco. Si a <multiple> se le asigna el valor `false', se
     consirararán todos los delimitadores.

          (%i1) split("1.2   2.3   3.4   4.5");
          (%o1)                 [1.2, 2.3, 3.4, 4.5]
          (%i2) split("first;;third;fourth",";",false);
          (%o2)               [first, , third, fourth]


 -- Función: sposition (<char>, <string>)
     Devuelve la posición del primer carácter de <string> que coincide
     con <char>. Al primer carácter de <string> le corresponde la
     posición 1.  Para cuando se quiera ignorar la diferencia entre
     mayúsculas y minúsculas, véase <ssearch>.

 -- Función: sremove (<seq>, <string>)
 -- Función: sremove (<seq>, <string>, <test>)
 -- Función: sremove (<seq>, <string>, <test>, <start>)
 -- Función: sremove (<seq>, <string>, <test>, <start>, <end>)
     Devuelve la cadena <string> pero sin las subcadenas que coinciden
     con <seq>.  La función de comparación por defecto es `sequal'.  Si
     se quiere ignorar la diferencia entre mayúsculas y minúsculas,
     hágase uso de `sequalignore' para el argumento <test>.  Utilícense
     <start> y <end> para acotar la búsqueda.  Al primer carácter de
     <string> le corresponde la posición 1.

          (%i1) sremove("n't","I don't like coffee.");
          (%o1)                   I do like coffee.
          (%i2) sremove ("DO ",%,'sequalignore);
          (%o2)                    I like coffee.


 -- Función: sremovefirst (<seq>, <string>)
 -- Función: sremovefirst (<seq>, <string>, <test>)
 -- Función: sremovefirst (<seq>, <string>, <test>, <start>)
 -- Función: sremovefirst (<seq>, <string>, <test>, <start>, <end>)
     Actúa de forma similar a la función `sremove', pero sólo elimina
     la primera aparición de la subcadena `seq'.


 -- Función: sreverse (<string>)
     Devuelve una cadena con todos los caracteres de <string> en orden
     inverso.


 -- Función: ssearch (<seq>, <string>)
 -- Función: ssearch (<seq>, <string>, <test>)
 -- Función: ssearch (<seq>, <string>, <test>, <start>)
 -- Función: ssearch (<seq>, <string>, <test>, <start>, <end>)
     Devuelve la posición de la primera subcadena de <string> que
     coincide con la cadena <seq>.  La función de comparación por
     defecto es `sequal'.  Si se quiere ignorar la diferencia entre
     mayúsculas y minúsculas, hágase uso de `sequalignore' para el
     argumento <test>.  Utilícense <start> y <end> para acotar la
     búsqueda.  Al primer carácter de <string> le corresponde la
     posición 1.

          (%i1) ssearch("~s","~{~S ~}~%",'sequalignore);
          (%o1)                                  4


 -- Función: ssort (<string>)
 -- Función: ssort (<string>, <test>)
     Devuelve una cadena con todos los caracteres de <string> en un
     orden tal que no haya dos caracteres sucesivos <c> y <d> que
     verifiquen que `test (<c>, <d>)' sea igual `false' y `test (<d>,
     <c>)' igual a `true'.  La función de comparación <test> por
     defecto es  <clessp>, siendo el conjunto de posibles valores para
     este argumento `{clessp, clesspignore, cgreaterp, cgreaterpignore,
     cequal, cequalignore}'.

          (%i1) ssort("I don't like Mondays.");
          (%o1)                    '.IMaddeiklnnoosty
          (%i2) ssort("I don't like Mondays.",'cgreaterpignore);
          (%o2)                 ytsoonnMlkIiedda.'


 -- Función: ssubst (<new>, <old>, <string>)
 -- Función: ssubst (<new>, <old>, <string>, <test>)
 -- Función: ssubst (<new>, <old>, <string>, <test>, <start>)
 -- Función: ssubst (<new>, <old>, <string>, <test>, <start>, <end>)
     Devuelve una cadena similar a <string> pero en la que aquellas
     subcadenas coincidentes con <old> han sido sustituidas por <new>.
     Las subcadenas <old> y <new> no necesitan ser de la misma longitud.
     La función de comparación por defecto es `sequal'.  Si se quiere
     ignorar la diferencia entre mayúsculas y minúsculas durante la
     búsqueda de <old>, hágase uso de `sequalignore' para el argumento
     <test>.  Utilícense <start> y <end> para acotar la búsqueda.  Al
     primer carácter de <string> le corresponde la posición 1.

          (%i1) ssubst("like","hate","I hate Thai food. I hate green tea.");
          (%o1)          I like Thai food. I like green tea.
          (%i2) ssubst("Indian","thai",%,'sequalignore,8,12);
          (%o2)         I like Indian food. I like green tea.


 -- Función: ssubstfirst (<new>, <old>, <string>)
 -- Función: ssubstfirst (<new>, <old>, <string>, <test>)
 -- Función: ssubstfirst (<new>, <old>, <string>, <test>, <start>)
 -- Función: ssubstfirst (<new>, <old>, <string>, <test>, <start>,
          <end>)
     Actúa de forma similar a la función `subst', pero sólo hace la
     sustitución en la primera coincidencia con <old>.

 -- Función: strim (<seq>,<string>)
     Devuelve la cadena <string> pero recortando los caracteres de
     <seq> que tuviese en sus extremos.

          (%i1) "/* comment */"$
          (%i2) strim(" /*",%);
          (%o2)                        comment
          (%i3) slength(%);
          (%o3)                           7


 -- Función: striml (<seq>, <string>)
     Actúa de forma similar a `strim', pero sólo recorta en el extremo
     final de <string>.

 -- Función: strimr (<seq>, <string>)
     Actúa de forma similar a `strim', pero sólo recorta en el extremo
     inicial de <string>.

 -- Función: substring (<string>, <start>)
 -- Función: substring (<string>, <start>, <end>)
     Devuelve la subcadena de <string> que comienza en la posición
     <start> y termina en la posición <end>.  El carácter en la
     posición <end> no se incluye.  En caso de no suministrarse el
     argumento <end>, la subcadena se extenderá hasta el final.  Al
     primer carácter de <string> le corresponde la posición 1.

          (%i1) substring("substring",4);
          (%o1)                        string
          (%i2) substring(%,4,6);
          (%o2)                          in


 -- Función: supcase (<string>)
 -- Función: supcase (<string>, <start>)
 -- Función: supcase (<string>, <start>, <end>)
     Devuelve la cadena <string> con todos sus caracteres entre las
     posiciones <start> y <end> en minúscula transformados a mayúscula.
     En caso de no suministrarse el argumento <end>, los cambios se
     extenderán hasta el final.

          (%i1) supcase("english",1,2);
          (%o1)                        English


 -- Función: tokens (<string>)
 -- Función: tokens (<string>, <test>)
     Devuelve la lista de todos los lexemas (tokens) de <string>.  Los
     lexemas son subcadenas cuyos caracteres satisfacen la  condición
     <test>.  Si no se suministra el argumento <test>, se utilizará la
     condición <constituent>, siendo el conjunto de las otras
     alternativas `{constituent, alphacharp, digitcharp, lowercasep,
     uppercasep, charp, characterp, alphanumericp}'.

          (%i1) tokens("24 October 2005");
          (%o1)                  [24, October, 2005]
          (%i2) tokens("05-10-24",'digitcharp);
          (%o2)                     [05, 10, 24]
          (%i3) map(parse_string,%);
          (%o3)                      [5, 10, 24]



File: maxima.info,  Node: to_poly_solve,  Next: unit,  Prev: stringproc,  Up: Top

78 to_poly_solve
****************

* Menu:

* Funciones y variables para to_poly_solve::



Local Variables:
coding: iso-8859-1
End:
