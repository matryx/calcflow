This is maxima.info, produced by makeinfo version 4.13 from maxima.texi.

Este é o Manual do Maxima no formato Texinfo

   Copyright 1994, 2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).     Um sistema de álgebra computacional.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Introdução às Equações Diferenciais,  Next: Definições para Equações Diferenciais,  Prev: Equações Diferenciais,  Up: Equações Diferenciais

22.1 Introdução às Equações Diferenciais
========================================

Esta secção descreve as funções disponíveis no Maxima para obter a
solução analítica de alguns tipos específicos de equações diferencias de
primeira e segunda ordem. Para obter a solução numérica dum sistema de
equações diferenciais, consulte o pacote adicional `dynamics'. Para
obter representações gráficas no espaço de fase, consulte o pacote
adicional `plotdf'.


File: maxima.info,  Node: Definições para Equações Diferenciais,  Prev: Introdução às Equações Diferenciais,  Up: Equações Diferenciais

22.2 Definições para Equações Diferenciais
==========================================

 -- Função: bc2 (<solução>, <xval1>, <yval1>, <xval2>, <yval2>)
     Resolve um problema de valores fronteira para uma equação
     diferencial de segunda ordem.  Aqui: <solução> é uma solução geral
     para a equação, calculada por `ode2'; <xval1> define o valor da
     variável independente, num primeiro ponto, na forma `<x> = <x1>', e
     <yval1> define o valor da variável dependente, no mesmo ponto, na
     forma `<y> = <y1>'. As expressões <xval2> e <yval2> definem os
     valores das mesmas variáveis, num segundo ponto, usando a mesma
     forma.

     Veja um exemplo da sua utilização na documentação de `ode2'.


 -- Função: desolve (<eqn>, <x>)
 -- Função: desolve ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_n>])
     A função `dsolve' resolve sistemas de equações diferenciais
     ordinárias lineares usando transformada de Laplace. Aqui as
     expressões <eqn> são equações diferenciais nas variáveis
     dependentes <x_1>, ..., <x_n>.  A relação funcional de <x_1>, ...,
     <x_n> na variável independente deve ser indicada explicitamente
     nas variáveis e nas suas derivadas. Por exemplo, esta forma de
     definir as equações não seria correcta:

          eqn_1: 'diff(f,x,2) = sin(x) + 'diff(g,x);
          eqn_2: 'diff(f,x) + x^2 - f = 2*'diff(g,x,2);

     A forma correcta seria:

          eqn_1: 'diff(f(x),x,2) = sin(x) + 'diff(g(x),x);
          eqn_2: 'diff(f(x),x) + x^2 - f(x) = 2*'diff(g(x),x,2);

     Assim, a chamada à função `desolve' seria:
          desolve([eqn_1, eqn_2], [f(x),g(x)]);

     Se as condições iniciais em `x=0' forem conhecidas, poderão ser
     fornecidas antes de usar `desolve', através de `atvalue'.

          (%i1) 'diff(f(x),x)='diff(g(x),x)+sin(x);
                           d           d
          (%o1)            -- (f(x)) = -- (g(x)) + sin(x)
                           dx          dx
          (%i2) 'diff(g(x),x,2)='diff(f(x),x)-cos(x);
                            2
                           d            d
          (%o2)            --- (g(x)) = -- (f(x)) - cos(x)
                             2          dx
                           dx
          (%i3) atvalue('diff(g(x),x),x=0,a);
          (%o3)                           a
          (%i4) atvalue(f(x),x=0,1);
          (%o4)                           1
          (%i5) desolve([%o1,%o2],[f(x),g(x)]);
                            x
          (%o5) [f(x) = a %e  - a + 1, g(x) =

                                                          x
                                             cos(x) + a %e  - a + g(0) - 1]
          (%i6) [%o1,%o2],%o5,diff;
                       x       x      x                x
          (%o6)   [a %e  = a %e , a %e  - cos(x) = a %e  - cos(x)]

     Se `desolve' não pode obter uma solução, retorna `false'.


 -- Função: ic1 (<solução>, <xval>, <yval>)
     Resolve problemas de valor inicial para equações diferenciais de
     primeira ordem.  Aqui <solução> é uma solução geral para a
     equação, na forma dada por `ode2', <xval> dá um valor inicial para
     a variável independente, na forma `<x> = <x0>', e <yval> dá o
     valor inicial para a variável dependente, na forma `<y> = <y0>'.

     Veja um exemplo da sua utilização na documentação de `ode2'.


 -- Função: ic2 (<solução>, <xval>, <yval>, <dval>)
     Resolve problemas de valores iniciais para equações diferenciais
     de segunda ordem. Aqui <solução> é uma solução geral para a
     equação, na forma dada por `ode2', <xval> dá um valor inicial para
     a variável independente, na forma `<x> = <x0>', <yval> dá o valor
     inicial para a variável dependente, na forma `<y> = <y0>' e <dval>
     dá o valor inicial para a primeira derivada da variável
     dependente, em função da variável independente, na forma
     `diff(<y>,<x>) = <dy0>' (`diff' não tem que ser precedido por
     apóstrofo).

     Veja um exemplo da sua utilização na documentação de `ode2'.


 -- Função: ode2 (<eqn>, <dvar>, <ivar>)
     A função `ode2' resolve uma equação diferencial ordinária (EDO) de
     primeira ou de segunda ordem.  Precisa de três argumentos: uma EDO
     dada por <eqn>, a variável dependente <dvar>, e a variável
     independente <ivar>.  Quando conseguir, retorna uma solução para a
     variável dependente, na forma explícita ou implícita. `%c' é usado
     para representar a constante de integração no caso de equações de
     primeira ordem, e `%k1' e `%k2' as constantes para equações de
     segunda ordem. A dependência da variável dependente na variável
     independente não tem que ser escrita em forma explícita, como no
     caso de `desolve', mas a variável independente deverá ser indicada
     sempre no terceiro argumento.

     Se por alguma razão `ode2' não conseguir encontrar a solução,
     retornará `false', após talvez mostrar uma mensagem de erro. Os
     métodos implementados para equações diferenciais de primeira
     ordem, na ordem em que serão testados, são: linear, separável,
     exacta - talvez requerendo um factor de integração, homogénea,
     equação de Bernoulli, homogénea generalizada. Os tipos de equações
     de segunda ordem que podem ser resolvidas são: coeficientes
     constantes, exactas, linear homogéneas com coeficientes
     não-constantes que possam ser transformados para constates,
     equação de Euler ou equi-dimensional, equações que possam ser
     resolvidas pelo método de variação dos parâmetros, e equações que
     não dependam ou da variável independente ou da variável dependente
     de modo que possam ser reduzidas a duas equações lineares de
     primeira ordem a serem resolvidas sequêncialmente.

     Durante o processo de resolução da EDO, serão dados valores a
     várias variáveis locais, com fins puramente informativos: `método'
     denota o método de solução usado (por exemplo, `linear'),
     `intfactor' denota qualquer factor integrante utilizado,
     `odeindex' denota o índice para o método de Bernoulli ou para o
     método homogéneo generalizado, e `yp' denota a solução particular
     no método de variação dos parâmetros.

     Para resolver problemas de valores iniciais (PVI) estão
     disponíveis as funções `ic1' e `ic2'e, para equações de primeira e
     segunda ordem, e para resolver problemas de valores fronteira
     (PVF) de segunda ordem pode usar-se a função `bc2'.

     Exemplo:

          (%i1) x^2*'diff(y,x) + 3*y*x = sin(x)/x;
                                2 dy           sin(x)
          (%o1)                x  -- + 3 x y = ------
                                  dx             x
          (%i2) ode2(%,y,x);
                                       %c - cos(x)
          (%o2)                    y = -----------
                                            3
                                           x
          (%i3) ic1(%o2,x=%pi,y=0);
                                        cos(x) + 1
          (%o3)                   y = - ----------
                                             3
                                            x
          (%i4) 'diff(y,x,2) + y*'diff(y,x)^3 = 0;
                                   2
                                  d y      dy 3
          (%o4)                   --- + y (--)  = 0
                                    2      dx
                                  dx
          (%i5) ode2(%,y,x);
                                3
                               y  + 6 %k1 y
          (%o5)                ------------ = x + %k2
                                    6
          (%i6) ratsimp(ic2(%o5,x=0,y=0,'diff(y,x)=2));
                                       3
                                    2 y  - 3 y
          (%o6)                   - ---------- = x
                                        6
          (%i7) bc2(%o5,x=0,y=1,x=1,y=3);
                                   3
                                  y  - 10 y       3
          (%o7)                   --------- = x - -
                                      6           2



File: maxima.info,  Node: Numérico,  Next: Arrays,  Prev: Equações Diferenciais,  Up: Top

23 Numérico
***********

* Menu:

* Introdução a Numérico::
* Pacotes de Fourier::
* Definições para Numérico::
* Definições para Séries de Fourier::


File: maxima.info,  Node: Introdução a Numérico,  Next: Pacotes de Fourier,  Prev: Numérico,  Up: Numérico

23.1 Introdução a Numérico
==========================


File: maxima.info,  Node: Pacotes de Fourier,  Next: Definições para Numérico,  Prev: Introdução a Numérico,  Up: Numérico

23.2 Pacotes de Fourier
=======================

O pacote `fft' compreende funções para computação numérica (não
simbólica) das transformações rápidas de Fourier.  `load ("fft")' chama
esse pacote.  Veja `fft'.

   O pacote `fourie' compreende funções para computação simbólica de
séries de Fourier.  `load ("fourie")' chama esse pacote.  Existem
funções no pacote `fourie' para calcular coeficientes da integral de
Fourier e algumas funções para manipulação de expressões.  Veja
`Definições para Séries'.


File: maxima.info,  Node: Definições para Numérico,  Next: Definições para Séries de Fourier,  Prev: Pacotes de Fourier,  Up: Numérico

23.3 Definições para Numérico
=============================

 -- Função: polartorect (<magnitude_array>, <phase_array>)
     Traduz valores complexos da forma `r %e^(%i t)' para a forma `a +
     b %i'.  `load ("fft")' chama essa função dentro do Maxima. Veja
     também `fft'.

     O módulo e a fase, `r' e `t', São tomados de <magnitude_array> e
     <phase_array>, respectivamente. Os valores originais de arrays de
     entrada são substituídos pelas partes real e emaginária, `a' e
     `b', no retorno. As saídas são calculadas como

          a: r cos (t)
          b: r sin (t)

     Os arrays de entrada devem ter o mesmo tamanho  e ser
     unidimensionais.  O tamanho do array não deve ser uma potência de
     2.

     `polartorect' é a função inversa de `recttopolar'.


 -- Função: recttopolar (<real_array>, <imaginary_array>)
     Traduz valores complexos da forma `a + b %i' para a forma `r
     %e^(%i t)'.  `load ("fft")' chama essa função dentro do Maxima.
     Veja também `fft'.

     As partes real e imaginária, `a' e `b', são tomadas de
     <real_array> e <imaginary_array>, respectivamente. Os valores
     originais dos arrays de entrada são substituídos pelo módulo e
     pelo ângulo, `r' e `t', no retorno. As saídas são calculadas como

          r: sqrt (a^2 + b^2)
          t: atan2 (b, a)

     O ângulo calculado encontra-se no intervalo de `-%pi' a `%pi'.

     Os arrays de entrada devem ter o mesmo tamanho e ser
     unidimensionais.  O tamanho do array não deve ser uma potência de
     2.

     `recttopolar' é a função inversa de `polartorect'.


 -- Função: ift (<real_array>, <imaginary_array>)
     Transformação rápida inversa discreta de Fourier . `load ("fft")'
     chama essa função dentro do Maxima.

     `ift' realiza a transformação rápida complexa de Fourier sobre
     arrays em ponto flutuante unidimensionais. A transformação inversa
     é definida como

          x[j]: sum (y[j] exp (+2 %i %pi j k / n), k, 0, n-1)

     Veja `fft' para maiores detalhes.


 -- Função: fft (<real_array>, <imaginary_array>)
 -- Função: ift (<real_array>, <imaginary_array>)
 -- Função: recttopolar (<real_array>, <imaginary_array>)
 -- Função: polartorect (<magnitude_array>, <phase_array>)
     Transformação rápidada de Fourier e funções relacionadas. `load
     ("fft")' chama essas funções dentro do Maxima.

     `fft' e `ift' realiza transformação rápida complexa de Fourier e a
     transformação inversa, respectivamente, sobre arrays em ponto
     flutuante unidimensionais. O tamanho de <imaginary_array> deve ser
     igual ao tamanho de <real_array>.

     `fft' e `ift' operam in-loco. Isto é, sobre o retorno de `fft' ou
     de `ift', O conteúdo original dos arrays de entrada é substituído
     pela saída.  A função `fillarray' pode fazer uma cópia de um
     array, isso pode ser necessário.

     A transformação discreta de Fourier e sua transformação inversa
     são definidas como segue. Tome `x' sendo os dados originais, com

          x[i]: real_array[i] + %i imaginary_array[i]

     Tome `y' sendo os dados transformados. A transformação normal e
     sua transformação inversa são

          y[k]: (1/n) sum (x[j] exp (-2 %i %pi j k / n), j, 0, n-1)

          x[j]:       sum (y[j] exp (+2 %i %pi j k / n), k, 0, n-1)

     Arrays adequadas podem ser alocadas pela função `array'. Por
     exemplo:

          array (my_array, float, n-1)$

     declara um array unidimensional com n elementos, indexado de 0 a
     n-1 inclusive. O número de elementos n deve ser igual a 2^m para
     algum m.

     `fft' pode ser aplicada a dados reais (todos os arrays imaginários
     são iguais a zero) para obter coeficientes seno e co-seno.  Após
     chamar `fft', os coeficientes seno e co-seno, digamos `a' e `b',
     podem ser calculados como

          a[0]: real_array[0]
          b[0]: 0

     e

          a[j]: real_array[j] + real_array[n-j]
          b[j]: imaginary_array[j] - imaginary_array[n-j]

     para j variando de 1 a n/2-1, e

          a[n/2]: real_array[n/2]
          b[n/2]: 0

     `recttopolar' traduz valores complexos da forma `a + b %i' para a
     forma `r %e^(%i t)'. Veja `recttopolar'.

     `polartorect' traduz valores complexos da forma `r %e^(%i t)' para
     a forma `a + b %i'. Veja `polartorect'.

     `demo ("fft")' exibe uma demonstração do pacote `fft'.


 -- Variável de opção: fortindent
     Valor por omissão: 0

     `fortindent' controla a margem esquerda de indentação de
     expressões mostradas pelo comando `fortran'.  0 fornece
     indentação normal (i.e., 6 espaços), e valores positivos farão com
     que expressões sejam mostrados mais além para a direita.


 -- Função: fortran (<expr>)
     Mostra <expr> como uma declaração Fortran.  A linha de saída é
     indentada com espaços.  Se a linha for muito longa, `fortran'
     imprime linhas de continuação.  `fortran' mostra o operador de
     exponenciação `^' como `**', e mostra um número complexo `a + b
     %i' na forma `(a,b)'.

     <expr> pode ser uma equação. Nesse caso, `fortran' mostra uma
     declaração de atribuição, atribuindo o primeiro membro (esquerda)
     da equação ao segundo membro (direita).  Em particular, se o
     primeiro membro <expr> é um nome de uma matriz, então `fortran'
     mostra uma declaração de atribuição para cada elemento da matriz.

     Se <expr> não for alguma coisa reconhecida por `fortran', a
     expressão é mostrada no formato `grind' sem reclamação.  `fortran'
     não conhece listas, arrays ou funções.

     `fortindent' controla o margem esquerda das linhas mostradas.  0 é
     a margem normal (i.e., indentada 6 espaços). Incrementando
     `fortindent' faz com que expressões sejam mostradas adiante para a
     direita.

     quando `fortspaces' for `true', `fortran' preenche cada linha
     mostrada com espaços em branco até completar 80 columas.

     `fortran' avalia seus argumentos; colocando um apóstrofo em um
     argumento evita avaliação.  `fortran' sempre retorna `done'.

     Exemplos:

          (%i1) expr: (a + b)^12$
          (%i2) fortran (expr);
                (b+a)**12
          (%o2)                         done
          (%i3) fortran ('x=expr);
                x = (b+a)**12
          (%o3)                         done
          (%i4) fortran ('x=expand (expr));
                x = b**12+12*a*b**11+66*a**2*b**10+220*a**3*b**9+495*a**4*b**8+792
               1   *a**5*b**7+924*a**6*b**6+792*a**7*b**5+495*a**8*b**4+220*a**9*b
               2   **3+66*a**10*b**2+12*a**11*b+a**12
          (%o4)                         done
          (%i5) fortran ('x=7+5*%i);
                x = (7,5)
          (%o5)                         done
          (%i6) fortran ('x=[1,2,3,4]);
                x = [1,2,3,4]
          (%o6)                         done
          (%i7) f(x) := x^2$
          (%i8) fortran (f);
                f
          (%o8)                         done


 -- Variável de opção: fortspaces
     Valor por omissão: `false'

     Quando `fortspaces' for `true', `fortran' preenche cada linha
     mostrada com espaços em branco até completar 80 columas.


 -- Função: horner (<expr>, <x>)
 -- Função: horner (<expr>)
     Retorna uma representação rearranjada de <expr> como na regra de
     Horner, usando <x> como variável principal se isso for
     especificado.  `x' pode ser omitido e nesse caso a variável
     principal da forma de expressão racional canónica de <expr> é
     usada.

     `horner' algumas vezes melhora a estabilidade se `expr' for ser
     numericamente avaliada.  Isso também é útil se Maxima é usado para
     gerar programas para rodar em Fortran. Veja também `stringout'.

          (%i1) expr: 1e-155*x^2 - 5.5*x + 5.2e155;
                                     2
          (%o1)            1.0E-155 x  - 5.5 x + 5.2E+155
          (%i2) expr2: horner (%, x), keepfloat: true;
          (%o2)            (1.0E-155 x - 5.5) x + 5.2E+155
          (%i3) ev (expr, x=1e155);
          Maxima encountered a Lisp error:

           floating point overflow

          Automatically continuing.
          To reenable the Lisp debugger set *debugger-hook* to nil.
          (%i4) ev (expr2, x=1e155);
          (%o4)                       7.0E+154


 -- Função: find_root (<f>(<x>), <x>, <a>, <b>)
 -- Função: find_root (<f>, <a>, <b>)
     Encontra a raíz da função <f> com a variável <x> percorrendo o
     intervalo `[<a>, <b>]'.  A função deve ter um sinal diferente em
     cada ponto final.  Se essa condição não for alcançada, a action of
     the function is governed by `find_root_error'.  If
     `find_root_error' is `true' then an error occurs, otherwise the
     value of `find_root_error' is returned (thus for plotting
     `find_root_error' might be set to 0.0).  De outra forma (dado que
     Maxima pode avaliar o primeiro argumento no intervalo
     especificado, e que o intervalo é contínuo) `find_root' é
     garantido vir para cima com a raíz (ou um deles se existir mais
     que uma raíz).  A precisão de `find_root' é governada por
     `intpolabs' e `intpolrel' os quais devem ser números em ponto
     flutuante não negativos.  `find_root' encerrará quando o primeiro
     argumento avaliar para alguma coisa menor que ou igual a
     `intpolabs' ou se sucessivas aproximações da raíz diferirem por
     não mais que `intpolrel * <um dos aproximandos>'.  O valor padrão
     de `intpolabs' e `intpolrel' são 0.0 de forma que `find_root' pega
     como boa uma resposta como for possível com a precisão aritmética
     simples que tivermos.  O primeiro argumento pode ser uma
     equação.  A ordem dos dois últimos argumentos é irrelevante.
     Dessa forma

          find_root (sin(x) = x/2, x, %pi, 0.1);

     é equivalente a

          find_root (sin(x) = x/2, x, 0.1, %pi);

     O método usado é uma busca binária no intervalo especificado pelos
     últimos dois argumentos.  Quando o resultado da busca for
     encontrado a função é fechada o suficiente para ser linear, isso
     inicia usando interpolação linear.

     Examples:
          (%i1) f(x) := sin(x) - x/2;
                                                  x
          (%o1)                  f(x) := sin(x) - -
                                                  2
          (%i2) find_root (sin(x) - x/2, x, 0.1, %pi);
          (%o2)                   1.895494267033981
          (%i3) find_root (sin(x) = x/2, x, 0.1, %pi);
          (%o3)                   1.895494267033981
          (%i4) find_root (f(x), x, 0.1, %pi);
          (%o4)                   1.895494267033981
          (%i5) find_root (f, 0.1, %pi);
          (%o5)                   1.895494267033981


 -- Variável de opção: find_root_abs
     Valor por omissão: 0.0

     `find_root_abs' é a precisão do comando `find_root'. A precisão é
     governada por `find_root_abs' e `find_root_rel' que devem ser
     números não negativos em ponto flutuante.  `find_root' terminará
     quando o primeiro argumento avaliar para alguma coisa menor que ou
     igual a `find_root_abs' ou se sucessivos aproximandos para a raíz
     diferirem por não mais que `find_root_rel * <um dos aproximandos>'.
     Os valores padrão de `find_root_abs' e `find_root_rel' são 0.0 de
     forma que `find_root' tome como boa uma resposta que for possível
     com a precisão aritmética simples que tivermos.


 -- Variável de opção: find_root_error
     Valor por omissão: `true'

     `find_root_error' governa o comportamento de `find_root'.  Quando
     `find_root' for chamada, ela determina se a função a ser resolvida
     satisfaz ou não a condição que os valores da função nos pontos
     finais do intervalo de interpolação são opostos em sinal.  Se eles
     forem de sinais opostos, a interpolação prossegue.  Se eles forem
     de mesmo sinal, e `find_root_error' for `true', então um erro é
     sinalizado.  Se eles forem de mesmo sinal e `find_root_error' não
     for `true', o valor de `find_root_error' é retornado.  Dessa forma
     para montagem de gráfico, `find_root_error' pode ser escolhida
     para 0.0.


 -- Variável de opção: find_root_rel
     Valor por omissão: 0.0

     `find_root_rel' é a precisão do comando `find_root' e é governada
     por `find_root_abs' e `find_root_rel' que devem ser números não
     negativos em ponto flutuante.  `find_root' terminará quando o
     primeiro argumento avaliar para alguma coisa menor que ou igual a
     `find_root_abs' ou se sucessivos aproximandos para a raíz
     diferirem de não mais que `find_root_rel * <um dos aproximandos>'.
     Os valores padrão de `find_root_labs' e `find_root_rel' é 0.0 de
     forma que `find_root' toma como boa uma resposta que for possível
     com a precisão aritmética simples que tivermos.


 -- Função: newton (<expr>, <x>, <x_0>, <eps>)
     Retorna uma solução aproximada de `<expr> = 0' através do método
     de Newton, considerando <expr> como sendo uma função de uma
     variável, <x>.  A busca pela solução começa com `<x> = <x_0>' e
     prossegue até `abs(<expr>) < <eps>' (com <expr> avaliada para o
     valor corrente de <x>).

     `newton' permite que variáveis indefinidas apareçam em <expr>,
     contanto que o teste de terminação `abs(<expr>) < <eps>' avalie
     para `true' ou `false'.  Dessa forma não é necessário que <expr>
     avalie para um número.

     `load(newton1)' chama essa função.

     Veja também `realroots', `allroots', `find_root', e `mnewton'.

     Exemplos:

          (%i1) load (newton1);
          (%o1) /usr/share/maxima/5.10.0cvs/share/numeric/newton1.mac
          (%i2) newton (cos (u), u, 1, 1/100);
          (%o2)                   1.570675277161251
          (%i3) ev (cos (u), u = %);
          (%o3)                 1.2104963335033528E-4
          (%i4) assume (a > 0);
          (%o4)                        [a > 0]
          (%i5) newton (x^2 - a^2, x, a/2, a^2/100);
          (%o5)                  1.00030487804878 a
          (%i6) ev (x^2 - a^2, x = %);
                                                     2
          (%o6)                6.098490481853958E-4 a



File: maxima.info,  Node: Definições para Séries de Fourier,  Prev: Definições para Numérico,  Up: Numérico

23.4 Definições para Séries de Fourier
======================================

 -- Função: equalp (<x>, <y>)
     Retorna `true' se `equal (<x>, <y>)' de outra forma `false' (não
     fornece uma mensagem de erro como `equal (x, y)' poderia fazer
     nesse caso).


 -- Função: remfun (<f>, <expr>)
 -- Função: remfun (<f>, <expr>, <x>)
     `remfun (<f>, <expr>)' substitue todas as ocorrências de `<f>
     (<arg>)' por <arg> em <expr>.

     `remfun (<f>, <expr>, <x>)' substitue todas as ocorrências de `<f>
     (<arg>)' por <arg> em <expr> somente se <arg> contiver a variável
     <x>.


 -- Função: funp (<f>, <expr>)
 -- Função: funp (<f>, <expr>, <x>)
     `funp (<f>, <expr>)' retorna `true' se <expr> contém a função <f>.

     `funp (<f>, <expr>, <x>)' retorna `true' se <expr> contém a
     função <f> e a variável <x> em algum lugar no argumento de uma das
     instâncias de <f>.


 -- Função: absint (<f>, <x>, <halfplane>)
 -- Função: absint (<f>, <x>)
 -- Função: absint (<f>, <x>, <a>, <b>)
     `absint (<f>, <x>, <halfplane>)' retorna a integral indefinida de
     <f> com relação a <x> no dado semi-plano (`pos', `neg', ou `both').
     <f> pode conter expressões da forma `abs (x)', `abs (sin (x))',
     `abs (a) * exp (-abs (b) * abs (x))'.

     `absint (<f>, <x>)' é equivalente a `absint (<f>, <x>, pos)'.

     `absint (<f>, <x>, <a>, <b>)' retorna a integral definida de <f>
     com relação a <x> de <a> até <b>.  <f> pode incluir valores
     absolutos.


 -- Função: fourier (<f>, <x>, <p>)
     Retorna uma lista de coeficientes de Fourier de `<f>(<x>)'
     definidos sobre o intervalo `[-p, p]'.


 -- Função: foursimp (<l>)
     Simplifica `sin (n %pi)' para 0 se `sinnpiflag' for `true' e `cos
     (n %pi)' para `(-1)^n' se `cosnpiflag' for `true'.


 -- Variável de opção: sinnpiflag
     Valor por omissão: `true'

     Veja `foursimp'.


 -- Variável de opção: cosnpiflag
     Valor por omissão: `true'

     Veja `foursimp'.


 -- Função: fourexpand (<l>, <x>, <p>, <limit>)
     Constrói e retorna a série de Fourier partindo da lista de
     coeficientes de Fourier <l> até (up through) <limit> termos
     (<limit> pode ser `inf'). <x> e <p> possuem o mesmo significado
     que em `fourier'.


 -- Função: fourcos (<f>, <x>, <p>)
     Retorna os coeficientes do co-seno de Fourier para `<f>(<x>)'
     definida sobre `[0, %pi]'.


 -- Função: foursin (<f>, <x>, <p>)
     Retorna os coeficientes do seno de Fourier para `<f>(<x>)'
     definida sobre `[0, <p>]'.


 -- Função: totalfourier (<f>, <x>, <p>)
     Retorna `fourexpand (foursimp (fourier (<f>, <x>, <p>)), <x>, <p>,
     'inf)'.


 -- Função: fourint (<f>, <x>)
     Constrói e retorna uma lista de coeficientes de integral de
     Fourier de `<f>(<x>)' definida sobre `[minf, inf]'.


 -- Função: fourintcos (<f>, <x>)
     Retorna os coeficientes da integral do co-seno de Fourier para
     `<f>(<x>)' on `[0, inf]'.


 -- Função: fourintsin (<f>, <x>)
     Retorna os coeficientes da integral do seno de Fourier para
     `<f>(<x>)' on `[0, inf]'.



File: maxima.info,  Node: Arrays,  Next: Matrizes e Álgebra Linear,  Prev: Numérico,  Up: Top

24 Arrays
*********

* Menu:

* Definições para Arrays::


File: maxima.info,  Node: Definições para Arrays,  Prev: Arrays,  Up: Arrays

24.1 Definições para Arrays
===========================

 -- Função: array (<name>, <dim_1>, ..., <dim_n>)
 -- Função: array (<name>, <type>, <dim_1>, ..., <dim_n>)
 -- Função: array ([<nome_1>, ..., <nome_m>], <dim_1>, ..., <dim_n>)
     Cria um array n-dimensional.  n pode ser menor ou igual a 5.  Os
     subscritos para a i'ésima dimensão são inteiros no intervalo de 0
     a <dim_i>.

     `array (<name>, <dim_1>, ..., <dim_n>)' cria um array genérico.

     `array (<name>, <type>, <dim_1>, ..., <dim_n>)' cria um array, com
     elementos de um tipo especificado.  <type> pode ser `fixnum' para
     inteiros de tamanho limitado ou `flonum' para números em ponto
     flutuante.

     `array ([<nome_1>, ..., <nome_m>], <dim_1>, ..., <dim_n>)' cria m
     arrays, todos da mesma dimensão.

     Se o utilizador atribui a uma variável subscrita antes de declarar
     o array correspondente, um array não declarado é criado.  Arrays
     não declarados, também conhecidos como array desordenado (porque o
     codigo desordenado termina nos subscritos), são mais gerais que
     arrays declarados.  O utilizador não declara seu tamanho máximo, e
     ele cresce dinamicamente e desordenadamente à medida que são
     atribuídos valores a mais elementos.  Os subscritos de um array
     não declarado não precisam sempre ser números.  Todavia, excepto
     para um array um tanto quanto esparso, é provavelmente mais
     eficiente declarar isso quando possível que deixar não declarado.
     A função `array' pode ser usada para transformar um array não
     declarado em um array declarado.


 -- Função: arrayapply (<A>, [<i_1>, ..., <i_n>])
     Avalia `<A> [<i_1>, ..., <i_n>]', quando <A> for um array e <i_1>,
     ..., <i_n> são inteiros.

     Ela é remanescente de `apply', excepto o primeiro argumento que é
     um array ao invés de uma função.


 -- Função: arrayinfo (<A>)
     Retorna informações sobre o array <A>.  O argumento <A> pode ser
     um array declarado, uma array não declarado ( que sofreu um hash),
     uma função de array, ou uma função que possui subscrito.

     Para arrays declarados, `arrayinfo' retorna uma lista
     compreendendo o átomo `declared', o n;umero de dimensões, e o
     tamanho de cada dimensão.  Os elementos do array, ambos associados
     e não associados, são retornados por `listarray'.

     Para arrays não declarados (arrays que sofreram um hash),
     `arrayinfo' retorna uma lista compreendendo o átomo `hashed', o
     número de subscritos, e os subscritos de de todo elemento que
     tiver um valor.  Os valores são retornados por meio de `listarray'.

     Para funções de array, `arrayinfo' retretorna uma lista
     compreendendo o átomo `hashed', o número de subscritos, e
     quaisquer valores de subscritos para os quais exista valores
     funcionais armazenados.  Os valores funcionais armazenados são
     retornados através de `listarray'.

     Para funções que possuem subscritos, `arrayinfo' retorna uma lista
     compreendendo o átomo `hashed', o número de subscritos, e qualquer
     valores subscritos para os quais existe uma expressões lambda.  As
     expressões lambda são retornadas por `listarray'.

     Examples:

     `arrayinfo' e `listarray' aplicado a um array declarado.

          (%i1) array (aa, 2, 3);
          (%o1)                          aa
          (%i2) aa [2, 3] : %pi;
          (%o2)                          %pi
          (%i3) aa [1, 2] : %e;
          (%o3)                          %e
          (%i4) arrayinfo (aa);
          (%o4)                 [declared, 2, [2, 3]]
          (%i5) listarray (aa);
          (%o5) [#####, #####, #####, #####, #####, #####, %e, #####,
                                                  #####, #####, #####, %pi]

     `arrayinfo' e `listarray' aplicado a um array não declarado (no
     qual foi aplicado um hash).

          (%i1) bb [FOO] : (a + b)^2;
                                             2
          (%o1)                       (b + a)
          (%i2) bb [BAR] : (c - d)^3;
                                             3
          (%o2)                       (c - d)
          (%i3) arrayinfo (bb);
          (%o3)               [hashed, 1, [BAR], [FOO]]
          (%i4) listarray (bb);
                                        3         2
          (%o4)                 [(c - d) , (b + a) ]

     `arrayinfo' e `listarray' aplicado a uma função de array.

          (%i1) cc [x, y] := y / x;
                                               y
          (%o1)                      cc     := -
                                       x, y    x
          (%i2) cc [u, v];
                                          v
          (%o2)                           -
                                          u
          (%i3) cc [4, z];
                                          z
          (%o3)                           -
                                          4
          (%i4) arrayinfo (cc);
          (%o4)              [hashed, 2, [4, z], [u, v]]
          (%i5) listarray (cc);
                                        z  v
          (%o5)                        [-, -]
                                        4  u

     `arrayinfo' e `listarray' aplicadas a funções com subscritos.

          (%i1) dd [x] (y) := y ^ x;
                                               x
          (%o1)                     dd (y) := y
                                      x
          (%i2) dd [a + b];
                                              b + a
          (%o2)                  lambda([y], y     )
          (%i3) dd [v - u];
                                              v - u
          (%o3)                  lambda([y], y     )
          (%i4) arrayinfo (dd);
          (%o4)             [hashed, 1, [b + a], [v - u]]
          (%i5) listarray (dd);
                                   b + a                v - u
          (%o5)      [lambda([y], y     ), lambda([y], y     )]

 -- Função: arraymake (<A>, [<i_1>, ..., <i_n>])
     Retorna a expressão `<A>[<i_1>, ..., <i_n>]'.  O resultado é uma
     referência a um array não avaliado.

     `arraymake' é remanicência de `funmake', excepto o valor retornado
     é um array de referência não avaliado ao invés de uma chamada de
     função não avaliada.

     Exemplos:

          (%i1) arraymake (A, [1]);
          (%o1)                          A
                                          1
          (%i2) arraymake (A, [k]);
          (%o2)                          A
                                          k
          (%i3) arraymake (A, [i, j, 3]);
          (%o3)                       A
                                       i, j, 3
          (%i4) array (A, fixnum, 10);
          (%o4)                           A
          (%i5) fillarray (A, makelist (i^2, i, 1, 11));
          (%o5)                           A
          (%i6) arraymake (A, [5]);
          (%o6)                          A
                                          5
          (%i7) ''%;
          (%o7)                          36
          (%i8) L : [a, b, c, d, e];
          (%o8)                    [a, b, c, d, e]
          (%i9) arraymake ('L, [n]);
          (%o9)                          L
                                          n
          (%i10) ''%, n = 3;
          (%o10)                          c
          (%i11) A2 : make_array (fixnum, 10);
          (%o11)          {Array:  #(0 0 0 0 0 0 0 0 0 0)}
          (%i12) fillarray (A2, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
          (%o12)          {Array:  #(1 2 3 4 5 6 7 8 9 10)}
          (%i13) arraymake ('A2, [8]);
          (%o13)                         A2
                                           8
          (%i14) ''%;
          (%o14)                          9


 -- Variável de sistema: arrays
     Valor por omissão: `[]'

     `arrays' é uma lista dos arrays que tiverem sido alocados.  Essa
     lista compreende arrays declarados através de `array', arrays
     desordenados (hashed) construídos através de definição implícita
     (atribuindo alguma coisa a um elemento de array), e funções de
     array definidas por meio de `:=' e `define'.  Arrays definidos por
     meio de `make_array' não estão incluídos.

     Veja também `array', `arrayapply', `arrayinfo', `arraymake',
     `fillarray', `listarray', e `rearray'.

     Exemplos:

          (%i1) array (aa, 5, 7);
          (%o1)                          aa
          (%i2) bb [FOO] : (a + b)^2;
                                             2
          (%o2)                       (b + a)
          (%i3) cc [x] := x/100;
                                             x
          (%o3)                      cc  := ---
                                       x    100
          (%i4) dd : make_array ('any, 7);
          (%o4)       {Array:  #(NIL NIL NIL NIL NIL NIL NIL)}
          (%i5) arrays;
          (%o5)                     [aa, bb, cc]


 -- Função: bashindices (<expr>)
     Transforma a expressão <expr> dando a cada somatório e a cada
     produto um único índice.  Isso dá a `changevar' grande precisão
     quando se está trabalhando com somatórios e produtos.  A forma do
     único índice é `j<number>'.  A quantidade <number> é determindad
     por referência a `gensumnum', que pode ser alterada pelo
     utilizador.  Por exemplo, `gensumnum:0$' reseta isso.


 -- Função: fillarray (<A>, <B>)
     Preenche o array <A> com <B>, que é uma lista ou um array.

     Se um tipo específico for declarado para <A> no momento de sua
     criação, <A> somente porde ser preenchido com elementos do tipo
     especificado; Constitui um erro alguma tentativa feita para copiar
     um um elemento de um tipo diferente.

     Se as dimensões dos arrays <A> e <B> forem diferents, <A> é
     preenchido no ordem de maior fileira.  Se não existirem elementos
     livres em <B> o último elemento é usado para preencher todo o
     resto de <A>.  Se existirem muitos , esses restantes seram
     ignorados.

     `fillarray' retorna esse primeiro argumento.

     Exemplos:

     Create an array of 9 elements and fill it from a list.

          (%i1) array (a1, fixnum, 8);
          (%o1)                          a1
          (%i2) listarray (a1);
          (%o2)              [0, 0, 0, 0, 0, 0, 0, 0, 0]
          (%i3) fillarray (a1, [1, 2, 3, 4, 5, 6, 7, 8, 9]);
          (%o3)                          a1
          (%i4) listarray (a1);
          (%o4)              [1, 2, 3, 4, 5, 6, 7, 8, 9]

     Quando existirem poucos elementos para preencher o array, o último
     elemento é repetido.  Quando houverem muitos elementos, os
     elementos extras são ignorados.

          (%i1) a2 : make_array (fixnum, 8);
          (%o1)             {Array:  #(0 0 0 0 0 0 0 0)}
          (%i2) fillarray (a2, [1, 2, 3, 4, 5]);
          (%o2)             {Array:  #(1 2 3 4 5 5 5 5)}
          (%i3) fillarray (a2, [4]);
          (%o3)             {Array:  #(4 4 4 4 4 4 4 4)}
          (%i4) fillarray (a2, makelist (i, i, 1, 100));
          (%o4)             {Array:  #(1 2 3 4 5 6 7 8)}

     Arrays multi-dimensionais são preenchidos em ordem de maior
     fileira.

          (%i1) a3 : make_array (fixnum, 2, 5);
          (%o1)        {Array:  #2A((0 0 0 0 0) (0 0 0 0 0))}
          (%i2) fillarray (a3, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
          (%o2)        {Array:  #2A((1 2 3 4 5) (6 7 8 9 10))}
          (%i3) a4 : make_array (fixnum, 5, 2);
          (%o3)     {Array:  #2A((0 0) (0 0) (0 0) (0 0) (0 0))}
          (%i4) fillarray (a4, a3);
          (%o4)     {Array:  #2A((1 2) (3 4) (5 6) (7 8) (9 10))}


 -- Função: listarray (<A>)
     Retorna uma lista dos elementos do array <A>.  O argumento <A>
     pode ser um array declarado, um array não declarado (desordenado -
     hashed), uma função de array, ou uma função com subscritos.

     Elementos são listados em ordem de linha maior.  Isto é, elementos
     são ordenados conforme o primeiro índice, en seguida conforme o
     segundo índice, e assim sucessivamente.  A sequuência de
     ordenação por meio dos valores dos índices é a mesma ordem
     estabelecida por meio de `orderless'.

     Para arrays não declarados , funções de arrays, e funções com
     subscritos, os elementos correspondem aos valores de índice
     retornados através de `arrayinfo'.

     Elemetos não associados de arrays genéricos declarados (isto é,
     não `fixnum' e não `flonum') são retornados como `#####'.
     Elementos não associados de arrays declarados `fixnum' ou `flonum'
     são retornados como 0 ou 0.0, respectivamente.  Elementos não
     associados de arrays não declarados, funções de array, e funções
     subscritas não são retornados.

     Exemplos:

     `listarray' e `arrayinfo' aplicados a um array declarado.

          (%i1) array (aa, 2, 3);
          (%o1)                          aa
          (%i2) aa [2, 3] : %pi;
          (%o2)                          %pi
          (%i3) aa [1, 2] : %e;
          (%o3)                          %e
          (%i4) listarray (aa);
          (%o4) [#####, #####, #####, #####, #####, #####, %e, #####,
                                                  #####, #####, #####, %pi]
          (%i5) arrayinfo (aa);
          (%o5)                 [declared, 2, [2, 3]]

     `listarray' e `arrayinfo' aplicadas a arrays não declarados
     (hashed - desordenados).

          (%i1) bb [FOO] : (a + b)^2;
                                             2
          (%o1)                       (b + a)
          (%i2) bb [BAR] : (c - d)^3;
                                             3
          (%o2)                       (c - d)
          (%i3) listarray (bb);
                                        3         2
          (%o3)                 [(c - d) , (b + a) ]
          (%i4) arrayinfo (bb);
          (%o4)               [hashed, 1, [BAR], [FOO]]

     `listarray' e `arrayinfo' aplicada a uma função de array.

          (%i1) cc [x, y] := y / x;
                                               y
          (%o1)                      cc     := -
                                       x, y    x
          (%i2) cc [u, v];
                                          v
          (%o2)                           -
                                          u
          (%i3) cc [4, z];
                                          z
          (%o3)                           -
                                          4
          (%i4) listarray (cc);
                                        z  v
          (%o4)                        [-, -]
                                        4  u
          (%i5) arrayinfo (cc);
          (%o5)              [hashed, 2, [4, z], [u, v]]

     `listarray' e `arrayinfo' aplicadas a funções com subscritos.

          (%i1) dd [x] (y) := y ^ x;
                                               x
          (%o1)                     dd (y) := y
                                      x
          (%i2) dd [a + b];
                                              b + a
          (%o2)                  lambda([y], y     )
          (%i3) dd [v - u];
                                              v - u
          (%o3)                  lambda([y], y     )
          (%i4) listarray (dd);
                                   b + a                v - u
          (%o4)      [lambda([y], y     ), lambda([y], y     )]
          (%i5) arrayinfo (dd);
          (%o5)             [hashed, 1, [b + a], [v - u]]


 -- Função: make_array (<type>, <dim_1>, ..., <dim_n>)
     Cria e retorna um array de Lisp.  <type> pode ser `any', `flonum',
     `fixnum', `hashed' ou `functional'.  Existem n indices, e o
     i'enésimo indice está no intervalo de 0 a <dim_i> - 1.

     A vantagem de `make_array' sobre `array' é que o valor de retorno
     não tem um nome, e uma vez que um ponteiro a ele vai, ele irá
     também.  Por exemplo, se `y: make_array (...)' então `y' aponta
     para um objecto que ocupa espaço, mas depois de `y: false', `y'
     não mais aponta para aquele objecto, então o objecto pode ser
     descartado.

     Exemplos:

          (%i1) A1 : make_array (fixnum, 10);
          (%o1)           {Array:  #(0 0 0 0 0 0 0 0 0 0)}
          (%i2) A1 [8] : 1729;
          (%o2)                         1729
          (%i3) A1;
          (%o3)          {Array:  #(0 0 0 0 0 0 0 0 1729 0)}
          (%i4) A2 : make_array (flonum, 10);
          (%o4) {Array:  #(0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0)}
          (%i5) A2 [2] : 2.718281828;
          (%o5)                      2.718281828
          (%i6) A2;
          (%o6)
               {Array:  #(0.0 0.0 2.718281828 0.0 0.0 0.0 0.0 0.0 0.0 0.0)}
          (%i7) A3 : make_array (any, 10);
          (%o7) {Array:  #(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)}
          (%i8) A3 [4] : x - y - z;
          (%o8)                      - z - y + x
          (%i9) A3;
          (%o9) {Array:  #(NIL NIL NIL NIL ((MPLUS SIMP) $X ((MTIMES SIMP)\
           -1 $Y) ((MTIMES SIMP) -1 $Z))
            NIL NIL NIL NIL NIL)}
          (%i10) A4 : make_array (fixnum, 2, 3, 5);
          (%o10) {Array:  #3A(((0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0)) ((0 0 \
          0 0 0) (0 0 0 0 0) (0 0 0 0 0)))}
          (%i11) fillarray (A4, makelist (i, i, 1, 2*3*5));
          (%o11) {Array:  #3A(((1 2 3 4 5) (6 7 8 9 10) (11 12 13 14 15))
              ((16 17 18 19 20) (21 22 23 24 25) (26 27 28 29 30)))}
          (%i12) A4 [0, 2, 1];
          (%o12)                         12


 -- Função: rearray (<A>, <dim_1>, ..., <dim_n>)
     Altera as dimenções de um array.  O novo array será preenchido com
     os elementos do antigo em ordem da maior linha.  Se o array antigo
     era muito pequeno, os elementos restantes serão preenchidos com
     `false', `0.0' ou `0', dependendo do tipo do array.  O tipo do
     array não pode ser alterado.


 -- Função: remarray (<A_1>, ..., <A_n>)
 -- Função: remarray (all)
     Remove arrays e funções associadas a arrays e libera o espaço
     ocupado.  Os argumentos podem ser arrays declarados, arrays não
     declarados (dsordenados - hashed), funções de array functions, e
     funções com subscritos.

     `remarray (all)' remove todos os ítens na lista global `arrays'.

     Isso pode ser necessário para usar essa função se isso é desejado
     para redefinir os valores em um array desordenado.

     `remarray' retorna a lista dos arrays removidos.


 -- Função: subvar (<x>, <i>)
     Avalia a expressão subscrita `<x>[<i>]'.

     `subvar' avalia seus argumentos.

     `arraymake (<x>, [<i>]' constrói a expressão `<x>[<i>]', mas não a
     avalia.

     Exemplos:

          (%i1) x : foo $

          (%i2) i : 3 $

          (%i3) subvar (x, i);
          (%o3) foo
           3
          (%i4) foo : [aa, bb, cc, dd, ee]$

          (%i5) subvar (x, i);
          (%o5) +(%i6) arraymake (x, [i]);
          (%o6) foo
           3
          (%i7) ''%;
          (%o7) +


 -- Variável de pção: use_fast_arrays
     - Se `true' somente dois tipos de arrays são reconhecidos.

     1) O array art-q (t no Lisp Comum) que pode ter muitas dimensões
     indexadas por inteiros, e pode aceitar qualquer objecto do Lisp ou
     do Maxima como uma entrada.  Para construir assim um array, insira
     `a:make_array(any,3,4);' então `a' terá como valor, um array com
     doze posições, e o índice é baseado em zero.

     2) O array Hash_table que é o tipo padrão de array criado se um
     faz `b[x+1]:y^2' (e `b' não é ainda um array, uma lista, ou uma
     matriz - se isso ou um desses ocorrer um erro pode ser causado
     desde `x+1' não poderá ser um subscrito válido para um array
     art-q, uma lista ou uma matriz).  Esses índices (também conhecidos
     como chaves) podem ser quaisquer objectos.  Isso somente pega uma
     chave por vez a cada vez (`b[x+1,u]:y' ignorará o `u').  A
     referência termina em `b[x+1] ==> y^2'.  Certamente a chave poe
     ser uma lista , e.g.  `b[[x+1,u]]:y' poderá ser válido.  Isso é
     incompatível com os arrays antigos do Maxima, mas poupa recursos.

     Uma vantagem de armazenar os arrays como valores de símbolos é que
     as convenções usuais sobre variáveis locais de uma função
     aplicam-se a arrays também.  O tipo Hash_table também usa menos
     recursos e é mais eficiente que o velho tipo hashar do Maxima.
     Para obter comportamento consistente em códigos traduzidos e
     compilados posicione `translate_fast_arrays' para ser `true'.



File: maxima.info,  Node: Matrizes e Álgebra Linear,  Next: Funções Afins,  Prev: Arrays,  Up: Top

25 Matrizes e Álgebra Linear
****************************

* Menu:

* Introdução a Matrizes e Álgebra Linear::
* Definições para Matrizes e Álgebra Linear::


File: maxima.info,  Node: Introdução a Matrizes e Álgebra Linear,  Next: Definições para Matrizes e Álgebra Linear,  Prev: Matrizes e Álgebra Linear,  Up: Matrizes e Álgebra Linear

25.1 Introdução a Matrizes e Álgebra Linear
===========================================

* Menu:

* Ponto::
* Vetores::
* auto::


File: maxima.info,  Node: Ponto,  Next: Vetores,  Prev: Introdução a Matrizes e Álgebra Linear,  Up: Introdução a Matrizes e Álgebra Linear

25.1.1 Ponto
------------

O operador `.' representa multiplicação não comutativa e produto
escalar.  Quando os operandos são matrizes 1-coluna ou 1-linha `a' e
`b', a expresão `a.b' é equivalente a `sum (a[i]*b[i], i, 1,
length(a))'.  Se `a' e `b' não são complexos, isso é o produto escalar,
também chamado produto interno ou produto do ponto, de `a' e `b'.  O
produto escalar é definido como `conjugate(a).b' quando `a' e `b' são
complexos; `innerproduct' no pacote `eigen' fornece o produto escalar
complexo.

   Quando os operandos são matrizes mais gerais, o produto é a matriz
produto `a' e `b'.  O número de linhas de `b' deve ser igual ao número
de colunas de `a', e o resultado tem número de linhas igual ao número
de linhas de `a' e número de colunas igual ao número de colunas de `b'.

   Para distinguir `.' como um operador aritmético do ponto decimal em
um número em ponto flutuante, pode ser necessário deixar espaços em
cada lado.  Por exemplo, `5.e3' é `5000.0' mas `5 . e3' é `5' vezes
`e3'.

   Existem muitos sinalizadores que governam a simplificação de
expresões envolvendo `.', a saber `dot', `dot0nscsimp', `dot0simp',
`dot1simp', `dotassoc', `dotconstrules', `dotdistrib', `dotexptsimp',
`dotident', e `dotscrules'.


File: maxima.info,  Node: Vetores,  Next: auto,  Prev: Ponto,  Up: Introdução a Matrizes e Álgebra Linear

25.1.2 Vetores
--------------

`vect' é um pacote de funções para análise vectorial.  `load ("vect")'
chama esse pacote, e `demo ("vect")' permite visualizar uma
demonstração.

   O pacote de análise vectorial pode combinar e simplificar expresões
simbólicas incluindo produtos dos pontos e productos dos x, juntamente
com o gradiente, divergencia, torção, e operadores Laplacianos.  A
distribuição desses operadores sobre adições ou produtos é governada
por muitos sinalizadores, como são várias outras expansões, incluindo
expansão dentro de componentes em qualquer sistema de coordenadas
ortogonais.  Existem também funções para derivar o escalar ou vector
potencial de um campo.

   O pacote `vect' contém essas funções: `vectorsimp', `scalefactors',
`express', `potential', e `vectorpotential'.

   Atenção: o pacote `vect' declara o operador ponto `.' como sendo um
operador comutativo.


File: maxima.info,  Node: auto,  Prev: Vetores,  Up: Introdução a Matrizes e Álgebra Linear

25.1.3 auto
-----------

O pacote `eigen' contém muitas funções devotadas para a computação
simbólica de autovalores e autovectores.  Maxima chama o pacote
automaticamente se uma das funções `eigenvalues' ou `eigenvectors' é
invocada.  O pacote pode ser chamado explicitamente com `load
("eigen")'.

   `demo ("eigen")' mostra uma demonstração das compatibilidades desse
pacote.  `batch ("eigen")' executa a mesma demonstração, mas sem
lembretes de utilizador entre sucessivas computações.

   As funções no pacote `eigen' são `innerproduct', `unitvector',
`columnvector', `gramschmidt', `eigenvalues', `eigenvectors',
`uniteigenvectors', e `similaritytransform'.


File: maxima.info,  Node: Definições para Matrizes e Álgebra Linear,  Prev: Introdução a Matrizes e Álgebra Linear,  Up: Matrizes e Álgebra Linear

25.2 Definições para Matrizes e Álgebra Linear
==============================================

 -- Função: addcol (<M>, <list_1>, ..., <list_n>)
     Anexa a(s) coluna(s) dadas por uma ou mais listas (ou matrizes)
     sobre a matriz <M>.


 -- Função: addrow (<M>, <list_1>, ..., <list_n>)
     Anexa a(s) linha(s) dadas por uma ou mais listas (ou matrizes)
     sobre a matriz <M>.


 -- Função: adjoint (<M>)
     Retorna a matriz adjunta da matriz <M>.  A matriz adjunta é a
     transposta da matriz dos cofactores de <M>.


 -- Função: augcoefmatrix ([<eqn_1>, ..., <eqn_m>], [<x_1>, ..., <x_n>])
     Retorna a matriz dos coeficientes aumentada para as variáveis
     <x_1>, ..., <x_n> do sistema de equações lineares <eqn_1>, ...,
     <eqn_m>.  Essa é a matriz dos coeficientes com uma coluna anexada
     para os termos independentes em cada equação (i.e., esses termos
     não dependem de <x_1>, ..., <x_n>).

          (%i1) m: [2*x - (a - 1)*y = 5*b, c + b*y + a*x = 0]$
          (%i2) augcoefmatrix (m, [x, y]);
                                 [ 2  1 - a  - 5 b ]
          (%o2)                  [                 ]
                                 [ a    b      c   ]


 -- Função: charpoly (<M>, <x>)
     Retorna um polinómio característico para a matriz <M> em
     relação à variável <x>.  Que é, `determinant (<M> - diagmatrix
     (length (<M>), <x>))'.

          (%i1) a: matrix ([3, 1], [2, 4]);
                                      [ 3  1 ]
          (%o1)                       [      ]
                                      [ 2  4 ]
          (%i2) expand (charpoly (a, lambda));
                                     2
          (%o2)                lambda  - 7 lambda + 10
          (%i3) (programmode: true, solve (%));
          (%o3)               [lambda = 5, lambda = 2]
          (%i4) matrix ([x1], [x2]);
                                       [ x1 ]
          (%o4)                        [    ]
                                       [ x2 ]
          (%i5) ev (a . % - lambda*%, %th(2)[1]);
                                    [ x2 - 2 x1 ]
          (%o5)                     [           ]
                                    [ 2 x1 - x2 ]
          (%i6) %[1, 1] = 0;
          (%o6)                     x2 - 2 x1 = 0
          (%i7) x2^2 + x1^2 = 1;
                                      2     2
          (%o7)                     x2  + x1  = 1
          (%i8) solve ([%th(2), %], [x1, x2]);
                            1               2
          (%o8) [[x1 = - -------, x2 = - -------],
                         sqrt(5)         sqrt(5)

                                                       1             2
                                              [x1 = -------, x2 = -------]]
                                                    sqrt(5)       sqrt(5)


 -- Função: coefmatrix ([<eqn_1>, ..., <eqn_m>], [<x_1>, ..., <x_n>])
     Retorna a matriz dos coeficientes para as variáveis <x_1>, ...,
     <x_n> do sistema de equações lineares <eqn_1>, ..., <eqn_m>.

          (%i1) coefmatrix([2*x-(a-1)*y+5*b = 0, b*y+a*x = 3], [x,y]);
                                           [ 2  1 - a ]
          (%o1)                            [          ]
                                           [ a    b   ]


 -- Função: col (<M>, <i>)
     Reorna a <i>'ésima coluna da matriz <M>.  O valor de retorno é uma
     matriz.


 -- Função: columnvector (<L>)
 -- Função: covect (<L>)
     Retorna uma matriz de uma coluna e `length (<L>)' linhas, contendo
     os elementos da lista <L>.

     `covect' é um sinônimo para `columnvector'.

     `load ("eigen")' chama essa função.

     Isso é útil se quiser usar partes das saídas das funções nesse
     pacote em cálculos matriciais.

     Exemplo:

          (%i1) load ("eigen")$
          Warning - you are redefining the Macsyma function autovalores
          Warning - you are redefining the Macsyma function autovectores
          (%i2) columnvector ([aa, bb, cc, dd]);
                                       [ aa ]
                                       [    ]
                                       [ bb ]
          (%o2)                        [    ]
                                       [ cc ]
                                       [    ]
                                       [ dd ]


 -- Função: conjugate (<x>)
     Retorna o conjugado complexo de <x>.

          (%i1) declare ([aa, bb], real, cc, complex, ii, imaginary);

          (%o1)                         done
          (%i2) conjugate (aa + bb*%i);

          (%o2)                      aa - %i bb
          (%i3) conjugate (cc);

          (%o3)                     conjugate(cc)
          (%i4) conjugate (ii);

          (%o4)                         - ii
          (%i5) conjugate (xx + yy);

          (%o5)             conjugate(yy) + conjugate(xx)


 -- Função: copymatrix (<M>)
     Retorna uma cópia da matriz <M>.  Esse é o único para fazer uma
     copia separada copiando <M> elemento a elemento.

     Note que uma atribuição de uma matriz para outra, como em `m2: m1',
     não copia `m1'.  Uma atribuição `m2 [i,j]: x' ou `setelmx (x, i,
     j, m2' também modifica `m1 [i,j]'.  criando uma cópia com
     `copymatrix' e então usando atribução cria uma separada e
     modificada cópia.


 -- Função: determinant (<M>)
     Calcula o determinante de <M> por um método similar à
     eliminação de Gauss.

     A forma do resultado depende da escolha do comutador `ratmx'.

     Existe uma rotina especial para calcular determinantes esparsos
     que é chamada quando os comutadores `ratmx' e `sparse' são ambos
     `true'.


 -- Variável: detout
     Valor por omissão: `false'

     Quando `detout' é `true', o determinante de uma matriz cuja
     inversa é calculada é factorado fora da inversa.

     Para esse comutador ter efeito `doallmxops' e `doscmxops' deveram
     ambos serem `false' (veja suas transcrições).  Alternativamente
     esses comutadores podem ser dados para `ev' o que faz com que os
     outros dois sejam escolhidos correctamente.

     Exemplo:

          (%i1) m: matrix ([a, b], [c, d]);
                                      [ a  b ]
          (%o1)                       [      ]
                                      [ c  d ]
          (%i2) detout: true$
          (%i3) doallmxops: false$
          (%i4) doscmxops: false$
          (%i5) invert (m);
                                    [  d   - b ]
                                    [          ]
                                    [ - c   a  ]
          (%o5)                     ------------
                                     a d - b c


 -- Função: diagmatrix (<n>, <x>)
     Retorna uma matriz diagonal de tamanho <n> por <n> com os
     elementos da diagonal todos iguais a <x>.  `diagmatrix (<n>, 1)'
     retorna uma matriz identidade (o mesmo que `ident (<n>)').

     <n> deve avaliar para um inteiro, de outra forma `diagmatrix'
     reclama com uma mensagem de erro.

     <x> pode ser qualquer tipo de expresão, incluindo outra matriz.
     Se <x> é uma matriz, isso não é copiado; todos os elementos da
     diagonal referem-se à mesma instância, <x>.


 -- Variável: doallmxops
     Valor por omissão: `true'

     Quando `doallmxops' é `true', todas as operações relacionadas a
     matrizes são realizadas.  Quando isso é `false' então a escolha de
     comutadores individuais `dot' governam quais operações são
     executadas.


 -- Variável: domxexpt
     Valor por omissão: `true'

     Quando `domxexpt' é `true', uma matriz exponencial, `exp (<M>)'
     onde <M> é a matriz, é interpretada como uma matriz com elementos
     `[i,j' iguais a `exp (m[i,j])'.  de outra forma `exp (<M>)' avalia
     para `exp (<ev(M)>'.

     `domxexpt' afecta todas as expresões da forma `<base>^<expoente>'
     onde <base> é uma expresão assumida escalar ou constante, e
     <expoente> é uma lista ou matriz.

     Exemplo:

          (%i1) m: matrix ([1, %i], [a+b, %pi]);
                                   [   1    %i  ]
          (%o1)                    [            ]
                                   [ b + a  %pi ]
          (%i2) domxexpt: false$
          (%i3) (1 - c)^m;
                                       [   1    %i  ]
                                       [            ]
                                       [ b + a  %pi ]
          (%o3)                 (1 - c)
          (%i4) domxexpt: true$
          (%i5) (1 - c)^m;
                            [                      %i  ]
                            [    1 - c      (1 - c)    ]
          (%o5)             [                          ]
                            [        b + a         %pi ]
                            [ (1 - c)       (1 - c)    ]


 -- Variável de opção: domxmxops
     Valor por omissão: `true'

     Quando `domxmxops' é `true', todas as operações matriz-matriz ou
     matriz-lista são realizadas (mas não operações escalar-matriz); se
     esse comutador é `false' tais operações não são.


 -- Variável de opção: domxnctimes
     Valor por omissão: `false'

     Quando `domxnctimes' é `true', produtos não comutativos de
     matrizes são realizados.


 -- Variável de opção: dontfactor
     Valor por omissão: `[]'

     `dontfactor' pode ser escolhido para uma lista de variáveis em
     relação a qual factoração não é para ocorrer.  (A lista é
     inicialmente vazia.)  Factoração também não pegará lugares com
     relação a quaisquer variáveis que são menos importantes, conforme
     a hierarquía de variável assumida para a forma expresão racional
     canónica (CRE), que essas na lista `dontfactor'.


 -- Variável de opção: doscmxops
     Valor por omissão: `false'

     Quando `doscmxops' é `true', operações escalar-matriz são
     realizadas.


 -- Variável de opção: doscmxplus
     Valor por omissão: `false'

     Quando `doscmxplus' é `true', operações escalar-matriz retornam
     uma matriz resultado.  Esse comutador não é subsomado sob
     `doallmxops'.


 -- Variável de opção: dot0nscsimp
     Valor por omissão: `true'

     Quando `dot0nscsimp' é `true', um produto não comutativo de zero e
     um termo não escalar é simplificado para um produto comutativo.


 -- Variável de opção: dot0simp
     Valor por omissão: `true'

     Quando `dot0simp' é `true', um produto não comutativo de zero e um
     termo escalar é simplificado para um produto não comutativo.


 -- Variável de opção: dot1simp
     Valor por omissão: `true'

     Quando `dot1simp' é `true', um produto não comutativo de um e
     outro termo é simplificado para um produto comutativo.


 -- Variável de opção: dotassoc
     Valor por omissão: `true'

     Quando `dotassoc' é `true', uma expresão `(A.B).C' simplifica para
     `A.(B.C)'.


 -- Variável de opção: dotconstrules
     Valor por omissão: `true'

     Quando `dotconstrules' é `true', um produto não comutativo de uma
     constante e outro termo é simplificado para um produto comutativo.
     Ativando esse sinalizador efectivamente activamos `dot0simp',
     `dot0nscsimp', e `dot1simp' também.


 -- Variável de opção: dotdistrib
     Valor por omissão: `false'

     Quando `dotdistrib' é `true', uma expresão `A.(B + C)' simplifica
     para `A.B + A.C'.


 -- Variável de opção: dotexptsimp
     Valor por omissão: `true'

     Quando `dotexptsimp' é `true', uma expresão `A.A' simplifica para
     `A^^2'.


 -- Variável de opção: dotident
     Valor por omissão: 1

     `dotident' é o valor retornado por `X^^0'.


 -- Variável de opção: dotscrules
     Valor por omissão: `false'

     Quando `dotscrules' é `true', uma expresão `A.SC' ou `SC.A'
     simplifica para `SC*A' e `A.(SC*B)' simplifica para `SC*(A.B)'.


 -- Função: echelon (<M>)
     Retorna a forma escalonada da matriz <M>, como produzido através
     da eliminação de Gauss.  A forma escalonada é calculada de <M> por
     operações elementares de linha tais que o primeiro elemento não
     zero em cada linha na matriz resultante seja o número um e os
     elementos da coluna abaixo do primeiro número um em cada linha
     sejam todos zero.

     `triangularize' também realiza eliminação de Gaussian, mas não
     normaliza o elemento líder não nulo em cada linha.

     `lu_factor' e `cholesky' são outras funções que retornam matrizes
     triangularizadas.

          (%i1) M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
                                 [  3   7  aa  bb ]
                                 [                ]
          (%o1)                  [ - 1  8  5   2  ]
                                 [                ]
                                 [  9   2  11  4  ]
          (%i2) echelon (M);
                            [ 1  - 8  - 5      - 2     ]
                            [                          ]
                            [         28       11      ]
                            [ 0   1   --       --      ]
          (%o2)             [         37       37      ]
                            [                          ]
                            [              37 bb - 119 ]
                            [ 0   0    1   ----------- ]
                            [              37 aa - 313 ]


 -- Função: eigenvalues (<M>)
 -- Função: eivals (<M>)
     Retorna uma lista de duas listas contendo os autovalores da matriz
     <M>.  A primeira sublista do valor de retorno é a lista de
     autovalores da matriz, e a segunda sublista é a lista de
     multiplicidade dos autovalores na ordem correspondente.

     `eivals' é um sinônimo de `eigenvalues'.

     `eigenvalues' chama a função `solve' para achar as raízes do
     polinómio característico da matriz.  Algumas vezes `solve' pode
     não estar habilitado a achar as raízes do polinómio; nesse caso
     algumas outras funções nesse pacote (except `innerproduct',
     `unitvector', `columnvector' e `gramschmidt') não irão trabalhar.

     Em alguns casos os autovalores achados por `solve' podem ser
     expresões complicadas.  (Isso pode acontecer quando `solve'
     retorna uma expresão real não trivial para um autovalor que é
     sabidamente real.)  Isso pode ser possível para simplificar os
     autovalores usando algumas outras funções.

     O pacote `eigen.mac' é chamado automaticamente quando
     `eigenvalues' ou `eigenvectors' é referenciado.  Se `eigen.mac'
     não tiver sido ainda chamado, `load ("eigen")' chama-o.  Após ser
     chamado, todas as funções e variáveis no pacote estarão
     disponíveis.


 -- Função: eigenvectors (<M>)
 -- Função: eivects (<M>)
     pegam uma matriz <M> como seu argumento e retorna uma lista de
     listas cuja primeira sublista é a saída de `eigenvalues' e as
     outras sublistas são os autovectores da matriz correspondente para
     esses autovalores respectivamente.

     `eivects' é um sinônimo para `eigenvectors'.

     O pacote `eigen.mac' é chamado automaticamente quando
     `eigenvalues' ou `eigenvectors' é referenciado.  Se `eigen.mac'
     não tiver sido ainda chamado, `load ("eigen")' chama-o.  Após ser
     chamado, todas as funções e variáveis no pacote estarão
     disponíveis.

     Os sinalizadores que afectam essa função são:

     `nondiagonalizable' é escolhido para `true' ou `false' dependendo
     de se a matriz é não diagonalizável ou diagonalizável após o
     retorno de `eigenvectors'.

     `hermitianmatrix' quando `true', faz com que os autovectores
     degenerados da matriz Hermitiana sejam ortogonalizados usando o
     algoritmo de Gram-Schmidt.

     `knowneigvals' quando `true' faz com que o pacote `eigen' assumir
     que os autovalores da matriz são conhecidos para o utilizador e
     armazenados sob o nome global `listeigvals'.  `listeigvals' poderá
     ser escolhido para uma lista similar à saída de `eigenvalues'.

     A função `algsys' é usada aqui para resolver em relação aos
     autovectores.  Algumas vezes se os autovalores estão ausêntes,
     `algsys' pode não estar habilitado a achar uma solução.  Em alguns
     casos, isso pode ser possível para simplificar os autovalores por
     primeiro achando e então usando o comando `eigenvalues' e então
     usando outras funções para reduzir os autovalores a alguma coisa
     mais simples.  Continuando a simplificação, `eigenvectors' pode
     ser chamada novamente com o sinalizador `knowneigvals' escolhido
     para `true'.


 -- Função: ematrix (<m>, <n>, <x>, <i>, <j>)
     Retorna uma matriz <m> por <n>, todos os elementos da qual são
     zero excepto para o elemento `[<i>, <j>]' que é <x>.


 -- Função: entermatrix (<m>, <n>)
     Retorna uma matriz <m> por <n>, lendo os elementos interativamente.

     Se <n> é igual a <m>, Maxima pergunta pelo tipo de matriz
     (diagonal, simétrica, antisimétrica, ou genérica) e por cada
     elemento.  Cada resposta é terminada por um ponto e vírgula `;' ou
     sinal de dólar `$'.

     Se <n> não é igual a <m>, Maxima pergunta por cada elemento.

     Os elementos podem ser quaisquer expressões, que são avaliadas.
     `entermatrix' avalia seus argumentos.

          (%i1) n: 3$
          (%i2) m: entermatrix (n, n)$

          Is the matriz  1.  Diagonal  2.  Symmetric  3.  Antisymmetric  4.  General
          Answer 1, 2, 3 or 4 :
          1$
          Row 1 Column 1:
          (a+b)^n$
          Row 2 Column 2:
          (a+b)^(n+1)$
          Row 3 Column 3:
          (a+b)^(n+2)$

          Matriz entered.
          (%i3) m;
                          [        3                     ]
                          [ (b + a)      0         0     ]
                          [                              ]
          (%o3)           [                  4           ]
                          [    0      (b + a)      0     ]
                          [                              ]
                          [                            5 ]
                          [    0         0      (b + a)  ]


 -- Função: genmatrix (<a>, <i_2>, <j_2>, <i_1>, <j_1>)
 -- Função: genmatrix (<a>, <i_2>, <j_2>, <i_1>)
 -- Função: genmatrix (<a>, <i_2>, <j_2>)
     Retorna uma matriz gerada de <a>, pegando o elemento
     `<a>[<i_1>,<j_1>]' como o elemento do canto superior esquerdo e
     `<a>[<i_2>,<j_2>]' como o elemento do canto inferior directo da
     matriz.  Aqui <a> é um array declarado (criado através de `array'
     mas não por meio de `make_array') ou um array não declarado, ou
     uma função array, ou uma expressão lambda de dois argumentos.
     (Uma funçãO array é criado como outras funções com `:=' ou
     `define', mas os argumentos são colocados entre colchêtes em lugar
     de parêntesis.)

     Se <j_1> é omitido, isso é assumido ser igual a <i_1>.  Se ambos
     <j_1> e <i_1> são omitidos, ambos são assumidos iguais a 1.

     Se um elemento seleccionado `i,j' de um array for indefinido, a
     matriz conterá um elemento simbólico `<a>[i,j]'.

     Exemplos:

          (%i1) h [i, j] := 1 / (i + j - 1);
                                              1
          (%o1)                  h     := ---------
                                  i, j    i + j - 1
          (%i2) genmatrix (h, 3, 3);
                                     [    1  1 ]
                                     [ 1  -  - ]
                                     [    2  3 ]
                                     [         ]
                                     [ 1  1  1 ]
          (%o2)                      [ -  -  - ]
                                     [ 2  3  4 ]
                                     [         ]
                                     [ 1  1  1 ]
                                     [ -  -  - ]
                                     [ 3  4  5 ]
          (%i3) array (a, fixnum, 2, 2);
          (%o3)                           a
          (%i4) a [1, 1] : %e;
          (%o4)                          %e
          (%i5) a [2, 2] : %pi;
          (%o5)                          %pi
          (%i6) genmatrix (a, 2, 2);
                                     [ %e   0  ]
          (%o6)                      [         ]
                                     [ 0   %pi ]
          (%i7) genmatrix (lambda ([i, j], j - i), 3, 3);
                                   [  0    1   2 ]
                                   [             ]
          (%o7)                    [ - 1   0   1 ]
                                   [             ]
                                   [ - 2  - 1  0 ]
          (%i8) genmatrix (B, 2, 2);
                                  [ B      B     ]
                                  [  1, 1   1, 2 ]
          (%o8)                   [              ]
                                  [ B      B     ]
                                  [  2, 1   2, 2 ]


 -- Função: gramschmidt (<x>)
 -- Função: gschmit (<x>)
     Realiza o algoritmo de ortonalização de Gram-Schmidt sobre <x>,
     seja ela uma matriz ou uma lista de listas.  <x> não é modificado
     por `gramschmidt'.

     Se <x> é uma matriz, o algoritmo é aplicado para as linhas de <x>.
     Se <x> é uma lista de listas, o algoritmo é aplicado às sublistas,
     que devem ter igual números de elementos.  Nos dois casos, o valor
     de retorno é uma lista de listas, as sublistas das listas são
     ortogonais e gera o mesmo spaço que <x>.  Se a dimensão do
     conjunto gerador de <x> é menor que o número de linhas ou
     sublistas, algumas sublistas do valor de retorno são zero.

     `factor' é chamada a cada estágio do algoritmo para simplificar
     resultados intermédios.  Como uma consequência, o valor de retorno
     pode conter inteiros factorados.

     `gschmit' (nota ortográfica) é um sinônimo para `gramschmidt'.

     `load ("eigen")' chama essa função.

     Exemplo:

          (%i1) load ("eigen")$
          Warning - you are redefining the Macsyma function autovalores
          Warning - you are redefining the Macsyma function autovectores
          (%i2) x: matrix ([1, 2, 3], [9, 18, 30], [12, 48, 60]);
                                   [ 1   2   3  ]
                                   [            ]
          (%o2)                    [ 9   18  30 ]
                                   [            ]
                                   [ 12  48  60 ]
          (%i3) y: gramschmidt (x);
                                 2      2            4     3
                                3      3   3 5      2  3  2  3
          (%o3)  [[1, 2, 3], [- ---, - --, ---], [- ----, ----, 0]]
                                2 7    7   2 7       5     5
          (%i4) i: innerproduct$
          (%i5) [i (y[1], y[2]), i (y[2], y[3]), i (y[3], y[1])];
          (%o5)                       [0, 0, 0]


 -- Função: ident (<n>)
     Retorna uma matriz identidade <n> por <n>.


 -- Função: innerproduct (<x>, <y>)
 -- Função: inprod (<x>, <y>)
     Retorna o produto interno (também chamado produto escalar ou
     produto do ponto) de <x> e <y>, que são listas de igual
     comprimento, ou ambas matrizes 1-coluna ou 1-linha de igual
     comprimento.  O valor de retorno é `conjugate (x) . y', onde `.' é
     o operador de multiplicação não comutativa.

     `load ("eigen")' chama essa função.

     `inprod' é um sinônimo para `innerproduct'.


 -- Função: invert (<M>)
     Retorna a inversa da matriz <M>.  A inversa é calculada pelo
     método adjunto.

     Isso permite a um utilizador calcular a inversa de uma matriz com
     entradas bfloat ou polinómios com coeficientes em ponto flutuante
     sem converter para a forma CRE.

     Cofactores são calculados pela função  `determinant', então se
     `ratmx' é `false' a inversa é calculada sem mudar a
     representação dos elementos.

     A implementação corrente é ineficiente para matrizes de alta ordem.

     Quando `detout' é `true', o determinante é factorado fora da
     inversa.

     Os elementos da inversa não são automaticamente expandidos.  Se
     <M> tem elementos polinomiais, melhor aparência de saída pode ser
     gerada por `expand (invert (m)), detout'.  Se isso é desejável
     para ela divisão até pelo determinante pode ser excelente por
     `xthru (%)' ou alternativamente na unha por

          expe (adjoint (m)) / expand (determinant (m))
          invert (m) := adjoint (m) / determinant (m)

     Veja `^^' (expoente não comutativo) para outro método de inverter
     uma matriz.


 -- Variável de opção: lmxchar
     Valor por omissão: `['

     `lmxchar' é o caractere mostrado como o delimitador esquerdo de
     uma matriz.  Veja também `rmxchar'.

     Exemplo:

          (%i1) lmxchar: "|"$
          (%i2) matrix ([a, b, c], [d, e, f], [g, h, i]);
                                     | a  b  c ]
                                     |         ]
          (%o2)                      | d  e  f ]
                                     |         ]
                                     | g  h  i ]


 -- Função: matrix (<row_1>, ..., <row_n>)
     Retorna uma matriz retangular que tem as linhas <row_1>, ...,
     <row_n>.  Cada linha é uma lista de expressões.  Todas as linhas
     devem ter o mesmo comprimento.

     As operações `+' (adição), `-' (subtração), `*' (multiplicação), e
     `/' (divisão), são realizadas elemento por elemento quando os
     operandos são duas matrizes, um escalar e uma matriz, ou uma
     matriz e um escalar.  A operação `^' (exponenciação,
     equivalentemente `**') é realizada elemento por elemento se os
     operandos são um escalar e uma matriz ou uma matriz e um escalar,
     mas não se os operandos forem duas matrizes.  Todos as operações
     são normalmente realizadas de forma completa, incluindo `.'
     (multiplicação não comutativa).

     Multiplicação de matrizes é representada pelo operador de
     multiplicação não comutativa `.'.  O correspondente operador de
     exponenciação não comutativa é `^^'.  Para uma matriz `<A>',
     `<A>.<A> = <A>^^2' e `<A>^^-1' é a inversa de <A>, se existir.

     Existem comutadores para controlar a simplificação de expresões
     envolvendo operações escalar e matriz-lista.  São eles
     `doallmxops', `domxexpt' `domxmxops', `doscmxops', e `doscmxplus'.

     Existem opções adicionais que são relacionadas a matrizes.  São
     elas: `lmxchar', `rmxchar', `ratmx', `listarith', `detout',
     `scalarmatrix', e `sparse'.

     Existe um número de funções que pegam matrizes como argumentos ou
     devolvem matrizes como valor de retorno.  Veja `eigenvalues',
     `eigenvectors', `determinant', `charpoly', `genmatrix', `addcol',
     `addrow', `copymatrix', `transpose', `echelon', e `rank'.

     Exemplos:

        * Construção de matrizes de listas.

          (%i1) x: matrix ([17, 3], [-8, 11]);
                                     [ 17   3  ]
          (%o1)                      [         ]
                                     [ - 8  11 ]
          (%i2) y: matrix ([%pi, %e], [a, b]);
                                     [ %pi  %e ]
          (%o2)                      [         ]
                                     [  a   b  ]

        * Adição, elemento por elemento.

          (%i3) x + y;
                                [ %pi + 17  %e + 3 ]
          (%o3)                 [                  ]
                                [  a - 8    b + 11 ]

        * Subtração, elemento por elemento.

          (%i4) x - y;
                                [ 17 - %pi  3 - %e ]
          (%o4)                 [                  ]
                                [ - a - 8   11 - b ]

        * Multiplicação, elemento por elemento.

          (%i5) x * y;
                                  [ 17 %pi  3 %e ]
          (%o5)                   [              ]
                                  [ - 8 a   11 b ]

        * Divisão, elemento por elemento.

          (%i6) x / y;
                                  [ 17       - 1 ]
                                  [ ---  3 %e    ]
                                  [ %pi          ]
          (%o6)                   [              ]
                                  [   8    11    ]
                                  [ - -    --    ]
                                  [   a    b     ]

        * Matriz para um expoente escalar, elemento por elemento.

          (%i7) x ^ 3;
                                   [ 4913    27  ]
          (%o7)                    [             ]
                                   [ - 512  1331 ]

        * Base escalar para um expoente matriz, elemento por elemento.

          (%i8) exp(y);
                                   [   %pi    %e ]
                                   [ %e     %e   ]
          (%o8)                    [             ]
                                   [    a     b  ]
                                   [  %e    %e   ]

        * Base matriz para um expoente matriz.  Essa não é realizada
          elemento por elemento.

          (%i9) x ^ y;
                                          [ %pi  %e ]
                                          [         ]
                                          [  a   b  ]
                               [ 17   3  ]
          (%o9)                [         ]
                               [ - 8  11 ]

        * Multiplicação não comutativa de matrizes.

          (%i10) x . y;
                            [ 3 a + 17 %pi  3 b + 17 %e ]
          (%o10)            [                           ]
                            [ 11 a - 8 %pi  11 b - 8 %e ]
          (%i11) y . x;
                          [ 17 %pi - 8 %e  3 %pi + 11 %e ]
          (%o11)          [                              ]
                          [  17 a - 8 b     11 b + 3 a   ]

        * Exponenciação não comutativa de matrizes.  Uma base escalar
          <b> para uma potência matriz <M> é realizada elemento por
          elemento e então `b^^m' é o mesmo que `b^m'.

          (%i12) x ^^ 3;
                                  [  3833   1719 ]
          (%o12)                  [              ]
                                  [ - 4584  395  ]
          (%i13) %e ^^ y;
                                   [   %pi    %e ]
                                   [ %e     %e   ]
          (%o13)                   [             ]
                                   [    a     b  ]
                                   [  %e    %e   ]

        * A matriz elevada a um expoente -1 com exponenciação não
          comutativa é a matriz inversa, se existir.

          (%i14) x ^^ -1;
                                   [ 11      3  ]
                                   [ ---  - --- ]
                                   [ 211    211 ]
          (%o14)                   [            ]
                                   [  8    17   ]
                                   [ ---   ---  ]
                                   [ 211   211  ]
          (%i15) x . (x ^^ -1);
                                      [ 1  0 ]
          (%o15)                      [      ]
                                      [ 0  1 ]


 -- Função: matrixmap (<f>, <M>)
     Retorna uma matriz com elemento `i,j' igual a `<f>(<M>[i,j])'.

     Veja também `map', `fullmap', `fullmapl', e `apply'.


 -- Função: matrixp (<expr>)
     Retorna `true' se <expr> é uma matriz, de outra forma retorna
     `false'.


 -- Variável de opção: matrix_element_add
     Valor por omissão: `+'

     `matrix_element_add' é a operação invocada em lugar da adição em
     uma multiplicação de matrizes.  A `matrix_element_add' pode ser
     atribuído qualquer operador n-ário (que é, uma função que manuseia
     qualquer número de argumentos).  Os valores atribuídos podem ser o
     nome de um operador entre aspas duplas, o nome da função, ou uma
     expressão lambda.

     Veja também `matrix_element_mult' e `matrix_element_transpose'.

     Exemplo:

          (%i1) matrix_element_add: "*"$
          (%i2) matrix_element_mult: "^"$
          (%i3) aa: matrix ([a, b, c], [d, e, f]);
                                     [ a  b  c ]
          (%o3)                      [         ]
                                     [ d  e  f ]
          (%i4) bb: matrix ([u, v, w], [x, y, z]);
                                     [ u  v  w ]
          (%o4)                      [         ]
                                     [ x  y  z ]
          (%i5) aa . transpose (bb);
                               [  u  v  w   x  y  z ]
                               [ a  b  c   a  b  c  ]
          (%o5)                [                    ]
                               [  u  v  w   x  y  z ]
                               [ d  e  f   d  e  f  ]


 -- Variável de opção: matrix_element_mult
     Valor por omissão: `*'

     `matrix_element_mult' é a operação invocada em lugar da
     multiplicação em uma multiplicação de matrizes.  A
     `matrix_element_mult' pode ser atribuído qualquer operador binário.
     O valor atribuído pode ser o nome de um operador entre aspas
     duplas, o nome de uma função, ou uma expressão lambda.

     O operador do ponto `.' é uma escolha útil em alguns contextos.

     Veja também `matrix_element_add' e `matrix_element_transpose'.

     Exemplo:

          (%i1) matrix_element_add: lambda ([[x]], sqrt (apply ("+", x)))$
          (%i2) matrix_element_mult: lambda ([x, y], (x - y)^2)$
          (%i3) [a, b, c] . [x, y, z];
                                    2          2          2
          (%o3)         sqrt((c - z)  + (b - y)  + (a - x) )
          (%i4) aa: matrix ([a, b, c], [d, e, f]);
                                     [ a  b  c ]
          (%o4)                      [         ]
                                     [ d  e  f ]
          (%i5) bb: matrix ([u, v, w], [x, y, z]);
                                     [ u  v  w ]
          (%o5)                      [         ]
                                     [ x  y  z ]
          (%i6) aa . transpose (bb);
                         [             2          2          2  ]
                         [ sqrt((c - w)  + (b - v)  + (a - u) ) ]
          (%o6)  Col 1 = [                                      ]
                         [             2          2          2  ]
                         [ sqrt((f - w)  + (e - v)  + (d - u) ) ]

                                   [             2          2          2  ]
                                   [ sqrt((c - z)  + (b - y)  + (a - x) ) ]
                           Col 2 = [                                      ]
                                   [             2          2          2  ]
                                   [ sqrt((f - z)  + (e - y)  + (d - x) ) ]


 -- Variável de opção: matrix_element_transpose
     Valor por omissão: `false'

     `matrix_element_transpose' é a operação aplicada a cada elemento
     de uma matriz quando for uma transposta.  A `matrix_element_mult'
     pode ser atribuído qualquer operador unário.  O valor atribuído
     pode ser  nome de um operador entre aspas duplas, o nome de uma
     função, ou uma expressão lambda.

     Quando `matrix_element_transpose' for igual a `transpose', a
     função  `transpose' é aplicada a todo elemento.  Quando
     `matrix_element_transpose' for igual a `nonscalars', a função
     `transpose' é aplicada a todo elemento não escalar.  Se algum
     elemento é um átomo, a opção `nonscalars' aplica `transpose'
     somente se o átomo for declarado não escalar, enquanto a opção
     `transpose' sempre aplica `transpose'.

     O valor padrão, `false', significa nenhuma operação é aplicada.

     Veja também `matrix_element_add' e `matrix_element_mult'.

     Exemplos:

          (%i1) declare (a, nonscalar)$
          (%i2) transpose ([a, b]);
                                  [ transpose(a) ]
          (%o2)                   [              ]
                                  [      b       ]
          (%i3) matrix_element_transpose: nonscalars$
          (%i4) transpose ([a, b]);
                                  [ transpose(a) ]
          (%o4)                   [              ]
                                  [      b       ]
          (%i5) matrix_element_transpose: transpose$
          (%i6) transpose ([a, b]);
                                  [ transpose(a) ]
          (%o6)                   [              ]
                                  [ transpose(b) ]
          (%i7) matrix_element_transpose: lambda ([x], realpart(x) - %i*imagpart(x))$
          (%i8) m: matrix ([1 + 5*%i, 3 - 2*%i], [7*%i, 11]);
                               [ 5 %i + 1  3 - 2 %i ]
          (%o8)                [                    ]
                               [   7 %i       11    ]
          (%i9) transpose (m);
                                [ 1 - 5 %i  - 7 %i ]
          (%o9)                 [                  ]
                                [ 2 %i + 3    11   ]


 -- Função: mattrace (<M>)
     Retorna o traço (que é, a soma dos elementos sobre a diagonal
     principal) da matriz quadrada <M>.

     `mattrace' é chamada por `ncharpoly', uma alternativa para
     `charpoly' do Maxima.

     `load ("nchrpl")' chama essa função.


 -- Função: minor (<M>, <i>, <j>)
     Retorna o <i>, <j> menor do elemento localizado na linha <i>
     coluna <j> da matriz <M>.  Que é <M> com linha <i> e coluna <j>
     ambas removidas.


 -- Função: ncexpt (<a>, <b>)
     Se uma expressão exponencial não comutativa é muito alta para ser
     mostrada como `<a>^^<b>' aparecerá como `ncexpt (<a>,<b>)'.

     `ncexpt' não é o nome de uma função ou operador; o nome somente
     aparece em saídas, e não é reconhecido em entradas.


 -- Função: ncharpoly (<M>, <x>)
     Retorna o polinómio característico da matriz <M> com relação a
     <x>.  Essa é uma alternativa para `charpoly' do Maxima.

     `ncharpoly' trabalha pelo cálculo dos traços das potências na dada
     matriz, que são sabidos serem iguais a somas de potências das
     raízes do polinómio característico.  Para essas quantidade a
     função simétrica das raízes pode ser calculada, que nada mais são
     que os coeficientes do polinómio característico.  `charpoly'
     trabalha formatando o determinante de `<x> * ident [n] - a'.
     Dessa forma `ncharpoly' é vencedor, por exemplo, no caso de largas
     e densas matrizes preencidas com inteiros, desde que isso evite
     inteiramente a aritmética polinomial.

     `load ("nchrpl")' loads this file.


 -- Função: newdet (<M>, <n>)
     Calcula o determinante de uma matriz ou array <M> pelo algoritmo
     da árvore menor de Johnson-Gentleman.  O argumento <n> é a ordem;
     isso é opcional se <M> for uma matriz.


 -- Declaração: nonscalar
     Faz átomos ser comportarem da mesma forma que uma lista ou matriz
     em relação ao operador do ponto.


 -- Função: nonscalarp (<expr>)
     Retorna `true' se <expr> é um não escalar, i.e., isso contém
     átomos declarados como não escalares, listas, ou matrizes.


 -- Função: permanent (<M>, <n>)
     Calcula o permanente da matriz <M>.  Um permanente é como um
     determinante mas sem mudança de sinal.


 -- Função: rank (<M>)
     Calcula o posto da matriz <M>.  Que é, a ordem do mais largo
     determinante não singular de <M>.

     <rank> pode retornar uma resposta ruim se não puder determinar que
     um elemento da matriz que é equivalente a zero é realmente isso.


 -- Variável de opção: ratmx
     Valor por omissão: `false'

     Quando `ratmx' é `false', adição, subtração, e multiplicação para
     determinantes e matrizes são executados na representação dos
     elementos da matriz e fazem com que o resultado da inversão de
     matrizes seja esquerdo na representação geral.

     Quando `ratmx' é `true', as 4 operações mencionadas acima são
     executadas na forma CRE e o resultado da matriz inversa é dado na
     forma CRE.  Note isso pode fazer com que os elementos sejam
     expandidos (dependendo da escolha de `ratfac') o que pode não ser
     desejado sempre.


 -- Função: row (<M>, <i>)
     retorna a <i>'ésima linha da matriz <M>.  O valor de retorno é uma
     matriz.


 -- Variável de opção: scalarmatrixp
     Valor por omissão: `true'

     Quando `scalarmatrixp' é `true', então sempre que uma matriz 1 x 1
     é produzida como um resultado de cálculos o produto do ponto de
     matrizes é simplificado para um escalar, a saber o elemento
     solitário da matriz.

     Quando `scalarmatrixp' é `all', então todas as matrizes 1 x 1
     serão simplificadas para escalares.

     Quando `scalarmatrixp' é `false', matrizes 1 x 1 não são
     simplificadas para escalares.


 -- Função: scalefactors (<coordinatetransform>)
     Aqui coordinatetransform avalia para a forma [[expresão1,
     expresão2, ...], indeterminação1, indeterminação2, ...], onde
     indeterminação1, indeterminação2, etc.  são as variáveis de
     coordenadas curvilíneas e onde a escolha de componentes
     cartesianas retangulares é dada em termos das coordenadas
     curvilíneas por [expresão1, expresão2, ...].  `coordinates' é
     escolhida para o vector [indeterminação1, indeterminação2,...], e
     `dimension' é escolhida para o comprimento desse vector.  SF[1],
     SF[2], ..., SF[DIMENSION] são escohidos para factores de escala de
     coordenada, e `sfprod' é escohido para o produto desse factores de
     escala.  Inicialmente, `coordinates' é [X, Y, Z], `dimension' é 3,
     e SF[1]=SF[2]=SF[3]=SFPROD=1, correspondendo a coordenadas
     Cartesianas retangulares 3-dimensional.  Para expandir uma
     expresão dentro de componentes físicos no sistema de coordenadas
     corrente , existe uma função com uso da forma


 -- Função: setelmx (<x>, <i>, <j>, <M>)
     Atribue <x> para o (<i>, <j>)'ésimo elemento da matriz <M>, e
     retorna a matriz alterada.

     `<M> [<i>, <j>]: <x>' tem o mesmo efeito, mas retorna <x> em lugar
     de <M>.


 -- Função: similaritytransform (<M>)
 -- Função: simtran (<M>)
     `similaritytransform' calcula uma transformação homotética da
     matriz `M'.  Isso retorna uma lista que é a saída do comando
     `uniteigenvectors'.  Em adição se o sinalizador `nondiagonalizable'
     é `false' duas matrizes globais `leftmatrix' e `rightmatrix' são
     calculadas.  Essas matrizes possuem a propriedade de `leftmatrix .
     <M> . rightmatrix' é uma matriz diagonal com os autovalores de <M>
     sobre a diagonal.  Se `nondiagonalizable' é `true' as matrizes
     esquerda e direita não são computadas.

     Se o sinalizador `hermitianmatrix' é `true' então `leftmatrix' é o
     conjugado complexo da transposta de `rightmatrix'.  De outra forma
     `leftmatrix' é a inversa de `rightmatrix'.

     `rightmatrix' é a matriz cujas colunas são os autovectores
     unitários de <M>.  Os outros sinalizadores (veja `eigenvalues' e
     `eigenvectors') possuem o mesmo efeito desde que
     `similaritytransform' chama as outras funções no pacote com o
     objectivo de estar habilitado para a forma `rightmatrix'.

     `load ("eigen")' chama essa função.

     `simtran' é um sinônimo para `similaritytransform'.


 -- Variável de opção: sparse
     Valor por omissão: `false'

     Quando `sparse' é `true', e se `ratmx' é `true', então
     `determinant' usará rotinas especiais para calcular determinantes
     esparsos.


 -- Função: submatrix (<i_1>, ..., <i_m>, <M>, <j_1>, ..., <j_n>)
 -- Função: submatrix (<i_1>, ..., <i_m>, <M>)
 -- Função: submatrix (<M>, <j_1>, ..., <j_n>)
     Retorna uma nova matriz formada pela matrix <M> com linhas <i_1>,
     ..., <i_m> excluídas, e colunas <j_1>, ..., <j_n> excluídas.


 -- Função: transpose (<M>)
     Retorna a transposta de <M>.

     Se <M> é uma matriz, o valor de retorno é outra matriz <N> tal que
     `N[i,j] = M[j,i]'.

     Se <M> for uma lista, o valor de retorno é uma matrix <N> de
     `length (m)' linhas e 1 coluna, tal que `N[i,1] = M[i]'.

     De outra forma <M> é um símbolo, e o valor de retorno é uma
     expressão substantiva `'transpose (<M>)'.


 -- Função: triangularize (<M>)
     Retorna a maior forma triangular da matriz `M', como produzido
     através da eliminação de Gauss.  O valor de retorno é o mesmo que
     `echelon', excepto que o o coeficiente lider não nulo em cada
     linha não é normalizado para 1.

     `lu_factor' e `cholesky' são outras funções que retornam matrizes
     triangularizadas.

          (%i1) M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
                                 [  3   7  aa  bb ]
                                 [                ]
          (%o1)                  [ - 1  8  5   2  ]
                                 [                ]
                                 [  9   2  11  4  ]
          (%i2) triangularize (M);
                       [ - 1   8         5            2      ]
                       [                                     ]
          (%o2)        [  0   - 74     - 56         - 22     ]
                       [                                     ]
                       [  0    0    626 - 74 aa  238 - 74 bb ]


 -- Função: uniteigenvectors (<M>)
 -- Função: ueivects (<M>)
     Calcula autovectores unitários da matriz <M>.  O valor de retorno
     é uma lista de listas, a primeiro sublista é a saída do comando
     `eigenvalues', e as outras sublistas são os autovectores unitários
     da matriz correspondente a esses autovalores respectivamente.

     Os sinalizadores mencionados na descrição do comando
     `eigenvectors' possuem o mesmo efeito aqui também.

     Quando `knowneigvects' é `true', o pacote `eigen' assume que os
     autovectores da matriz são conhecidos para o utilizador são
     armazenados sob o nome global `listeigvects'.  `listeigvects' pode
     ser ecolhido para uma lista similar à saída do comando
     `eigenvectors'.

     Se `knowneigvects' é escolhido para `true' e a lista de
     autovectores é dada a escolha do sinalizador `nondiagonalizable'
     pode não estar correcta.  Se esse é o caso por favor ecolha isso
     para o valor correcto.  O autor assume que o utilizador sabe o que
     está fazendo e que não tentará diagonalizar uma matriz cujos
     autovectores não geram o mesmo espaço vectorial de dimensão
     apropriada.

     `load ("eigen")' chama essa função.

     `ueivects' é um sinônimo para `uniteigenvectors'.


 -- Função: unitvector (<x>)
 -- Função: uvect (<x>)
     Retorna <x>/norm(<x>); isso é um vector unitário na mesma
     direção que <x>.

     `load ("eigen")' chama essa função.

     `uvect' é um sinônimo para `unitvector'.


 -- Função: vectorsimp (<expr>)
     Aplica simplificações e expansões conforme os seguintes
     sinalizadores globais:

     `expandall', `expanddot', `expanddotplus', `expandcross',
     `expandcrossplus', `expandcrosscross', `expandgrad',
     `expandgradplus', `expandgradprod', `expanddiv', `expanddivplus',
     `expanddivprod', `expandcurl', `expandcurlplus', `expandcurlcurl',
     `expandlaplacian', `expandlaplacianplus', e `expandlaplacianprod'.

     Todos esses sinalizadores possuem valor padrão `false'.  O sufixo
     `plus' refere-se a utilização aditivamente ou distribuitivamente.
     O sufixo `prod' refere-se a expansão para um operando que é
     qualquer tipo de produto.

    `expandcrosscross'
          Simplifica p ~ (q ~ r) para (p . r)*q - (p . q)*r.

    `expandcurlcurl'
          Simplifica curl curl p para grad div p + div grad p.

    `expandlaplaciantodivgrad'
          Simplifica laplacian p para div grad p.

    `expandcross'
          Habilita `expandcrossplus' e `expandcrosscross'.

    `expandplus'
          Habilita `expanddotplus', `expandcrossplus', `expandgradplus',
          `expanddivplus', `expandcurlplus', e `expandlaplacianplus'.

    `expandprod'
          Habilita `expandgradprod', `expanddivprod', e
          `expandlaplacianprod'.

     Esses sinalizadores foram todos declarados `evflag'.


 -- Variável de opção: vect_cross
     Valor por omissão: `false'

     Quando `vect_cross' é `true', isso permite DIFF(X~Y,T) trabalhar
     onde ~ é definido em SHARE;VECT (onde VECT_CROSS é escolhido para
     `true', de qualqeur modo.)


 -- Função: zeromatrix (<m>, <n>)
     Retorna um matriz <m> por <n>, com todos os elementos sendo zero.


 -- Símbolo especial: [
 -- Símbolo especial: ]
     `[' e `]' marcam o omeço e o fim, respectivamente, de uma lista.

     `[' e `]' também envolvem os subscritos de uma lista, array, array
     desordenado, ou função array.

     Exemplos:

          (%i1) x: [a, b, c];
          (%o1)                       [a, b, c]
          (%i2) x[3];
          (%o2)                           c
          (%i3) array (y, fixnum, 3);
          (%o3)                           y
          (%i4) y[2]: %pi;
          (%o4)                          %pi
          (%i5) y[2];
          (%o5)                          %pi
          (%i6) z['foo]: 'bar;
          (%o6)                          bar
          (%i7) z['foo];
          (%o7)                          bar
          (%i8) g[k] := 1/(k^2+1);
                                            1
          (%o8)                     g  := ------
                                     k     2
                                          k  + 1
          (%i9) g[10];
                                          1
          (%o9)                          ---
                                         101



File: maxima.info,  Node: Funções Afins,  Next: itensor,  Prev: Matrizes e Álgebra Linear,  Up: Top

26 Funções Afins
****************

* Menu:

* Definições para Funções Afins::


File: maxima.info,  Node: Definições para Funções Afins,  Prev: Funções Afins,  Up: Funções Afins

26.1 Definições para Funções Afins
==================================

 -- Função: fast_linsolve ([<expr_1>, ..., <expr_m>], [<x_1>, ...,
          <x_n>])
     Resolve equações lineares simultâneas <expr_1>, ..., <expr_m> para
     as variáveis <x_1>, ..., <x_n>.  Cada <expr_i> pode ser uma
     equação ou uma expressão geral; se for dada como uma expressão
     geral, será tratada como uma equação na forma `<expr_i> = 0'.

     O valor de retorno é uma lista de equações da forma `[<x_1> =
     <a_1>, ..., <x_n> = <a_n>]' onde <a_1>, ..., <a_n> são todas
     livres de <x_1>, ..., <x_n>.

     `fast_linsolve' é mais rápido que `linsolve' para sistemas de
     equações que são esparsas.

     Para usar essa função escreva primeiramente `load(affine)'.

 -- Função: grobner_basis ([<expr_1>, ..., <expr_m>])
     Retorna uma base de Groebner para as equações <expr_1>, ...,
     <expr_m>.  A funçã `polysimp' pode então ser usada para
     simplificar outras funções relativas às equações.

          grobner_basis ([3*x^2+1, y*x])$

          polysimp (y^2*x + x^3*9 + 2) ==> -3*x + 2

     `polysimp(f)' produz 0 se e somente se <f> está no ideal gerado por
     <expr_1>, ..., <expr_m>, isto é, se e somente se <f> for uma
     combinação polinomial dos elementos de <expr_1>, ..., <expr_m>.

     Para usar essa função escreva primeiramente `load(affine)'.

 -- Função: set_up_dot_simplifications (<eqns>, <check_through_degree>)
 -- Função: set_up_dot_simplifications (<eqns>)
     As <eqns> são equações polinomiais em variáveis não comutativas.
     O valor de `current_variables'  é uma lista de variáveis usadas
     para calcular graus.  As equações podem ser homogéneas, de forma a
     que o procedimento termine.

     Se tiver optado por sobreposição de simplificações em
     `dot_simplifications' acima do grau de <f>, então o seguinte é
     verdadeiro: `dotsimp (<f>)' retorna 0 se, e somente se, <f> está
     no ideal gerado pelas equações, i.e., se e somente se <f> for uma
     combinação polinomial dos elementos das equações.

     O grau é aquele retornado por `nc_degree'.  Isso por sua vez é
     influenciado pelos pesos das variáveis individuais.

     Para usar essa função escreva primeiramente `load(affine)'.

 -- Função: declare_weights (<x_1>, <w_1>, ..., <x_n>, <w_n>)
     Atribui pesos <w_1>, ..., <w_n> to <x_1>, ..., <x_n>,
     respectivamente.  Esses são pesos usados em cálculos `nc_degree'.

     Para usar essa função escreva primeiramente `load(affine)'.

 -- Função: nc_degree (<p>)
     Retorna o grau de um polinómio não comutativo <p>.  Veja
     `declare_weights'.

     Para usar essa função escreva primeiramente `load(affine)'.

 -- Função: dotsimp (<f>)
     Retorna 0 se e somente se <f> for um ideal gerado pelas equações,
     i.e., se e somente se <f> for uma combinação polinomial dos
     elementos das equações.

     Para usar essa função escreva primeiramente `load(affine)'.

 -- Função: fast_central_elements ([<x_1>, ..., <x_n>], <n>)
     Se `set_up_dot_simplifications' tiver sido feito previamente, ache
     o polinómio central nas variáveis <x_1>, ..., <x_n> no grau dado,
     <n>.

     Por exemplo:
          set_up_dot_simplifications ([y.x + x.y], 3);
          fast_central_elements ([x, y], 2);
          [y.y, x.x];

     Para usar essa função escreva primeiramente `load(affine)'.

 -- Função: check_overlaps (<n>, <add_to_simps>)
     Verifica as sobreposições através do grau <n>, garantindo que tem
     regras de simplificaçõ suficientes em cada grau, para `dotsimp'
     trabalhar correctamente.  Esse processo pode ser mais rápido se
     souber de antemão a dimensão do espaço de monómios.  Se for de
     dimensão global finita, então `hilbert' pode ser usada.  Se não
     conhece as dimensões monomiais, não especifique nenhum
     `rank_function'.  Um terceiro argumento opcional, `reset', `false'
     diz para não se incomodar em perguntar sobre reiniciar coisas.

     Para usar essa função escreva primeiramente `load(affine)'.

 -- Função: mono ([<x_1>, ..., <x_n>], <n>)
     Retorna a lista de monómios independentes relativamente à
     simplificação actual do grau <n> nas variáveis <x_1>, ..., <x_n>.

     Para usar essa função escreva primeiramente `load(affine)'.

 -- Função: monomial_dimensions (<n>)
     Calcula a série de Hilbert através do grau <n> para a algebra
     corrente.

     Para usar essa função escreva primeiramente `load(affine)'.

 -- Função: extract_linear_equations ([<p_1>, ..., <p_n>], [<m_1>, ...,
          <m_n>])
     Faz uma lista dos coeficientes dos polinómios não comutativos
     <p_1>, ..., <p_n> dos monomios não comutatvos <m_1>, ..., <m_n>.
     Os coeficientes podem ser escalares.   Use `list_nc_monomials'
     para construir a lista dos monómios.

     Para usar essa função escreva primeiramente `load(affine)'.

 -- Função: list_nc_monomials ([<p_1>, ..., <p_n>])
 -- Função: list_nc_monomials (<p>)
     Retorna uma lista de monómios não comutativos que ocorrem em um
     polinómio <p> ou em uma lista de polinómios <p_1>, ..., <p_n>.

     Para usar essa função escreva primeiramente `load(affine)'.

 -- Variável de opção: all_dotsimp_denoms
     Valor por omissão: `false'

     Quando `all_dotsimp_denoms' é uma lista, os denominadores
     encontrados por `dotsimp' são adicionados ao final da lista.
     `all_dotsimp_denoms' pode ser iniciado como uma lista vazia `[]'
     antes chamando `dotsimp'.

     Por padrão, denominadores não são colectados por `dotsimp'.



File: maxima.info,  Node: itensor,  Next: ctensor,  Prev: Funções Afins,  Up: Top

27 itensor
**********

* Menu:

* Introdução a itensor::
* Definições para itensor::


File: maxima.info,  Node: Introdução a itensor,  Next: Definições para itensor,  Prev: itensor,  Up: itensor

27.1 Introdução a itensor
=========================

Maxima implementa a manipulação de tensores simbólicos d dois tipos
distintos: manipulação de componentes de tensores (pacote `ctensor') e
manipulação de tensores indiciais (pacote `itensor').

   Note bem: Por favor veja a nota sobre 'nova notação de tensor'
abaixo.

   Manipulação de componentes de tensores significa que objectos do tipo
tensor geométrico são representados como arrays ou matrizes.
Operações com tensores tais com contração ou diferenciação covariante
são realizadas sobre índices (que ocorrem exactamente duas vezes)
repetidos com declarações `do'.  Isto é, se executa explicitamente
operações sobre as componentes apropriadas do tensor armazenadas em um
array ou uma matriz.

   Manipulação tensorial de índice é implementada através da
representação de tensores como funções e suas covariantes,
contravariantes e índices de derivação. Operações com tensores como
contração ou diferenciação covariante são executadas através de
manipulação dos índices em si mesmos em lugar das componentes para as
quais eles correspondem.

   Esses dois métodos aproximam-se do tratamento de processos
diferenciais, algébricos e analíticos no contexto da geometria de
Riemannian possuem várias vantagens e desvantagens as quais se revelam
por si mesmas somente apesar da natureza particular e dificuldade dos
problemas de utilizador.  Todavia, se pode ter em mente as seguintes
características das duas implementações:

   As representações de tensores e de operações com tensores
explicitamente em termos de seus componntes tornam o pacote `ctensor'
fácil de usar. Especificação da métrica e o cálculo de tensores
induzidos e invariantes é directo. Embora todas a capacidade de
simplificação poderosa do Maxima está em manusear, uma métrica complexa
com intrincada dependência funcional e de coordenadas pode facilmente
conduzir a expressões cujo tamanho é excessivo e cuja estrutura está
escondida. Adicionalmente, muitos cálculos envolvem expressões
intermédias cujo crescimento fazem com que os programas terminem antes
de serem completados. Através da experiência, um utilizador pode evitar
muitas dessas dificuldade.

   O motivo de caminhos especiais através dos quais tensores e
operações de tensores são representados em termos de operações
simbólicas sobre seus índices, expressões cujas representação de
componentes podem ser não gerenciaveis da forma comum podem algumas
vezes serem grandemente simplificadas através do uso das rotinas
especiais para objectos simétricos em `itensor'. Nesse caminho a
estrutura de uma expressão grande pode ser mais transparente. Por outro
lado, o motivo da representação indicial especial em `itensor', faz com
que em alguns casos o utilizador possa encontrar dificuldade com a
especificação da métrica, definição de função, e a avaliação de
objectos "indexados" diferenciados.

27.1.1 Nova notação d tensores
------------------------------

Até agora, o pacote `itensor' no Maxima tinha usado uma notação que
algumas vezes conduzia a ordenação incorrecta de índices. Considere o
seguinte, por exemplo:

     (%i2) imetric(g);
     (%o2)                                done
     (%i3) ishow(g([],[j,k])*g([],[i,l])*a([i,j],[]))$
                                      i l  j k
     (%t3)                           g    g    a
                                                i j
     (%i4) ishow(contract(%))$
                                           k l
     (%t4)                                a

   O resultado está incorrecto a menos que ocorra ser `a' um tensor
simétrico.  A razão para isso é que embora `itensor' mantenha
correctamente a ordem dentro do conjunto de índices covariantes e
contravariantes, assim que um índice é incrementado ou decrementado,
sua posição relativa para o outro conjunto de índices é perdida.

   Para evitar esse problema, uma nova notação tem sido desenvolvida
que mantém total compatibilidade com a notação existente e pode ser
usada intercambiavelmente. Nessa notação, índices contravariantes são
inseridos na posição apropriada na lista de índices covariantes, mas
com um sinal de menos colocado antes.  Funções como `contract' e
`ishow' estão agora consciente dessa nova notação de índice e podem
processar tensores apropriadamente.

   Nessa nova notação, o exemplo anterior retorna um resultado correcto:

     (%i5) ishow(g([-j,-k],[])*g([-i,-l],[])*a([i,j],[]))$
                                      i l       j k
     (%t5)                           g    a    g
                                           i j
     (%i6) ishow(contract(%))$
                                           l k
     (%t6)                                a

   Presentemente, o único código que faz uso dessa notação é a
função `lc2kdt'. Através dessa notação, a função `lc2kdt' encontra com
êxito resultados consistentes como a aplicação do tensor métrico para
resolver os símbolos de Levi-Civita sem reordenar para índices
numéricos.

   Uma vez que esse código é um tipo novo, provavelmente contém erros.
Enquanto esse tipo novo não tiver sido testado para garantir que ele
não interrompe nada usando a "antiga" notação de tensor, existe uma
considerável chance que "novos" tensores irão falhar em interoperar com
certas funções ou recursos. Essas falhas serão corrigidas à medida que
forem encontradas... até então, seja cuidadoso!

27.1.2 Manipulação de tensores indiciais
----------------------------------------

o pacote de manipulação de tensores indiciais pode ser chamado através
de `load(itensor)'. Demonstações estão também disponíveis: tente
`demo(tensor)'.  Em `itensor' um tensor é representado como um "objecto
indexado" .  Um "objecto indexado" é uma função de 3 grupos de índices
os quais representam o covariante, o contravariante e o índice de
derivação.  Os índices covariantes são especificados através de uma
lista com o primeiro argumento para o objecto indexado, e os índices
contravariantes através de uma lista como segundo argumento. Se o
objecto indexado carece de algum desses grupos de índices então a lista
vazia `[]' é fornecida como o argumento correspondente.  Dessa forma,
`g([a,b],[c])' representa um objecto indexado chamado `g' o qual tem
dois índices covariantes `(a,b)', um índice contravariante (`c') e não
possui índices de derivação.

   Os índices de derivação, se estiverem presente, são anexados ao
final como argumentos adicionais para a função numérica representando o
tensor.  Eles podem ser explicitamente especificado pelo utilizador ou
serem criados no processo de diferenciação com relação a alguma
variável coordenada.  Uma vez que diferenciação ordinária é comutativa,
os índices de derivação são ordenados alfanumericamente, a menos que
`iframe_flag' seja escolhida para `true', indicando que um referencial
métrico está a ser usado. Essa ordenação canónica torna possível para
Maxima reconhecer que, por exemplo, `t([a],[b],i,j)' é o mesmo que
`t([a],[b],j,i)'.  Diferenciação de um objecto indexado com relação a
alguma coordenada cujos índices não aparecem como um argumento para o
objecto indexado podem normalmente retornar zero. Isso é porque Maxima
pode não saber que o tensor representado através do objecto indexado
possívelmente depende implicitamente da respectiva coordenada.  Pela
modificação da função existente no Maxima, `diff',  em `itensor',
Maxima sabe assumir que todos os objectos indexados dependem de
qualquer variável de diferenciação a menos que seja declarado de outra
forma.  Isso torna possível para a convençào de somatório ser extendida
para índices derivativos. Pode ser verificado que `itensor' não possui
a compatibilidade de incrementar índices derivativos, e então eles são
sempre tratados como covariantes.

   As seguintes funções estão disponíveis no pacote tensor para
manipulação de objectos.  Actualmente, com relação às rotinas de
simplificação, é assumido que objectos indexados não possuem por padrão
propriedades simétricas. Isso pode ser modificado através da escolha da
variável `allsym[false]' para `true', o que irá resultar no tratamento
de todos os objectos indexados completamente simétricos em suas listas
de índices covariantes e simétricos em suas listas de índices
contravariantes.

   O pacote `itensor' geralmente trata tensores como objectos opacos.
Equações tensoriais são manipuladas baseadas em regras algébricas,
especificamente simetria e regras de contração. Adicionalmente, o
pacote `itensor' não entende diferenciação covariante, curvatura, e
torsão. Cálculos podem ser executados relativamente a um métrica de
referenciais de movimento, dependendo da escolha para a variável
`iframe_flag'.

   Uma sessão demonstrativa abaixo mostra como chamar o pacote
`itensor', especificando o nome da métrica, e executando alguns
cálculos simples.

     (%i1) load(itensor);
     (%o1)      /share/tensor/itensor.lisp
     (%i2) imetric(g);
     (%o2)                                done
     (%i3) components(g([i,j],[]),p([i,j],[])*e([],[]))$
     (%i4) ishow(g([k,l],[]))$
     (%t4)                               e p
                                            k l
     (%i5) ishow(diff(v([i],[]),t))$
     (%t5)                                  0
     (%i6) depends(v,t);
     (%o6)                               [v(t)]
     (%i7) ishow(diff(v([i],[]),t))$
                                         d
     (%t7)                               -- (v )
                                         dt   i
     (%i8) ishow(idiff(v([i],[]),j))$
     (%t8)                                v
                                           i,j
     (%i9) ishow(extdiff(v([i],[]),j))$
     (%t9)                             v    - v
                                        j,i    i,j
                                       -----------
                                            2
     (%i10) ishow(liediff(v,w([i],[])))$
                                    %3          %3
     (%t10)                        v   w     + v   w
                                        i,%3    ,i  %3
     (%i11) ishow(covdiff(v([i],[]),j))$
                                                   %4
     (%t11)                        v    - v   ichr2
                                    i,j    %4      i j
     (%i12) ishow(ev(%,ichr2))$
                    %4 %5
     (%t12) v    - g      v   (e p       + e   p     - e p       - e    p
             i,j           %4     j %5,i    ,i  j %5      i j,%5    ,%5  i j

                                                     + e p       + e   p    )/2
                                                          i %5,j    ,j  i %5
     (%i13) iframe_flag:true;
     (%o13)                               true
     (%i14) ishow(covdiff(v([i],[]),j))$
                                                  %6
     (%t14)                        v    - v   icc2
                                    i,j    %6     i j
     (%i15) ishow(ev(%,icc2))$
                                                  %6
     (%t15)                        v    - v   ifc2
                                    i,j    %6     i j
     (%i16) ishow(radcan(ev(%,ifc2,ifc1)))$
                  %6 %8                    %6 %8
     (%t16) - (ifg      v   ifb       + ifg      v   ifb       - 2 v
                         %6    j %8 i             %6    i j %8      i,j

                                                         %6 %8
                                                    - ifg      v   ifb      )/2
                                                                %6    %8 i j
     (%i17) ishow(canform(s([i,j],[])-s([j,i])))$
     (%t17)                            s    - s
                                        i j    j i
     (%i18) decsym(s,2,0,[sym(all)],[]);
     (%o18)                               done
     (%i19) ishow(canform(s([i,j],[])-s([j,i])))$
     (%t19)                                 0
     (%i20) ishow(canform(a([i,j],[])+a([j,i])))$
     (%t20)                            a    + a
                                        j i    i j
     (%i21) decsym(a,2,0,[anti(all)],[]);
     (%o21)                               done
     (%i22) ishow(canform(a([i,j],[])+a([j,i])))$
     (%t22)                                 0


File: maxima.info,  Node: Definições para itensor,  Prev: Introdução a itensor,  Up: itensor

27.2 Definições para itensor
============================

27.2.1 Gerenciando objectos indexados
-------------------------------------

 -- Função: entertensor (<nome>)
     É uma função que, através da linha de comando, permite criar um
     objecto indexado chamado <nome> com qualquer número de índices de
     tensores e derivativos. Ou um índice simples ou uma lista de
     índices (às quais podem ser nulas) são entradas aceitáveis (veja o
     exemplo sob `covdiff').


 -- Função: changename (<antigo>, <novo>, <expr>)
     Irá mudar o nome de todos os objectos indexados chamados <antigo>
     para <novo> em <expr>. <antigo> pode ser ou um símbolo ou uma
     lista da forma `[<nome>, <m>, <n>]' nesse caso somente esses
     objectos indexados chamados <nome> com índice covariante <m> e
     índice contravariante <n> serão renomeados para <novo>.


 -- Função: listoftens
     Lista todos os tensores em uma expressão tensorial, incluindo seus
     índices. E.g.,


          (%i6) ishow(a([i,j],[k])*b([u],[],v)+c([x,y],[])*d([],[])*e)$
                                                   k
          (%t6)                        d e c    + a    b
                                            x y    i j  u,v
          (%i7) ishow(listoftens(%))$
                                         k
          (%t7)                        [a   , b   , c   , d]
                                         i j   u,v   x y


 -- Função: ishow (<expr>)
     Mostra <expr> com os objectos indexados tendo seus índices
     covariantes como subscritos e índices contravariantes como
     sobrescritos.  Os índices derivativos são mostrados como
     subscritos, separados dos índices covariantes por uma vírgula
     (veja os exemplos através desse documento).


 -- Função: indices (<expr>)
     Retorna uma lista de dois elementos.  O primeiro é uma lista de
     índices livres em <expr> (aqueles que ocorrem somente uma vez). O
     segundo é uma lista de indices que ocorrem exactamente duas vezes
     em <expr> (dummy) como demonstra o seguinte exemplo.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(a([i,j],[k,l],m,n)*b([k,o],[j,m,p],q,r))$
                                          k l      j m p
          (%t2)                          a        b
                                          i j,m n  k o,q r
          (%i3) indices(%);
          (%o3)                 [[l, p, i, n, o, q, r], [k, j, m]]

     Um produto de tensores contendo o mesmo índice mais que duas vezes
     é sintaticamente ilegal. `indices' tenta lidar com essas
     expressões de uma forma razoável; todavia, quando `indices' é
     chamada para operar sobre tal uma expressão ilegal, seu
     comportamento pode ser considerado indefinido.


 -- Função: rename (<expr>)
 -- Função: rename (<expr>, <contador>)
     Retorna uma expressão equivalente para <expr> mas com índices que
     ocorrem exactamente duas vezes em cada termo alterado do conjunto
     `[%1, %2,...]', se o segundo argumento opcional for omitido. De
     outra forma, os índices que ocorrem exactamente duas vezes são
     indexados começando no valor de <contador>.  Cada índice que
     ocorre exactamente duas vezes em um produto será diferente. Para
     uma adição, `rename' irá operar sobre cada termo na a adição
     zerando o contador com cada termo. Nesse caminho `rename' pode
     servir como um simplificador tensorial. Adicionalmente, os índices
     serão ordenados alfanumericamente (se `allsym' for `true') com
     relação a índices covariantes ou contravariantes dependendo do
     valor de `flipflag'.  Se `flipflag' for `false' então os índices
     serão renomeados conforme a ordem dos índices contravariantes. Se
     `flipflag' for `true' a renomeação ocorrerá conforme a ordem dos
     índices covariantes. Isso muitas vezes ajuda que o efeito
     combinado dos dois restantes sejam reduzidos a uma expressão de
     valor um ou mais que um por si mesma.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) allsym:true;
          (%o2)                                true
          (%i3) g([],[%4,%5])*g([],[%6,%7])*ichr2([%1,%4],[%3])*
          ichr2([%2,%3],[u])*ichr2([%5,%6],[%1])*ichr2([%7,r],[%2])-
          g([],[%4,%5])*g([],[%6,%7])*ichr2([%1,%2],[u])*
          ichr2([%3,%5],[%1])*ichr2([%4,%6],[%3])*ichr2([%7,r],[%2]),noeval$
          (%i4) expr:ishow(%)$

                 %4 %5  %6 %7      %3         u          %1         %2
          (%t4) g      g      ichr2      ichr2      ichr2      ichr2
                                   %1 %4      %2 %3      %5 %6      %7 r

                        %4 %5  %6 %7      u          %1         %3         %2
                     - g      g      ichr2      ichr2      ichr2      ichr2
                                          %1 %2      %3 %5      %4 %6      %7 r
          (%i5) flipflag:true;
          (%o5)                                true
          (%i6) ishow(rename(expr))$
                 %2 %5  %6 %7      %4         u          %1         %3
          (%t6) g      g      ichr2      ichr2      ichr2      ichr2
                                   %1 %2      %3 %4      %5 %6      %7 r

                        %4 %5  %6 %7      u          %1         %3         %2
                     - g      g      ichr2      ichr2      ichr2      ichr2
                                          %1 %2      %3 %4      %5 %6      %7 r
          (%i7) flipflag:false;
          (%o7)                                false
          (%i8) rename(%th(2));
          (%o8)                                  0
          (%i9) ishow(rename(expr))$
                 %1 %2  %3 %4      %5         %6         %7        u
          (%t9) g      g      ichr2      ichr2      ichr2     ichr2
                                   %1 %6      %2 %3      %4 r      %5 %7

                        %1 %2  %3 %4      %6         %5         %7        u
                     - g      g      ichr2      ichr2      ichr2     ichr2
                                          %1 %3      %2 %6      %4 r      %5 %7


 -- Variável de Opção: flipflag
     Valor por omissão: `false'. Se `false' então os índices irão ser
     renomeados conforme a ordem dos índices contravariantes, de outra
     forma serão ordenados conforme a ordem dos índices covariantes.

     Se `flipflag' for `false' então `rename' forma uma lista de
     índices contravariantes na ordem em que forem encontrados da
     esquerda para a direita (se `true' então de índices
     contravariantes). O primeiro índice que ocorre exactamente duas
     vezes na lista é renomeado para `%1', o seguinte para `%2', etc.
     Então a ordenação ocorre após a ocorrência do `rename' (veja o
     exemplo sob `rename').


 -- Função: defcon (<tensor_1>)
 -- Função: defcon (<tensor_1>, <tensor_2>, <tensor_3>)
     Dado <tensor_1> a propriedade que a contração de um produto do
     <tensor_1> e do <tensor_2> resulta em <tensor_3> com os índices
     apropriados.  Se somente um argumento, <tensor_1>, for dado, então
     a contração do produto de <tensor_1> com qualquer objecto indexado
     tendo os índices apropriados (digamos `my_tensor') irá retornar
     como resultado um objecto indexado com aquele nome, i.e.
     `my_tensor', e com uma nova escolha de índices refletindo as
     contrações executadas.  Por exemplo, se `imetric:g', então
     `defcon(g)' irá implementar o incremento e decremento de índices
     através da contração com o tensor métrico.  Mais de uma `defcon'
     pode ser dada para o mesmo objecto indexado; o último  fornecido
     que for aplicado a uma contração particular será usado.
     `contractions' é uma lista de objectos indexados que tenham
     fornecido propriedades de contrações com `defcon'.


 -- Função: remcon (<tensor_1>, ..., <tensor_n>)
 -- Função: remcon (all)
     Remove todas as propriedades de contração de <tensor_1>, ...,
     <tensor_n>). `remcon(all)' remove todas as propriedades de
     contração de todos os objectos indexados.


 -- Função: contract (<expr>)
     Realiza contrações tensoriais em <expr> a qual pode ser qualquer
     combinação de adições e produtos. Essa função usa a informação
     dada para a função `defcon'. Para melhores resultados, `expr' pode
     ser completamente expandida. `ratexpand' é o meio mais rápido para
     expandir produtos e expoentes de adições se não existirem
     variáveis nos denominadores dos termos. O comutador `gcd' pode ser
     `false' se cancelamentos de máximo divisor comum forem
     desnecessários.


 -- Função: indexed_tensor (<tensor>)
     Deve ser executada antes de atribuir componentes para um <tensor>
     para o qual um valor interno já existe como com `ichr1', `ichr2',
     `icurvature'. Veja o exemplo sob `icurvature'.


 -- Função: components (<tensor>, <expr>)
     Permite que se atribua um valor indicial a uma expressão <expr>
     dando os valores das componentes do <tensor>. Esses são
     automaticamente substituídos para o tensor mesmo que isso ocorra
     com todos os seus índices. O tensor deve ser da forma
     `t([...],[...])' onde qualquer lista pode ser vazia. <expr> pode
     ser qualquer expressão indexada envolvendo outros objectos com os
     mesmos índices livres que <tensor>. Quando usada para atribuir
     valores a um tensor métrico no qual as componentes possuem índices
     que ocorrem exactamente duas vezes se deve ser cuidadoso para
     definir esses índices de forma a evitar a geração de índices que
     ocorrem exactamente duas vezes e que são múltiplos. a remoção
     dessas atribuições é dada para a função `remcomps'.

     É importante ter em mente que `components' cuida somente da
     valência de um tensor, e que ignora completamente qualquer
     ordenação particular de índices. Dessa forma atribuindo
     componentes a, digamos, `x([i,-j],[])', `x([-j,i],[])', ou
     `x([i],[j])' todas essas atribuições produzem o mesmo resultado, a
     saber componentes sendo atribuidas a um tensor chamado `x' com
     valência `(1,1)'.

     Componentes podem ser atribuidas a uma expressão indexada por
     quatro caminhos, dois dos quais envolvem o uso do comando
     `components':

     1) Como uma expressão indexada. Por exemplo:


          (%i2) components(g([],[i,j]),e([],[i])*p([],[j]))$
          (%i3) ishow(g([],[i,j]))$
                                                i  j
          (%t3)                                e  p

     2) Como uma matriz:


          (%i6) components(g([i,j],[]),lg);
          (%o6)                                done
          (%i7) ishow(g([i,j],[]))$
          (%t7)                                g
                                                i j
          (%i8) g([3,3],[]);
          (%o8)                                  1
          (%i9) g([4,4],[]);
          (%o9)                                 - 1

     3) Como uma função. Pode usar uma função Maxima para especificar as
     componentes de um tensor baseado nesses índices. Por exemplo, os
     seguintes códigos atribuem `kdelta' a `h' se `h' tiver o mesmo
     número de índices covariantes e índices contravariantes e nenhum
     índice derivativo, e atribui `kdelta' a `g' caso as condições
     anteriores não sejam atendidas:


          (%i4) h(l1,l2,[l3]):=if length(l1)=length(l2) and length(l3)=0
            then kdelta(l1,l2) else apply(g,append([l1,l2], l3))$
          (%i5) ishow(h([i],[j]))$
                                                    j
          (%t5)                               kdelta
                                                    i
          (%i6) ishow(h([i,j],[k],l))$
                                               k
          (%t6)                               g
                                               i j,l

     4) Usando a compatibilidade dos modelos de coincidência do Maxima,
     especificamente os comandos `defrule' e `applyb1':


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) matchdeclare(l1,listp);
          (%o2)                                done
          (%i3) defrule(r1,m(l1,[]),(i1:idummy(),
                g([l1[1],l1[2]],[])*q([i1],[])*e([],[i1])))$

          (%i4) defrule(r2,m([],l1),(i1:idummy(),
                w([],[l1[1],l1[2]])*e([i1],[])*q([],[i1])))$

          (%i5) ishow(m([i,n],[])*m([],[i,m]))$
                                              i m
          (%t5)                              m    m
                                                   i n
          (%i6) ishow(rename(applyb1(%,r1,r2)))$
                                     %1  %2  %3 m
          (%t6)                     e   q   w     q   e   g
                                                   %1  %2  %3 n


 -- Função: remcomps (<tensor>)
     Desassocia todos os valores de <tensor> que foram atribuídos com a
     função `components'.


 -- Função: showcomps (<tensor>)
     Mostra atribuições de componentes de um tensor, feitas usando o
     comando `components'. Essa função pode ser particularmente útil
     quando uma matriz é atribuída a um tensor indicial usando
     `components', como demonstrado através do seguinte exemplo:


          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) load(itensor);
          (%o2)      /share/tensor/itensor.lisp
          (%i3) lg:matrix([sqrt(r/(r-2*m)),0,0,0],[0,r,0,0],
                          [0,0,sin(theta)*r,0],[0,0,0,sqrt((r-2*m)/r)]);
                         [         r                                     ]
                         [ sqrt(-------)  0       0              0       ]
                         [      r - 2 m                                  ]
                         [                                               ]
                         [       0        r       0              0       ]
          (%o3)          [                                               ]
                         [       0        0  r sin(theta)        0       ]
                         [                                               ]
                         [                                      r - 2 m  ]
                         [       0        0       0        sqrt(-------) ]
                         [                                         r     ]
          (%i4) components(g([i,j],[]),lg);
          (%o4)                                done
          (%i5) showcomps(g([i,j],[]));
                            [         r                                     ]
                            [ sqrt(-------)  0       0              0       ]
                            [      r - 2 m                                  ]
                            [                                               ]
                            [       0        r       0              0       ]
          (%t5)      g    = [                                               ]
                      i j   [       0        0  r sin(theta)        0       ]
                            [                                               ]
                            [                                      r - 2 m  ]
                            [       0        0       0        sqrt(-------) ]
                            [                                         r     ]
          (%o5)                                false

     O comando `showcomps' pode também mostrar componentes de um tensor
     de categoria maior que 2.


 -- Função: idummy ()
     Incrementos `icounter' e retorno como seu valor um índice da forma
     `%n' onde n é um inteiro positivo.  Isso garante que índices que
     ocorrem exactamente duas vezes e que são necessários na
     formação de expressões não irão conflitar com índices que já
     estiverem sendo usados (veja o exemplo sob `indices').


 -- Variável de opção: idummyx
     Valor por omissão: `%'

     É o prefixo para índices que ocorrem exactamente duas vezes (veja
     o exemplo sob índices `indices').


 -- Variável de Opção: icounter
     Valor por omissão: `1'

     Determina o sufixo numérico a ser usado na geração do próximo
     índice que ocorre exactamente duas vezes no pacote tensor.  O
     prefixo é determinado através da opção `idummy' (padrão: `%').

 -- Função: kdelta (<L1>, <L2>)
     é a função delta generalizada de Kronecker definida no pacote
     `itensor' com <L1> a lista de índices covariantes e <L2> a lista
     de índices contravariantes.  `kdelta([i],[j])' retorna o delta de
     Kronecker comum.  O comando `ev(<expr>,kdelta)' faz com que a
     avaliação de uma expressão contendo `kdelta([],[])' se dê para a
     dimensão de multiplicação.

     No que conduzir a um abuso dessa notação, `itensor' também permite
     `kdelta' ter 2 covariantes e nenhum contravariante, ou 2
     contravariantes e nenhum índice covariante, com efeito fornecendo
     uma compatibilidade para "matriz unitária" covariante ou
     contravariante. Isso é estritamente considerado um recurso de
     programação e não significa implicar que `kdelta([i,j],[])' seja
     um objecto tensorial válido.


 -- Função: kdels (<L1>, <L2>)
     Delta de Kronecker simetrizado, usado em alguns cálculos. Por
     exemplo:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) kdelta([1,2],[2,1]);
          (%o2)                                 - 1
          (%i3) kdels([1,2],[2,1]);
          (%o3)                                  1
          (%i4) ishow(kdelta([a,b],[c,d]))$
                                       c       d         d       c
          (%t4)                  kdelta  kdelta  - kdelta  kdelta
                                       a       b         a       b
          (%i4) ishow(kdels([a,b],[c,d]))$
                                       c       d         d       c
          (%t4)                  kdelta  kdelta  + kdelta  kdelta
                                       a       b         a       b


 -- Função: levi_civita (<L>)
     é o tensor de permutação (ou de Levi-Civita) que retorna 1 se a
     lista <L> consistir de uma permutação par de inteiros, -1 se isso
     consistir de uma permutação ímpar, e 0 se alguns índices em <L>
     forem repetidos.


 -- Função: lc2kdt (<expr>)
     Simplifica expressões contendo os símbolos de Levi-Civita,
     convertendo esses para expressões delta de Kronecker quando
     possível. A principal diferença entre essa função e simplesmente
     avaliar os simbolos de Levi-Civita é que a avaliação directa
     muitas vezes resulta em expressões Kronecker contendo índices
     numéricos. Isso é muitas vezes indesejável como na prevenção de
     simplificação adicional.  A função `lc2kdt' evita esse problema,
     retornando expressões que são mais facilmente simplificadas com
     `rename' ou `contract'.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) expr:ishow('levi_civita([],[i,j])*'levi_civita([k,l],[])*a([j],[k]))$
                                            i j  k
          (%t2)                  levi_civita    a  levi_civita
                                                 j            k l
          (%i3) ishow(ev(expr,levi_civita))$
                                            i j  k       1 2
          (%t3)                       kdelta    a  kdelta
                                            1 2  j       k l
          (%i4) ishow(ev(%,kdelta))$
                       i       j         j       i   k
          (%t4) (kdelta  kdelta  - kdelta  kdelta ) a
                       1       2         1       2   j

                                         1       2         2       1
                                  (kdelta  kdelta  - kdelta  kdelta )
                                         k       l         k       l
          (%i5) ishow(lc2kdt(expr))$
                               k       i       j    k       j       i
          (%t5)               a  kdelta  kdelta  - a  kdelta  kdelta
                               j       k       l    j       k       l
          (%i6) ishow(contract(expand(%)))$
                                           i           i
          (%t6)                           a  - a kdelta
                                           l           l

     A função `lc2kdt' algumas vezes faz uso de tensores métricos.  Se
     o tensor métrico não tiver sido definido previamente com `imetric',
     isso resulta em um erro.


          (%i7) expr:ishow('levi_civita([],[i,j])*'levi_civita([],[k,l])*a([j,k],[]))$
                                           i j            k l
          (%t7)                 levi_civita    levi_civita    a
                                                               j k
          (%i8) ishow(lc2kdt(expr))$
          Maxima encountered a Lisp error:

           Error in $IMETRIC [or a callee]:
           $IMETRIC [or a callee] requires less than two arguments.

          Automatically continuing.
          To reenable the Lisp debugger set *debugger-hook* to nil.
          (%i9) imetric(g);
          (%o9)                                done
          (%i10) ishow(lc2kdt(expr))$
                   %3 i       k   %4 j       l     %3 i       l   %4 j       k
          (%t10) (g     kdelta   g     kdelta   - g     kdelta   g     kdelta  ) a
                              %3             %4               %3             %4   j k
          (%i11) ishow(contract(expand(%)))$
                                            l i      l i
          (%t11)                           a    - a g


 -- Função: lc_l
     Regra de simplificação usada para expressões contendo símbolos não
     avaliados de Levi-Civita (`levi_civita'). Juntamente com `lc_u',
     pode ser usada para simplificar muitas expressões mais
     eficientemente que a avaliação de `levi_civita'.  Por exemplo:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2)  el1:ishow('levi_civita([i,j,k],[])*a([],[i])*a([],[j]))$
                                       i  j
          (%t2)                       a  a  levi_civita
                                                       i j k
          (%i3) el2:ishow('levi_civita([],[i,j,k])*a([i])*a([j]))$
                                                 i j k
          (%t3)                       levi_civita      a  a
                                                        i  j
          (%i4) ishow(canform(contract(expand(applyb1(el1,lc_l,lc_u)))))$
          (%t4)                                  0
          (%i5) ishow(canform(contract(expand(applyb1(el2,lc_l,lc_u)))))$
          (%t5)                                  0


 -- Função: lc_u
     Regra de simplificação usada para expressões contendo símbolos não
     avaliados de Levi-Civita (`levi_civita'). Juntamente com `lc_u',
     pode ser usada para simplificar muitas expressões mais
     eficientemente que a avaliação de `levi_civita'.  Para detalhes,
     veja `lc_l'.


 -- Função: canten (<expr>)
     Simplifica <expr> por renomeação (veja `rename') e permutando
     índices que ocorrem exactamente duas vezes. `rename' é restrito a
     adições de produto de tensores nos quais nenhum índice derivativo
     estiver presente. Como tal isso é limitado e pode somente ser
     usado se `canform' não for capaz de realizar a simplificação
     requerida.

     A função `canten' retorna um resultado matematicamente correcto
     somente se seu argumento for uma expressão que é completamente
     simétrica em seus índices.  Por essa razão, `canten' retorna um
     erro se `allsym' não for posicionada em `true'.


 -- Função: concan (<expr>)
     Similar a `canten' mas também executa contração de índices.


27.2.2 Simetrias de tensores
----------------------------

 -- Variável de Opção: allsym
     Valor por omissão: `false'. Se `true' então todos os objectos
     indexados são assumidos simétricos em todos os seus índices
     covariantes e contravariantes. Se `false' então nenhum simétrico
     de qualquer tipo é assumidos nesses índices. Índices derivativos
     são sempre tomados para serem simétricos a menos que `iframe_flag'
     seja escolhida para `true'.


 -- Função: decsym (<tensor>, <m>, <n>, [<cov_1>, <cov_2>, ...],
          [<contr_1>, <contr_2>, ...])
     Declara propriedades de simetria para <tensor> de covariante <m> e
     <n> índices contravariantes. As <cov_i> e <contr_i> são
     pseudofunções expressando relações de simetrias em meio a índices
     covariante e índices contravariantes respectivamente.  Esses são
     da forma `symoper(<index_1>, <index_2>,...)' onde `symoper' é um
     entre `sym', `anti' ou `cyc' e os <index_i> são inteiros indicando
     a posição do índice no <tensor>.  Isso irá declarar <tensor> para
     ser simétrico, antisimétrico ou cíclico respectivamente nos
     <index_i>. `symoper(all)' é também forma permitida que indica
     todos os índices obedecem à condição de simetria. Por exemplo,
     dado um objecto `b' com 5 índices covariantes,
     `decsym(b,5,3,[sym(1,2),anti(3,4)],[cyc(all)])' declara `b'
     simétrico no seu primeiro e no seu segundo índices e antisimétrico
     no seu terceiro e quarto índices covariantes, e cíclico em todos
     de seus índices contravariantes.  Qualquer lista de declarações de
     simetria pode ser nula.  A função que executa as simplificações é
     `canform' como o exemplo abaixo ilustra.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) expr:contract(expand(a([i1,j1,k1],[])*kdels([i,j,k],[i1,j1,k1])))$
          (%i3) ishow(expr)$
          (%t3)         a      + a      + a      + a      + a      + a
                         k j i    k i j    j k i    j i k    i k j    i j k
          (%i4) decsym(a,3,0,[sym(all)],[]);
          (%o4)                                done
          (%i5) ishow(canform(expr))$
          (%t5)                              6 a
                                                i j k
          (%i6) remsym(a,3,0);
          (%o6)                                done
          (%i7) decsym(a,3,0,[anti(all)],[]);
          (%o7)                                done
          (%i8) ishow(canform(expr))$
          (%t8)                                  0
          (%i9) remsym(a,3,0);
          (%o9)                                done
          (%i10) decsym(a,3,0,[cyc(all)],[]);
          (%o10)                               done
          (%i11) ishow(canform(expr))$
          (%t11)                        3 a      + 3 a
                                           i k j      i j k
          (%i12) dispsym(a,3,0);
          (%o12)                     [[cyc, [[1, 2, 3]], []]]


 -- Função: remsym (<tensor>, <m>, <n>)
     Remove todas as propriedades de simetria de <tensor> que tem <m>
     índices covariantes e <n> índices contravariantes.

 -- Função: canform (<expr>)
     Simplifica <expr> através de mudança de nome de índices que
     ocorrem exactamente duas vezes e reordenação de todos os índices
     como ditados pelas condições de simetria impostas sobre eles. Se
     `allsym' for `true' então todos os índices são assumidos
     simétricos, de outra forma a informação de simetria fornecida
     pelas declarações `decsym' irão ser usadas. Os índices que ocorrem
     exactamente duas vezes são renomeados da mesma maneira que na
     função `rename'. Quando `canform' é aplicada a uma expressão larga
     o cálculo pode tomar um considerável montante de tempo.  Esse
     tempo pode ser diminuído através do uso de `rename' sobre a
     expressão em primeiro lugar.  Também veja o exemplo sob `decsym'.
     Nota: `canform' pode não estar apta a reduzir um expressão
     completamente para sua forma mais simples embora retorne sempre um
     resultado matemáticamente correcto.

27.2.3 Cálculo de tensores indiciais
------------------------------------

 -- Função: diff (<expr>, <v_1>, [<n_1>, [<v_2>, <n_2>] ...])
     É a função usual de diferenciação do Maxima que tem sido expandida
     nessas habilidades para `itensor'. `diff' toma a derivada de <expr>
     <n_1> vezes com relação a <v_1>, <n_2> vezes com relação a <v_2> ,
     etc. Para o pacote `tensor', a função tem sido modificada de forma
     que os <v_i> possam ser inteiros de 1 até o valor da variável
     `dim'.  Isso causará a conclusão da diferenciação com relação ao
     <v_i>ésimo membro da lista `vect_coords'.  Se `vect_coords' for
     associado a uma variável atômica, então aquela variável subscrita
     através de <v_i> será usada para a variável de diferenciação.
     Isso permite que um array de nomes de coordenadas ou nomes
     subscritos como `x[1]', `x[2]', ...  sejam usados.

 -- Função: idiff (<expr>, <v_1>, [<n_1>, [<v_2>, <n_2>] ...])
     Diferenciação indicial. A menos que `diff', que diferencia com
     relação a uma variável independente, `idiff' possa ser usada para
     diferenciar com relação a uma coordenada. Para um objecto indexado,
     isso equivale a anexar ao final os <v_i> como índices derivativos.
     Subsequêntemente, índices derivativos irão ser ordenados, a menos
     que `iframe_flag' seja escolhida para `true'.

     `idiff' pode também ser o determinante de um tensor métrico. Dessa
     forma, se `imetric' tiver sido associada a `G' então
     `idiff(determinant(g),k)' irá retornar
     `2*determinant(g)*ichr2([%i,k],[%i])' onde o índice que ocorre
     exactamente duas vezes `%i' é escolhido apropriadamente.


 -- Função: liediff (<v>, <ten>)
     Calcula a derivada de Lie da expressão tensorial <ten> com
     relação ao campo vectorial <v>. <ten> pode ser qualquer expressão
     tensorial indexada; <v> pode ser o nome (sem índices) de um campo
     vectorial. Por exemplo:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(liediff(v,a([i,j],[])*b([],[k],l)))$
                 k    %2            %2          %2
          (%t2) b   (v   a       + v   a     + v   a    )
                 ,l       i j,%2    ,j  i %2    ,i  %2 j

                                          %1  k        %1  k      %1  k
                                      + (v   b      - b   v    + v   b   ) a
                                              ,%1 l    ,l  ,%1    ,l  ,%1   i j


 -- Função: rediff (<ten>)
     Avalia todas as ocorrências do comando `idiff' na expressão
     tensorial <ten>.


 -- Função: undiff (<expr>)
     Retorna uma expressão equivalente a <expr> mas com todas as
     derivadas de objectos indexados substituídas pela forma
     substantiva da função `idiff'. Seu argumento pode retornar aquele
     objecto indexado se a diferenciação for concluída.  Isso é útil
     quando for desejado substituir um objecto indexado que sofreu
     diferenciação com alguma definição de função resultando em <expr>
     e então concluir a diferenciação através de digamos `ev(<expr>,
     idiff)'.


 -- Função: evundiff (<expr>)
     Equivalente à execução de `undiff', seguida por `ev' e `rediff'.

     O ponto dessa operação é facilmente avaliar expressões que não
     possam ser directamente avaliadas na forma derivada. Por exemplo,
     o seguinte causa um erro:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) icurvature([i,j,k],[l],m);
          Maxima encountered a Lisp error:

           Error in $ICURVATURE [or a callee]:
           $ICURVATURE [or a callee] requires less than three arguments.

          Automatically continuing.
          To reenable the Lisp debugger set *debugger-hook* to nil.

     Todavia, se `icurvature' é informado em sua forma substantiva,
     pode ser avaliado usando `evundiff':

          (%i3) ishow('icurvature([i,j,k],[l],m))$
                                                   l
          (%t3)                          icurvature
                                                   i j k,m
          (%i4) ishow(evundiff(%))$
                       l              l         %1           l           %1
          (%t4) - ichr2        - ichr2     ichr2      - ichr2       ichr2
                       i k,j m        %1 j      i k,m        %1 j,m      i k

                          l              l         %1           l           %1
                   + ichr2        + ichr2     ichr2      + ichr2       ichr2
                          i j,k m        %1 k      i j,m        %1 k,m      i j

     Nota: Em versões anteriores do Maxima, formas derivadas dos
     símbolos de Christoffel também não podiam ser avaliadas. Isso foi
     corrigido actualmente, de forma que `evundiff' não mais é
     necessária para expressões como essa:

          (%i5) imetric(g);
          (%o5)                                done
          (%i6) ishow(ichr2([i,j],[k],l))$
                 k %3
                g     (g         - g         + g        )
                        j %3,i l    i j,%3 l    i %3,j l
          (%t6) -----------------------------------------
                                    2

                                   k %3
                                  g     (g       - g       + g      )
                                   ,l     j %3,i    i j,%3    i %3,j
                                + -----------------------------------
                                                   2


 -- Função: flush (<expr>, <tensor_1>, <tensor_2>, ...)
     Escolhe para zero, em <expr>, todas as ocorrências de <tensor_i>
     que não tiverem índices derivativos.


 -- Função: flushd (<expr>, <tensor_1>, <tensor_2>, ...)
     Escolhe para zero, em <expr>, todas as ocorrências de <tensor_i>
     que tiverem índices derivativos.


 -- Função: flushnd (<expr>, <tensor>, <n>)
     Escolhe para zero, em <expr>, todas as ocorrências do objecto
     diferenciado <tensor> que tem <n> ou mais índices derivativos como
     demonstra o seguinte exemplo.

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(a([i],[J,r],k,r)+a([i],[j,r,s],k,r,s))$
                                          J r      j r s
          (%t2)                          a      + a
                                          i,k r    i,k r s
          (%i3) ishow(flushnd(%,a,3))$
                                               J r
          (%t3)                               a
                                               i,k r

 -- Função: coord (<tensor_1>, <tensor_2>, ...)
     Dados os <tensor_i> a propriedade de diferenciação da coordenada
     que a derivada do vector contravariante cujo nome é um dos
     <tensor_i> retorna um delta de Kronecker. Por exemplo, se
     `coord(x)' tiver sido concluída então `idiff(x([],[i]),j)' fornece
     `kdelta([i],[j])'.  `coord' que é uma lista de todos os objectos
     indexados tendo essa propriedade.


 -- Função: remcoord (<tensor_1>, <tensor_2>, ...)
 -- Função: remcoord (all)
     Remove a propriedade de coordenada de diferenciação dos `tensor_i'
     que foram estabelecidos através da função `coord'.  `remcoord(all)'
     remove essa propriedade de todos os objectos indexados.


 -- Função: makebox (<expr>)
     Mostra <expr> da mesma maneira que `show'; todavia, qualquer
     tensor d'Alembertiano ocorrendo em <expr> será indicado usando o
     símbolo `[]'.  Por exemplo, `[]p([m],[n])' representa
     `g([],[i,j])*p([m],[n],i,j)'.


 -- Função: conmetderiv (<expr>, <tensor>)
     Simplifica expressões contendo derivadas comuns de ambas as formas
     covariantes e contravariantes do tensor métrico (a restrição
     corrente).  Por exemplo, `conmetderiv' pode relatar a derivada do
     tensor contravariante métrico com símbolos de Christoffel como
     visto adiante:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(g([],[a,b],c))$
                                                a b
          (%t2)                                g
                                                ,c
          (%i3) ishow(conmetderiv(%,g))$
                                   %1 b      a       %1 a      b
          (%t3)                 - g     ichr2     - g     ichr2
                                             %1 c              %1 c

 -- Função: simpmetderiv (<expr>)
 -- Função: simpmetderiv (<expr>[, <stop>])
     Simplifica expressões contendo produtos de derivadas de tensores
     métricos. Especificamente, `simpmetderiv' reconhece duas
     identidades:


             ab        ab           ab                 a
            g   g   + g   g     = (g   g  )   = (kdelta )   = 0
             ,d  bc        bc,d         bc ,d          c ,d

     consequêntemente


             ab          ab
            g   g   = - g   g
             ,d  bc          bc,d

     e


            ab          ab
           g   g     = g   g
            ,j  ab,i    ,i  ab,j

     que seguem de simetrias de símbolos de Christoffel.

     A função `simpmetderiv' toma um parâmetro opcional que, quando
     presente, faz com que a função pare após a primeira
     substituição feita com sucesso em uma expressão produto. A
     função `simpmetderiv' também faz uso da variável global <flipflag>
     que determina como aplicar uma ordenação "canonica" para os
     índices de produto.

     Colocados juntos, essas compatibilidades podem ser usadas
     poderosamente para encontrar simplificações que são difíceis ou
     impossíveis de realizar de outra forma.  Isso é demonstrado
     através do seguinte exemplo que explicitamente usa o recurso de
     simplificação parcial de `simpmetderiv' para obter uma expressão
     contractível:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) imetric(g);
          (%o2)                                done
          (%i3) ishow(g([],[a,b])*g([],[b,c])*g([a,b],[],d)*g([b,c],[],e))$
                                       a b  b c
          (%t3)                       g    g    g      g
                                                 a b,d  b c,e
          (%i4) ishow(canform(%))$

          errexp1 has improper indices
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i5) ishow(simpmetderiv(%))$
                                       a b  b c
          (%t5)                       g    g    g      g
                                                 a b,d  b c,e
          (%i6) flipflag:not flipflag;
          (%o6)                                true
          (%i7) ishow(simpmetderiv(%th(2)))$
                                         a b  b c
          (%t7)                         g    g    g    g
                                         ,d   ,e   a b  b c
          (%i8) flipflag:not flipflag;
          (%o8)                                false
          (%i9) ishow(simpmetderiv(%th(2),stop))$
                                         a b  b c
          (%t9)                       - g    g    g      g
                                              ,e   a b,d  b c
          (%i10) ishow(contract(%))$
                                              b c
          (%t10)                           - g    g
                                              ,e   c b,d

     Veja também `weyl.dem' para um exemplo que usa `simpmetderiv' e
     `conmetderiv' juntos para simplificar contrações do tensor de Weyl.


 -- Função: flush1deriv (<expr>, <tensor>)
     Escolhe para zero, em `expr', todas as ocorrências de `tensor' que
     possuem exactamente um índice derivativo.


27.2.4 Tensores em espaços curvos
---------------------------------

 -- Função: imetric (<g>)
 -- Variável de sistema: imetric
     Especifica a métrica através de atribuição à variável `imetric:<g>'
     adicionalmente, as propriedades de contração da métrica <g> são
     escolhidas através da execução dos comandos
     `defcon(<g>),defcon(<g>,<g>,kdelta)'.  A variável `imetric'
     (desassociada por padrão), é associada à métrica, atribuida pelo
     comando `imetric(<g>)'.


 -- Função: idim (<n>)
     Escolhe as dimensões da métrica. Também inicializa as propriedades
     de antisimetria dos símbolos de Levi-Civita para as dimensões
     dadas.


 -- Função: ichr1 ([<i>, <j>, <k>])
     Retorna o símbolo de Christoffel de primeiro tipo via definição
                 (g      + g      - g     )/2 .
                   ik,j     jk,i     ij,k
     Para avaliar os símbolos de Christoffel para uma métrica
     particular, à variável `imetric' deve ser atribuída um nome como
     no exemplo sob `chr2'.


 -- Função: ichr2 ([<i>, <j>], [<k>])
     Retorna o símbolo de Christoffel de segundo tipo definido pela
     relação
                                 ks
             ichr2([i,j],[k]) = g    (g      + g      - g     )/2
                                       is,j     js,i     ij,s

 -- Função: icurvature ([<i>, <j>, <k>], [<h>])
     Retorna o tensor da curvatura de Riemann em termos de símbolos de
     Christoffel de segundo tipo (`ichr2').  A seguinte notação é usada:
                         h             h            h         %1         h
               icurvature     = - ichr2      - ichr2     ichr2    + ichr2
                         i j k         i k,j        %1 j      i k        i j,k
                                         h          %1
                                  + ichr2      ichr2
                                         %1 k       i j

 -- Função: covdiff (<expr>, <v_1>, <v_2>, ...)
     Retorna a derivada da covariante de <expr> com relação às
     variáveis <v_i> em termos de símbolos de Christoffel de segundo
     tipo (`ichr2').  Com o objectivo de avaliar esses, se pode usar
     `ev(<expr>,ichr2)'.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) entertensor()$
          Enter tensor name: a;
          Enter a list of the índices covariantes: [i,j];
          Enter a list of the índices contravariantes: [k];
          Enter a list of the derivative indices: [];
                                                k
          (%t2)                                a
                                                i j
          (%i3) ishow(covdiff(%,s))$
                       k         %1     k         %1     k            k     %1
          (%t3)     - a     ichr2    - a     ichr2    + a      + ichr2     a
                       i %1      j s    %1 j      i s    i j,s        %1 s  i j
          (%i4) imetric:g;
          (%o4)            g
          (%i5) ishow(ev(%th(2),ichr2))$
            %1 %4  k
           g      a     (g       - g       + g  )
            i %1   s %4,j  j s,%4    j %4,s
          (%t5) - ------------------------------------------
                 2
              %1 %3  k
             g   a     (g       - g    + g     )
              %1 j   s %3,i    i s,%3    i %3,s
           - ------------------------------------------
                   2
              k %2  %1
             g     a    (g        - g    + g      )
             i j   s %2,%1    %1 s,%2    %1 %2,s   k
           + ------------------------------------------- + a
             2     i j,s
          (%i6)


 -- Função: lorentz_gauge (<expr>)
     Impõe a condição de Lorentz através da substituição de 0 para
     todos os objectos indexados em <expr> que possui um índice de
     derivada idêntico ao índice contravariante.


 -- Função: igeodesic_coords (<expr>, <nome>)
     Faz com que símbolos de Christoffel não diferenciados e a primeira
     derivada do tensor métrico tendam para zero em <expr>. O <nome> na
     função `igeodesic_coords' refere-se à métrica <nome> (se isso
     aparecer em <expr>) enquando os coeficientes de conecção devem ser
     chamados com os nomes `ichr1' e/ou `ichr2'. O seguinte exemplo
     demonstra a verificação da identidade cíclica satisfeita através
     do tensor da curvatura de Riemann usando a função
     `igeodesic_coords'.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(icurvature([r,s,t],[u]))$
                       u            u         %1         u            u         %1
          (%t2) - ichr2      - ichr2     ichr2    + ichr2      + ichr2     ichr2
                       r t,s        %1 s      r t        r s,t        %1 t      r s
          (%i3) ishow(igeodesic_coords(%,ichr2))$
                                           u            u
          (%t3)                       ichr2      - ichr2
                                           r s,t        r t,s
          (%i4) ishow(igeodesic_coords(icurvature([r,s,t],[u]),ichr2)+
                      igeodesic_coords(icurvature([s,t,r],[u]),ichr2)+
                      igeodesic_coords(icurvature([t,r,s],[u]),ichr2))$
                       u            u            u            u            u
          (%t4) - ichr2      + ichr2      + ichr2      - ichr2      - ichr2
                       t s,r        t r,s        s t,r        s r,t        r t,s

                                                                            u
                                                                     + ichr2
                                                                            r s,t
          (%i5) canform(%);
          (%o5)                                  0


27.2.5 Referenciais móveis
--------------------------

Maxima actualmente tem a habilidade de executar cálculos usando
referenciais móveis.  Essas podem ser referenciais ortonormais
(tetrads, vielbeins) ou um referencial arbitrária.

   Para usar referenciais,  primeiro escolha `iframe_flag' para `true'.
Isso faz com que os símbolos de Christoffel, `ichr1' e `ichr2', sejam
substituídos pelos referenciais mais gerais de coeficientes de
conecção `icc1' e `icc2' em cálculos. Especialmente, o comportamento de
`covdiff' e `icurvature' são alterados.

   O referencial é definido através de dois tensores: o campo de
referencial inversa (`ifri'), a base tetrad dual), e a métrica do
referencial `ifg'. A métrica do referencial é a matriz identidade para
referenciais ortonormais, ou a métrica de Lorentz para referenciais
ortonormais no espaço-tempo de Minkowski. O campo de referencial
inverso define a base do referencial (vectores unitários).
Propriedades de contração são definidas para o campo de referencial e
para a métrica do referencial.

   Quando `iframe_flag' for `true', muitas expressões `itensor' usam a
métrica do referencial `ifg' em lugar da métrica definida através de
`imetric' para o decremento e para o incremento de índices.

   IMPORTANTE: Escolhendo a variável `iframe_flag' para `true' NÃO
remove a definição das propriedades de contração de uma métrica
definida através de uma chamada a `defcon' ou `imetric'. Se um campo de
referencial for usado, ele é melhor para definir a métrica através de
atribuição desse nome para a variável `imetric' e NÃO invoque a
função `imetric'.

   Maxima usa esses dois tensores para definir os coeficientes de
referencial (`ifc1' e `ifc2') cuja forma parte dos coeficientes de
conecção (`icc1' e `icc2'), como demonstra o seguinte exemplo:


     (%i1) load(itensor);
     (%o1)      /share/tensor/itensor.lisp
     (%i2) iframe_flag:true;
     (%o2)                                true
     (%i3) ishow(covdiff(v([],[i]),j))$
                                    i        i     %1
     (%t3)                         v   + icc2     v
                                    ,j       %1 j
     (%i4) ishow(ev(%,icc2))$
                             %1      i           i        i
     (%t4)                  v   (ifc2     + ichr2    ) + v
                                     %1 j        %1 j     ,j
     (%i5) ishow(ev(%,ifc2))$
                 %1    i %2
                v   ifg     (ifb        - ifb        + ifb       )
                                j %2 %1      %2 %1 j      %1 j %2     i
     (%t5)      -------------------------------------------------- + v
                                        2                             ,j
     (%i6) ishow(ifb([a,b,c]))$
                            %5    %4
     (%t6)               ifr   ifr   (ifri        - ifri       )
                            a     b       c %4,%5       c %5,%4

   Um método alternativo é usado para calcular o suporte do referencial
(`ifb') se o sinalizador `iframe_bracket_form' é escolhido para `false':


     (%i8) block([iframe_bracket_form:false],ishow(ifb([a,b,c])))$
                            %7    %6        %6      %7
     (%t8)              (ifr   ifr     - ifr     ifr  ) ifri
                            a     b,%7      a,%7    b       c %6

 -- Função: iframes ()
     Uma vez que nessa versão do Maxima, identidades de contração para
     `ifr' e `ifri' são sempre definidas, como é o suporte do
     referencial (`ifb'), essa função não faz nada.


 -- Variável: ifb
     O suporte do referencial. A contribuição da métrica do referencial
     para os coeficientes de conecção é expressa usando o suporte do
     referencial:


                    - ifb      + ifb      + ifb
                         c a b      b c a      a b c
          ifc1    = --------------------------------
              abc                  2

     O suporte do referencial por si mesmo é definido em termos de
     campo de referencial e métrica do referencial. Dois métodos
     alternativos de cálculo são usados dependendo do valor de
     `frame_bracket_form'. Se `true' (o padrão) ou se o sinalizador
     `itorsion_flag' for `true':


                    d      e                                      f
          ifb =  ifr    ifr   (ifri      - ifri      - ifri    itr   )
             abc    b      c       a d,e       a e,d       a f    d e

     Otherwise:


                       e      d        d      e
          ifb    = (ifr    ifr    - ifr    ifr   ) ifri
             abc       b      c,e      b,e    c        a d


 -- Variável: icc1
     Coeficientes de conecção de primeiro tipo. Em `itensor', definido
     como


          icc1    = ichr1    - ikt1    - inmc1
              abc        abc       abc        abc

     Nessa expressão, se `iframe_flag' for `true', o símbolo de
     Christoffel `ichr1' é substituído com o coeficiente de conecção do
     referencial `ifc1'.  Se `itorsion_flag' for `false', `ikt1' será
     omitido. `ikt1' é também omitido se uma base de referencial for
     usada, como a torsão está já calculada como parte do suporte do
     referencial.  Ultimamente, como `inonmet_flag' é `false', `inmc1'
     não estará presente.


 -- Variável: icc2
     Coeficientes de conecção de segundo tipo. Em `itensor', definido
     como


              c         c        c         c
          icc2   = ichr2   - ikt2   - inmc2
              ab        ab       ab        ab

     Nessa expressão, se `iframe_flag' for `true', o símbolo de
     Christoffel `ichr2' é substituído com o coeficiente de conecção
     `ifc2'.  Se `itorsion_flag' for `false', `ikt2' será omitido.
     `ikt2' também será omitido se uma base de referencial for usada,
     uma vez que a torsão já está calculada como parte do suporte do
     referencial.  Ultimamente, como `inonmet_flag' é `false', `inmc2'
     não estará presente.


 -- Variável: ifc1
     Coeficiente de referencial de primeiro tipo (também conhecido como
     coeficientes de rotação de Ricci).  Esse tensor representa a
     contribuição da métrica do referencial para o coeficiente de
     conecção de primeiro tipo. Definido como:


                    - ifb      + ifb      + ifb
                         c a b      b c a      a b c
          ifc1    = --------------------------------
              abc                   2


 -- Variável: ifc2
     Coeficiente de referencial de primeiro tipo. Esse tensor
     representa a contribuição da métrica do referencial para o
     coeficiente de conecção de primeiro tipo. Definido como uma
     permutação de suporte de referencial (`ifb') com os índices
     apropriados incrementados e decrementados como necessário:


              c       cd
          ifc2   = ifg   ifc1
              ab             abd


 -- Variável: ifr
     O campo do referencial. Contrai (`ifri') para e com a forma do
     campo inverso do referencial para formar a métrica do referencial
     (`ifg').


 -- Variável: ifri
     O campo inverso do referencial. Especifica a base do referencial
     (vectores base duais). Juntamente com a métrica do referencial,
     forma a base de todos os cálculos baseados em referenciais.


 -- Variável: ifg
     A métrica do referencial. O valor padrão é `kdelta', mas pode ser
     mudada usando `components'.


 -- Variável: ifgi
     O inverso da métrica do referencial. Contrai com a métrica do
     referencial (`ifg') para `kdelta'.


 -- Variável de Opção: iframe_bracket_form
     Valor por omissão: `true'

     Especifica como o suporte do referencial (`ifb') é calculado.


27.2.6 Torsão e não metricidade
-------------------------------

Maxima pode trabalhar com torsão e não metricidade. Quando o sinalizador
`itorsion_flag' for escolhido para `true', a contribuição de torsão é
adicionada aos coeficientes de conecção. Similarmente, quando o
sinalizador `inonmet_flag' for `true', componentes de não metricidades
são incluídos.

 -- Variável: inm
     O vector de não metricidade. Conforme a não metricidade está
     definida através da derivada covariante do tensor métrico.
     Normalmente zero, o tensor da métrica derivada covariante irá
     avaliar para o seguinte quando `inonmet_flag' for escolhido para
     `true':


          g     =- g  inm
           ij;k     ij  k


 -- Variável: inmc1
     Permutação covariante de componentes do vector de não metricidade.
     Definida como


                     g   inm  - inm  g   - g   inm
                      ab    c      a  bc    ac    b
          inmc1    = ------------------------------
               abc                 2

     (Substitue `ifg' em lugar de `g' se um referencial métrico for
     usada.)


 -- Variável: inmc2
     Permutação covariante de componentes do vector de não metricidade.
     Usada nos coeficicientes de conecção se `inonmet_flag' for `true'.
     Definida como:


                                c         c         cd
                    -inm  kdelta  - kdelta  inm  + g   inm  g
               c        a       b         a    b          d  ab
          inmc2   = -------------------------------------------
               ab                        2

     (Substitue `ifg' em lugar de `g' se um referencial métrico for
     usada.)


 -- Variável: ikt1
     Permutação covariante do tensor de torsão (também conhecido como
     contorsão).  Definido como:


                            d           d       d
                    -g   itr  - g    itr   - itr   g
                      ad    cb    bd    ca      ab  cd
          ikt1    = ----------------------------------
              abc                   2

     (Substitue `ifg' em lugar de `g' se um referencial métrico for
     usada.)


 -- Variável: ikt2
     Permutação contravariante do tensor de torsão (também conhecida
     como contorsão).  Definida como:


              c     cd
          ikt2   = g   ikt1
              ab           abd

     (Substitue `ifg' em lugar de `g' se um referencial métrico for
     usada.)


 -- Variável: itr
     O tensor de torsão. Para uma métrica com torsão, diferenciação
     covariante repetida sobre uma funçào escalar não irá comutar,como
     demonstrado através do seguinte exemplo:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) imetric:g;
          (%o2)                                  g
          (%i3) covdiff(covdiff(f([],[]),i),j)-covdiff(covdiff(f([],[]),j),i)$
          (%i4) ishow(%)$
                                             %4              %2
          (%t4)                    f    ichr2    - f    ichr2
                                    ,%4      j i    ,%2      i j
          (%i5) canform(%);
          (%o5)                                  0
          (%i6) itorsion_flag:true;
          (%o6)                                true
          (%i7) covdiff(covdiff(f([],[]),i),j)-covdiff(covdiff(f([],[]),j),i)$
          (%i8) ishow(%)$
                                     %8             %6
          (%t8)             f    icc2    - f    icc2    - f     + f
                             ,%8     j i    ,%6     i j    ,j i    ,i j
          (%i9) ishow(canform(%))$
                                             %1             %1
          (%t9)                     f    icc2    - f    icc2
                                     ,%1     j i    ,%1     i j
          (%i10) ishow(canform(ev(%,icc2)))$
                                             %1             %1
          (%t10)                    f    ikt2    - f    ikt2
                                     ,%1     i j    ,%1     j i
          (%i11) ishow(canform(ev(%,ikt2)))$
                                %2 %1                    %2 %1
          (%t11)          f    g      ikt1       - f    g      ikt1
                           ,%2            i j %1    ,%2            j i %1
          (%i12) ishow(factor(canform(rename(expand(ev(%,ikt1))))))$
                                     %3 %2            %1       %1
                               f    g      g      (itr    - itr   )
                                ,%3         %2 %1     j i      i j
          (%t12)               ------------------------------------
                                                2
          (%i13) decsym(itr,2,1,[anti(all)],[]);
          (%o13)                               done
          (%i14) defcon(g,g,kdelta);
          (%o14)                               done
          (%i15) subst(g,nounify(g),%th(3))$
          (%i16) ishow(canform(contract(%)))$
                                                     %1
          (%t16)                           - f    itr
                                              ,%1    i j


27.2.7 Álgebra externa (como em produto externo)
------------------------------------------------

O pacote `itensor' pode executar operações sobre campos tensores
covariantes totalmente antisimétricos. Um campo tensor totalmente
antisimétrico de classe (0,L) corresponde a uma forma diferencial L.
Sobre esses objectos, uma operação de multiplicação funciona como um
produto externo, ou produto cunha, é definido.

   Desafortunadamente, nem todos os autores concordam sobre a
definição de produto cunha. Alguns autores preferem uma definição que
corresponde à noção de antisimetrização: nessas palavras, o produto
cunha de dois campos vectoriais, por exemplo, pode ser definido como

                 a a  - a a
                  i j    j i
      a  /\ a  = -----------
       i     j        2

   Mais geralmente, o produto de uma forma p e uma forma q pode ser
definido como

                            1     k1..kp l1..lq
     A       /\ B       = ------ D              A       B
      i1..ip     j1..jq   (p+q)!  i1..ip j1..jq  k1..kp  l1..lq

   onde `D' simboliza o delta de Kronecker.

   Outros autores, todavia, preferem uma definição "geométrica" que
corresponde à notação de elemento volume:

     a  /\ a  = a a  - a a
      i     j    i j    j i

   e, no caso geral

                            1    k1..kp l1..lq
     A       /\ B       = ----- D              A       B
      i1..ip     j1..jq   p! q!  i1..ip j1..jq  k1..kp  l1..lq

   Uma vez que `itensor' é um pacote de algebra de tensores, a primeira
dessas duas definições aparenta ser a mais natural por si mesma. Muitas
aplicações, todavia, usam a segunda definição. Para resolver esse
dilema, um sinalizador tem sido implementado que controla o
comportamento do produto cunha: se `igeowedge_flag' for `false' (o
padrão), a primeira, definição "tensorial" é usada, de outra forma a
segunda, definição "geométrica" irá ser aplicada.

 -- Operador: ~
     O operador do produto cunha é definido como sendo o acento til
     `~'. O til é um operador binário. Seus argumentos podem ser
     expressões envolvendo escalares, tensores covariantes de categoria
     1, ou tensores covariantes de categoria `l' que tiverem sido
     declarados antisimétricos em todos os índices covariantes.

     O comportamento do operador do produto cunha é controlado através
     do sinalizador `igeowedge_flag', como no seguinte exemplo:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(a([i])~b([j]))$
                                           a  b  - b  a
                                            i  j    i  j
          (%t2)                            -------------
                                                 2
          (%i3) decsym(a,2,0,[anti(all)],[]);
          (%o3)                                done
          (%i4) ishow(a([i,j])~b([k]))$
                                    a    b  + b  a    - a    b
                                     i j  k    i  j k    i k  j
          (%t4)                     ---------------------------
                                                 3
          (%i5) igeowedge_flag:true;
          (%o5)                                true
          (%i6) ishow(a([i])~b([j]))$
          (%t6)                            a  b  - b  a
                                            i  j    i  j
          (%i7) ishow(a([i,j])~b([k]))$
          (%t7)                     a    b  + b  a    - a    b
                                     i j  k    i  j k    i k  j


 -- Operador: |
     A barra vertical `|' denota a operação binária "contração com um
     vector". Quando um tensor covariante totalmente antisimétrico é
     contraído com um vector contravariante, o resultado é o mesmo
     independente de qual índice foi usado para a contração. Dessa
     forma, é possível definir a operação de contração de uma forma
     livre de índices.

     No pacote `itensor', contração com um vector é sempre realizada
     com relação ao primeiro índice na ordem literal de ordenação. Isso
     garante uma melhor simplificação de expressões envolvendo o
     operador `|'. Por exemplo:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) decsym(a,2,0,[anti(all)],[]);
          (%o2)                                done
          (%i3) ishow(a([i,j],[])|v)$
                                              %1
          (%t3)                              v   a
                                                  %1 j
          (%i4) ishow(a([j,i],[])|v)$
                                               %1
          (%t4)                             - v   a
                                                   %1 j

     Note que isso é essencial que os tensores usado como o operador
     `|' seja declarado totalmente antisimétrico em seus índices
     covariantes. De outra forma, os resultados serão incorrectos.


 -- Função: extdiff (<expr>, <i>)
     Calcula a derivada externa de <expr> com relação ao índice <i>. A
     derivada externa é formalmente definida como o produto cunha do
     operador de derivada parcial e uma forma diferencial. Como tal,
     essa operação é também controlada através da escolha de
     `igeowedge_flag'.  Por exemplo:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(extdiff(v([i]),j))$
                                            v    - v
                                             j,i    i,j
          (%t2)                             -----------
                                                 2
          (%i3) decsym(a,2,0,[anti(all)],[]);
          (%o3)                                done
          (%i4) ishow(extdiff(a([i,j]),k))$
                                     a      - a      + a
                                      j k,i    i k,j    i j,k
          (%t4)                      ------------------------
                                                3
          (%i5) igeowedge_flag:true;
          (%o5)                                true
          (%i6) ishow(extdiff(v([i]),j))$
          (%t6)                             v    - v
                                             j,i    i,j
          (%i7) ishow(extdiff(a([i,j]),k))$
          (%t7)                      a      - a      + a
                                      j k,i    i k,j    i j,k


 -- Função: hodge (<expr>)
     Calcula o Hodge dual de <expr>. Por exemplo:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) imetric(g);
          (%o2)                            done
          (%i3) idim(4);
          (%o3)                            done
          (%i4) icounter:100;
          (%o4)                             100
          (%i5) decsym(A,3,0,[anti(all)],[])$

          (%i6) ishow(A([i,j,k],[]))$
          (%t6)                           A
                                           i j k
          (%i7) ishow(canform(hodge(%)))$
                                    %1 %2 %3 %4
                         levi_civita            g        A
                                                 %1 %102  %2 %3 %4
          (%t7)          -----------------------------------------
                                             6
          (%i8) ishow(canform(hodge(%)))$
                           %1 %2 %3 %8            %4 %5 %6 %7
          (%t8) levi_civita            levi_civita            g        g
                                                               %1 %106  %2 %107
                                                      g        g      A        /6
                                                       %3 %108  %4 %8  %5 %6 %7
          (%i9) lc2kdt(%)$

          (%i10) %,kdelta$

          (%i11) ishow(canform(contract(expand(%))))$
          (%t11)                     - A
                                        %106 %107 %108


 -- Variável de Opção: igeowedge_flag
     Valor por omissão: `false'

     Controla o comportamento de produto cunha e derivada externa.
     Quando for esconhida para `false' (o padrão), a noção de formas
     diferenciais irá corresponder àquela de um campo tensor covariante
     totalmente antisimétrico.  Quando escolhida para `true', formas
     diferenciais irão concordar com a noção do elemento volume.


27.2.8 Exportando expressões TeX
--------------------------------

O pacote `itensor' fornece suporte limitado à exportação de expressões
de tensores para o TeX.  Uma vez que expressões `itensor' aparecem como
chamada a funções, o comando regular `tex' do Maxima não produzirá a
saída esperada. Pode tentar no seu lugar o comando `tentex', o qual
tenta traduzir expressões de tensores dentro de objectos TeX indexados
apropriadamente.

 -- Função: tentex (<expr>)
     Para usar a função `tentex', deve primeiro chamar `tentex', como
     no seguinte exemplo:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) load(tentex);
          (%o2)       /share/tensor/tentex.lisp
          (%i3) idummyx:m;
          (%o3)                                  m
          (%i4) ishow(icurvature([j,k,l],[i]))$
                      m1       i           m1       i           i            i
          (%t4)  ichr2    ichr2     - ichr2    ichr2     - ichr2      + ichr2
                      j k      m1 l        j l      m1 k        j l,k        j k,l
          (%i5) tentex(%)$
          $$\Gamma_{j\,k}^{m_1}\,\Gamma_{l\,m_1}^{i}-\Gamma_{j\,l}^{m_1}\,
           \Gamma_{k\,m_1}^{i}-\Gamma_{j\,l,k}^{i}+\Gamma_{j\,k,l}^{i}$$

     Note o uso da declaração `idummyx', para evitar o aparecimento do
     sinal de porcentagem na expressão TeX, o qual pode induzir a erros
     de compilação.

     Note Bem: Essa vesão da função `tentex' é um tanto quanto
     experimental.


27.2.9 Interagindo com o pacote `ctensor'
-----------------------------------------

O pacote `itensor' possui a habilidade de gerar código Maxima que pode
então ser executado no contexto do pacote `ctensor'. A função que
executa essa tarefa é `ic_convert'.

 -- Função: ic_convert (<eqn>)
     Converte a equação <eqn> na sintaxe `itensor' para uma
     declaração de atribuição `ctensor'.  Adições implícitas sobre
     índices que ocorrem exactamente duas vezes são tornadas explícitas
     enquanto objectos indexados são transformados em arrays (os arrays
     subscritos estão na ordem de covariância seguidos de índices
     contravariantes dos objectos indexados). A derivada de um objecto
     indexado será substituída pela forma substantiva de `diff' tomada
     com relação a `ct_coords' subscrita pelo índice de derivação. Os
     símbolos de Christoffel `ichr1' e `ichr2' irão ser traduzidos para
     `lcs' e `mcs', respectivamente e se `metricconvert' for `true'
     então todas as ocorrências da métrica com dois índices covariantes
     (ou contravariantes) irão ser renomeadas para `lg' (ou `ug').
     Adicionalmente, ciclos `do' irão ser introduzidos adicionando sobre
     todos os índices livres de forma que a declaração de atribuição
     transformada pode ser avaliada através de apenas fazendo `ev'. Os
     seguintes exemplos demonstam os recursos dessa função.

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) eqn:ishow(t([i,j],[k])=f([],[])*g([l,m],[])*a([],[m],j)*b([i],[l,k]))$
                                       k        m   l k
          (%t2)                       t    = f a   b    g
                                       i j      ,j  i    l m
          (%i3) ic_convert(eqn);
          (%o3) for i thru dim do (for j thru dim

          do (for k thru dim do t        : f sum(sum(diff(a , ct_coords ) b
                                 i, j, k                   m           j   i, l, k

           g    , l, 1, dim), m, 1, dim)))
            l, m
          (%i4) imetric(g);
          (%o4)                                done
          (%i5) metricconvert:true;
          (%o5)                                true
          (%i6) ic_convert(eqn);
          (%o6) for i thru dim do (for j thru dim

          do (for k thru dim do t        : f sum(sum(diff(a , ct_coords ) b
                                 i, j, k                   m           j   i, l, k

           lg    , l, 1, dim), m, 1, dim)))
             l, m


27.2.10 Palavras reservadas
---------------------------

As palavras seguintes do Maxima são usadas internamente pelo pacote
`itensor' e não podem ser redefinidas:

       Keyword    Comments
       ------------------------------------------
       indices2() versão interna de `indices()'
       conti      Lista de índices contravariantes
       covi       Lista de índices covariantes de um objecto indexado
       deri       Lista de índices de derivada de um objecto indexado
       name       Retorna o nome de um objecto indexado
       concan
       irpmon
       lc0
       _lc2kdt0
       _lcprod
       _extlc


File: maxima.info,  Node: ctensor,  Next: Pacote atensor,  Prev: itensor,  Up: Top

28 ctensor
**********

* Menu:

* Introdução a ctensor::
* Definições para ctensor::


File: maxima.info,  Node: Introdução a ctensor,  Next: Definições para ctensor,  Prev: ctensor,  Up: ctensor

28.1 Introdução a ctensor
=========================

`ctensor' é um pacote de manipulação de componentes.  Para usar o
pacote `ctensor', digite `load(ctensor)'.  Para começar uma sessão
iterativa com `ctensor', digite `csetup()'. O primeiro que será pedido
pelo pacote é a dimensão a ser manipulada. Se a dimensão for 2, 3 ou 4
então a lista de coordenadas padrão é `[x,y]', `[x,y,z]' ou `[x,y,z,t]'
respectivamente.  Esses nomes podem ser mudados através da
atribuição de uma nova lista de coordenadas para a variável `ct_coords'
(descrita abaixo) e o utilizador é questionado sobre isso. Deve ter o
cuidado de evitar conflitos de nomes de coordenadas com outras
definições de objectos.

   No próximo passo, o utilizador informa a métrica ou directamente ou
de um ficheiro especificando sua posição ordinal. Como um exemplo de um
ficheiro de métrica comum, veja `share/tensor/metrics.mac'. A métrica é
armazenada na matriz LG. Finalmente, o inverso da métrica é calculado e
armazenado na matriz UG. Se tem a opção de realizar todos os cálculos
em séries de potência.

   A seguir, mostramos um exemplo de protocolo para a métrica estática,
esfericamente simétrica (coordenadas padrão) que será aplicada ao
problema de derivação das equações de vácuo de Einstein (que levam à
solução de Schwarzschild). Muitas das funções em `ctensor' irão ser
mostradas como exemplos para a métrica padrão.

     (%i1) load(ctensor);
     (%o1)      /usr/local/lib/maxima/share/tensor/ctensor.mac
     (%i2) csetup();
     Enter the dimension of the coordinate system:
     4;
     Do you wish to change the coordinate names?
     n;
     Do you want to
     1. Enter a new metric?

     2. Enter a metric from a file?

     3. Approximate a metric with a Taylor series?
     1;

     Is the matrix  1. Diagonal  2. Symmetric  3. Antisymmetric  4. General
     Answer 1, 2, 3 or 4
     1;
     Row 1 Column 1:
     a;
     Row 2 Column 2:
     x^2;
     Row 3 Column 3:
     x^2*sin(y)^2;
     Row 4 Column 4:
     -d;

     Matrix entered.
     Enter functional dependencies with the DEPENDS function or 'N' if none
     depends([a,d],x);
     Do you wish to see the metric?
     y;
                               [ a  0       0        0  ]
                               [                        ]
                               [     2                  ]
                               [ 0  x       0        0  ]
                               [                        ]
                               [         2    2         ]
                               [ 0  0   x  sin (y)   0  ]
                               [                        ]
                               [ 0  0       0       - d ]
     (%o2)                                done
     (%i3) christof(mcs);
                                                 a
                                                  x
     (%t3)                          mcs        = ---
                                       1, 1, 1   2 a

                                                  1
     (%t4)                           mcs        = -
                                        1, 2, 2   x

                                                  1
     (%t5)                           mcs        = -
                                        1, 3, 3   x

                                                 d
                                                  x
     (%t6)                          mcs        = ---
                                       1, 4, 4   2 d

                                                   x
     (%t7)                          mcs        = - -
                                       2, 2, 1     a

                                                cos(y)
     (%t8)                         mcs        = ------
                                      2, 3, 3   sin(y)

                                                    2
                                               x sin (y)
     (%t9)                      mcs        = - ---------
                                   3, 3, 1         a

     (%t10)                   mcs        = - cos(y) sin(y)
                                 3, 3, 2

                                                 d
                                                  x
     (%t11)                         mcs        = ---
                                       4, 4, 1   2 a
     (%o11)                               done


File: maxima.info,  Node: Definições para ctensor,  Prev: Introdução a ctensor,  Up: ctensor

28.2 Definições para ctensor
============================

28.2.1 Inicialização e configuração
-----------------------------------

 -- Função: csetup ()
     É uma função no pacote `ctensor' (component tensor) que inicializa
     o pacote e permite ao utilizador inserir uma métrica
     interativamente. Veja `ctensor' para mais detalhes.

 -- Função: cmetric (<dis>)
 -- Função: cmetric ()
     É uma função no pacote `ctensor' que calcula o inverso da métrica
     e prepara o pacote para cálculos adiante.

     Se `cframe_flag' for `false', a função calcula a métrica inversa
     `ug' a partir da matriz `lg' (definida pelo utilizador). O
     determinante da métrica é também calculado e armazenado na
     variável `gdet'. Mais adiante, o pacote determina se a métrica é
     diagonal e escolhe o valor de `diagmetric' conforme a
     determinação. Se o argumento opcional <dis> estiver presente e não
     for `false', a saída é mostrada ao utilizador pela linha de comando
     para que ele possa ver o inverso da métrica.

     Se `cframe_flag' for `true', a função espera que o valor de `fri'
     (a matriz referencial inversa) e `lfg' (a métrica do referencial)
     sejam definidas. A partir dessas, a matriz do referencial `fr' e a
     métrica do referencial inverso `ufg' são calculadas.


 -- Função: ct_coordsys (<sistema_de_coordenadas>, <extra_arg>)
 -- Função: ct_coordsys (<sistema_de_coordenadas>)
     Escolhe um sistema de coordenadas predefinido e uma métrica. O
     argumento <sistema_de_coordenadas> pode ser um dos seguintes
     símbolos:


            SYMBOL               Dim Coordenadas       Descrição/comentários
            --------------------------------------------------------------------------
            cartesian2d           2  [x,y]             Sist. de coord. cartesianas 2D
            polar                 2  [r,phi]           Sist. de coord. Polare
            elliptic              2  [u,v]
            confocalelliptic      2  [u,v]
            bipolar               2  [u,v]
            parabolic             2  [u,v]
            cartesian3d           3  [x,y,z]           Sist. de coord. cartesianas 3D
            polarcylindrical      3  [r,theta,z]
            ellipticcylindrical   3  [u,v,z]           Elíptica 2D com Z cilíndrico
            confocalellipsoidal   3  [u,v,w]
            bipolarcylindrical    3  [u,v,z]           Bipolar 2D com Z cilíndrico
            paraboliccylindrical  3  [u,v,z]           Parabólico 2D com Z cilíndrico
            paraboloidal          3  [u,v,phi]
            conical               3  [u,v,w]
            toroidal              3  [u,v,phi]
            spherical             3  [r,theta,phi]     Sist. de coord. Esféricas
            oblatespheroidal      3  [u,v,phi]
            oblatespheroidalsqrt  3  [u,v,phi]
            prolatespheroidal     3  [u,v,phi]
            prolatespheroidalsqrt 3  [u,v,phi]
            ellipsoidal           3  [r,theta,phi]
            cartesian4d           4  [x,y,z,t]         Sist. de coord. 4D
            spherical4d           4  [r,theta,eta,phi]
            exteriorschwarzschild 4  [t,r,theta,phi]   Métrica de Schwarzschild
            interiorschwarzschild 4  [t,z,u,v]        Métrica de Schwarzschild Interior
            kerr_newman           4  [t,r,theta,phi]   Métrica simétrica axialmente alterada

     `sistema_de_coordenadas' pode também ser uma lista de funções de
     transformação, seguida por uma lista contendo as varáveis
     coordenadas. Por exemplo, pode especificar uma métrica esférica
     como segue:


          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) ct_coordsys([r*cos(theta)*cos(phi),r*cos(theta)*sin(phi),
                r*sin(theta),[r,theta,phi]]);
          (%o2)                                done
          (%i3) lg:trigsimp(lg);
                                     [ 1  0         0        ]
                                     [                       ]
                                     [     2                 ]
          (%o3)                      [ 0  r         0        ]
                                     [                       ]
                                     [         2    2        ]
                                     [ 0  0   r  cos (theta) ]
          (%i4) ct_coords;
          (%o4)                           [r, theta, phi]
          (%i5) dim;
          (%o5)                                  3

     Funções de transformação podem também serem usadas quando
     `cframe_flag' for `true':


          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) cframe_flag:true;
          (%o2)                                true
          (%i3) ct_coordsys([r*cos(theta)*cos(phi),r*cos(theta)*sin(phi),
                r*sin(theta),[r,theta,phi]]);
          (%o3)                                done
          (%i4) fri;
                [ cos(phi) cos(theta)  - cos(phi) r sin(theta)  - sin(phi) r cos(theta) ]
                [                                                                       ]
          (%o4) [ sin(phi) cos(theta)  - sin(phi) r sin(theta)   cos(phi) r cos(theta)  ]
                [                                                                       ]
                [     sin(theta)            r cos(theta)                   0            ]
          (%i5) cmetric();
          (%o5)                                false
          (%i6) lg:trigsimp(lg);
                                     [ 1  0         0        ]
                                     [                       ]
                                     [     2                 ]
          (%o6)                      [ 0  r         0        ]
                                     [                       ]
                                     [         2    2        ]
                                     [ 0  0   r  cos (theta) ]

     O argumento opcional <extra_arg> pode ser qualquer um dos
     seguintes:

     `cylindrical' diz a `ct_coordsys' para anexar uma coordenada
     adicional cilíndrica.

     `minkowski' diz a `ct_coordsys' para anexar uma coordenada com
     assinatura métrica negativa.

     `all' diz a `ct_coordsys' para chamar `cmetric' e
     `christof(false)' após escolher a métrica.

     Se a variável global `verbose' for escolhida para `true',
     `ct_coordsys' mostra os valores de `dim', `ct_coords', e ou `lg'
     ou `lfg' e `fri', dependendo do valor de `cframe_flag'.


 -- Função: init_ctensor ()
     Inicializa o pacote `ctensor'.

     A função `init_ctensor' reinicializa o pacote `ctensor'. Essa
     função remove todos os arrays e matrizes usados por `ctensor',
     coloca todos os sinalizadores de volta a seus valores padrão,
     retorna `dim' para 4, e retorna a métrica do referencial para a
     métrica do referencial de Lorentz.


28.2.2 Os tensores do espaço curvo
----------------------------------

O principal propósito do pacote `ctensor' é calcular os tensores do
espaç(tempo) curvo, mais notavelmente os tensores usados na
relatividade geral.

   Quando uma base métrica é usada, `ctensor' pode calcular os
seguintes tensores:


      lg  -- ug
        \      \
         lcs -- mcs -- ric -- uric
                   \      \       \
                    \      tracer - ein -- lein
                     \
                      riem -- lriem -- weyl
                          \
                           uriem

   `ctensor' pode também usar referenciais móveis. Quando `cframe_flag'
for escolhida para `true', os seguintes tensores podem ser calculados:


      lfg -- ufg
          \
      fri -- fr -- lcs -- mcs -- lriem -- ric -- uric
           \                       |  \      \       \
            lg -- ug               |   weyl   tracer - ein -- lein
                                   |\
                                   | riem
                                   |
                                   \uriem

 -- Função: christof (<dis>)
     Uma função no pacote `ctensor'.  Essa função calcula os símbolos
     de Christoffel de ambos os tipos.  O argumento <dis> determina
     quais resultados são para serem imediatamente mostrados.  Os
     símbolos de Christoffel de primeiro e de segundo tipo são
     armazenados nos arrays `lcs[i,j,k]' e `mcs[i,j,k]' respectivamente
     e definidos para serem simétricos nos primeiros dois índices. Se o
     argumento para `christof' for `lcs' ou for `mcs' então o único
     valor não nulo de `lcs[i,j,k]' ou de `mcs[i,j,k]',
     respectivamente, será mostrado. Se o argumento for `all' então o
     único valor não nulo de `lcs[i,j,k]' e o único valor não nulo de
     `mcs[i,j,k]' serão mostrados.  Se o argumento for `false' então a
     exibição dos elementos não acontecerá. Os elementos do array
     `mcs[i,j,k]' são definidos de uma tal maneira que o índice final é
     contravariante.

 -- Função: ricci (<dis>)
     Uma função no pacote `ctensor'.  `ricci' calcula as componentes
     contravariantes (simétricas) `ric[i,j]' do tensor de Ricci.  Se o
     argumento <dis> for `true', então as componentes não nulas são
     mostradas.

 -- Função: uricci (<dis>)
     Essa função primeiro calcula as componentes contravariantes
     `ric[i,j]' do tensor de Ricci.  Então o tensor misto de Ricci é
     calculado usando o tensor métrico contravariante.  Se o valor do
     argumento <dis> for `true', então essas componentes mistas,
     `uric[i,j]' (o índice "i" é covariante e o índice "j" é
     contravariante), serão mostradas directamente.  De outra forma,
     `ricci(false)' irá simplesmente calcular as entradas do array
     `uric[i,j]' sem mostrar os resultados.


 -- Função: scurvature ()
     Retorna a curvatura escalar (obtida através da contração do tensor
     de Ricci) do Riemaniano multiplicado com a métrica dada.


 -- Função: einstein (<dis>)
     Uma função no pacote `ctensor'.  `einstein' calcula o tensor misto
     de Einstein após os símbolos de Christoffel e o tensor de Ricci
     terem sido obtidos (com as funções `christof' e `ricci').  Se o
     argumento <dis> for `true', então os valores não nulos do tensor
     misto de Einstein `ein[i,j]' serão mostrados quando `j' for o
     índice contravariante.  A variável `rateinstein' fará com que a
     simplificação racional ocorra sobre esses componentes. Se `ratfac'
     for `true' então as componentes irão também ser factoradas.


 -- Função: leinstein (<dis>)
     Tensor covariante de Einstein. `leinstein' armazena o valor do
     tensor covariante de Einstein no array `lein'. O tensor covariante
     de Einstein é calculado a partir tensor misto de Einstein `ein'
     através da multiplicação desse pelo tensor métrico. Se o argumento
     <dis> for `true', então os valores não nulos do tensor covariante
     de Einstein são mostrados.


 -- Função: riemann (<dis>)
     Uma função no pacote `ctensor'.  `riemann' calcula o tensor de
     curvatura de Riemann a partir da métrica dada e correspondendo aos
     símbolos de Christoffel. As seguintes convenções de índice são
     usadas:

                          l      _l       _l       _l   _m    _l   _m
           R[i,j,k,l] =  R    = |      - |      + |    |   - |    |
                          ijk     ij,k     ik,j     mk   ij    mj   ik

     Essa notação é consistente com a notação usada por no pacote
     `itensor' e sua função `icurvature'.  Se o argumento opcional
     <dis> for `true', as componentes não nulas `riem[i,j,k,l]' serão
     mostradas.  Como com o tensor de Einstein, vários comutadores
     escolhidos pelo utilizador controlam a simplificação de
     componentes do tensor de Riemann.  Se `ratriemann' for `true',
     então simplificação racional será feita. Se `ratfac' for `true'
     então cada uma das componentes irá também ser factorada.

     Se a variável `cframe_flag' for `false', o tensor de Riemann é
     calculado directamente dos símbolos de Christoffel. Se
     `cframe_flag' for `true', o tensor covariante de Riemann é
     calculado primeiro dos coeficientes de campo do referencial.


 -- Função: lriemann (<dis>)
     Tensor covariante de Riemann (`lriem[]').

     Calcula o tensor covariante de Riemann como o array `lriem'. Se o
     argumento <dis> for `true', únicos valores não nulos são mostrados.

     Se a variável `cframe_flag' for `true', o tensor covariante de
     Riemann é calculado directamente dos coeficientes de campo do
     referencial. De outra forma, o tensor (3,1) de Riemann é calculado
     primeiro.

     Para informação sobre a ordenação de índice, veja `riemann'.


 -- Função: uriemann (<dis>)
     Calcula as componentes contravariantes do tensor de curvatura  de
     Riemann como elementos do array `uriem[i,j,k,l]'.  Esses são
     mostrados se <dis> for `true'.


 -- Função: rinvariant ()
     Compõe o invariante de Kretchmann (`kinvariant') obtido através da
     contração dos tensores

          lriem[i,j,k,l]*uriem[i,j,k,l].

     Esse objecto não é automaticamente simplificado devido ao facto de
     poder ser muito largo.


 -- Função: weyl (<dis>)
     Calcula o tensor conformal de Weyl.  Se o argumento <dis> for
     `true', as componentes não nulas `weyl[i,j,k,l]' irão ser
     mostradas para o utilizador.  De outra forma, essas componentes
     irão simplesmente serem calculadas e armazenadas.  Se o comutador
     `ratweyl' é escolhido para `true', então as componentes irão ser
     racionalmente simplificadas; se `ratfac' for `true' então os
     resultados irão ser factorados também.


28.2.3 Expansão das séries de Taylor
------------------------------------

O pacote `ctensor' possui a habilidade para truncar resultados
assumindo que eles são aproximações das séries de Taylor. Esse
comportamenteo é controlado através da variável `ctayswitch'; quando
escolhida para `true', `ctensor' faz uso internamente da função
`ctaylor' quando simplifica resultados.

   A função `ctaylor' é invocada pelas seguintes funções de `ctensor':


         Function     Comments
         ---------------------------------
         christof()   só para mcs
         ricci()
         uricci()
         einstein()
         riemann()
         weyl()
         checkdiv()

 -- Função: ctaylor ()
     A função `ctaylor' trunca seus argumentos através da conversão
     destes para uma série de Taylor usando `taylor', e então chamando
     `ratdisrep'. Isso tem efeito combinado de abandonar termos de
     ordem mais alta na variável de expansão `ctayvar'. A ordem dos
     termos que podem ser abandonados é definida através de `ctaypov';
     o ponto em torno do qual a expansão da série é realizada está
     especificado em `ctaypt'.

     Como um exemplo, considere uma métrica simples que é uma
     perturbação da métrica de Minkowski. Sem restrições adicionais,
     mesmo uma métrica diagonal produz expressões para o tensor de
     Einstein que são de longe muito complexas:


          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) ratfac:true;
          (%o2)                                true
          (%i3) derivabbrev:true;
          (%o3)                                true
          (%i4) ct_coords:[t,r,theta,phi];
          (%o4)                         [t, r, theta, phi]
          (%i5) lg:matrix([-1,0,0,0],[0,1,0,0],[0,0,r^2,0],[0,0,0,r^2*sin(theta)^2]);
                                  [ - 1  0  0         0        ]
                                  [                            ]
                                  [  0   1  0         0        ]
                                  [                            ]
          (%o5)                   [          2                 ]
                                  [  0   0  r         0        ]
                                  [                            ]
                                  [              2    2        ]
                                  [  0   0  0   r  sin (theta) ]
          (%i6) h:matrix([h11,0,0,0],[0,h22,0,0],[0,0,h33,0],[0,0,0,h44]);
                                      [ h11   0    0    0  ]
                                      [                    ]
                                      [  0   h22   0    0  ]
          (%o6)                       [                    ]
                                      [  0    0   h33   0  ]
                                      [                    ]
                                      [  0    0    0   h44 ]
          (%i7) depends(l,r);
          (%o7)                               [l(r)]
          (%i8) lg:lg+l*h;
                   [ h11 l - 1      0          0                 0            ]
                   [                                                          ]
                   [     0      h22 l + 1      0                 0            ]
                   [                                                          ]
          (%o8)    [                        2                                 ]
                   [     0          0      r  + h33 l            0            ]
                   [                                                          ]
                   [                                    2    2                ]
                   [     0          0          0       r  sin (theta) + h44 l ]
          (%i9) cmetric(false);
          (%o9)                                done
          (%i10) einstein(false);
          (%o10)                               done
          (%i11) ntermst(ein);
          [[1, 1], 62]
          [[1, 2], 0]
          [[1, 3], 0]
          [[1, 4], 0]
          [[2, 1], 0]
          [[2, 2], 24]
          [[2, 3], 0]
          [[2, 4], 0]
          [[3, 1], 0]
          [[3, 2], 0]
          [[3, 3], 46]
          [[3, 4], 0]
          [[4, 1], 0]
          [[4, 2], 0]
          [[4, 3], 0]
          [[4, 4], 46]
          (%o12)                               done

     Todavia, se nós recalcularmos esse exemplo como uma aproximação
     que é linear na variável `l', pegamos expressões muito simples:


          (%i14) ctayswitch:true;
          (%o14)                               true
          (%i15) ctayvar:l;
          (%o15)                                 l
          (%i16) ctaypov:1;
          (%o16)                                 1
          (%i17) ctaypt:0;
          (%o17)                                 0
          (%i18) christof(false);
          (%o18)                               done
          (%i19) ricci(false);
          (%o19)                               done
          (%i20) einstein(false);
          (%o20)                               done
          (%i21) ntermst(ein);
          [[1, 1], 6]
          [[1, 2], 0]
          [[1, 3], 0]
          [[1, 4], 0]
          [[2, 1], 0]
          [[2, 2], 13]
          [[2, 3], 2]
          [[2, 4], 0]
          [[3, 1], 0]
          [[3, 2], 2]
          [[3, 3], 9]
          [[3, 4], 0]
          [[4, 1], 0]
          [[4, 2], 0]
          [[4, 3], 0]
          [[4, 4], 9]
          (%o21)                               done
          (%i22) ratsimp(ein[1,1]);
                                   2      2  4               2     2
          (%o22) - (((h11 h22 - h11 ) (l )  r  - 2 h33 l    r ) sin (theta)
                                        r               r r

                                          2               2      4    2
                            - 2 h44 l    r  - h33 h44 (l ) )/(4 r  sin (theta))
                                     r r                r

     Essa compatibilidade pode ser útil, por exemplo, quando
     trabalhamos no limite do campo fraco longe de uma fonte
     gravitacional.


28.2.4 Campos de referencial
----------------------------

Quando a variável `cframe_flag' for escolhida para `true', o pacote
`ctensor' executa seus cálculos usando um referencial móvel.

 -- Função: frame_bracket (<fr>, <fri>, <diagframe>)
     O delimitador do referencial (`fb[]').

     Calcula o delimitador do referencial conforme a seguinte
     definição:

             c          c         c        d     e
          ifb   = ( ifri    - ifri    ) ifr   ifr
             ab         d,e       e,d      a     b


28.2.5 Classificação Algébrica
------------------------------

Um novo recurso (a partir de November de 2004) de `ctensor' é sua
habilidade para calcular a classificação de Petrov de uma métrica
espaço tempo tetradimensional.  Para uma demonstração dessa
compatibilidade, veja o ficheiro `share/tensor/petrov.dem'.

 -- Função: nptetrad ()
     Calcula um tetrad nulo de Newman-Penrose (`np') e seus índices
     ascendentes em contrapartida (`npi'). Veja `petrov' para um
     exemplo.

     O tetrad nulo é construído assumindo que um referencial métrico
     ortonormal tetradimensional com assinatura métrica (-,+,+,+) está
     sendo usada.  As componentes do tetrad nulo são relacionadas para
     a matriz referencial inversa como segue:


          np  = (fri  + fri ) / sqrt(2)
            1       1      2

          np  = (fri  - fri ) / sqrt(2)
            2       1      2

          np  = (fri  + %i fri ) / sqrt(2)
            3       3         4

          np  = (fri  - %i fri ) / sqrt(2)
            4       3         4


 -- Função: psi (<dis>)
     Calcula os cinco coeficientes de Newman-Penrose
     `psi[0]'...`psi[4]'.  Se `psi' for escolhida para `true', os
     coeficientes são mostrados.  Veja `petrov' para um exemplo.

     Esses coeficientes são calculados a partir do tensor de Weyl em uma
     base de coordenada.  Se uma base de referencial for usada, o
     tensor de Weyl é primeiro convertido para a base de coordenada,
     que pode ser um procedimento computacional expansível. Por essa
     razão, em alguns casos pode ser mais vantajoso usar uma base de
     coordenada em primeiro lugar antes que o tensor de Weyl seja
     calculado. Note todavia, que para a construção de um tetrad nulo de
     Newman-Penrose é necessário uma base de referencial. Portanto, uma
     sequência de cálculo expressiva pode começar com uma base de
     referencial, que é então usada para calcular `lg' (calculada
     automaticamente através de `cmetric') e em seguida calcula `ug'.
     Nesse ponto, pode comutar de volta para uma base de coordenada
     escolhendo `cframe_flag' para `false' antes de começar a calcular
     os símbolos de Christoffel. Mudando para uma base de referencial
     num estágio posterior pode retornar resultados inconsistentes, já
     que pode terminar com uma grande mistura de tensores, alguns
     calculados numa base de referencial, e outros numa base de
     coordenada, sem nenhum modo para distinguir entre os dois tipos.


 -- Função: petrov ()
     Calcula a classificação de petrov da métrica caracterizada através
     de `psi[0]'...`psi[4]'.

     Por exemplo, o seguinte demonstra como obter a classificação de
     Petrov da métrica de Kerr:

          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) (cframe_flag:true,gcd:spmod,ctrgsimp:true,ratfac:true);
          (%o2)                                true
          (%i3) ct_coordsys(exteriorschwarzschild,all);
          (%o3)                                done
          (%i4) ug:invert(lg)$
          (%i5) weyl(false);
          (%o5)                                done
          (%i6) nptetrad(true);
          (%t6) np =

                 [  sqrt(r - 2 m)           sqrt(r)                                     ]
                 [ ---------------   ---------------------      0             0         ]
                 [ sqrt(2) sqrt(r)   sqrt(2) sqrt(r - 2 m)                              ]
                 [                                                                      ]
                 [  sqrt(r - 2 m)            sqrt(r)                                    ]
                 [ ---------------  - ---------------------     0             0         ]
                 [ sqrt(2) sqrt(r)    sqrt(2) sqrt(r - 2 m)                             ]
                 [                                                                      ]
                 [                                              r      %i r sin(theta)  ]
                 [        0                    0             -------   ---------------  ]
                 [                                           sqrt(2)       sqrt(2)      ]
                 [                                                                      ]
                 [                                              r       %i r sin(theta) ]
                 [        0                    0             -------  - --------------- ]
                 [                                           sqrt(2)        sqrt(2)     ]

                                       sqrt(r)          sqrt(r - 2 m)
          (%t7) npi = matrix([- ---------------------, ---------------, 0, 0],
                                sqrt(2) sqrt(r - 2 m)  sqrt(2) sqrt(r)

                    sqrt(r)            sqrt(r - 2 m)
          [- ---------------------, - ---------------, 0, 0],
             sqrt(2) sqrt(r - 2 m)    sqrt(2) sqrt(r)

                     1               %i
          [0, 0, ---------, --------------------],
                 sqrt(2) r  sqrt(2) r sin(theta)

                     1                 %i
          [0, 0, ---------, - --------------------])
                 sqrt(2) r    sqrt(2) r sin(theta)

          (%o7)                                done
          (%i7) psi(true);
          (%t8)                              psi  = 0
                                                0

          (%t9)                              psi  = 0
                                                1

                                                    m
          (%t10)                             psi  = --
                                                2    3
                                                    r

          (%t11)                             psi  = 0
                                                3

          (%t12)                             psi  = 0
                                                4
          (%o12)                               done
          (%i12) petrov();
          (%o12)                                 D

     A função de classificação Petrov é baseada no algoritmo publicado
     em "Classifying geometries in general relativity: III
     Classification in practice" por Pollney, Skea, e d'Inverno, Class.
     Quant. Grav. 17 2885-2902 (2000).  Exceto para alguns casos de
     teste simples, a implementação não está testada até 19 de Dezembro
     de 2004, e é provável que contenha erros.


28.2.6 Torsão e não metricidade
-------------------------------

`ctensor' possui a habilidade de calcular e incluir coeficientes de
torsão e não metricidade nos coeficientes de conecção.

   Os coeficientes de torsão são calculados a partir de um tensor
fornecido pelo utilizador `tr', que pode ser um tensor de categoria
(2,1).  A partir disso, os coeficientes de torsão `kt' são calculados
de acordo com a seguinte fórmula:


                   m          m      m
            - g  tr   - g   tr   - tr   g
               im  kj    jm   ki     ij  km
     kt   = -------------------------------
       ijk                 2


       k     km
     kt   = g   kt
       ij         ijm

   Note que somente o tensor de índice misto é calculao e armazenado no
array `kt'.

   Os coeficientes de não metricidade são calculados a partir  do
vector de não metricidade fornecido pelo utilizador `nm'. A partir
disso, os coeficientes de não metricidade `nmc' são calculados como
segue:


                  k    k        km
            -nm  D  - D  nm  + g   nm  g
        k      i  j    i   j         m  ij
     nmc  = ------------------------------
        ij                2

   onde D simboliza o delta de Kronecker.

   Quando `ctorsion_flag' for escolhida para `true', os valores de `kt'
são subtraídos dos coeficientes de conecção indexados mistos calculados
através de `christof' e armazenados em `mcs'. Similarmente, se
`cnonmet_flag' for escolhida para `true', os valores de `nmc' são
subtraídos dos coeficientes de conecção indexados mistos.

   Se necessário, `christof' chama as funções `contortion' e
`nonmetricity' com o objectivo de calcular `kt' e `nm'.

 -- Função: contortion (<tr>)
     Calcula os coeficientes de contorsão de categoria (2,1) a partir
     do tensor de torsão <tr>.


 -- Função: nonmetricity (<nm>)
     Calcula o coeficiente de não metricidade de categoria (2,1) a
     partir do vector de não metricidade <nm>.


28.2.7 Recursos diversos
------------------------

 -- Função: ctransform (<M>)
     Uma função no pacote `ctensor' que irá executar uma
     transformação de coordenadas sobre uma matriz simétrica quadrada
     arbitrária <M>. O utilizador deve informar as funçãoes que definem
     a transformação.  (Formalmente chamada `transform'.)


 -- Função: findde (<A>, <n>)
     Retorna uma lista de equações diferenciais únicas (expressões)
     correspondendo aos elementos do array quadrado <n> dimensional
     <A>. Actualmente, <n> pode ser 2 ou 3. `deindex' é uma lista global
     contendo os índices de <A> correspondendo a essas únicas
     equações diferenciais. Para o tensor de Einstein (`ein'), que é um
     array dimensional, se calculado para a métrica no exemplo abaixo,
     `findde' fornece as seguintes equações diferenciais independentes:

          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) derivabbrev:true;
          (%o2)                                true
          (%i3) dim:4;
          (%o3)                                  4
          (%i4) lg:matrix([a,0,0,0],[0,x^2,0,0],[0,0,x^2*sin(y)^2,0],[0,0,0,-d]);
                                    [ a  0       0        0  ]
                                    [                        ]
                                    [     2                  ]
                                    [ 0  x       0        0  ]
          (%o4)                     [                        ]
                                    [         2    2         ]
                                    [ 0  0   x  sin (y)   0  ]
                                    [                        ]
                                    [ 0  0       0       - d ]
          (%i5) depends([a,d],x);
          (%o5)                            [a(x), d(x)]
          (%i6) ct_coords:[x,y,z,t];
          (%o6)                            [x, y, z, t]
          (%i7) cmetric();
          (%o7)                                done
          (%i8) einstein(false);
          (%o8)                                done
          (%i9) findde(ein,2);
                                                      2
          (%o9) [d  x - a d + d, 2 a d d    x - a (d )  x - a  d d  x + 2 a d d
                  x                     x x         x        x    x            x

                                                                  2          2
                                                          - 2 a  d , a  x + a  - a]
                                                               x      x
          (%i10) deindex;
          (%o10)                     [[1, 1], [2, 2], [4, 4]]


 -- Função: cograd ()
     Calcula o gradiente covariante de uma função escalar permitindo ao
     utilizador escolher o nome do vector correspondente como o exemplo
     sob `contragrad' ilustra.

 -- Função: contragrad ()
     Calcula o gradiente contravariante de uma função escalar permitindo
     ao utilizador escolher o nome do vector correspondente como o
     exemplo abaixo como ilustra a métrica de Schwarzschild:


          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) derivabbrev:true;
          (%o2)                                true
          (%i3) ct_coordsys(exteriorschwarzschild,all);
          (%o3)                                done
          (%i4) depends(f,r);
          (%o4)                               [f(r)]
          (%i5) cograd(f,g1);
          (%o5)                                done
          (%i6) listarray(g1);
          (%o6)                            [0, f , 0, 0]
                                                r
          (%i7) contragrad(f,g2);
          (%o7)                                done
          (%i8) listarray(g2);
                                         f  r - 2 f  m
                                          r        r
          (%o8)                      [0, -------------, 0, 0]
                                               r


 -- Função: dscalar ()
     Calcula o tensor d'Alembertiano da função escalar assim que as
     dependências tiverem sido declaradas sobre a função. Po exemplo:

          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) derivabbrev:true;
          (%o2)                                true
          (%i3) ct_coordsys(exteriorschwarzschild,all);
          (%o3)                                done
          (%i4) depends(p,r);
          (%o4)                               [p(r)]
          (%i5) factor(dscalar(p));
                                    2
                              p    r  - 2 m p    r + 2 p  r - 2 m p
                               r r           r r        r          r
          (%o5)               --------------------------------------
                                                 2
                                                r


 -- Função: checkdiv ()
     Calcula a divergência covariante do tensor de segunda categoria
     misto (cujo primeiro índice deve ser covariante) imprimindo as
     correspondentes n componentes do campo do vector (a divergência)
     onde n = `dim'. Se o argumento para a função for `g' então a
     divergência do tensor de Einstein será formada e pode ser zero.
     Adicionalmente, a divergência (vector) é dada no array chamado
     `div'.

 -- Função: cgeodesic (<dis>)
     Uma função no pacote `ctensor'.  `cgeodesic' calcula as equações
     geodésicas de movimento para uma dada métrica.  Elas são
     armazenadas no array `geod[i]'.  Se o argumento <dis> for `true'
     então essas equações são mostradas.


 -- Função: bdvac (<f>)
     Gera as componentes covariantes das equações de campo de vácuo da
     teoria de gravitação de Brans-Dicke. O campo escalar é especificado
     através do argumento <f>, que pode ser um nome de função (com
     apóstrofo) com dependências funcionais, e.g., `'p(x)'.

     As componentes de segunda categoria do tensor campo covariante são
     as componentes de segunda categoria representadas pelo array `bd'.


 -- Função: invariant1 ()
     Gera o tensor misto de Euler-Lagrange (equações de campo) para a
     densidade invariante de R^2. As equações de campo são componentes
     de um array chamado `inv1'.


 -- Função: invariant2 ()
     *** NOT YET IMPLEMENTED ***

     Gera o tensor misto de Euler-Lagrange (equações de campo) para a
     densidade invariante de `ric[i,j]*uriem[i,j]'. As equações de
     campo são as componentes de um array chamado `inv2'.


 -- Função: bimetric ()
     *** NOT YET IMPLEMENTED ***

     Gera as euauações de campo da teoria bimétrica de Rosen. As
     equações de campo são as componentes de um array chamado `rosen'.


28.2.8 Funções utilitárias
--------------------------

 -- Função: diagmatrixp (<M>)
     Retorna `true' se <M> for uma matriz diagonal ou um array (2D).


 -- Função: symmetricp (<M>)
     Retorna `true' se <M> for uma matriz simétrica ou um array (2D).


 -- Função: ntermst (<f>)
     Fornece ao utilizador um rápido quadro do "tamanho" do tensor
     duplamente subscrito (array) <f>.  Imprime uma lista de dois
     elementos onde o segundo elemento corresponde a N-TERMOS de
     componentes especificadas através dos primeiros elementos.  Nesse
     caminho, é possível rapidamente encontrar as expressões não nulas
     e tentar simplificação.


 -- Função: cdisplay (<ten>)
     Mostra todos os elementos do tensor <ten>, como representados por
     um array multidimensional. Tensores de categoria 0 e 1, assim como
     outros tipos de variáveis, são mostrados com `ldisplay'. Tensores
     de categoria 2 são mostrados como matrizes bidimensionais,
     enquanto tensores de alta categoria são mostrados como uma lista
     de matrizes bidimensionais. Por exemplo, o tensor de Riemann da
     métrica de Schwarzschild pode ser visto como:

          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) ratfac:true;
          (%o2)                                true
          (%i3) ct_coordsys(exteriorschwarzschild,all);
          (%o3)                                done
          (%i4) riemann(false);
          (%o4)                                done
          (%i5) cdisplay(riem);
                         [ 0               0                    0            0      ]
                         [                                                          ]
                         [                              2                           ]
                         [      3 m (r - 2 m)   m    2 m                            ]
                         [ 0  - ------------- + -- - ----       0            0      ]
                         [            4          3     4                            ]
                         [           r          r     r                             ]
                         [                                                          ]
              riem     = [                                 m (r - 2 m)              ]
                  1, 1   [ 0               0               -----------       0      ]
                         [                                      4                   ]
                         [                                     r                    ]
                         [                                                          ]
                         [                                              m (r - 2 m) ]
                         [ 0               0                    0       ----------- ]
                         [                                                   4      ]
                         [                                                  r       ]

                                          [    2 m (r - 2 m)       ]
                                          [ 0  -------------  0  0 ]
                                          [          4             ]
                                          [         r              ]
                               riem     = [                        ]
                                   1, 2   [ 0        0        0  0 ]
                                          [                        ]
                                          [ 0        0        0  0 ]
                                          [                        ]
                                          [ 0        0        0  0 ]

                                          [         m (r - 2 m)    ]
                                          [ 0  0  - -----------  0 ]
                                          [              4         ]
                                          [             r          ]
                               riem     = [                        ]
                                   1, 3   [ 0  0        0        0 ]
                                          [                        ]
                                          [ 0  0        0        0 ]
                                          [                        ]
                                          [ 0  0        0        0 ]

                                          [            m (r - 2 m) ]
                                          [ 0  0  0  - ----------- ]
                                          [                 4      ]
                                          [                r       ]
                               riem     = [                        ]
                                   1, 4   [ 0  0  0        0       ]
                                          [                        ]
                                          [ 0  0  0        0       ]
                                          [                        ]
                                          [ 0  0  0        0       ]

                                         [       0         0  0  0 ]
                                         [                         ]
                                         [       2 m               ]
                                         [ - ------------  0  0  0 ]
                              riem     = [    2                    ]
                                  2, 1   [   r  (r - 2 m)          ]
                                         [                         ]
                                         [       0         0  0  0 ]
                                         [                         ]
                                         [       0         0  0  0 ]

                             [     2 m                                         ]
                             [ ------------  0        0               0        ]
                             [  2                                              ]
                             [ r  (r - 2 m)                                    ]
                             [                                                 ]
                             [      0        0        0               0        ]
                             [                                                 ]
                  riem     = [                         m                       ]
                      2, 2   [      0        0  - ------------        0        ]
                             [                     2                           ]
                             [                    r  (r - 2 m)                 ]
                             [                                                 ]
                             [                                         m       ]
                             [      0        0        0         - ------------ ]
                             [                                     2           ]
                             [                                    r  (r - 2 m) ]

                                          [ 0  0       0        0 ]
                                          [                       ]
                                          [            m          ]
                                          [ 0  0  ------------  0 ]
                               riem     = [        2              ]
                                   2, 3   [       r  (r - 2 m)    ]
                                          [                       ]
                                          [ 0  0       0        0 ]
                                          [                       ]
                                          [ 0  0       0        0 ]

                                          [ 0  0  0       0       ]
                                          [                       ]
                                          [               m       ]
                                          [ 0  0  0  ------------ ]
                               riem     = [           2           ]
                                   2, 4   [          r  (r - 2 m) ]
                                          [                       ]
                                          [ 0  0  0       0       ]
                                          [                       ]
                                          [ 0  0  0       0       ]

                                                [ 0  0  0  0 ]
                                                [            ]
                                                [ 0  0  0  0 ]
                                                [            ]
                                     riem     = [ m          ]
                                         3, 1   [ -  0  0  0 ]
                                                [ r          ]
                                                [            ]
                                                [ 0  0  0  0 ]

                                                [ 0  0  0  0 ]
                                                [            ]
                                                [ 0  0  0  0 ]
                                                [            ]
                                     riem     = [    m       ]
                                         3, 2   [ 0  -  0  0 ]
                                                [    r       ]
                                                [            ]
                                                [ 0  0  0  0 ]

                                         [   m                      ]
                                         [ - -   0   0       0      ]
                                         [   r                      ]
                                         [                          ]
                                         [        m                 ]
                                         [  0   - -  0       0      ]
                              riem     = [        r                 ]
                                  3, 3   [                          ]
                                         [  0    0   0       0      ]
                                         [                          ]
                                         [              2 m - r     ]
                                         [  0    0   0  ------- + 1 ]
                                         [                 r        ]

                                              [ 0  0  0    0   ]
                                              [                ]
                                              [ 0  0  0    0   ]
                                              [                ]
                                   riem     = [            2 m ]
                                       3, 4   [ 0  0  0  - --- ]
                                              [             r  ]
                                              [                ]
                                              [ 0  0  0    0   ]

                                          [       0        0  0  0 ]
                                          [                        ]
                                          [       0        0  0  0 ]
                                          [                        ]
                               riem     = [       0        0  0  0 ]
                                   4, 1   [                        ]
                                          [      2                 ]
                                          [ m sin (theta)          ]
                                          [ -------------  0  0  0 ]
                                          [       r                ]

                                          [ 0        0        0  0 ]
                                          [                        ]
                                          [ 0        0        0  0 ]
                                          [                        ]
                               riem     = [ 0        0        0  0 ]
                                   4, 2   [                        ]
                                          [         2              ]
                                          [    m sin (theta)       ]
                                          [ 0  -------------  0  0 ]
                                          [          r             ]

                                        [ 0  0          0          0 ]
                                        [                            ]
                                        [ 0  0          0          0 ]
                                        [                            ]
                             riem     = [ 0  0          0          0 ]
                                 4, 3   [                            ]
                                        [                2           ]
                                        [         2 m sin (theta)    ]
                                        [ 0  0  - ---------------  0 ]
                                        [                r           ]

                           [        2                                             ]
                           [   m sin (theta)                                      ]
                           [ - -------------         0                0         0 ]
                           [         r                                            ]
                           [                                                      ]
                           [                         2                            ]
                           [                    m sin (theta)                     ]
                riem     = [        0         - -------------         0         0 ]
                    4, 4   [                          r                           ]
                           [                                                      ]
                           [                                          2           ]
                           [                                   2 m sin (theta)    ]
                           [        0                0         ---------------  0 ]
                           [                                          r           ]
                           [                                                      ]
                           [        0                0                0         0 ]

          (%o5)                                done

 -- Função: deleten (<L>, <n>)
     Retorna uma nova lista consistindo de <L> com o <n>'ésimo elemento
     apagado.

28.2.9 Variáveis usadas por `ctensor'
-------------------------------------

 -- Variável de opção: dim
     Valor por omissão: 4

     Uma opção no pacote `ctensor'.  `dim' é a dimensão de
     multiplicação com o padrão 4. O comando `dim: n' irá escolher a
     dimensão para qualquer outro valor `n'.


 -- Variável de opção: diagmetric
     Valor por omissão: `false'

     Uma opção no pacote `ctensor'.  Se `diagmetric' for `true' rotinas
     especiais calculam todos os objectos geométricos (que possuem o
     tensor métrico explicitamente) levando em consideração a
     diagonalidade da métrica. Tempo de execuçào reduzido irá, com
     certeza, resultar dessa escolha. Nota: essa opção é escolhida
     automaticamente por `csetup' se uma métrica diagonal for
     especificada.


 -- Variável de opção: ctrgsimp
     Faz com que simplificações trigonométricas sejam usadas quando
     tensores forem calculados. Actualmente, `ctrgsimp' afecta somente
     cálculos envolvendo um referencial móvel.


 -- Variável de opção: cframe_flag
     Faz com que cálculos sejam executados relativamente a um
     referencial móvel em oposição a uma métrica holonómica. O
     referencial é definido através do array do referencial inverso
     `fri' e da métrica do referencial `lfg'. Para cálculos usando um
     referencial Cartesiano, `lfg' pode ser a matriz unitária de
     dimensão apropriada; para cálculos num referencial de Lorentz,
     `lfg' pode ter a assinatura apropriada.


 -- Variável de opção: ctorsion_flag
     Faz com que o tensor de contorsão seja incluído no cálculo dos
     coeficientes de conecção. O tensor de contorsão por si mesmo é
     calculado através de `contortion' a partir do tensor `tr'
     fornecido pelo utilizador.


 -- Variável de opção: cnonmet_flag
     Faz com que os coeficientes de não metricidade sejam incluídos no
     cálculo dos coeficientes de conecção. Os coeficientes de não
     metricidade são calculados a partir do vector de não metricidade
     `nm' fornecido pelo utilizador através da função `nonmetricity'.


 -- Variável de opção: ctayswitch
     Se escolhida para `true', faz com que alguns cálculos de `ctensor'
     sejam realizados usando expansões das séries de Taylor.
     actualmente, `christof', `ricci', `uricci', `einstein', e `weyl'
     levam em conta essa escolha.


 -- Variável de opção: ctayvar
     Variável usada pela expansão de séries de Taylor se `ctayswitch' é
     escolhida para `true'.


 -- Variável de opção: ctaypov
     Maximo expoente usado em expansões de séries de Taylor quando
     `ctayswitch' for escolhida para `true'.


 -- Variável de opção: ctaypt
     Ponto em torno do qual expansões de séries de Taylor sao
     realizadas quando `ctayswitch' for escolhida para `true'.


 -- Variável de sistema: gdet
     O determinante do tensor métrico `lg'. Calculado através de
     `cmetric' quando `cframe_flag' for escolhido para `false'.


 -- Variável de opção: ratchristof
     Faz com que simplificações racionais sejam aplicadas através de
     `christof'.


 -- Variável de opção: rateinstein
     Valor por omissão: `true'

     Se `true' simplificação racional será executada sobre as
     componentes não nulas de tensores de Einstein; se `ratfac' for
     `true' então as componentes irão também ser factoradas.


 -- Variável de opção: ratriemann
     Valor por omissão: `true'

     Um dos comutadores que controlam simplificações dos tensores de
     Riemann; se `true', então simplificações racionais irão ser
     concluídas; se `ratfac' for `true' então cada uma das componentes
     irá também ser factorada.


 -- Variável de opção: ratweyl
     Valor por omissão: `true'

     Se `true', esse comutador faz com que a função de `weyl' aplique
     simplificações racionais aos valores do tensor de Weyl. Se
     `ratfac' for `true', então as componentes irão também ser
     factoradas.

 -- Variável: lfg
     O referencial métrico covariante. Por padrão, é inicializado para
     o referencial tetradimensional de Lorentz com assinatura
     (+,+,+,-). Usada quando `cframe_flag' for `true'.

 -- Variável: ufg
     A métrica do referencial inverso. Calculada de `lfg' quando
     `cmetric' for chamada enquanto `cframe_flag' for escolhida para
     `true'.

 -- Variável: riem
     O tensor de categoria (3,1) de Riemann. Calculado quando a
     função `riemann' é invocada. Para informação sobre ordenação de
     índices, veja a descrição de `riemann'.

     Se `cframe_flag' for `true', `riem' é calculado a partir do tensor
     covariante de Riemann `lriem'.


 -- Variável: lriem
     O tensor covariante de Riemann. Calculado através de `lriemann'.


 -- Variável: uriem
     O tensor contravariante de Riemann. Calculado através de
     `uriemann'.


 -- Variável: ric
     O tensor misto de Ricci. Calculado através de `ricci'.


 -- Variável: uric
     O tensor contravariante de Ricci. Calculado através de `uricci'.


 -- Variável: lg
     O tensor métrico. Esse tensor deve ser especificado (como uma
     `dim' através da matriz `dim') antes que outro cálculo possa ser
     executado.


 -- Variável: ug
     O inverso do tensor métrico. Calculado através de `cmetric'.


 -- Variável: weyl
     O tensor de Weyl. Calculado através de `weyl'.


 -- Variável: fb
     Coeficientes delimitadores do referencial, como calculado através
     de `frame_bracket'.


 -- Variável: kinvariant
     O invariante de Kretchmann. Calculado através de `rinvariant'.


 -- Variável: np
     Um tetrad nulo de Newman-Penrose. Calculado através de `nptetrad'.


 -- Variável: npi
     O índice ascendente do tetrad nulo de Newman-Penrose. Calculado
     através de `nptetrad'.  Definido como `ug.np'. O produto
     `np.transpose(npi)' é constante:

          (%i39) trigsimp(np.transpose(npi));
                                        [  0   - 1  0  0 ]
                                        [                ]
                                        [ - 1   0   0  0 ]
          (%o39)                        [                ]
                                        [  0    0   0  1 ]
                                        [                ]
                                        [  0    0   1  0 ]


 -- Variável: tr
     Tensor de categoria 3 fornecido pelo utilizador representando
     torsão. Usado por `contortion'.

 -- Variável: kt
     O tensor de contorsão, calculado a partir de `tr' através de
     `contortion'.

 -- Variável: nm
     Vetor de não metrcidade fornecido pelo utilizador. Usado por
     `nonmetricity'.

 -- Variável: nmc
     Os coeficientes de não metricidade, calculados a partir de `nm'
     por `nonmetricity'.


 -- Variável de sistema: tensorkill
     Variável indicando se o pacote tensor foi inicializado. Escolhida
     e usada por `csetup', retornada ao seu valor original através de
     `init_ctensor'.


 -- Variável de opção: ct_coords
     Valor por omissão: `[]'

     Uma opção no pacote `ctensor'.  `ct_coords' contém uma lista de
     coordenadas.  Enquanto normalmente definida quando a função
     `csetup' for chamada, se pode redefinir as coordenadas com a
     atribuição `ct_coords: [j1, j2, ..., jn]' onde os j's são os novos
     nomes de coordenadas.  Veja também `csetup'.


28.2.10 Nomes reservados
------------------------

Os seguintes nomes são usados internamente pelo pacote `ctensor' e não
devem ser redefinidos:

       Name         Description
       ---------------------------------------
       _lg()        Avalia para `lfg' se for usado o referencial métrico,
                         para `lg' de outra forma
       _ug()        Avalia para `ufg' se for usado o referencial métrico,
                         para `ug' de outra forma
       cleanup()    Remove ítens da lista `deindex'
       contract4()  Usado por psi()
       filemet()    Usado por csetup() quando lendo a métrica de um ficheiro
       findde1()    Usado por findde()
       findde2()    Usado por findde()
       findde3()    Usado por findde()
       kdelt()      Delta de Kronecker (não generalizado)
       newmet()     Usado por csetup() para escolher uma métrica
                         interativamente
       setflags()   Usado por init_ctensor()
       readvalue()
       resimp()
       sermet()     Usado por csetup() para informar uma métricacom série
                         de Taylor
       txyzsum()
       tmetric()    Referencial métrico, usado por cmetric() quando
                         cframe_flag:true
       triemann()   Tensor de Riemann na base do referencial, usado quando
                         cframe_flag:true
       tricci()     Tensor de Ricci na base do referencial, usado quando
                         cframe_flag:true
       trrc()       Coeficientes de rotação de Ricci, usado por
                         christof()
       yesp()

28.2.11 Modificações
--------------------

Em Novembro de 2004, o pacote `ctensor' foi extensivamente reescrito.
Muitas funções e variáveis foram renomeadas com o objectivo de tornar o
pacote com a versão comercial do Macsyma.

       Novo Nome    Nome Antigo     Descrição
       --------------------------------------------------------------------
       ctaylor()    DLGTAYLOR()     Expansão da série de Taylor de uma
       -----------------------------expressão
       lgeod[]      EM              Equações geodésicas
       ein[]        G[]             Tensor misto de Einstein
       ric[]        LR[]            Tensor misto de Ricci
       ricci()      LRICCICOM()     Calcula o tensor misto de Ricci
       ctaypov      MINP            Maximo expoente em expansões de séries de
       -----------------------------Taylor
       cgeodesic()  MOTION          Calcula as equações geodésicas
       ct_coords    OMEGA           Coordenadas métricas
       ctayvar      PARAM           Variável de expansão de séries de
       -----------------------------Taylor
       lriem[]      R[]             Tensor covariante de Riemann
       uriemann()   RAISERIEMANN()  Calcula o tensor contravariante de
       -----------------------------Riemann
       ratriemann   RATRIEMAN       Simplificação racional do tensor de
       -----------------------------Riemann
       uric[]       RICCI[]         Tensor de Ricci contravariante
       uricci()     RICCICOM()      Calcula o tensor de Ricci contravariante
       cmetric()    SETMETRIC()     Escolhe a métrica
       ctaypt       TAYPT           Ponto para expansões de séries de Taylor
       ctayswitch   TAYSWITCH       Escolhe o comutador de séries de Taylor
       csetup()     TSETUP()        Inicia sessão interativa de configuração
       ctransform() TTRANSFORM()    Transformação de coordenadas interativa
       uriem[]      UR[]            Tensor contravariante de Riemann
       weyl[]       W[]             Tensor (3,1) de Weyl


File: maxima.info,  Node: Pacote atensor,  Next: Séries,  Prev: ctensor,  Up: Top

29 Pacote atensor
*****************

* Menu:

* Introdução ao Pacote atensor::
* Definições para o Pacote atensor::


File: maxima.info,  Node: Introdução ao Pacote atensor,  Next: Definições para o Pacote atensor,  Prev: Pacote atensor,  Up: Pacote atensor

29.1 Introdução ao Pacote atensor
=================================

`atensor' é um pacote de manipulção de tensores algébricos.  Para usar
`atensor', digite `load(atensor)', seguido por uma chamada à função
`init_atensor'.

   A essência de `atensor' é um conjunto de regras de simplificação
para o operador de produto (ponto) não comutativo ("`.'").  `atensor'
reconhece muitos tipos de álgebra; as regras de simplificação
correspondentes são activadas quando a função `init_atensor' é chamada.

   A compatibilidade de `atensor' pode ser demonstrada pela
definição da álgebra de quaterniões como uma álgebra de Clifford
Cl(0,2) com dois vectores fundamentais.  As três unidades
quaterniónicas imaginárias fundamentais são então os dois vectores base
e seu produto, i.e.:

         i = v     j = v     k = v  .  v
              1         2         1    2

   Embora o pacote `atensor' tenha uma definição interna para a álgebra
dos quaterniões, isso não foi usado nesse exemplo, no qual nós nos
esforçamos para construir a tabela de multiplicação dos quaterniões
como uma matriz:


     (%i1) load(atensor);
     (%o1)       /share/tensor/atensor.mac
     (%i2) init_atensor(clifford,0,0,2);
     (%o2)                                done
     (%i3) atensimp(v[1].v[1]);
     (%o3)                                 - 1
     (%i4) atensimp((v[1].v[2]).(v[1].v[2]));
     (%o4)                                 - 1
     (%i5) q:zeromatrix(4,4);
                                     [ 0  0  0  0 ]
                                     [            ]
                                     [ 0  0  0  0 ]
     (%o5)                           [            ]
                                     [ 0  0  0  0 ]
                                     [            ]
                                     [ 0  0  0  0 ]
     (%i6) q[1,1]:1;
     (%o6)                                  1
     (%i7) for i thru adim do q[1,i+1]:q[i+1,1]:v[i];
     (%o7)                                done
     (%i8) q[1,4]:q[4,1]:v[1].v[2];
     (%o8)                               v  .  v
                                          1    2
     (%i9) for i from 2 thru 4 do for j from 2 thru 4 do
           q[i,j]:atensimp(q[i,1].q[1,j]);
     (%o9)                                done
     (%i10) q;
                        [    1        v         v      v  .  v  ]
                        [              1         2      1    2 ]
                        [                                      ]
                        [   v         - 1     v  .  v    - v    ]
                        [    1                 1    2      2   ]
     (%o10)             [                                      ]
                        [   v      - v  .  v     - 1      v     ]
                        [    2        1    2              1    ]
                        [                                      ]
                        [ v  .  v      v        - v       - 1   ]
                        [  1    2      2          1            ]

   `atensor' reconhece como bases vectoriais símbolos indexados, onde o
símbolo é aquele armazenado em `asymbol' e o iíndice está entre 1 e
`adim'.  Para símbolos indexado, e somente para símbolos indexados, as
formas bilineares `sf', `af', e `av' são avaliadas.  A avaliação
substitui os valores  de `aform[i,j]' em lugar de `fun(v[i],v[j])' onde
`v' representa o valor de `asymbol' e `fun' é ainda `af' ou `sf'; ou,
isso substitui `v[aform[i,j]]' em lugar de `av(v[i],v[j])'.

   Desnecessário dizer, as funções `sf', `af' e `av' podem ser
redefinidas.

   Quando o pacote `atensor' é chamado, os seguintes sinalizadores são
configurados:

     dotscrules:true;
     dotdistrib:true;
     dotexptsimp:false;

   Se quiser experimentar com uma álgebra não associativa, pode também
considerar a configuração de `dotassoc' para `false'.  Nesse caso,
todavia, `atensimp' não stará sempre habilitado a obter as
simplificações desejadas.


File: maxima.info,  Node: Definições para o Pacote atensor,  Prev: Introdução ao Pacote atensor,  Up: Pacote atensor

29.2 Definições para o Pacote atensor
=====================================

 -- Função: init_atensor (<alg_type>, <opt_dims>)
 -- Função: init_atensor (<alg_type>)
     Inicializa o pacote `atensor' com o tipo especificado de álgebra.
     <alg_type> pode ser um dos seguintes:

     `universal': A álgebra universal tendo regras não comutativas.

     `grassmann': A álgebra de Grassman é definida pela relação de
     comutação `u.v+v.u=0'.

     `clifford': A álgebra de Clifford é definida pela relação de
     comutação `u.v+v.u=-2*sf(u,v)' onde `sf' é a função valor-escalar
     simétrico.  Para essa álgebra, <opt_dims> pode ser acima de três
     inteiros não negativos, representando o número de dimensões
     positivas, dimensões degeneradas, e dimensões negativas da
     álgebra, respectivamente.  Se quaisquer valores <opt_dims> são
     fornecidos, `atensor' irá configurar os valores de `adim' e
     `aform' apropriadamente.  Caso contrário, `adim' irá por padrão
     para 0 e `aform' não será definida.

     `symmetric': A álgebra simétrica é definida pela relação de
     comutação `u.v-v.u=0'.

     `symplectic': A álgebra simplética é definida pela relação de
     comutação `u.v-v.u=2*af(u,v)' onde `af' é uma função valor-escalar
     antisimétrica.  Para a álgebra simplética, <opt_dims> pode mais de
     dois inteiros não negativos, representando a dimensão não
     degenerada e e a dimensão degenerada, respectivamente.  Se
     quaisquer valores <opt_dims> são fornecidos, `atensor' irá
     configurar os valores de `adim' e `aform' apropriadamente.  Caso
     contrário, `adim' irá por padrão para 0 e `aform' não será
     definida.

     `lie_envelop': O invólucro da álgebra de Lie é definido pela
     relação de comutação `u.v-v.u=2*av(u,v)' onde `av' é uma função
     antisimétrica.

     A função `init_atensor' também reconhece muitos tipos
     pré-definidos de álgebra:

     `complex' implementa a álgebra de números complexos como a álgebra
     de Clifford Cl(0,1).  A chamada `init_atensor(complex)' é
     equivalente a `init_atensor(clifford,0,0,1)'.

     `quaternion' implementa a álgebra de quaterniões.  A chamada
     `init_atensor(quaternion)' é equivalente a
     `init_atensor(clifford,0,0,2)'.

     `pauli' implementa a álgebra de spinores de Pauli como a álgebra
     de Clifford Cl(3,0).  Uma chamada a `init_atensor(pauli)' é
     equivalente a `init_atensor(clifford,3)'.

     `dirac' implementa a álgebra de spinores de Dirac como a álgebra
     de Clifford Cl(3,1).  Uma chamada a `init_atensor(dirac)' é
     equivalente a `init_atensor(clifford,3,0,1)'.


 -- Função: atensimp (<expr>)
     Simplifica a expressão algébrica de tensores <expr> conforme as
     regras configuradas por uma chamada a `init_atensor'.
     Simplificações incluem aplicação recursiva de relações comutativas
     e resoluções de chamadas a `sf', `af', e `av' onde for aplicável.
     Uma salvaguarda é usada para garantir que a função sempre termine,
     mesmo para expressões complexas.


 -- Função: alg_type
     O tipo de álgebra.  Valores válidos sáo `universal', `grassmann',
     `clifford', `symmetric', `symplectic' e `lie_envelop'.


 -- Variável: adim
     A dimensionalidade da álgebra.  `atensor' usa o valor de `adim'
     para determinar se um objecto indexado é uma base vectorial
     válida. Veja `abasep'.


 -- Variável: aform
     Valor por omissão para as formas bilineares `sf', `af', e `av'.  O
     padrão é a matriz identidade `ident(3)'.


 -- Variável: asymbol
     O símbolo para bases vectoriais.


 -- Função: sf (<u>, <v>)
     É uma função escalar simétrica que é usada em relações
     comutativas.  A implementação padrão verifica se ambos os
     argumentos são bases vectoriais usando `abasep' e se esse for o
     caso, substitui o valor correspondente da matriz `aform'.


 -- Função: af (<u>, <v>)
     É uma função escalar antisimétrica que é usada em relações
     comutativas.  A implementação padrão verifica se ambos os
     argumentos são bases vectoriais usando `abasep' e se esse for o
     caso, substitui o valor correspondente da matriz `aform'.


 -- Função: av (<u>, <v>)
     É uma função antisimétrica que é usada em relações comutativas.  A
     implementação padrão verifica se ambos os argumentos são bases
     vectoriais usando `abasep' e se esse for o caso, substitui o valor
     correspondente da matriz `aform'.

     Por exemplo:

          (%i1) load(atensor);
          (%o1)       /share/tensor/atensor.mac
          (%i2) adim:3;
          (%o2)                                  3
          (%i3) aform:matrix([0,3,-2],[-3,0,1],[2,-1,0]);
                                         [  0    3   - 2 ]
                                         [               ]
          (%o3)                          [ - 3   0    1  ]
                                         [               ]
                                         [  2   - 1   0  ]
          (%i4) asymbol:x;
          (%o4)                                  x
          (%i5) av(x[1],x[2]);
          (%o5)                                 x
                                                 3


 -- Função: abasep (<v>)
     Verifica se esse argumento é uma base vectorial `atensor' .

     E será, se ele for um símbolo indexado, com o símbolo sendo o
     mesmo que o valor de `asymbol', e o índice tiver o mesmo valor
     numérico entre 1 e `adim'.



File: maxima.info,  Node: Séries,  Next: Teoria dos Números,  Prev: Pacote atensor,  Up: Top

30 Séries
*********

* Menu:

* Introdução a Séries::
* Definições para Séries::


File: maxima.info,  Node: Introdução a Séries,  Next: Definições para Séries,  Prev: Séries,  Up: Séries

30.1 Introdução a Séries
========================

Maxima contém funções `taylor' e `powerseries' (séries de potência)
para encontrar as séries de funções diferenciáveis.   Maxima também tem
ferramentas  tais como `nusum' capazes de encontrar a forma fechada de
algumas séries.   Operações tais como adição e multiplicação travalham
da forma usual sobre séries.  Essa secção apresenta as variáveis
globais que controlam a expansão.


File: maxima.info,  Node: Definições para Séries,  Prev: Introdução a Séries,  Up: Séries

30.2 Definições para Séries
===========================

 -- Variável de opção: cauchysum
     Valor por omissão: `false'

     Quando multiplicando adições jutas com `inf' como seus limites
     superiores, se `sumexpand' for `true' e `cauchysum' for `true'
     então o produto de Cauchy será usado em lugar do produto usual.
     No produto de Cauchy o índice do somatório interno é uma função do
     índice do externo em lugar de variar independentemente.

     Exemplo:

          (%i1) sumexpand: false$
          (%i2) cauchysum: false$
          (%i3) s: sum (f(i), i, 0, inf) * sum (g(j), j, 0, inf);
                                inf         inf
                                ====        ====
                                \           \
          (%o3)                ( >    f(i))  >    g(j)
                                /           /
                                ====        ====
                                i = 0       j = 0
          (%i4) sumexpand: true$
          (%i5) cauchysum: true$
          (%i6) ''s;
                           inf     i1
                           ====   ====
                           \      \
          (%o6)             >      >     g(i1 - i2) f(i2)
                           /      /
                           ====   ====
                           i1 = 0 i2 = 0


 -- Função: deftaylor (<f_1>(<x_1>), <expr_1>, ..., <f_n>(<x_n>),
          <expr_n>)
     Para cada função <f_i> de uma variável <x_i>, `deftaylor' define
     <expr_i> como a séries de Taylor sobre zero.  <expr_i> é
     tipicamente um polinómio em <x_i> ou um somatório; expressões mais
     gerais são aceitas por `deftaylor' sem reclamações.

     `powerseries (<f_i>(<x_i>), <x_i>, 0)' retorna as séries definidas
     por `deftaylor'.

     `deftaylor' retorna uma lista das funções <f_1>, ..., <f_n>.
     `deftaylor' avalia seus argumentos.

     Exemplo:

          (%i1) deftaylor (f(x), x^2 + sum(x^i/(2^i*i!^2), i, 4, inf));
          (%o1)                          [f]
          (%i2) powerseries (f(x), x, 0);
                                inf
                                ====      i1
                                \        x         2
          (%o2)                  >     -------- + x
                                /       i1    2
                                ====   2   i1!
                                i1 = 4
          (%i3) taylor (exp (sqrt (f(x))), x, 0, 4);
                                2         3          4
                               x    3073 x    12817 x
          (%o3)/T/     1 + x + -- + ------- + -------- + . . .
                               2     18432     307200


 -- Variável de opção: maxtayorder
     Valor por omissão: `true'

     Quando `maxtayorder' for `true', durante a manipulação algébrica
     de séries (truncadas) de Taylor, `taylor' tenta reter tantos
     termos quantos forem conhecidos serem correctos.


 -- Função: niceindices (<expr>)
     Renomeia os índices de adições e produtos em <expr>.
     `niceindices' tenta renomear cada índice para o valor de
     `niceindicespref[1]', a menos que o nome apareça nas parcelas do
     somatório ou produtório, nesses casos `niceindices' tenta os
     elementos seguintes de `niceindicespref' por sua vez, até que uma
     varável não usada unused variable seja encontrada.  Se a lista
     inteira for exaurida, índices adicionais são constrídos através da
     anexaao de inteiros ao valor de `niceindicespref[1]', e.g., `i0',
     `i1', `i2', ....

     `niceindices' retorna uma expressão.  `niceindices' avalia seu
     argumento.

     Exemplo:

          (%i1) niceindicespref;
          (%o1)                  [i, j, k, l, m, n]
          (%i2) product (sum (f (foo + i*j*bar), foo, 1, inf), bar, 1, inf);
                           inf    inf
                          /===\   ====
                           ! !    \
          (%o2)            ! !     >      f(bar i j + foo)
                           ! !    /
                          bar = 1 ====
                                  foo = 1
          (%i3) niceindices (%);
                               inf  inf
                              /===\ ====
                               ! !  \
          (%o3)                ! !   >    f(i j l + k)
                               ! !  /
                              l = 1 ====
                                    k = 1


 -- Variável de opção: niceindicespref
     Valor por omissão: `[i, j, k, l, m, n]'

     `niceindicespref' é a lista da qual `niceindices' obtém os nomes
     dos índices de adições e produtos products.

     Os elementos de `niceindicespref' são tipicamente nomes de
     variáveis, embora que não seja imposto por `niceindices'.

     Exemplo:

          (%i1) niceindicespref: [p, q, r, s, t, u]$
          (%i2) product (sum (f (foo + i*j*bar), foo, 1, inf), bar, 1, inf);
                           inf    inf
                          /===\   ====
                           ! !    \
          (%o2)            ! !     >      f(bar i j + foo)
                           ! !    /
                          bar = 1 ====
                                  foo = 1
          (%i3) niceindices (%);
                               inf  inf
                              /===\ ====
                               ! !  \
          (%o3)                ! !   >    f(i j q + p)
                               ! !  /
                              q = 1 ====
                                    p = 1


 -- Função: nusum (<expr>, <x>, <i_0>, <i_1>)
     Realiza o somatório hipergeométrico indefinido de <expr> com
     relação a <x> usando um procedimento de decisão devido a R.W.
     Gosper.  <expr> e o resultado deve ser expressável como produtos
     de expoentes inteiros, factoriais, binomios, e funções recionais.

     Os termos "definido" and "e somatório indefinido" são usados
     analogamente a "definida" and "integração indefinida".  Adicionar
     indefinidamente significa dar um resultado simólico para a
     adição sobre intervalos de comprimentos de variáveis, não apenas
     e.g. 0 a infinito.  Dessa forma, uma vez que não existe fórmula
     para a adição parcial geral de séries binomiais, `nusum' não pode
     fazer isso.

     `nusum' e `unsum' conhecem um porco sobre adições e subtrações de
     produtos finitos.  Veja também `unsum'.

     Exemplos:

          (%i1) nusum (n*n!, n, 0, n);

          Dependent equations eliminated:  (1)
          (%o1)                     (n + 1)! - 1
          (%i2) nusum (n^4*4^n/binomial(2*n,n), n, 0, n);
                               4        3       2              n
                2 (n + 1) (63 n  + 112 n  + 18 n  - 22 n + 3) 4      2
          (%o2) ------------------------------------------------ - ------
                              693 binomial(2 n, n)                 3 11 7
          (%i3) unsum (%, n);
                                        4  n
                                       n  4
          (%o3)                   ----------------
                                  binomial(2 n, n)
          (%i4) unsum (prod (i^2, i, 1, n), n);
                              n - 1
                              /===\
                               ! !   2
          (%o4)              ( ! !  i ) (n - 1) (n + 1)
                               ! !
                              i = 1
          (%i5) nusum (%, n, 1, n);

          Dependent equations eliminated:  (2 3)
                                      n
                                    /===\
                                     ! !   2
          (%o5)                      ! !  i  - 1
                                     ! !
                                    i = 1


 -- Função: pade (<taylor_series>, <numer_deg_bound>, <denom_deg_bound>)
     Retorna uma lista de todas as funções racionais que possuem a dada
     expansão da séries de Taylor onde a adição dos graus do numerador
     e do denominador é menor que ou igual ao nível de truncação das
     séries de potência, i.e.  são "melhores" aproximações, e que
     adicionalmente satisfazem o grau especificado associado.

     <taylor_series> é uma séries de Taylor de uma variável.
     <numer_deg_bound> e <denom_deg_bound> são inteiros positivos
     especificando o grau associado sobre o numerador e o denominador.

     <taylor_series> podem também ser séries de Laurent, e o grau
     associado pode ser `inf' que acarreta todas funções racionais cujo
     grau total for menor que ou igual ao comprimento das séries de
     potências a serem retornadas.  O grau total é definido como
     `<numer_deg_bound> + <denom_deg_bound>'.  O comprimento de séries
     de potência é definido como `"nível de trncação" + 1 - min(0,
     "ordem das séries")'.

          (%i1) taylor (1 + x + x^2 + x^3, x, 0, 3);
                                        2    3
          (%o1)/T/             1 + x + x  + x  + . . .
          (%i2) pade (%, 1, 1);
                                           1
          (%o2)                       [- -----]
                                         x - 1
          (%i3) t: taylor(-(83787*x^10 - 45552*x^9 - 187296*x^8
                             + 387072*x^7 + 86016*x^6 - 1507328*x^5
                             + 1966080*x^4 + 4194304*x^3 - 25165824*x^2
                             + 67108864*x - 134217728)
                 /134217728, x, 0, 10);
                              2    3       4       5       6        7
                       x   3 x    x    15 x    23 x    21 x    189 x
          (%o3)/T/ 1 - - + ---- - -- - ----- + ----- - ----- - ------
                       2    16    32   1024    2048    32768   65536

                                            8         9          10
                                      5853 x    2847 x    83787 x
                                    + ------- + ------- - --------- + . . .
                                      4194304   8388608   134217728
          (%i4) pade (t, 4, 4);
          (%o4)                          []

     Não existe função racional de grau 4 numerador/denominador, com
     essa expansão de série de potência.  Você obrigatoriamente em
     geral tem grau do numerador e grau do denominador adicionando para
     cima ao menor grau das séries de potência, com o objectivo de ter
     disponível coeficientes desconhecidos para resolver.

          (%i5) pade (t, 5, 5);
                               5                4                 3
          (%o5) [- (520256329 x  - 96719020632 x  - 489651410240 x

                            2
           - 1619100813312 x  - 2176885157888 x - 2386516803584)

                         5                 4                  3
          /(47041365435 x  + 381702613848 x  + 1360678489152 x

                            2
           + 2856700692480 x  + 3370143559680 x + 2386516803584)]


 -- Variável de opção: powerdisp
     Valor por omissão: `false'

     Quando `powerdisp' for `true', uma adição é mostrada com seus
     termos em ordem do crescimento do expoente.  Dessa forma um
     polinómio é mostrado como séries de potências truncadas, com o
     termo constante primeiro e o maior expoente por último.

     Por padão, termos de uma adição são mostrados em ordem do expoente
     decrescente.


 -- Função: powerseries (<expr>, <x>, <a>)
     Retorna a forma geral expansão de séries de potência para <expr>
     na variável <x> sobre o ponto <a> (o qual pode ser `inf' para
     infinito).

     Se `powerseries' incapaz de expandir <expr>, `taylor' pode dar os
     primeiros muitos termos de séries.

     Quando `verbose' for `true', `powerseries' mostra mensagens de
     progresso.

          (%i1) verbose: true$
          (%i2) powerseries (log(sin(x)/x), x, 0);
          can't expand
                                           log(sin(x))
          so we'll try again after applying the rule:
                                                  d
                                                / -- (sin(x))
                                                [ dx
                                  log(sin(x)) = i ----------- dx
                                                ]   sin(x)
                                                /
          in the first simplification we have returned:
                                       /
                                       [
                                       i cot(x) dx - log(x)
                                       ]
                                       /
                              inf
                              ====        i1  2 i1             2 i1
                              \      (- 1)   2     bern(2 i1) x
                               >     ------------------------------
                              /                i1 (2 i1)!
                              ====
                              i1 = 1
          (%o2)                -------------------------------------
                                                2


 -- Variável de opção: psexpand
     Valor por omissão: `false'

     Quando `psexpand' for `true', uma expressão função racional
     extendida é mostrada completamente expandida.  O comutador
     `ratexpand' tem o mesmo efeito.

     Quando `psexpand' for `false', uma expressão de várias variáveis é
     mostrada apenas como no pacote de função racional.

     Quando `psexpand' for  `multi', então termos com o mesmo grau
     total nas variáveis são agrupados juntos.


 -- Função: revert (<expr>, <x>)
 -- Função: revert2 (<expr>, <x>, <n>)
     Essas funções retornam a reversão de <expr>, uma série de Taylor
     sobre zero na variável <x>.  `revert' retorna um polinómio de grau
     igual ao maior expoente em <expr>.  `revert2' retorna um polinómio
     de grau <n>, o qual pode ser maior que, igual a, ou menor que o
     grau de <expr>.

     `load ("revert")' chama essas funções.

     Exemplos:

          (%i1) load ("revert")$
          (%i2) t: taylor (exp(x) - 1, x, 0, 6);
                             2    3    4    5     6
                            x    x    x    x     x
          (%o2)/T/      x + -- + -- + -- + --- + --- + . . .
                            2    6    24   120   720
          (%i3) revert (t, x);
                         6       5       4       3       2
                     10 x  - 12 x  + 15 x  - 20 x  + 30 x  - 60 x
          (%o3)/R/ - --------------------------------------------
                                          60
          (%i4) ratexpand (%);
                               6    5    4    3    2
                              x    x    x    x    x
          (%o4)             - -- + -- - -- + -- - -- + x
                              6    5    4    3    2
          (%i5) taylor (log(x+1), x, 0, 6);
                              2    3    4    5    6
                             x    x    x    x    x
          (%o5)/T/       x - -- + -- - -- + -- - -- + . . .
                             2    3    4    5    6
          (%i6) ratsimp (revert (t, x) - taylor (log(x+1), x, 0, 6));
          (%o6)                           0
          (%i7) revert2 (t, x, 4);
                                    4    3    2
                                   x    x    x
          (%o7)                  - -- + -- - -- + x
                                   4    3    2


 -- Função: taylor (<expr>, <x>, <a>, <n>)
 -- Função: taylor (<expr>, [<x_1>, <x_2>, ...], <a>, <n>)
 -- Função: taylor (<expr>, [<x>, <a>, <n>, 'asymp])
 -- Função: taylor (<expr>, [<x_1>, <x_2>, ...], [<a_1>, <a_2>, ...],
          [<n_1>, <n_2>, ...])
 -- Função: taylor (<expr>, [<x_1>, <a_1>, <n_1>], [<x_2>, <a_2>,
          <n_2>], ...)
     `taylor (<expr>, <x>, <a>, <n>)' expande a expressão <expr> em uma
     série truncada de Taylor ou de Laurent na variável <x> em torno do
     ponto <a>, contendo termos até `(<x> - <a>)^<n>'.

     Se <expr> é da forma `<f>(<x>)/<g>(<x>)' e `<g>(<x>)' não possui
     de grau acima do grau <n> então `taylor' tenta expandir `<g>(<x>)'
     acima do gau `2 <n>'.  Se existe ainda termos não zero, `taylor'
     dobra o grau de expansão de `<g>(<x>)' contanto que o grau da
     expansão o grau da expansão seja menor que ou igual a `<n>
     2^taylordepth'.

     `taylor (<expr>, [<x_1>, <x_2>, ...], <a>, <n>)' retorna uma série
     de potência truncada de grau <n> em todas as variáveis <x_1>,
     <x_2>, ...  sobre o ponto `(<a>, <a>, ...)'.

     `taylor (<expr>, [<x_1>, <a_1>, <n_1>], [<x_2>, <a_2>, <n_2>],
     ...)'  retorna uma série de potência truncada nas variáveis <x_1>,
     <x_2>, ...  sobre o ponto `(<a_1>, <a_2>, ...)', truncada em
     <n_1>, <n_2>, ....

     `taylor (<expr>, [<x_1>, <x_2>, ...], [<a_1>, <a_2>, ...], [<n_1>,
     <n_2>, ...])' retorna uma série de potência truncada nas variáveis
     <x_1>, <x_2>, ...  sobre o ponto `(<a_1>, <a_2>, ...)', truncada
     em <n_1>, <n_2>, ....

     `taylor (<expr>, [<x>, <a>, <n>, 'asymp])' retorna uma expansão de
     <expr> em expoentes negativos de `<x> - <a>'.  O termo de maior
     ordem é `(<x> - <a>)^<-n>'.

     Quando `maxtayorder' for `true', então durante maniplulação
     algébrica da séries de Taylor (truncada), `taylor' tenta reter
     tantos termos quantos forem conhecidos serem correctos.

     Quando `psexpand' for `true', uma expressão de função racional
     extendida é mostrada completamente expandida.  O comutador
     `ratexpand' tem o mesmo efeito.  Quando `psexpand' for `false',
     uma expressão de várias variáveis é mostrada apenas como no pacote
     de função racional.  Quando `psexpand' for  `multi', então os
     termos com o mesmo grau total nas variáveis são agrupados juntos.

     Veja também o comutador `taylor_logexpand' para controlar a
     expansão.

     Exemplos:

          (%i1) taylor (sqrt (sin(x) + a*x + 1), x, 0, 3);
                                     2             2
                       (a + 1) x   (a  + 2 a + 1) x
          (%o1)/T/ 1 + --------- - -----------------
                           2               8

                                             3      2             3
                                         (3 a  + 9 a  + 9 a - 1) x
                                       + -------------------------- + . . .
                                                     48
          (%i2) %^2;
                                              3
                                             x
          (%o2)/T/           1 + (a + 1) x - -- + . . .
                                             6
          (%i3) taylor (sqrt (x + 1), x, 0, 5);
                                 2    3      4      5
                            x   x    x    5 x    7 x
          (%o3)/T/      1 + - - -- + -- - ---- + ---- + . . .
                            2   8    16   128    256
          (%i4) %^2;
          (%o4)/T/                  1 + x + . . .
          (%i5) product ((1 + x^i)^2.5, i, 1, inf)/(1 + x^2);
                                   inf
                                  /===\
                                   ! !    i     2.5
                                   ! !  (x  + 1)
                                   ! !
                                  i = 1
          (%o5)                   -----------------
                                        2
                                       x  + 1
          (%i6) ev (taylor(%, x,  0, 3), keepfloat);
                                         2           3
          (%o6)/T/    1 + 2.5 x + 3.375 x  + 6.5625 x  + . . .
          (%i7) taylor (1/log (x + 1), x, 0, 3);
                                         2       3
                           1   1   x    x    19 x
          (%o7)/T/         - + - - -- + -- - ----- + . . .
                           x   2   12   24    720
          (%i8) taylor (cos(x) - sec(x), x, 0, 5);
                                          4
                                     2   x
          (%o8)/T/                - x  - -- + . . .
                                         6
          (%i9) taylor ((cos(x) - sec(x))^3, x, 0, 5);
          (%o9)/T/                    0 + . . .
          (%i10) taylor (1/(cos(x) - sec(x))^3, x, 0, 5);
                                                         2          4
                      1     1       11      347    6767 x    15377 x
          (%o10)/T/ - -- + ---- + ------ - ----- - ------- - --------
                       6      4        2   15120   604800    7983360
                      x    2 x    120 x

                                                                    + . . .
          (%i11) taylor (sqrt (1 - k^2*sin(x)^2), x, 0, 6);
                         2  2       4      2   4
                        k  x    (3 k  - 4 k ) x
          (%o11)/T/ 1 - ----- - ----------------
                          2            24

                                              6       4       2   6
                                         (45 k  - 60 k  + 16 k ) x
                                       - -------------------------- + . . .
                                                    720
          (%i12) taylor ((x + 1)^n, x, 0, 4);
                                2       2     3      2         3
                              (n  - n) x    (n  - 3 n  + 2 n) x
          (%o12)/T/ 1 + n x + ----------- + --------------------
                                   2                 6

                                         4      3       2         4
                                       (n  - 6 n  + 11 n  - 6 n) x
                                     + ---------------------------- + . . .
                                                    24
          (%i13) taylor (sin (y + x), x, 0, 3, y, 0, 3);
                         3                 2
                        y                 y
          (%o13)/T/ y - -- + . . . + (1 - -- + . . .) x
                        6                 2

                              3                       2
                         y   y            2      1   y            3
                    + (- - + -- + . . .) x  + (- - + -- + . . .) x  + . . .
                         2   12                  6   12
          (%i14) taylor (sin (y + x), [x, y], 0, 3);
                               3        2      2      3
                              x  + 3 y x  + 3 y  x + y
          (%o14)/T/   y + x - ------------------------- + . . .
                                          6
          (%i15) taylor (1/sin (y + x), x, 0, 3, y, 0, 3);
                    1   y              1    1               1            2
          (%o15)/T/ - + - + . . . + (- -- + - + . . .) x + (-- + . . .) x
                    y   6               2   6                3
                                       y                    y

                                                     1            3
                                                + (- -- + . . .) x  + . . .
                                                      4
                                                     y
          (%i16) taylor (1/sin (y + x), [x, y], 0, 3);
                                       3         2       2        3
                      1     x + y   7 x  + 21 y x  + 21 y  x + 7 y
          (%o16)/T/ ----- + ----- + ------------------------------- + . . .
                    x + y     6                   360


 -- Variável de opção: taylordepth
     Valor por omissão: 3

     Se existem ainda termos não zero, `taylor' dobra o grau da
     expansão de `<g>(<x>)' contanto que o grau da expansão seja menor
     que ou igual a `<n> 2^taylordepth'.


 -- Função: taylorinfo (<expr>)
     Retorna information about the séries de Taylor <expr>.  O valor de
     retorno é uma lista de listas.  Cada lista compreende o nome de
     uma variável, o ponto de expansão, e o grau da expansão.

     `taylorinfo' retorna `false' se <expr> não for uma séries de
     Taylor.

     Exemplo:

          (%i1) taylor ((1 - y^2)/(1 - x), x, 0, 3, [y, a, inf]);
                            2                       2
          (%o1)/T/ - (y - a)  - 2 a (y - a) + (1 - a )

                   2                        2
           + (1 - a  - 2 a (y - a) - (y - a) ) x

                   2                        2   2
           + (1 - a  - 2 a (y - a) - (y - a) ) x

                   2                        2   3
           + (1 - a  - 2 a (y - a) - (y - a) ) x  + . . .
          (%i2) taylorinfo(%);
          (%o2)               [[y, a, inf], [x, 0, 3]]


 -- Função: taylorp (<expr>)
     Retorna `true' se <expr> for uma séries de Taylor, e `false' de
     outra forma.


 -- Variável de opção: taylor_logexpand
     Valor por omissão: `true'

     `taylor_logexpand' controla expansão de logaritmos em séries de
     `taylor'.

     Quando `taylor_logexpand' for `true', todos  logaritmos são
     expandidos completamente dessa forma problemas de reconhecimento
     de zero envolvendo envolvendo identidades logarítmicas não
     atrapalham o processo de expansão.  Todavia, esse esquema não é
     sempre matematicamente correcto uma vez que isso ignora
     informações de ramo.

     Quando `taylor_logexpand' for escolhida para `false', então a
     expansão logarítmica que ocorre é somente aquela que for
     necessária para obter uma séries de potência formal.


 -- Variável de opção: taylor_order_coefficients
     Valor por omissão: `true'

     `taylor_order_coefficients' controla a ordenação dos coeficientes
     em uma série de Taylor.

     Quando `taylor_order_coefficients' for `true', coeficientes da
     séries de Taylor são ordenados canonicamente.


 -- Função: taylor_simplifier (<expr>)
     Simplifica coeficientes da séries  de potência <expr>.  `taylor'
     chama essa função.


 -- Variável de opção: taylor_truncate_polynomials
     Valor por omissão: `true'

     Quando `taylor_truncate_polynomials' for `true', polinómios são
     truncados baseados sobre a entrada de níveis de truncação.

     De outra forma, entrada de polinómios para `taylor' são
     consideradas terem precisão infinita.


 -- Função: taytorat (<expr>)
     Converte <expr> da forma `taylor' para a forma de expressão
     racional canónica (CRE).  O efeito é o mesmo que `rat (ratdisrep
     (<expr>))', mas mais rápido.


 -- Função: trunc (<expr>)
     Coloca notas na representação interna da expressão geral <expr> de
     modo que isso é mostrado como se suas adições forem séries de
     Taylor truncadas.  <expr> is not otherwise modified.

     Exemplo:

          (%i1) expr: x^2 + x + 1;
                                      2
          (%o1)                      x  + x + 1
          (%i2) trunc (expr);
                                          2
          (%o2)                  1 + x + x  + . . .
          (%i3) is (expr = trunc (expr));
          (%o3)                         true


 -- Função: unsum (<f>, <n>)
     Retorna a primeira diferençã de trás para frente `<f>(<n>) -
     <f>(<n> - 1)'.  Dessa forma `unsum' logicamente é a inversa de
     `sum'.

     Veja também `nusum'.

     Exemplos:

          (%i1) g(p) := p*4^n/binomial(2*n,n);
                                               n
                                            p 4
          (%o1)               g(p) := ----------------
                                      binomial(2 n, n)
          (%i2) g(n^4);
                                        4  n
                                       n  4
          (%o2)                   ----------------
                                  binomial(2 n, n)
          (%i3) nusum (%, n, 0, n);
                               4        3       2              n
                2 (n + 1) (63 n  + 112 n  + 18 n  - 22 n + 3) 4      2
          (%o3) ------------------------------------------------ - ------
                              693 binomial(2 n, n)                 3 11 7
          (%i4) unsum (%, n);
                                        4  n
                                       n  4
          (%o4)                   ----------------
                                  binomial(2 n, n)


 -- Variável de opção: verbose
     Valor por omissão: `false'

     Quando `verbose' for `true', `powerseries' mostra mensagens de
     progresso.



File: maxima.info,  Node: Teoria dos Números,  Next: Simetrias,  Prev: Séries,  Up: Top

31 Teoria dos Números
*********************

* Menu:

* Definições para Teoria dos Números::



Local Variables:
coding: iso-8859-1
End:
