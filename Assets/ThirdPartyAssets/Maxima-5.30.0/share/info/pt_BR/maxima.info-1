This is maxima.info, produced by makeinfo version 4.13 from maxima.texi.

Esse é um Manual do Maxima no formato Texinfo

   Copyright 1994,2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).     Um sistema de álgebra computacional.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Top,  Next: Introdução ao Maxima,  Prev: (dir),  Up: (dir)

Manual do Maxima
****************

Maxima é um sistema de álgebra computacional, implementado em Lisp.

   Maxima é derivado do sistema Macsyma, desenvolvido no MIT nos anos
de 1968 a 1982 como parte do Projeto MAC.  MIT remanejou uma cópia do
código fonte do Macsyma para o Departamento de Energia em 1982; aquela
versão é agora conhecida como Macsyma DOE.  Uma cópia do Macsyma DOE
foi mantida pelo Professor William F. Schelter da Universidade do Texas
de 1982 até sua morte em 2001.  Em 1998, Schelter obteve permissão do
Departamento de Energia para liberar o código fonte do Macsyma DOE sob
a Licença Pública GNU, e em 2000 ele iniciou o projeto Maxima no
SourceForge para manter e desenvolver o Macsyma DOE, agora chamado
Maxima.

   Notas de tradução:

   Com o término da tradução inicia-se o processo de revisão da mesma.
Está  aberta a temporada de caça aos erros de tradução, erros de
hifenização e de adequação entre  a linguagem matemática inglesa e a
linguagem matemática brasileira. Caso você me  envie alguma correção ou
melhoria a comunidade matemática que utiliza o Sofware Livre  lhe
ficará muito grata ( e nós, da equipe do Maxima, também).

   O código fonte deste documento encontra-se no formato texinfo.
Para contribuir com a equipe do Maxima na tarefa de manter a
tradução para o português sempre atualizada envie um  e-mail para
<maxima at math dot utexas dot edu>.

   Em caso de dúvida sobre algum trecho deste manual consulte o original
inglês. Caso sua dúvida persista ou tenha alguma
sugestão/aperfeiçoamento/  crítica mande-nos um e-mail no endereço
acima.

   Versão do manual no formato pdf: maxima.pdf

   Versão do manual no formato info: maxima-info.tar.gz

   Veja o arquivo AUTHORS para conhecer todos os mantenedores do Maxima.

* Menu:

Infraestrutura do Maxima

* Introdução ao Maxima::        Exemplo de sessões do Maxima.
* Detecção e Relato de Erros::  Encontrando e relatando erros no Maxima.
* Ajuda::                       Solicitando ajuda de dentro de uma
                                sessão do Maxima.
* Linha de Comando::            Sintaxe de linha de comando do Maxima.
* Operadores::                  Operadores usados em expressões do Maxima.
* Expressões::                  Expressões no Maxima.
* Simplificação::               Simplificando expressões.
* Montando Gráficos::           Saídas gráficas em 2D e 3D.
* Entrada e Saída::             Entrada e saída de arquivos.
* Ponto Flutuante::             Rotinas numéricas de baixo nível.
* Contextos::                   Conjunto de fatos assumidos.

Suporte a áreas específicas da matemática

* Polinômios::                  Formas padrão para polinômios, e
                                funções operando sobre polinômios.
* Constantes::                  Constantes numéricas.
* Logarítmos::                  Manipulação de expressões envolvendo
                                logarítmos.
* Trigonometria::               Manipulando expressões com trigonometria e
                                Funções trigonométricas inversas.
* Funções Especiais::           Funções especiais
* Funções Elípticas::           Funções Elípticas e Integrais
* Limites::                     Limites de expressões.
* Diferenciação::               Cálculo diferencial.
* Integração::                  Cálculo integral.
* Equações::                    Definindo e resolvendo equações.
* Equações Diferenciais::       Definindo e resolvendo equações diferenciais.
* Numérico::                    Integração numérica, transformações
                                de Fourier, etc.
* Arrays ::                     Criando e trabalhando com arrays.
* Matrizes e Álgebra Linear::   Operações com Matrizes.
* Funções Afins::
* itensor::                     Manipulação de índice de Tensores.
* ctensor::                     Manipulação de componentes de Tensores.
* Pacote atensor::              Manipulação de Tensores Algébricos.
* Séries::                      Taylor e séries de potência.
* Teoria dos Números::          Teoria dos números.
* Simetrias::                   Polinômios simétricos
* Grupos::                      Álgebra Abstrata.

Facilidades avançadas e programação

* Ambiente em Tempo de Execução:: Customização do ambiente Maxima.
* Opções Diversas::             Opções com efeito global sobre o Maxima.
* Regras e Modelos::            Coincidência de expressões definidas pelo utilizador e regras de simplificação.
* Listas::                      Manipulação de listas.
* Conjuntos::                   Manipulação de conjuntos.
* Definição de Função::         Definindo funções.
* Fluxo de Programa::           Definindo programas do Maxima.
* Depurando::                   Depurando programas do Maxima.

Pacotes Adicionais

* augmented_lagrangian::        Pacote augmented_lagrangian.
* bode::                        Gráficos de ganho e fase de Bode.
* contrib_ode::                 Rotinas adicionais para EDOs
* descriptive::                 Estatística descritiva.
* diag::                        Matrizes de Jordan.
* distrib::                     Distribuições de probabilidade.
* draw::                        Uma interface Maxima-Gnuplot.
* dynamics::                    Gráficos para sistemas dinâmicos e fractais.
* eval_string::                 Expressões do Maxima como cadeias de texto.
* f90::                         Tradutor do Maxima para o fortran.
* ggf::                         Função geradora para sequências.
* grobner::                     Funções para trabalhar com as bases de Groebner.
* impdiff::                     Derivadas implícitas.
* implicit_plot::               Gráficos implítos.
* interpol::                    Pacote de interpolação.
* lbfgs::                       L-BFGS pacote de minimização não limitada.
* lindstedt::                   Pacote Lindstedt.
* linearalgebra::               Funções de álgebra linear.
* lsquares::                    Método dos mínimos quadrados.
* makeOrders::                  Expoentes de polinômios.
* mnewton::                     Método de Newton.
* numericalio::                 Leitura e escritura de arquivos.
* opsubst::                     Comandos para subsituições.
* orthopoly::                   Polinómios ortogonais.
* plotdf::                      Gráficos de campos de direcções.
* romberg::                     Método de Romberg para integração numerica.
* simplex::                     Programação linear.
* simplification::              Funções e regras de simplificação.
* solve_rec::                   Relações de recorrências lineares.
* stats::                       Pacote de inferências estatísticas.
* stirling::                    Fórmula de Stirling.
* stringproc::                  Manipulação de seqüências de caracteres.
* unit::                        Pacote de unidades e dimensões.
* zeilberger::                  Funções para somatórios hipergeométricos.


Índice

* Índice de Funções e Variáveis:: Índice::

 --- Listagem de Nodos Detalhada ---

Introdução

* Introdução ao Maxima::

Ajuda

* Lisp e Maxima::
* Descartando::
* Documentação::
* Funções e Variáveis Definidas para Ajuda::

Linha de Comando

* Introdução a Linha de Comando::
* Funções e Variáveis Definidas para Linha de Comando::

Operadores

* N-Argumentos::
* Operador não fixado::
* Operador Pósfixado::
* Operador Préfixado::
* Operadores Aritméticos::
* Operadores Relacionais::
* Operadores Geral::

Expressões

* Introdução a Expressões::
* Complexo::
* Desigualdade::
* Sintaxe::
* Funções e Variáveis Definidas para Expressões::

Simplificação

* Funções e Variáveis Definidas para Simplificação::

Montando Gráficos

* Funções e Variáveis Definidas para Montagem de Gráficos::

Entrada e Saída

* Comentários::
* Arquivos::
* Funções e Variáveis Definidas para Entrada e Saída::

Ponto Flutuante

* Funções e Variáveis Definidas para ponto Flutuante::

Contextos

* Funções e Variáveis Definidas para Contextos::

Polinômios

* Introdução a Polinômios::
* Funções e Variáveis Definidas para Polinômios::

Constantes

* Funções e Variáveis Definidas para Constantes::

Logarítmos

* Funções e Variáveis Definidas para Logarítmos::

Trigonometria

* Introdução ao Pacote Trigonométrico::
* Funções e Variáveis Definidas para Trigonometria::

Funções Especiais

* Introdução a Funções Especiais::
* Funções e Variáveis Definidas para Funções Especiais::

Funções Elípticas

* Introdução a Funções Elípticas e Integrais::
* Funções e Variáveis Definidas para Funções Elípticas::
* Funções e Variáveis Definidas para Integrais Elípticas::

Limites

* Funções e Variáveis Definidas para Limites::

Diferenciação

* Funções e Variáveis Definidas para Diferenciação::

Integração

* Introdução a Integração::
* Funções e Variáveis Definidas para Integração::

Equações

* Funções e Variáveis Definidas para Equações::

Equações Diferenciais

* Introdução a Equações Diferenciais::
* Funções e Variáveis Definidas para Equações Diferenciais::

Numérico

* Introdução a Numérico::
* Pacotes de Fourier::
* Funções e Variáveis Definidas para Numérico::
* Funções e Variáveis Definidas para Séries de Fourier::

Arrays

* Funções e Variáveis Definidas para Arrays::

Matrizes e Álgebra Linear

* Introdução a Matrizes e Álgebra Linear::
* Ponto::
* Vetores::
* auto::
* Funções e Variáveis Definidas para Matrizes e Álgebra Linear::

Funções Afins

* Funções e Variáveis Definidas para Funções Afins::

itensor

* Introdução a itensor::
* Funções e Variáveis Definidas para itensor::

ctensor

* Introdução a ctensor::
* Funções e Variáveis Definidas para ctensor::

Pacote atensor

* Introdução ao Pacote atensor::
* Funções e Variáveis Definidas para o Pacote atensor::

Séries

* Introdução a Séries::
* Funções e Variáveis Definidas para Séries::

Teoria dos Números

* Funções e Variáveis Definidas para Teoria dos Números::

Simetrias

* Funções e Variáveis Definidas para Simetrias::

Grupos

* Funções e Variáveis Definidas para Grupos::

Ambiente em Tempo de Execução

* Introdução a Ambiente em Tempo de Execução::
* Interrupções::
* Funções e Variáveis Definidas para Ambiente em Tempo de Execução::

Opções Diversas

* Introdução a Opções Diversas::
* Compartilhado::
* Funções e Variáveis Definidas para Opções Diversas::

Regras e Modelos

* Introdução a Regras e Modelos::
* Funções e Variáveis Definidas para Regras e Modelos::

Listas

* Introdução a Listas::
* Funções e Variáveis Definidas para Listas::

Conjuntos

* Introdução a Conjuntos::
* Funções e Variáveis Definidas para Conjuntos::

Definição de Função

* Introdução a Definição de Função::
* Função::
* Macros::
* Funções e Variáveis para Definição de Função::

Fluxo de Programa

* Introdução a Fluxo de Programa::
* Funções e Variáveis Definidas para Fluxo de Programa::

Depurando

* Funções e Variáveis Definidas para Depuração::

augmented_lagrangian

* Funções e Variáveis Definidas para augmented_lagrangian::

bode

* Funções e Variáveis Definidas para bode::

contrib_ode

* Introdução a contrib_ode::
* Funções e Variáveis Definidas para contrib_ode::
* Possibilidades de melhorias em contrib_ode::
* Casos de teste para contrib_ode::
* Referências bibliográficas para contrib_ode::

descriptive

* Introdução ao pacote descriptive::
* Funções e Variáveis Definidas para manipulação da dados::
* Funções e Variáveis Definidas para estatística descritiva::
* Funções e Variáveis Definidas específicas para estatística descritiva de várias variáveis::
* Funções e Variáveis Definidas para gráficos estatísticos::

diag

* Funções e Variáveis Definidas para diag::

distrib

* Introdução a distrib::
* Funções e Variáveis Definidas para distribuições contínuas::
* Funções e Variáveis Definidas para distribuições discretas::

draw

* Introdução a draw::
* Funções e Variáveis Definidas para draw::

dynamics

* Introdução a dynamics::
* Funções e Variáveis Definidas para dynamics::

eval_string

* Funções e Variáveis Definidas para eval_string::

f90

* Funções e Variáveis Definidas para f90::

ggf

* Funções e Variáveis Definidas para ggf::

grobner

* Introdução a grobner::
* Funções e Variáveis Definidas para grobner::

impdiff

* Funções e Variáveis Definidas para impdiff::

implicit_plot

* Funções e Variáveis Definidas para implicit_plot::

interpol

* Introdução a interpol::
* Funções e Variáveis Definidas para interpol::

lbfgs

* Introdução a lbfgs::
* Funções e Variáveis Definidas para lbfgs::

lindstedt

* Funções e Variáveis Definidas para lindstedt::

linearalgebra

* Introdução a linearalgebra::
* Funções e Variáveis Definidas para linearalgebra::

lsquares

* Funções e Variáveis Definidas para lsquares::

makeOrders

* Funções e Variáveis Definidas para makeOrders::

mnewton

* Funções e Variáveis Definidas para mnewton::

numericalio

* Introdução a numericalio::
* Funções e Variáveis Definidas para numericalio::

opsubst

* Funções e Variáveis Definidas para opsubst::

orthopoly

* Introdução a polinômios ortogonais::
* Funções e Variáveis Definidas para polinômios ortogonais::

plotdf

* Introdução a plotdf::
* Funções e Variáveis Definidas para plotdf::

romberg

* Funções e Variáveis Definidas para romberg::

simplex

* Introdução a simplex::
* Funções e Variáveis Definidas para simplex::

simplification

* Introdução a simplification::
* Funções e Variáveis Definidas para simplification::

solve_rec

* Introdução a solve_rec::
* Funções e Variáveis Definidas para solve_rec::

stats

* Introdução a stats::
* Funções e Variáveis Definidas para inference_result::
* Funções e Variáveis Definidas para stats::
* Funções e Variáveis Definidas para distribuições especiais::

stirling

* Funções e Variáveis Definidas para stirling::

stringproc

* Introdução a manipulação de seqüências de caracteres::
* Funções e Variáveis para entrada e saída::
* Funções e Variáveis para caracteres::
* Funções e Variáveis para seqüências de caracteres::

unit

* Introdução a Units::
* Funções e Variáveis Definidas para Units::

zeilberger

* Introdução a zeilberger::
* Funções e Variáveis Definidas para zeilberger::


File: maxima.info,  Node: Introdução ao Maxima,  Next: Detecção e Relato de Erros,  Prev: Top,  Up: Top

1 Introdução ao Maxima
**********************

Inicie o Maxima com o comando "maxima".  Maxima mostrará a
informação de versão e uma linha de comando.  Termine cada comando
Maxima com um ponto e vírgula.  Termine uma sessão com o comando
"quit();".  Aqui está um exemplo de sessão:

     [wfs@chromium]$ maxima
     Maxima 5.9.1 http://maxima.sourceforge.net
     Using Lisp CMU Common Lisp 19a
     Distributed under the GNU Public License. See the file COPYING.
     Dedicated to the memory of William Schelter.
     This is a development version of Maxima. The function bug_report()
     provides bug reporting information.
     (%i1) factor(10!);
                                 8  4  2
     (%o1)                      2  3  5  7
     (%i2) expand ((x + y)^6);
            6        5       2  4       3  3       4  2      5      6
     (%o2) y  + 6 x y  + 15 x  y  + 20 x  y  + 15 x  y  + 6 x  y + x
     (%i3) factor (x^6 - 1);
                                   2            2
     (%o3)       (x - 1) (x + 1) (x  - x + 1) (x  + x + 1)
     (%i4) quit();
     [wfs@chromium]$

   Maxima pode procurar as páginas info.  Use o comando `describe' para
mostrar informações sobre o comando ou todos os comandos e variáveis
contendo uma seqüência de caracteres.  O ponto de interrogação `?'
(busca exata) e o duplo ponto de interrogação `??' (busca inexata) são
abreviações para `describe':

     (%i1) ?? integ
      0: Functions and Variables for Elliptic Integrals
      1: Functions and Variables for Integration
      2: Introduction to Elliptic Functions and Integrals
      3: Introduction to Integration
      4: askinteger  (Functions and Variables for Simplification)
      5: integerp  (Functions and Variables for Miscellaneous Options)
      6: integer_partitions  (Functions and Variables for Sets)
      7: integrate  (Functions and Variables for Integration)
      8: integrate_use_rootsof  (Functions and Variables for Integration)
      9: integration_constant_counter  (Functions and Variables for Integration)
      10: nonnegintegerp  (Functions and Variables for linearalgebra)
     Enter space-separated numbers, `all' or `none': 5 4

      -- Function: integerp (<expr>)
          Returns `true' if <expr> is a literal numeric integer, otherwise
          `false'.

          `integerp' returns false if its argument is a symbol, even if the
          argument is declared integer.

          Examples:

               (%i1) integerp (0);
               (%o1)                         true
               (%i2) integerp (1);
               (%o2)                         true
               (%i3) integerp (-17);
               (%o3)                         true
               (%i4) integerp (0.0);
               (%o4)                         false
               (%i5) integerp (1.0);
               (%o5)                         false
               (%i6) integerp (%pi);
               (%o6)                         false
               (%i7) integerp (n);
               (%o7)                         false
               (%i8) declare (n, integer);
               (%o8)                         done
               (%i9) integerp (n);
               (%o9)                         false

      -- Function: askinteger (<expr>, integer)
      -- Function: askinteger (<expr>)
      -- Function: askinteger (<expr>, even)
      -- Function: askinteger (<expr>, odd)
          `askinteger (<expr>, integer)' attempts to determine from the
          `assume' database whether <expr> is an integer.  `askinteger'
          prompts the user if it cannot tell otherwise, and attempt to
          install the information in the database if possible.  `askinteger
          (<expr>)' is equivalent to `askinteger (<expr>, integer)'.

          `askinteger (<expr>, even)' and `askinteger (<expr>, odd)'
          likewise attempt to determine if <expr> is an even integer or odd
          integer, respectively.

     (%o1)                                true

   Para usar um resultado em cálculos posteriores, você pode atribuir
esse valor a uma variável ou referir-se a esse mesmo valor através de
seu rótulo gerado automaticamente.  Adicionalmente, `%' refere-se ao
mais recente resultado calculado:

     (%i1) u: expand ((x + y)^6);
            6        5       2  4       3  3       4  2      5      6
     (%o1) y  + 6 x y  + 15 x  y  + 20 x  y  + 15 x  y  + 6 x  y + x
     (%i2) diff (u, x);
              5         4       2  3       3  2       4        5
     (%o2) 6 y  + 30 x y  + 60 x  y  + 60 x  y  + 30 x  y + 6 x
     (%i3) factor (%o2);
                                         5
     (%o3)                      6 (y + x)

   Maxima tem conhecimento sobre números complexos e constantes
numéricas:

     (%i1) cos(%pi);
     (%o1)                          - 1
     (%i2) exp(%i*%pi);
     (%o2)                          - 1

   Maxima pode fazer cálculos diferenciais e integrais:

     (%i1) u: expand ((x + y)^6);
            6        5       2  4       3  3       4  2      5      6
     (%o1) y  + 6 x y  + 15 x  y  + 20 x  y  + 15 x  y  + 6 x  y + x
     (%i2) diff (%, x);
              5         4       2  3       3  2       4        5
     (%o2) 6 y  + 30 x y  + 60 x  y  + 60 x  y  + 30 x  y + 6 x
     (%i3) integrate (1/(1 + x^3), x);
                                       2 x - 1
                     2            atan(-------)
                log(x  - x + 1)        sqrt(3)    log(x + 1)
     (%o3)    - --------------- + ------------- + ----------
                       6             sqrt(3)          3

   Maxima pode resolver sistemas lineares e equações cúbicas:

     (%i1) linsolve ([3*x + 4*y = 7, 2*x + a*y = 13], [x, y]);
                             7 a - 52        25
     (%o1)              [x = --------, y = -------]
                             3 a - 8       3 a - 8
     (%i2) solve (x^3 - 3*x^2 + 5*x = 15, x);
     (%o2)       [x = - sqrt(5) %i, x = sqrt(5) %i, x = 3]

   Maxima pode resolver sistemas de equações não lineares.  Note que se
você não quer um resultado impresso, você pode encerrar seu comando com
`$' em lugar de encerrar com `;'.

     (%i1) eq_1: x^2 + 3*x*y + y^2 = 0$
     (%i2) eq_2: 3*x + y = 1$
     (%i3) solve ([eq_1, eq_2]);
                   3 sqrt(5) + 7      sqrt(5) + 3
     (%o3) [[y = - -------------, x = -----------],
                         2                 2

                                    3 sqrt(5) - 7        sqrt(5) - 3
                               [y = -------------, x = - -----------]]
                                          2                   2

   Maxima pode gerar gráficos de uma ou mais funções:

     (%i1) eq_1: x^2 + 3*x*y + y^2 = 0$
     (%i2) eq_2: 3*x + y = 1$
     (%i3) solve ([eq_1, eq_2]);
                   3 sqrt(5) + 7      sqrt(5) + 3
     (%o3) [[y = - -------------, x = -----------],
                         2                 2

                                    3 sqrt(5) - 7        sqrt(5) - 3
                               [y = -------------, x = - -----------]]
                                          2                   2
     (%i4) kill(labels);
     (%o0)                         done
     (%i1) plot2d (sin(x)/x, [x, -20, 20]);
     (%o1)
     (%i2) plot2d ([atan(x), erf(x), tanh(x)], [x, -5, 5]);
     (%o2)
     (%i3) plot3d (sin(sqrt(x^2 + y^2))/sqrt(x^2 + y^2), [x, -12, 12], [y, -12, 12]);
     (%o3)


File: maxima.info,  Node: Detecção e Relato de Erros,  Next: Ajuda,  Prev: Introdução ao Maxima,  Up: Top

2 Detecção e Relato de Erros
****************************

* Menu:

* Definições para Detecção e Relato de Erros::


File: maxima.info,  Node: Definições para Detecção e Relato de Erros,  Up: Detecção e Relato de Erros

2.1 Definições para Detecção e Relato de Erros
==============================================

 -- Função: run_testsuite ()
 -- Função: run_testsuite (<boolean>)
 -- Função: run_testsuite (<boolean>, <boolean>)
 -- Função: run_testsuite (<boolean>, <boolean>, <list>)
     Executa o conjunto de testes do Maxima.  Testes que produzem a
     resposta desejada são considerados "passes," e testes que não
     produzem a resposta desejada, são marcados como erros conhecidos.

     `run_testsuite ()' mostra somente testes que não são aprovados.

     `run_testsuite (true)' mostra somente testes que são marcados como
     erros conhecidos, bem como as falhas.

     `run_testsuite (true, true)' mostra todos os testes.

     Se o terceiro argumento opcional for dado, um subconjunto de
     testes é executado.  O subconjunto de testes para executar é dado
     como uma lista de nomes dos testes.  O conjunto completo de testes
     é especificado por `testsuite_files'.

     `run_testsuite' altera a variável de ambiente Maxima.  Tipicamente
     um script de teste executa `kill' para estabelecer uma variável de
     ambiente (uma a saber sem funções definidas pelo usuário e
     variáveis) e então define funções e variáveis apropriadamente para
     o teste.

     `run_testsuite' retorna `done'.

 -- Variável de opção: testsuite_files
     `testsuite_files' é o conjunto de testes a ser executado por
     `run_testsuite'.  Isso é uma lista de nomes de arquivos contendo
     os testes a executar.  Se alguns dos testes em um arquivo falha de
     forma conhecida, então em lugar de listar o nome do arquivo, uma
     lista contendo o nome do arquivo e o número dos testes que
     falharam é usada.

     por exemplo, a linha adinate é uma parte do conjunto de testes
     padrão:

           ["rtest13s", ["rtest14", 57, 63]]

     Essa linha especifica a suite de testes que consiste dos arquivos
     "rtest13s" e "rtest14", mas "rtest14" contém dois testes que
     falham de forma conhecida: 57 e 63.

 -- Função: bug_report ()
     Imprime os números de versão do Maxima e do Lisp, e chama o link
     para a página web de informação de erros do projeto Maxima.  A
     informação da versão é a mesma reportada por `build_info'.

     Quando um erro é informado, é muito útil copiar a versão do Maxima
     e do Lisp dentro da informação do erro.

     `bug_report' retorna uma seqüência de caracteres vazia `""'.

 -- Função: build_info ()
     Imprime um sumário de parâmetros da compilação do Maxima.

     `build_info' retorna uma seqüência de caracteres vazia `""'.


File: maxima.info,  Node: Ajuda,  Next: Linha de Comando,  Prev: Detecção e Relato de Erros,  Up: Top

3 Ajuda
*******

* Menu:

* Lisp e Maxima::
* Descartando::
* Documentação::
* Funções e Variáveis Definidas para Ajuda::


File: maxima.info,  Node: Lisp e Maxima,  Next: Descartando,  Prev: Ajuda,  Up: Ajuda

3.1 Lisp e Maxima
=================

Maxima é escrito na liguagem de programação Lisp, e é fácil acessar
funções Lisp e variáveis a partir do Maxima e vice-versa.  Símbolos
Lisp e Maxima são distingüidos através de uma convenção de nome.  Um
símbolo Lisp que começa com um sinal de dólar `$' corresponde a um
símbolo Maxima sem o sinal de dólar.  Um símbolo Maxima que começa com
um ponto de interrogação `?' corresponde a um símbolo Lisp sem o ponto
de interrogação.  Por exemplo, o símbolo Maxima `foo' corresponde ao
símbolo Lisp `$foo', enquanto o símbolo Maxima `?foo' corresponde ao
símbolo Lisp `foo', Note que `?foo' é escrito sem um espaço entre `?' e
`foo'; de outra forma pode ser uma chamada errônea para `describe
("foo")'.

   Hífen `-', asterisco `*', ou outro caractere especial em símbolos
Lisp deve ser precedido por uma barra invertida `\' onde ele aparecer
no código Maxima.  Por exemplo, o identificador Lisp `*foo-bar*' é
escrito `?\*foo\-bar\*' no Maxima.

   Código Lisp pode ser executado dentro de uma sessão Maxima.  Uma
linha simples de Lisp (contendo uma ou mais formas) pode ser executada
através do comando especial `:lisp'. Por exemplo,

     (%i1) :lisp (foo $x $y)

chama a função Lisp `foo' com variáveis Maxima `x' e `y' como
argumentos.  A constução `:lisp' pode aparecer na linha de comando
interativa ou em um arquivo processado por `batch' ou `demo', mas não
em um arquivo processado por `load', `batchload', `translate_file', ou
`compile_file'.

   A função `to_lisp()' abre uma sessão interativa Lisp.  Digitando
`(to-maxima)' fecha a sessão Lisp e retorna para o Maxima.

   Funções Lisp e variáveis que são para serem visíveis no Maxima como
funções e variáveis com nomes comuns (sem pontuação especial) devem ter
nomes Lisp começando com o sinal de dólar `$'.

   Maxima é sensível à caixa, distingue entre letras em caixa alta
(maiúsculas) e letras em caixa baixa (minúsculas) em identificadores,
enquanto Lisp não é sensível à caixa.  Existem algumas regras
governando a tradução de nomes entre o Lisp e o Maxima.

  1. Um identificador Lisp não contido entre barras verticais
     corresponde a um identificador Maxima em caixa baixa.  Se o
     identificador Lisp estiver em caixa alta, caixa baixa, ou caixa
     mista, é ignorado.  E.g., Lisp `$foo', `$FOO', e `$Foo' todos
     correspondem a Maxima `foo'.

  2. Um identificador Lisp que está todo em caixa alta ou todo em caixa
     baixa e contido em barras verticais corresponde a um identificador
     Maxima com caixa invertida.  Isto é, caixa alta é alterada para
     caixa baixa e caixa baixa para caixa alta.  E.g., Lisp `|$FOO|' e
     `|$foo|' corresponde a Maxima `foo' e `FOO', respectivamente.

  3. Um identificador Lisp que é misto de caixa alta e caixa baixa e
     contido entre barras verticais corresponde a um identificador
     Maxima com o mesma caixa.  E.g., Lisp `|$Foo|' corresponde a
     Maxima `Foo'.

   A macro Lisp `#$' permite o uso de expressões Maxima em código Lisp.
`#$<expr>$' expande para uma expressão Lisp equivalente à expressão
Maxima <expr>.

     (msetq $foo #$[x, y]$)

Isso tem o mesmo efeito que digitar

     (%i1) foo: [x, y];

A função Lisp `displa' imprime uma expressão em formato Maxima.

     (%i1) :lisp #$[x, y, z]$
     ((MLIST SIMP) $X $Y $Z)
     (%i1) :lisp (displa '((MLIST SIMP) $X $Y $Z))
     [x, y, z]
     NIL

   Funções definidas em Maxima não são funções comuns em Lisp.  A
função Lisp `mfuncall' chama uma função Maxima.  Por exemplo:

     (%i1) foo(x,y) := x*y$
     (%i2) :lisp (mfuncall '$foo 'a 'b)
     ((MTIMES SIMP) A B)

   Algumas funções Lisp possuem o mesmo nome que no pacote Maxima, a
saber as seguintes.

   `complement', `continue', `//', `float', `functionp', `array', `exp',
`listen', `signum', `atan', `asin', `acos', `asinh', `acosh', `atanh',
`tanh', `cosh', `sinh', `tan', `break', e `gcd'.


File: maxima.info,  Node: Descartando,  Next: Documentação,  Prev: Lisp e Maxima,  Up: Ajuda

3.2 Descartando
===============

Computação simbólica tende a criar um bom volume de arquivos
temporários, e o efetivo manuseio disso pode ser crucial para sucesso
completo de alguns programas.

   Sob GCL, nos sistemas UNIX onde a chamada de sistema mprotect (
controle de acessso autorizado a uma região de memória) está disponível
(incluindo SUN OS 4.0 e algumas variantes de BSD) uma organização de
arquivos temporários estratificada está disponível.   Isso limita a
organização para páginas que tenham sido recentemente escritas.    Veja
a documentação da GCL sob ALLOCATE e GBC.   No ambiente Lisp fazendo
(setq si::*notify-gbc* t) irá ajudar você a determinar quais áreas
podem precisar de mais espaço.


File: maxima.info,  Node: Documentação,  Next: Funções e Variáveis Definidas para Ajuda,  Prev: Descartando,  Up: Ajuda

3.3 Documentação
================

O manual on-line de usuário do Maxima pode ser visto em diferentes
formas.  A partir da linha de comando interativa do Maxima, o manual de
usuário é visto em texto plano através do comando `?' (i.e., a
função `describe' ).  O manual de usuário é visto como hipertexto
`info' através do programa visualizador `info' e como uma web page
através de qualquer navegador web comum.

   `example' mostra exemplos de muitas funções do Maxima.  Por exemplo,

     (%i1) example (integrate);

   retorna

     (%i2) test(f):=block([u],u:integrate(f,x),ratsimp(f-diff(u,x)))
     (%o2) test(f) := block([u], u : integrate(f, x),

                                              ratsimp(f - diff(u, x)))
     (%i3) test(sin(x))
     (%o3)                           0
     (%i4) test(1/(x+1))
     (%o4)                           0
     (%i5) test(1/(x^2+1))
     (%o5)                           0

   e saída adicional.


File: maxima.info,  Node: Funções e Variáveis Definidas para Ajuda,  Prev: Documentação,  Up: Ajuda

3.4 Funções e Variáveis Definidas para Ajuda
============================================

 -- Função: demo (<nomearquivo>)
     Avalia expressões Maxima em <nomearquivo> e mostra os resultados.
     `demo' faz uma pausa após avaliar cada expressão e continua após a
     conclusão com um enter das entradas de usuário.  (Se executando em
     Xmaxima, `demo' pode precisar ver um ponto e vírgula `;' seguido
     por um enter.)

     `demo' procura na lista de diretórios `file_search_demo' para
     achar `nomearquivo'.  Se o arquivo tiver o sufixo `dem', o sufixo
     pode ser omitido.  Veja também `file_search'.

     `demo' avalia seus argumento.  `demo' retorna o nome do arquivo de
     demonstração.

     Exemplo:

          (%i1) demo ("disol");

          batching /home/wfs/maxima/share/simplification/disol.dem
           At the _ prompt, type ';' followed by enter to get next demo
          (%i2)                      load(disol)

          _
          (%i3)           exp1 : a (e (g + f) + b (d + c))
          (%o3)               a (e (g + f) + b (d + c))

          _
          (%i4)                disolate(exp1, a, b, e)
          (%t4)                         d + c

          (%t5)                         g + f

          (%o5)                   a (%t5 e + %t4 b)

          _
          (%i5) demo ("rncomb");

          batching /home/wfs/maxima/share/simplification/rncomb.dem
           At the _ prompt, type ';' followed by enter to get next demo
          (%i6)                     load(rncomb)

          _
                                       z         x
          (%i7)               exp1 : ----- + ---------
                                     y + x   2 (y + x)
                                    z         x
          (%o7)                   ----- + ---------
                                  y + x   2 (y + x)

          _
          (%i8)                     combine(exp1)
                                    z         x
          (%o8)                   ----- + ---------
                                  y + x   2 (y + x)

          _
          (%i9)                     rncombine(%)
                                       2 z + x
          (%o9)                       ---------
                                      2 (y + x)

          _
                                       d   c   b   a
          (%i10)                exp2 : - + - + - + -
                                       3   3   2   2
                                    d   c   b   a
          (%o10)                    - + - + - + -
                                    3   3   2   2

          _
          (%i11)                    combine(exp2)
                                2 d + 2 c + 3 (b + a)
          (%o11)                ---------------------
                                          6

          _
          (%i12)                   rncombine(exp2)
                                2 d + 2 c + 3 b + 3 a
          (%o12)                ---------------------
                                          6

          _
          (%i13)


 -- Função: describe (<string>)
 -- Função: describe (<string>, exact)
 -- Função: describe (<string>, inexact)
     `describe(<string>)' é equivalente a `describe(<string>, exact)'.

     `describe(<string>, exact)' encontra um item com título igual
     (case-insensitive) a <string>, se existir tal item.

     `describe(<string>, inexact)' encontra todos os itens documentados
     que contiverem <string> em seus títulos.  Se existe mais de um de
     tal item, Maxima solicita ao usuário selecionar um item ou ítens
     para mostrar.

     Na linha de comando interativa, `? foo' (com um espaço entre `?' e
     `foo') é equivalente a `describe("foo", exact)'.  e `?? foo' é
     equivalente a `describe("foo", inexact)'.

     `describe("", inexact)' retorna uma lista de todos os tópicos
     documentados no manual on-line.

     `describe' não avalia seu argumento.  `describe' retorna `true' se
     alguma documentação for encontrada, de outra forma retorna `false'.

     Veja também *note Documentação::.

     Exemplo:

          (%i1) ?? integ
           0: Functions and Variables for Elliptic Integrals
           1: Functions and Variables for Integration
           2: Introduction to Elliptic Functions and Integrals
           3: Introduction to Integration
           4: askinteger  (Functions and Variables for Simplification)
           5: integerp  (Functions and Variables for Miscellaneous Options)
           6: integer_partitions  (Functions and Variables for Sets)
           7: integrate  (Functions and Variables for Integration)
           8: integrate_use_rootsof  (Functions and Variables for Integration)
           9: integration_constant_counter  (Functions and Variables for Integration)
           10: nonnegintegerp  (Functions and Variables for linearalgebra)
          Enter space-separated numbers, `all' or `none': 7 8

           -- Function: integrate (<expr>, <x>)
           -- Function: integrate (<expr>, <x>, <a>, <b>)
               Attempts to symbolically compute the integral of <expr> with
               respect to <x>.  `integrate (<expr>, <x>)' is an indefinite
               integral, while `integrate (<expr>, <x>, <a>, <b>)' is a definite
               integral, [...]

           -- Option variable: integrate_use_rootsof
               Default value: `false'

               When `integrate_use_rootsof' is `true' and the denominator of a
               rational function cannot be factored, `integrate' returns the
               integral in a form which is a sum over the roots (not yet known)
               of the denominator.
               [...]

     Nesse exemplo, ítens 7 e 8 foram selecionados (a saída foi
     encurtada por razões tipográficas e economico-financeiras como
     indicado por `[...]'.  Todos ou nenhum dos ítens poderia ter sido
     selecionado através da inserção de `all' ou `none', que podem ser
     abreviado para `a' ou para `n', respectivamente.


 -- Função: example (<tópico>)
 -- Função: example ()
     `example (<topic>)' mostra alguns exemplos de <tópico>, que é um
     símbolo (não uma seqüência de caracteres).  A maioria dos tópicos
     são nomes de função.  `example ()' retorna a lista de todos os
     tópicos reconhecidos.

     O nome do arquivo contendo os exemplos é dado pela variável global
     `manual_demo', cujo valor padrão é `"manual.demo"'.

     `example' não avalia seu argumento.  `example' retorna `done' a
     menos que ocorra um erro ou não exista o argumento fornecido pelo
     usuário, nesse caso `example' retorna uma lista de todos os
     tópicos reconhecidos.

     Exemplos:

          (%i1) example (append);
          (%i2) append([x+y,0,-3.2],[2.5E+20,x])
          (%o2)             [y + x, 0, - 3.2, 2.5E+20, x]
          (%o2)                         done
          (%i3) example (coeff);
          (%i4) coeff(b+tan(x)+2*a*tan(x) = 3+5*tan(x),tan(x))
          (%o4)                      2 a + 1 = 5
          (%i5) coeff(1+x*%e^x+y,x,0)
          (%o5)                         y + 1
          (%o5)                         done



File: maxima.info,  Node: Linha de Comando,  Next: Operadores,  Prev: Ajuda,  Up: Top

4 Linha de Comando
******************

* Menu:

* Introdução a Linha de Comando::
* Funções e Variáveis Definidas para Linha de Comando::


File: maxima.info,  Node: Introdução a Linha de Comando,  Next: Funções e Variáveis Definidas para Linha de Comando,  Prev: Linha de Comando,  Up: Linha de Comando

4.1 Introdução a Linha de Comando
=================================

 -- Operador: '
     O operador apóstrofo `'' evita avaliação.

     Aplicado a um símbolo, o apóstrofo evita avaliação do símbolo.

     Aplicado a uma chamada de função, o apóstrofo evita avaliação da
     chamada de função, embora os argumentos da função sejam ainda
     avaliados (se a avaliação não for de outra forma evitada).  O
     resultado é a forma substantiva da chamada de função.

     Aplicada a uma espressão com parêntesis, o apóstrofo evita
     avaliação de todos os símbolos e chamadas de função na expressão.
     E.g., `'(f(x))' significa não avalie a expressão `f(x)'.  `'f(x)'
     (com apóstrofo aplicado a `f' em lugar de `f(x)') retorna a forma
     substantiva de `f' aplicada a `[x]'.

     O apóstrofo nao evita simplificação.

     Quando o sinalizador global `noundisp' for `true', substantivos
     são mostrados com um apóstrofo.  Esse comutador é sempre `true'
     quando mostrando definições de funções.

     Veja também operador apóstrofo-apóstrofo `''' e `nouns'.

     Exemplos:

     Aplicado a um símbolo, o apóstrofo evita avaliação do símbolo.

          (%i1) aa: 1024;
          (%o1)                         1024
          (%i2) aa^2;
          (%o2)                        1048576
          (%i3) 'aa^2;
                                           2
          (%o3)                          aa
          (%i4) ''%;
          (%o4)                        1048576

     Aplicado a uma chamada de função, o apóstrofo evita avaliação da
     chamada de função.  O resultado é a forma substantiva da chamada
     de função.

          (%i1) x0: 5;
          (%o1)                           5
          (%i2) x1: 7;
          (%o2)                           7
          (%i3) integrate (x^2, x, x0, x1);
                                         218
          (%o3)                          ---
                                          3
          (%i4) 'integrate (x^2, x, x0, x1);
                                       7
                                      /
                                      [   2
          (%o4)                       I  x  dx
                                      ]
                                      /
                                       5
          (%i5) %, nouns;
                                         218
          (%o5)                          ---
                                          3

     Aplicado a uma expressão com parêntesis, o apóstrofo evita
     avaliação de todos os símbolos e chamadas de função na expressão.

          (%i1) aa: 1024;
          (%o1)                         1024
          (%i2) bb: 19;
          (%o2)                          19
          (%i3) sqrt(aa) + bb;
          (%o3)                          51
          (%i4) '(sqrt(aa) + bb);
          (%o4)                     bb + sqrt(aa)
          (%i5) ''%;
          (%o5)                          51

     O apóstrofo não evita simplificação.

          (%i1) sin (17 * %pi) + cos (17 * %pi);
          (%o1)                          - 1
          (%i2) '(sin (17 * %pi) + cos (17 * %pi));
          (%o2)                          - 1


 -- Operador: "
     O operador apóstrofo-apóstrofo `''' (dois apóstrofost) modifica
     avaliação em expressões de entrada.

     Aplicado a uma expressão geral <expr>, apóstrofo-apóstrofo faz com
     que o valor de <expr> seja substituído por <expr> na expressão de
     entrada.

     Aplicado ao operadro de uma expressão, apóstrofo-apóstrofo
     modifica o operadro de um susbstantivo para um verbo (se esse
     operador não for já um verbo).

     O operador apóstrofo-apóstrofo é aplicado através do passador de
     entrada; o apóstrofo-apóstrofo não é armazenado como parte de uma
     expressão de entrada passada.  O operador apóstrofo-apóstrofo é
     sempre aplicado tão rapidamente quanto for passado, e não pode
     receber um terceiro apóstrofo.  Dessa forma faz com que ocorra
     avaliação quando essa avaliação for de outra forma suprimida, da
     mesma forma que em definições de função, definições de expressãoes
     lambda, e expressões que recebem um apóstrofo simples `''.

     Apóstrofo-apóstrofo é reconhecido por `batch' e `load'.

     Veja também o operador apóstrofo `'' e `nouns'.

     Exemplos:

     Aplicado a uma expressão geral <expr>, apóstrofo-apóstrofo fazem
     com que o valor de <expr> seja substituido por <expr> na expressão
     de entrada.

          (%i1) expand ((a + b)^3);
                               3        2      2      3
          (%o1)               b  + 3 a b  + 3 a  b + a
          (%i2) [_, ''_];
                                   3    3        2      2      3
          (%o2)     [expand((b + a) ), b  + 3 a b  + 3 a  b + a ]
          (%i3) [%i1, ''%i1];
                                   3    3        2      2      3
          (%o3)     [expand((b + a) ), b  + 3 a b  + 3 a  b + a ]
          (%i4) [aa : cc, bb : dd, cc : 17, dd : 29];
          (%o4)                   [cc, dd, 17, 29]
          (%i5) foo_1 (x) := aa - bb * x;
          (%o5)                 foo_1(x) := aa - bb x
          (%i6) foo_1 (10);
          (%o6)                      cc - 10 dd
          (%i7) ''%;
          (%o7)                         - 273
          (%i8) ''(foo_1 (10));
          (%o8)                         - 273
          (%i9) foo_2 (x) := ''aa - ''bb * x;
          (%o9)                 foo_2(x) := cc - dd x
          (%i10) foo_2 (10);
          (%o10)                        - 273
          (%i11) [x0 : x1, x1 : x2, x2 : x3];
          (%o11)                    [x1, x2, x3]
          (%i12) x0;
          (%o12)                         x1
          (%i13) ''x0;
          (%o13)                         x2
          (%i14) '' ''x0;
          (%o14)                         x3

     Aplicado ao operador de uma expressão, apóstrofo-apóstrofo muda o
     operadro de um substantivo para um verbo (se esse operadro não for
     já um verbo).

          (%i1) sin (1);
          (%o1)                        sin(1)
          (%i2) ''sin (1);
          (%o2)                    0.8414709848079
          (%i3) declare (foo, noun);
          (%o3)                         done
          (%i4) foo (x) := x - 1729;
          (%o4)                 ''foo(x) := x - 1729
          (%i5) foo (100);
          (%o5)                       foo(100)
          (%i6) ''foo (100);
          (%o6)                        - 1629

     O operador apóstrofo-apóstrofo é aplicado por meio de um passador
     de entrada; operador-apóstrofo não é armazenado como parte da
     expressão de entrada.

          (%i1) [aa : bb, cc : dd, bb : 1234, dd : 5678];
          (%o1)                 [bb, dd, 1234, 5678]
          (%i2) aa + cc;
          (%o2)                        dd + bb
          (%i3) display (_, op (_), args (_));
                                     _ = cc + aa

                                   op(cc + aa) = +

                              args(cc + aa) = [cc, aa]

          (%o3)                         done
          (%i4) ''(aa + cc);
          (%o4)                         6912
          (%i5) display (_, op (_), args (_));
                                     _ = dd + bb

                                   op(dd + bb) = +

                              args(dd + bb) = [dd, bb]

          (%o5)                         done

     Apóstrofo apóstrofo faz com que ocorra avaliação quando a
     avaliação tiver sido de outra forma suprimida, da mesma forma que
     em definições de função, da mesma forma que em definições de
     função lambda expressions, E expressões que recebem o apóstrofo
     simples `''.

          (%i1) foo_1a (x) := ''(integrate (log (x), x));
          (%o1)               foo_1a(x) := x log(x) - x
          (%i2) foo_1b (x) := integrate (log (x), x);
          (%o2)           foo_1b(x) := integrate(log(x), x)
          (%i3) dispfun (foo_1a, foo_1b);
          (%t3)               foo_1a(x) := x log(x) - x

          (%t4)           foo_1b(x) := integrate(log(x), x)

          (%o4)                      [%t3, %t4]
          (%i4) integrate (log (x), x);
          (%o4)                     x log(x) - x
          (%i5) foo_2a (x) := ''%;
          (%o5)               foo_2a(x) := x log(x) - x
          (%i6) foo_2b (x) := %;
          (%o6)                    foo_2b(x) := %
          (%i7) dispfun (foo_2a, foo_2b);
          (%t7)               foo_2a(x) := x log(x) - x

          (%t8)                    foo_2b(x) := %

          (%o8)                      [%t7, %t8]
          (%i8) F : lambda ([u], diff (sin (u), u));
          (%o8)             lambda([u], diff(sin(u), u))
          (%i9) G : lambda ([u], ''(diff (sin (u), u)));
          (%o9)                  lambda([u], cos(u))
          (%i10) '(sum (a[k], k, 1, 3) + sum (b[k], k, 1, 3));
          (%o10)         sum(b , k, 1, 3) + sum(a , k, 1, 3)
                              k                  k
          (%i11) '(''(sum (a[k], k, 1, 3)) + ''(sum (b[k], k, 1, 3)));
          (%o11)             b  + a  + b  + a  + b  + a
                              3    3    2    2    1    1



File: maxima.info,  Node: Funções e Variáveis Definidas para Linha de Comando,  Prev: Introdução a Linha de Comando,  Up: Linha de Comando

4.2 Funções e Variáveis Definidas para Linha de Comando
=======================================================

 -- Função: alias (<new_name_1>, <old_name_1>, ..., <new_name_n>,
          <old_name_n>)
     provê um nome alternativo para uma função (de usuário ou de
     sistema), variável, array, etc.  Qualquer número de argumentos
     pode ser usado.


 -- Variável de opção: debugmode
     Valor padrão: `false'

     Quando um erro do Maxima ocorre, Maxima iniciará o depurador se
     `debugmode' for `true'.  O usuário pode informar comandos para
     examinar o histórico de chamadas, marcar pontos de parada,
     percorrer uma linha por vez o código do Maxima, e assim por
     diante.  Veja `debugging' para uma lista de opções do depurador.

     Habilitando `debugmode' por meio da alteração de seu valor para
     `true', não serão capturados erros do Lisp.


 -- Função: ev (<expr>, <arg_1>, ..., <arg_n>)
     Avalia a expressão <expr> no ambiente especificado pelos
     argumentos <arg_1>, ..., <arg_n>.  Os argumentos são comutadores
     (sinalizadores Booleanos), atribuições, equações, e funções.  `ev'
     retorna o resultado (outra expressão) da avaliação.

     A avaliação é realizada em passos, como segue.

       1. Primeiro o ambiente é preparado examinando os argumentos que
          podem ser quaisquer ou todos os seguintes.

             * `simp' faz com que <expr> seja simplificado
               independentemente da posição do comutador `simp' que
               inibe simplificação se `false'.

             * `noeval' suprime a fase de avaliação de `ev' (veja passo
               (4) adiante).  Isso é útil juntamente com outros
               comutadores e faz com que <expr> seja simplificado
               novamente sem ser reavaliado.

             * `nouns' causa a avaliação de formas substantivas
               (tipicamente funções não avaliadas tais como
               `'integrate' ou `'diff') em <expr>.

             * `expand' causa expansão.

             * `expand (<m>, <n>)' causa expansão, alterando os valores
               de `maxposex' e `maxnegex' para <m> e <n>
               respectivamente.

             * `detout' faz com que qualquer matriz inversa calculada
               em <expr> tenha seu determinante mantido fora da inversa
               ao invés de dividindo a cada elemento.

             * `diff' faz com que todas as diferenciações indicadas em
               <expr> sejam executadas.

             * `derivlist (<x>, <y>, <z>, ...)' causa somente
               diferenciações referentes às variáveis indicadas.

             * `float' faz com que números racionais não inteiros sejam
               convertidos para ponto flutuante.

             * `numer' faz com que algumas funções matemáticas
               (incluindo a exponenciação) com argumentos sejam
               valiadas em ponto flutuante.  Isso faz com que variávels
               em <expr> que tenham sido dados numervals (valores
               numéricos) sejam substituídas por seus valores.  Isso
               também modifica o comutador `float' para ativado.

             * `pred' faz com que predicados (expressões que podem ser
               avaliados em `true' ou `false') sejam avaliadas.

             * `eval' faz com que uma avaliação posterior de <expr>
               ocorra.  (Veja passo (5) adiante.)  `eval' pode ocorrer
               multiplas vezes.  Para cada instância de `eval', a
               expressão é avaliada novamente.

             * `A' onde `A' é um átomo declarado seja um sinalizador de
               avaliação (veja `evflag') faz com que `A' seja associado
               a `true' durante a avaliação de <expr>.

             * `V: expresão' (ou alternativamente `V=expressão') faz
               com que `V' seja associado ao valor de `expressão'
               durante a avaliação de <expr>.  Note que se `V' é uma
               opção do Maxima, então `expression' é usada para seu
               valor durante a avaliação de <expr>.  Se mais que um
               argumento para `ev' é desse tipo então a associação
               termina em paralelo.  Se `V' é uma expressão não atômica
               então a substituição, ao invés de uma associação, é
               executada.

             * `F' onde `F', um nome de função, tenha sido declarado
               para ser uma função de avaliação (veja `evfun') faz com
               que `F' seja aplicado a <expr>.

             * Qualquer outro nome de função (e.g., `sum') causa a
               avaliação de ocorrências desses nomes em <expr> mesmo
               que eles tenham sido verbos.

             * De forma adicional uma função ocorrendo em <expr>
               (digamos `F(x)') pode ser definida localmente para o
               propósito dessa avaliação de <expr> dando `F(x) :=
               expressão' como um argumento para `ev'.

             * Se um átomo não mensionado acima ou uma variável
               subscrita ou expressão subscrita for dada como um
               argumento, isso é avaliado e se o resultado for uma
               equação ou uma atribuição então a associação indicada ou
               substituição é executada.  Se o resultado for uma lista
               então os membros da lista serão tratados  como se eles
               fossem argumentos adicionais dados para `ev'.  Isso
               permite que uma lista de equações seja dada (e.g. `[X=1,
               Y=A**2]') ou que seja dado uma lista de nomes de
               equações (e.g., `[%t1, %t2]' onde `%t1' e `%t2' são
               equações) tais como aquelas listas retornadas por
               `solve'.

          Os argumentos de `ev' podem ser dados em qualquer ordem com
          exceção de substituições de equações que são manuseadas em
          seqüência, da esquerda para a direita, e funções de
          avaliação que são compostas, e.g., `ev (<expr>, ratsimp,
          realpart)' são manuseadas como `realpart (ratsimp (<expr>))'.

          Os comutadores `simp', `numer', `float', e `pred' podem
          também ser alterados localmente em um bloco, ou globalmente
          no Maxima dessa forma eles irã permanecer em efeito até serem
          resetados ao término da execução do bloco.

          Se <expr> for uma expressão racional canônica (CRE), então a
          expressão retornada por `ev' é também uma CRE, contanto que
          os comutadores `numer' e `float' não sejam ambos `true'.

       2. Durante o passo (1), é feito uma lista  de variáveis não
          subscritas aparecendo do lado esquerdo das equações nos
          argumentos ou nos valores de alguns argumentos se o valor for
          uma equação.  As variáveis (variáveis subscritas que não
          possuem funções array associadas bem como variáveis não
          subscritas) na expressão <expr> são substituídas por seus
          valores globais, exceto para esse aparecendo nessa lista.
          Usualmente, <expr> é apenas um rótulo ou `%' (como em `%i2'
          no exemplo adiante), então esse passo simplesmente repete a
          expressão nomeada pelo rótulo, de modo que `ev' possa
          trabalhar sobre isso.

       3. Se quaisquer substituições tiveem sido indicadas pelos
          argumentos, elas serão realizadas agora.

       4. A expressão resultante é então reavaliada (a menos que um dos
          argumentos seja `noeval') e simplificada conforme os
          argumentos.  Note que qualquer chamada de função em <expr>
          será completada depois das variáveis nela serem avalidas e
          que `ev(F(x))' dessa forma possa comportar-se como `F(ev(x))'.

       5. Para cada instância de `eval' nos argumentos, os passos (3) e
          (4) são repetidos.

     Exemplos

          (%i1) sin(x) + cos(y) + (w+1)^2 + 'diff (sin(w), w);
                                               d                    2
          (%o1)              cos(y) + sin(x) + -- (sin(w)) + (w + 1)
                                               dw
          (%i2) ev (%, sin, expand, diff, x=2, y=1);
                                    2
          (%o2)           cos(w) + w  + 2 w + cos(1) + 1.909297426825682

     Uma sintaxe alternativa de alto nível tem sido provida por `ev',
     por meio da qual se pode apenas digitar seus argumentos, sem o
     `ev()'.  Isto é, se pode escrever simplesmente

          <expr>, <arg_1>, ..., <arg_n>

     Isso não é permitido como parte de outra expressão, e.g., em
     funções, blocos, etc.

     Observe o processo de associação paralela no seguinte exemplo.

          (%i3) programmode: false;
          (%o3)                                false
          (%i4) x+y, x: a+y, y: 2;
          (%o4)                              y + a + 2
          (%i5) 2*x - 3*y = 3$
          (%i6) -3*x + 2*y = -4$
          (%i7) solve ([%o5, %o6]);
          Solution

                                                    1
          (%t7)                               y = - -
                                                    5

                                                   6
          (%t8)                                x = -
                                                   5
          (%o8)                            [[%t7, %t8]]
          (%i8) %o6, %o8;
          (%o8)                              - 4 = - 4
          (%i9) x + 1/x > gamma (1/2);
                                             1
          (%o9)                          x + - > sqrt(%pi)
                                             x
          (%i10) %, numer, x=1/2;
          (%o10)                      2.5 > 1.772453850905516
          (%i11) %, pred;
          (%o11)                               true


 -- Propriedade: evflag
     Quando um símbolo <x> tem a propriedade `evflag', as expressões
     `ev(<expr>, <x>)' e `<expr>, <x>' (na linha de comando interativa)
     são equivalentes a `ev(<expr>, <x> = true)'.  Isto é, <x> está
     associada a `true' enquanto <expr> for avaliada.

     A expressão `declare(<x>, evflag)' fornece a propriedade `evflag'
     para a variável <x>.

     Os sinalizadores que possuem a propriedade `evflag' por padrão são
     os seguintes: `algebraic', `cauchysum', `demoivre', `dotscrules',
     `%emode', `%enumer', `exponentialize', `exptisolate', `factorflag',
     `float', `halfangles', `infeval', `isolate_wrt_times', `keepfloat',
     `letrat', `listarith', `logabs', `logarc', `logexpand',
     `lognegint', `lognumer', `m1pbranch', `numer_pbranch',
     `programmode', `radexpand', `ratalgdenom', `ratfac', `ratmx',
     `ratsimpexpons', `simp', `simpsum', `sumexpand', e `trigexpand'.

     Exemplos:

          (%i1) sin (1/2);
                                           1
          (%o1)                        sin(-)
                                           2
          (%i2) sin (1/2), float;
          (%o2)                   0.479425538604203
          (%i3) sin (1/2), float=true;
          (%o3)                   0.479425538604203
          (%i4) simp : false;
          (%o4)                         false
          (%i5) 1 + 1;
          (%o5)                         1 + 1
          (%i6) 1 + 1, simp;
          (%o6)                           2
          (%i7) simp : true;
          (%o7)                         true
          (%i8) sum (1/k^2, k, 1, inf);
                                      inf
                                      ====
                                      \     1
          (%o8)                        >    --
                                      /      2
                                      ====  k
                                      k = 1
          (%i9) sum (1/k^2, k, 1, inf), simpsum;
                                           2
                                        %pi
          (%o9)                         ----
                                         6
          (%i10) declare (aa, evflag);
          (%o10)                        done
          (%i11) if aa = true then SIM else NÃO;
          (%o11)                         NÃO
          (%i12) if aa = true then SIM else NÃO, aa;
          (%o12)                         SIM


 -- Propriedade: evfun
     Quando uma função <F> tem a propriedade `evfun', as expressões
     `ev(<expr>, <F>)' e `<expr>, <F>' (na linha de comando interativa)
     são equivalentes a `<F>(ev(<expr>))'.

     Se duas ou mais funções <F>, <G>, etc., que possuem a propriedade
     `evfun' forem especificadas, as funções serão aplicadas na ordem
     em que forem especificadas.

     A expressão `declare(<F>, evfun)' fornece a propriedade `evfun'
     para a função <F>.

     As funções que possuem a propriedade `evfun' por padrão são as
     seguintes: `bfloat', `factor', `fullratsimp', `logcontract',
     `polarform', `radcan', `ratexpand', `ratsimp', `rectform',
     `rootscontract', `trigexpand', e `trigreduce'.

     Exemplos:

          (%i1) x^3 - 1;
                                        3
          (%o1)                        x  - 1
          (%i2) x^3 - 1, factor;
                                          2
          (%o2)                 (x - 1) (x  + x + 1)
          (%i3) factor (x^3 - 1);
                                          2
          (%o3)                 (x - 1) (x  + x + 1)
          (%i4) cos(4 * x) / sin(x)^4;
                                      cos(4 x)
          (%o4)                       --------
                                         4
                                      sin (x)
          (%i5) cos(4 * x) / sin(x)^4, trigexpand;
                           4           2       2         4
                        sin (x) - 6 cos (x) sin (x) + cos (x)
          (%o5)         -------------------------------------
                                          4
                                       sin (x)
          (%i6) cos(4 * x) / sin(x)^4, trigexpand, ratexpand;
                                     2         4
                                6 cos (x)   cos (x)
          (%o6)               - --------- + ------- + 1
                                    2          4
                                 sin (x)    sin (x)
          (%i7) ratexpand (trigexpand (cos(4 * x) / sin(x)^4));
                                     2         4
                                6 cos (x)   cos (x)
          (%o7)               - --------- + ------- + 1
                                    2          4
                                 sin (x)    sin (x)
          (%i8) declare ([F, G], evfun);
          (%o8)                         done
          (%i9) (aa : bb, bb : cc, cc : dd);
          (%o9)                          dd
          (%i10) aa;
          (%o10)                         bb
          (%i11) aa, F;
          (%o11)                        F(cc)
          (%i12) F (aa);
          (%o12)                        F(bb)
          (%i13) F (ev (aa));
          (%o13)                        F(cc)
          (%i14) aa, F, G;
          (%o14)                      G(F(cc))
          (%i15) G (F (ev (aa)));
          (%o15)                      G(F(cc))


 -- Variável de opção: infeval
     Habilita o modo "avaliação infinita".  `ev' repetidamente avalia
     uma expressão até que ela permaneça invariante.  Para prevenir uma
     variável, digamos `X', seja demoradamente avaliada nesso modo,
     simplesmente inclua `X='X' como um argumento para `ev'.
     Certamente expressões tais como `ev (X, X=X+1, infeval)' irão
     gerar um ciclo infinito.


 -- Função: kill (<a_1>, ..., <a_n>)
 -- Função: kill (labels)
 -- Função: kill (inlabels, outlabels, linelabels)
 -- Função: kill (<n>)
 -- Função: kill ([<m>, <n>])
 -- Função: kill (values, functions, arrays, ...)
 -- Função: kill (all)
 -- Função: kill (allbut (<a_1>, ..., <a_n>))
     Remove todas as associações (valor, funções, array, ou regra) dos
     argumentos <a_1>, ..., <a_n>.  Um argumento <a_k> pode ser um
     símbolo ou um elemento de array simples.  Quando <a_k> for um
     elemento de array simples, `kill' remove a associação daquele
     elemento sem afetar qualquer outro elemento do array.

     Muitos argumentos especiais são reconhecidos.  Diferentes famílias
     de argumentos podem ser combinadas, e.g., `kill (inlabels,
     functions, allbut (foo, bar))'

     todos os rótulos de entrada, de saída, e de expressões
     intermediárias criados até então.  `kill (inlabels)' libera
     somente rótudos de entrada que começam com o valor corrente de
     `inchar'.  De forma semelhante, `kill (outlabels)' libera somente
     rótulos de saída que começam com o valor corrente de `outchar', e
     `kill (linelabels)' libera somente rótulos de expressões
     intermediárias que começam com o valor corrente de `linechar'.

     `kill (<n>)', onde <n> é um inteiro, libera os <n> mais recentes
     rótulos de entrada e saída.

     `kill ([<m>, <n>])' libera rótulos de entrada e saída de <m> até
     <n>.

     `kill (<infolist>)', onde <infolist> é um item em `infolists'
     (tais como `values', `functions', ou `arrays') libera todos os
     ítens em <infolist>.  Veja também `infolists'.

     `kill (all)' liberar todos os ítens em todas as infolists.  `kill
     (all)' não retorna variáveis globais para seus valores padrões;
     Veja `reset' sobre esse ponto.

     `kill (allbut (<a_1>, ..., <a_n>))' remove a associação de todos
     os itens sobre todas as infolistas exceto para <a_1>, ..., <a_n>.
     `kill (allbut (<infolist>))' libera todos os ítens exceto para si
     próprio em <infolist>, onde <infolist> é `values', `functions',
     `arrays', etc.

     A memória usada por uma propriedade de associação não será
     liberada até que todos os símbolos sejam liberados disso.  Em
     particular, para liberar a memória usada pelo valor de um símbolo,
     deve-se liberar o rótulo de saída que mosta o valor associado, bem
     como liberando o próprio símbolo.

     `kill' coloca um apóstro em seus argumentos (não os avalia).  O
     operador apóstrofo-apóstrofo, `''', faz com que ocorra
     avaliação.

     `kill (<símbolo>)' libera todas as propriedades de <símbolo>.  Em
     oposição, `remvalue', `remfunction', `remarray', e `remrule'
     liberam uma propriedade específica.

     `kill' sempre retorna `done', igualmente se um argumento não tem
     associações.


 -- Função: labels (<símbolo>)
 -- Variável de sistema: labels
     Retorna a lista de rótulos de entradas, de saída, de expressões
     intermediárias que começam com <símbolo>.  Tipicamente <símbolo> é
     o valor de `inchar', `outchar', ou `linechar'.  O caracter rótulo
     pode ser dado com ou sem o sinal de porcentagem, então, por
     exemplo, `i' e `%i' retornam o mesmo resultado.

     Se nenhum rótulo começa com <símbolo>, `labels' retorna uma lista
     vazia.

     A função `labels' não avalia seu argumento.  O operador
     apóstrofo-apóstrofo `''' faz com que ocorra avaliação.  Por
     exemplo, `labels (''inchar)' retorna os rótulos de entrada que
     começam com o caractere corrente do rótulo de entrada.

     A variável `labels' é uma lista de rótulos de entrada, saída, e de
     expressões intermediárias, incluindo todos os rótulos anteriores
     se `inchar', `outchar', ou `linechar' que tiverem sido redefinidos.

     Por padrão, Maxima mostra o resultado de cada expressão de entrada
     do usuário, dando ao resultado um rótulo de saída.  A exibição da
     saída é suprimida pelo encerramento da entrada com `$' (sinal de
     dolar) em lugar de `;' (ponto e vírgula).  Um rótulo de saída é
     construido e associado ao resultado, mas não é mostrado, e o
     rótulo pode ser referenciado da mesma forma que rótulos de saída
     mostrados.  Veja também `%', `%%', e `%th'.

     Rótulos de expressões intermediárias podem ser gerados por algumas
     funções.  O sinalizador `programmode' controla se `solve' e
     algumas outras funções geram rótulos de expressões intermediárias
     em lugar de retornar uma lista de expressões.  Algumas outras
     funções, tais como `ldisplay', sempre geram rótulos de expressões
     intermediárias.

     Veja também `inchar', `outchar', `linechar', e `infolists'.


 -- Variável de sistema: linenum
     Retorna o número da linha do par corrente de expressões de entrada
     e saída.


 -- Variável de sistema: myoptions
     Valor padrão: `[]'

     `myoptions' é a lista de todas as opções alguma vez alteradas pelo
     usuário, tenha ou não ele retornado a alteração para o seu valor
     padrão.


 -- Variável de opção: nolabels
     Valor padrão: `false'

     Quando `nolabels' for `true', rótulos de entrada e saída (`%i' e
     `%o', respectivamente) são mostrados, mas os rótulos não são
     associados aos resultados, e os rótulos não são anexados ao final
     da lista `labels'.  Uma vez que rótulos não são associados aos
     resultados, a reciclagem pode recuperar a memória tomada pelos
     resultados.

     De outra forma rótulos de entrada e saída são associados aos
     resultados, e os rótulos são anexados ao final da lista `labels'.

     Veja também `batch', `batchload', e `labels'.


 -- Variável de opção: optionset
     Valor padrão: `false'

     Quando `optionset' for `true', Maxima mostrará uma mensagem sempre
     que uma opção do Maxima for alterada.  Isso é útil se o usuário
     está incerto sobre a ortografia de alguma opção e quer ter certeza
     que a variável por ele atribuído um valor foi realmente uma
     variável de opção.


 -- Função: playback ()
 -- Função: playback (<n>)
 -- Função: playback ([<m>, <n>])
 -- Função: playback ([<m>])
 -- Função: playback (input)
 -- Função: playback (slow)
 -- Função: playback (time)
 -- Função: playback (grind)
     Mostra expressões de entrada, de saída, e expressões
     intermediárias, sem refazer os cálculos.  `playback' somente
     mostra as expressões associadas a rótulos; qualquer outra saída
     (tais como textos impressos por `print' ou `describe', ou
     messagens de erro) não é mostrada.  Veja também `labels'.

     `playback' não avalia seus argumentos.  O operador
     apóstrofo-apóstrofo, `''', sobrepõe-se às aspas.  `playback'
     sempre retorna `done'.

     `playback ()' (sem argumentos) mostra todas as entradas, saídas e
     expressões intermediárias geradas até então.  Uma expressão de
     saída é mostrada mesmo se for suprimida pelo terminador `$' quando
     ela tiver sido originalmente calculada.

     `playback (<n>)' mostra as mais recentes <n> expressões.  Cada
     entrada, saída e expressão intermediária conta como um.

     `playback ([<m>, <n>])' mostra entradas, saídas e expressões
     intermediárias com os números de <m> até <n>, inclusive.

     `playback ([<m>])' é equivalente a `playback ([<m>, <m>])'; isso
     usualmente imprime um par de expressões de entrada e saída.

     `playback (input)' mostra todas as expressões de entrada geradas
     até então.

     `playback (slow)' insere pausas entre expressões e espera que o
     usuário pressione `enter'.  Esse comportamento é similar a `demo'.
     `playback (slow)' é útil juntamente com `save' ou `stringout'
     quando criamos um arquivo secundário de armazenagem com a
     finalidade de capturar expressões úteis.

     `playback (time)' mostra o tempo de computação de cada expressão.

     `playback (grind)' mostra expressões de entrada no mesmo formato
     da função `grind'.  Expressões de saída não são afetadas pela
     opção `grind'.  Veja `grind'.

     Argumentos podem ser combinados, e.g., `playback ([5, 10], grind,
     time, slow)'.


 -- Função: printprops (<a>, <i>)
 -- Função: printprops ([<a_1>, ..., <a_n>], <i>)
 -- Função: printprops (all, <i>)
     Mostra a propriedade como o indicador <i> associada com o átomo
     <a>.  <a> pode também ser uma lista de átomos ou o átomo `all'
     nesse caso todos os átomos com a propriedade dada serão usados.
     Por exemplo, `printprops ([f, g], atvalue)'.  `printprops' é para
     propriedades que não podem  ser mostradas de outra forma, i.e. para
     `atvalue', `atomgrad', `gradef', e `matchdeclare'.


 -- Variável de opção: prompt
     Valor padrão: `_'

     `prompt' é o símbolo de linha de comando da função `demo', modo
     `playback (slow)', e da interrupção de ciclos do Maxima (como
     invocado por `break').


 -- Função: quit ()
     Encerra a sessão do Maxima.  Note que a função pode ser invocada
     como `quit();' ou `quit()$', não por sí mesma `quit'.

     Para parar um cálculo muito longo, digite `control-C'.  A ação
     padrão é retornar à linha de comando do Maxima.  Se
     `*debugger-hook*' é `nil', `control-C' abre o depurador Lisp.
     Veja também `debugging'.


 -- Função: remfunction (<f_1>, ..., <f_n>)
 -- Função: remfunction (all)
     Desassocia as definições de função dos síbolos <f_1>, ..., <f_n>.
     Os argumentos podem ser os nomes de funções comuns (criadas por
     meio de `:=' ou `define') ou funções macro (criadas por meio de
     `::=').

     `remfunction (all)' desassocia todas as definições de funcção.

     `remfunction' coloca um ap'ostrofo em seus argumentos (não os
     avalia).

     `remfunction' retorna uma lista de símbolos para a qual a
     definição de função foi desassociada.  `false' é retornado em
     lugar de qualquer símbolo para o qual não exista definição de
     função.


 -- Função: reset ()
     Retorna muitas variáveis globais e opções, e algumas outras
     variáveis, para seus valores padrões.

     `reset' processa as variáveis na lista Lisp
     `*variable-initial-values*'.  A macro Lisp `defmvar' coloca
     variáveis nessa lista (entre outras ações).  Muitas, mas não
     todas, variáveis globais e opções são definidas por `defmvar',  e
     algumas variáveis definidas por `defmvar' não são variáveis
     globais ou variáveis de opção.


 -- Variável de opção: showtime
     Valor padrão: `false'

     Quando `showtime' for `true', o tempo de computação e o tempo
     decorrido são impressos na tela com cada expressão de saída.

     O tempo de cálculo é sempre gravado, então `time' e `playback'
     podem mostrar o tempo de cálculo mesmo quando `showtime' for
     `false'.

     Veja também `timer'.


 -- Função: sstatus (<recurso>, <pacote>)
     Altera o status de <recurso> em <pacote>.  Após `sstatus
     (<recurso>, <pacote>)' ser executado, `status (<recurso>,
     <pacote>)' retorna `true'.  Isso pode ser útil para quem escreve
     pacotes, para manter um registro de quais recursos os pacotes usam.


 -- Função: to_lisp ()
     Insere o sistema Lisp dentro do Maxima.  `(to-maxima)' retorna
     para o Maxima.


 -- Variável de sistema: values
     Valor inicial: `[]'

     `values' é uma lista de todas as varáveis de usuário associadas
     (não opções Maxima ou comutadores).  A lista compreende símbolos
     associados por `:' , `::', ou `:='.



File: maxima.info,  Node: Operadores,  Next: Expressões,  Prev: Linha de Comando,  Up: Top

5 Operadores
************

* Menu:

* N-Argumentos::
* Operador não fixado::
* Operador Pósfixado::
* Operador Préfixado::
* Operadores Aritméticos::
* Operadores Relacionais::
* Operadores Geral::


File: maxima.info,  Node: N-Argumentos,  Next: Operador não fixado,  Prev: Operadores,  Up: Operadores

5.1 N-Argumentos
================

Um operador `nary' é usado para denotar uma função com qualquer número
de argumentos, cada um dos quais é separado por uma ocorrência do
operador, e.g. A+B ou A+B+C.  A função `nary("x")'  é uma função de
extensão sintática para declarar x como sendo um operador `nary'.
Funções podem ser declaradas para serem `nary'.  Se `declare(j,nary);'
é concluída, diz ao simplicador para simplificar, e.g.
`j(j(a,b),j(c,d))' para `j(a, b, c, d)'.

   Veja também `syntax'.


File: maxima.info,  Node: Operador não fixado,  Next: Operador Pósfixado,  Prev: N-Argumentos,  Up: Operadores

5.2 Operador não fixado
=======================

Operadores `nofix' são usados para denotar funções sem argumentos.  A
mera presença de tal operador em um comando fará com que a função
correspondente seja avaliada.  Por exemplo, quando se digita "exit;"
para sair de uma parada do Maxima, "exit" tem comportamento similar a um
operador `nofix'.  A função `nofix("x")' é uma função de extensão
sintática que declara x como sendo um operador `nofix'.

   Veja também `syntax'.


File: maxima.info,  Node: Operador Pósfixado,  Next: Operador Préfixado,  Prev: Operador não fixado,  Up: Operadores

5.3 Operador Pósfixado
======================

Operadores `postfix' como a variedade `prefix' denotam funções de um
argumento simples, mas nesse caso  o argumento sucede imediatamente uma
ocorrência do operador na seqüência de caracteres de entrada, e.g. 3! .
Uma função `postfix("x")' é uma função de extensão sintática que
declara x como sendo um operador `postfix'.

   Veja também `syntax'.


File: maxima.info,  Node: Operador Préfixado,  Next: Operadores Aritméticos,  Prev: Operador Pósfixado,  Up: Operadores

5.4 Operador Préfixado
======================

Um operador `prefix' é um que significa uma função de um argumento, o
qual imediatamente segue uma ocorrência do operador.  `prefix("x")' é
uma função de extensão sintática que declara x como sendo um operador
`prefix'.

   Veja também `syntax'.


File: maxima.info,  Node: Operadores Aritméticos,  Next: Operadores Relacionais,  Prev: Operador Préfixado,  Up: Operadores

5.5 Operadores Aritméticos
==========================

 -- Operador: +
 -- Operador: -
 -- Operador: *
 -- Operador: /
 -- Operador: ^
     Os símbolos `+' `*' `/' e `^' representam adição, multiplicação,
     divisão, e exponenciação, respectivamente.  O nome desses
     operadores são `"+"' `"*"' `"/"' e `"^"', os quais podem aparecer
     em lugares onde o nome da função ou operador é requerido.

     Os símbolos `+' e `-' representam a adição unária e a negação
     unária, respectivamente, e os nomes desses operadores são `"+"' e
     `"-"', respectivamente.

     A subtração `a - b' é representada dentro do Maxima como a
     adição, `a + (- b)'.  Expressões tais como `a + (- b)' são
     mostradas como subtração.  Maxima reconhece `"-"' somente como o
     nome do operador unário de negação, e não como o nome do operador
     binário de subração.

     A divisão `a / b' é representada dentro do Maxima como
     multiplicação, `a * b^(- 1)'.  Expressões tais como `a * b^(- 1)'
     são mostradas como divisão.  Maxima reconhece `"/"' como o nome do
     operador de divisão.

     A adição e a multiplicação são operadores enários e comutativos.
     a divisão e a exponenciação são operadores binários e não
     comutativos.

     Maxima ordena os operandos de operadores não comutativos para
     construir uma representação canônica.  Para armazenamento interno,
     a ordem é determinada por `orderlessp'.  Para mostrar na tela, a
     ordem para adição é determinada por `ordergreatp', e para a
     multiplicação, a ordem é a mesma da ordenação para armazenamento
     interno.

     Computações aritiméticas são realizadas sobre números literais
     (inteiro, racionais, números comuns em ponto flutuante, e grandes
     números em ponto flutuante de dupla precisão).  Execto a
     exponenciação, todas as operações aritméticas sobre números são
     simplificadas para números.  A exponenciação é simplificada para
     um número se ou o operando é um número comum em ponto flutuante ou
     um grande número em ponto flutuante de dupla precisão ou se o
     resultado for um inteiro exato ou um racional exato; de outra
     forma uma exponenciação pode ser simplificada para `sqrt' ou outra
     exponenciação ou permanecer inalterada.

     A propagação de números em ponto flutuante aplica-se a
     computações aritiméticas: Se qualquer operando for um grande
     número em ponto flutuante, o resultado é um grande número em ponto
     flutuante; de outra forma, se qualquer operando for um número em
     ponto flutuante comum, o resultado é um número comum em ponto
     flutuante; de outra forma, se os operandos forem racioanis ou
     inteiros e o resultado será um racional ou inteiro.

     Computaçãoes aritiméticas são uma simplificação, não uma
     avaliação.  Dessa forma a aritmética é realizada em  expressões
     com apóstrofo (mas simplificadas).

     Operações aritméticas são aplicadas elemento-por-elemento para
     listas quando a variável global `listarith' for `true', e sempre
     aplicada elemento-por-elemento para matrizes.  Quando um operando
     for uma lista ou uma matriz e outro for um operando de algum outro
     tipo, o outro operando é combinado com cada um dos elementos da
     lista ou matriz.

     Exemplos:

     Adição e multiplicação são opeadores enários comutativos.  Maxima
     ordena os operandos para construir uma representação canônica.  Os
     nomes desses operadores são `"+"' e `"*"'.

          (%i1) c + g + d + a + b + e + f;
          (%o1)               g + f + e + d + c + b + a
          (%i2) [op (%), args (%)];
          (%o2)              [+, [g, f, e, d, c, b, a]]
          (%i3) c * g * d * a * b * e * f;
          (%o3)                     a b c d e f g
          (%i4) [op (%), args (%)];
          (%o4)              [*, [a, b, c, d, e, f, g]]
          (%i5) apply ("+", [a, 8, x, 2, 9, x, x, a]);
          (%o5)                    3 x + 2 a + 19
          (%i6) apply ("*", [a, 8, x, 2, 9, x, x, a]);
                                           2  3
          (%o6)                       144 a  x

     Divisão e exponenciação são operadores binários e não comutativos.
     Os nomes desses operadores são `"/"' e `"^"'.

          (%i1) [a / b, a ^ b];
                                        a   b
          (%o1)                        [-, a ]
                                        b
          (%i2) [map (op, %), map (args, %)];
          (%o2)              [[/, ^], [[a, b], [a, b]]]
          (%i3) [apply ("/", [a, b]), apply ("^", [a, b])];
                                        a   b
          (%o3)                        [-, a ]
                                        b

     Subtração e divisão são representados internamente em termos de
     adição e multiplicação, respectivamente.

          (%i1) [inpart (a - b, 0), inpart (a - b, 1), inpart (a - b, 2)];
          (%o1)                      [+, a, - b]
          (%i2) [inpart (a / b, 0), inpart (a / b, 1), inpart (a / b, 2)];
                                             1
          (%o2)                       [*, a, -]
                                             b

     Cálculos são realizados sobre números lterais.  A propagação de
     números em poto flutuante aplica-se.

          (%i1) 17 + b - (1/2)*29 + 11^(2/4);
                                                 5
          (%o1)                   b + sqrt(11) + -
                                                 2
          (%i2) [17 + 29, 17 + 29.0, 17 + 29b0];
          (%o2)                   [46, 46.0, 4.6b1]

     Computações aritméticas são uma simplificação, não uma
     avaliação.

          (%i1) simp : false;
          (%o1)                         false
          (%i2) '(17 + 29*11/7 - 5^3);
                                        29 11    3
          (%o2)                    17 + ----- - 5
                                          7
          (%i3) simp : true;
          (%o3)                         true
          (%i4) '(17 + 29*11/7 - 5^3);
                                          437
          (%o4)                         - ---
                                           7

     A aritmética é realizada elemento-por-elemento para listas lists
     (dependendo de `listarith') e dependendo de matrizes.

          (%i1) matrix ([a, x], [h, u]) - matrix ([1, 2], [3, 4]);
                                  [ a - 1  x - 2 ]
          (%o1)                   [              ]
                                  [ h - 3  u - 4 ]
          (%i2) 5 * matrix ([a, x], [h, u]);
                                    [ 5 a  5 x ]
          (%o2)                     [          ]
                                    [ 5 h  5 u ]
          (%i3) listarith : false;
          (%o3)                         false
          (%i4) [a, c, m, t] / [1, 7, 2, 9];
                                    [a, c, m, t]
          (%o4)                     ------------
                                    [1, 7, 2, 9]
          (%i5) [a, c, m, t] ^ x;
                                                x
          (%o5)                     [a, c, m, t]
          (%i6) listarith : true;
          (%o6)                         true
          (%i7) [a, c, m, t] / [1, 7, 2, 9];
                                        c  m  t
          (%o7)                     [a, -, -, -]
                                        7  2  9
          (%i8) [a, c, m, t] ^ x;
                                    x   x   x   x
          (%o8)                   [a , c , m , t ]


 -- Operador: **
     Operador de exponenciação.  Maxima reconhece `**' como o mesmo
     operador que `^' em entrada, e `**' é mostrado como `^' em saída
     unidimensional, ou colocando o expoente  como sobrescrito em saída
     bidimensional.

     A função `fortran' mostra o operador de exponenciação com como
     `**', independente de a entrada ter sido na forma `**' ou a forma
     `^'.

     Exemplos:

          (%i1) is (a**b = a^b);
          (%o1)                         true
          (%i2) x**y + x^z;
                                        z    y
          (%o2)                        x  + x
          (%i3) string (x**y + x^z);
          (%o3)                        x^z+x^y
          (%i4) fortran (x**y + x^z);
                x**z+x**y
          (%o4)                         done



File: maxima.info,  Node: Operadores Relacionais,  Next: Operadores Geral,  Prev: Operadores Aritméticos,  Up: Operadores

5.6 Operadores Relacionais
==========================

 -- Operador: <
 -- Operador: <=
 -- Operador: >=
 -- Operador: >


File: maxima.info,  Node: Operadores Geral,  Prev: Operadores Relacionais,  Up: Operadores

5.7 Operadores Geral
====================

 -- Operador: ^^

 -- Operador: !
     O operador fatorial.  Para qualquer número complexo `x' (incluíndo
     números inteiros, racionais, e reais) exceto para inteiros
     negativos, `x!' é definido como `gamma(x+1)'.

     Para um inteiro `x', `x!' simplifica para o produto de inteiros de
     1 a `x' inclusive.  `0!' simplifica para 1.  Para um número em
     ponto flutuante `x', `x!' simplifica para o valor de `gamma (x+1)'.
     Para `x' igual a `n/2' onde `n' é um inteiro ímpar, `x!'
     simplifica para um fator racional vezes `sqrt (%pi)' (uma vez que
     `gamma (1/2)' é igual a `sqrt (%pi)').  Se `x' for qualquer outra
     coisa, `x!' não é simplificado.

     As variáveis `factlim', `minfactorial', e `factcomb' controlam a
     simplificação de expressões contendo fatoriais.

     As funções `gamma', `bffac', e `cbffac' são variedades da
     função `gamma'.  `makegamma' substitui `gamma' para funções
     relacionadas a fatoriais.

     Veja também `binomial'.

     O fatorial de um inteiro, inteiro dividido por dois, ou argumento
     em ponto flutuante é simplificado a menos que o operando seja
     maior que `factlim'.

          (%i1) factlim : 10;
          (%o1)                          10
          (%i2) [0!, (7/2)!, 4.77!, 8!, 20!];
          +            105 sqrt(%pi)
          +(%o2)   [1, -------------, 81.44668037931199, 40320, 20!]
          +                 16

     O fatorial de um número complexo, constante conhecida, ou
     expressão geral não é simplificado.  Ainda assim pode ser possível
     simplificar o fatorial após avaliar o operando.

          (%i1) [(%i + 1)!, %pi!, %e!, (cos(1) + sin(1))!];
          (%o1)      [(%i + 1)!, %pi!, %e!, (sin(1) + cos(1))!]
          (%i2) ev (%, numer, %enumer);
          (%o2) [(%i + 1)!, 7.188082728976037, 4.260820476357,
                                                         1.227580202486819]

     O fatorial de um símbolo não associado não é simplificado.

          (%i1) kill (foo);
          (%o1)                         done
          (%i2) foo!;
          (%o2)                         foo!

     Fatoriais são simplificados, não avaliados.  Dessa forma `x!' pode
     ser substituído mesmo em uma expressão com apóstrofo.

          (%i1) '([0!, (7/2)!, 4.77!, 8!, 20!]);
                    105 sqrt(%pi)
          (%o1) [1, -------------, 81.44668037931199, 40320,
                         16
                                                       2432902008176640000]


 -- Operador: !!
     O operador de duplo fatorial.

     Para um número inteiro, número em ponto flutuante, ou número
     racional `n', `n!!' avalia para o produto `n (n-2) (n-4) (n-6) ...
     (n - 2 (k-1))' onde `k' é igual a `entier (n/2)', que é, o maior
     inteiro menor que ou igual a `n/2'.  Note que essa definição não
     coincide com outras definições publicadas para argumentos que não
     são inteiros.

     Para um inteiro par (ou ímpar) `n', `n!!' avalia para o produto de
     todos os inteiros consecutivos pares (ou ímpares) de 2 (ou 1) até
     `n' inclusive.

     Para um argumento `n' que não é um número inteiro, um número em
     ponto flutuante, ou um número racional, `n!!' retorna uma forma
     substantiva `genfact (n, n/2, 2)'.


 -- Operador: #
     Representa a negação da igualdade sintática `='.

     Note que pelo fato de as regras de avaliação de expressões
     predicadas (em particular pelo fato de `not <expr>' fazer com que
     ocorra a avaliação de <expr>), a forma `not <a> = <b>' não é
     equivalente à forma `<a> # <b>' em alguns casos.

     Note que devido às regras para avaliação de expressões predicadas
     (em particular devido a `not <expr>' fazer com que a avaliação de
     <expr> ocorra), `not <a> = <b>' é equivalente a `is(<a> # <b>)',
     em lugar de ser equivalente a `<a> # <b>'.

     Exemplos:
          (%i1) a = b;
          (%o1)                         a = b
          (%i2) é (a = b);
          (%o2)                         false
          (%i3) a # b;
          (%o3)                         a # b
          (%i4) not a = b;
          (%o4)                         true
          (%i5) é (a # b);
          (%o5)                         true
          (%i6) é (not a = b);
          (%o6)                         true


 -- Operador: .
     O operador ponto, para multiplicação (não comutativa) de matrizes.
     Quando "." é usado com essa finalidade, espaços devem ser
     colocados em ambos os lados desse operador, e.g. A . B.  Isso
     distingüe o operador ponto plenamente de um ponto decimal em um
     número em ponto flutuante.

     Veja também `dot', `dot0nscsimp', `dot0simp', `dot1simp',
     `dotassoc', `dotconstrules', `dotdistrib', `dotexptsimp',
     `dotident', e `dotscrules'.


 -- Operador: :
     O operador de atribuição.  E.g. A:3 escolhe a variável A para 3.


 -- Operador: ::
     Operador de atribuição.  :: atribui o valor da expressão em seu
     lado direito para o valor da quantidade na sua esquerda, que pode
     avaliar para uma variável atômica ou variável subscrita.


 -- Operador: ::=
     Operador de definição de função de macro.  `::=' define uma
     função (chamada uma "macro" por razões históricas) que coloca um
     apóstrofo em seus argumentos (evitando avaliação), e a expressão
     que é retornada (chamada a "expansão de macro") é avaliada no
     contexto a partir do qual a macro foi chamada.  Uma função de
     macro é de outra forma o mesmo que uma função comum.

     `macroexpand' retorna uma expansão de macro (sem avaliar a
     expansão).  `macroexpand (foo (x))' seguida por `''%' é
     equivalente a `foo (x)' quando `foo' for uma função de macro.

     `::=' coloca o nome da nova função de macro dentro da lista global
     `macros'.  `kill', `remove', e `remfunction' desassocia
     definições de função de macro e remove nomes de `macros'.

     `fundef' e `dispfun' retornam respectivamente uma definição de
     função de macro e uma atribuição dessa definição a um rótulo,
     respectivamente.

     Funções de macro comumente possuem expressões `buildq' e `splice'
     para construir uma expressão, que é então avaliada.

     Exemplos

     Uma função de macro coloca um apóstrofo em seus argumentos
     evitando então a avaliação, então mensagem (1) mostra `y - z', não
     o valor de `y - z'.  A expansão de macro (a expressão com
     apóstrofo `'(print ("(2) x is equal to", x))' é avaliada no
     contexto a partir do qual a macro for chamada, mostrando a
     mensagem (2).

          (%i1) x: %pi;
          (%o1)                          %pi
          (%i2) y: 1234;
          (%o2)                         1234
          (%i3) z: 1729 * w;
          (%o3)                        1729 w
          (%i4) printq1 (x) ::= block (print ("(1) x é igual a", x), '(print ("(2) x é igual a", x)));
          (%o4) printq1(x) ::= block(print("(1) x é igual a", x),
                                          '(print("(2) x é igual a", x)))
          (%i5) printq1 (y - z);
          (1) x é igual a y - z
          (2) x é igual a %pi
          (%o5)                          %pi

     Uma função comum avalia seus argumentos, então message (1) mostra
     o valor de `y - z'.  O valor de retorno não é avaliado, então
     mensagem (2) não é mostrada até a avaliação explícita `''%'.

          (%i1) x: %pi;
          (%o1)                          %pi
          (%i2) y: 1234;
          (%o2)                         1234
          (%i3) z: 1729 * w;
          (%o3)                        1729 w
          (%i4) printe1 (x) := block (print ("(1) x é igual a", x), '(print ("(2) x é igual a", x)));
          (%o4) printe1(x) := block(print("(1) x é igual a", x),
                                          '(print("(2) x é igual a", x)))
          (%i5) printe1 (y - z);
          (1) x é igual a 1234 - 1729 w
          (%o5)              print((2) x é igual a, x)
          (%i6) ''%;
          (2) x é igual a %pi
          (%o6)                          %pi

     `macroexpand' retorna uma expansão de macro.  `macroexpand (foo
     (x))' seguido por `''%' é equivalente a `foo (x)' quando `foo' for
     uma função de macro.

          (%i1) x: %pi;
          (%o1)                          %pi
          (%i2) y: 1234;
          (%o2)                         1234
          (%i3) z: 1729 * w;
          (%o3)                        1729 w
          (%i4) g (x) ::= buildq ([x], print ("x é igual a", x));
          (%o4)    g(x) ::= buildq([x], print("x é igual a", x))
          (%i5) macroexpand (g (y - z));
          (%o5)              print(x é igual a, y - z)
          (%i6) ''%;
          x é igual a 1234 - 1729 w
          (%o6)                     1234 - 1729 w
          (%i7) g (y - z);
          x é igual a 1234 - 1729 w
          (%o7)                     1234 - 1729 w


 -- Operador: :=
     O operador de definição de função.  E.g. `f(x):=sin(x)' define uma
     função `f'.


 -- Operador: =
     O operador de equação.

     Uma expressão `<a> = <b>', por si mesma, representa uma equação
     não avaliada, a qual pode ou não se manter.  Equações não
     avaliadas podem aparecer como argumentos para `solve' e `algsys'
     ou algumas outras funções.

     A função `is' avalia `=' para um valor Booleano.  `is(<a> = <b>)'
     avalia `<a> = <b>' para `true' quando <a> e <b> forem idênticos.
     Isto é, <a> e <b> forem átomos que são idênticos, ou se eles não
     forem átomos e seus operadores forem idênticos e seus argumentos
     forem idênticos.  De outra forma, `is(<a> = <b>)' avalia para
     `false'; `is(<a> = <b>)' nunca avalia para `unknown'.  Quando
     `is(<a> = <b>)' for `true', <a> e <b> são ditos para serem
     sintaticamente iguais, em contraste para serem expressões
     equivalentes, para as quais `is(equal(<a>, <b>))' é `true'.
     Expressões podem ser equivalentes e não sintáticamente iguais.

     A negação de `=' é representada por `#'.  Da mesma forma que com
     `=', uma expressão `<a> # <b>', por si mesma, não é avaliada.
     `is(<a> # <b>)' avalia `<a> # <b>' para `true' ou `false'.

     Complementando a função `is', alguns outros operadores avaliam `='
     e `#' para `true' ou `false', a saber `if', `and', `or', e `not'.

     Note que pelo fato de as regras de avaliação de expressões
     predicadas (em particular pelo fato de `not <expr>' fazer com que
     ocorra a avaliação de <expr>), a forma `not <a> = <b>' é
     equivalente a `is(<a> # <b>)', em lugar de ser equivalente a `<a>
     # <b>'.

     `rhs' e `lhs' retornam o primeiro membro e o segundo membro de uma
     equação, respectivamente, de uma equação ou inequação.

     Veja também `equal' e `notequal'.

     Exemplos:

     Uma expressão `<a> = <b>', por si mesma, representa uma equação
     não avaliada, a qual pode ou não se manter.

          (%i1) eq_1 : a * x - 5 * y = 17;
          (%o1)                    a x - 5 y = 17
          (%i2) eq_2 : b * x + 3 * y = 29;
          (%o2)                    3 y + b x = 29
          (%i3) solve ([eq_1, eq_2], [x, y]);
                                  196         29 a - 17 b
          (%o3)          [[x = ---------, y = -----------]]
                               5 b + 3 a       5 b + 3 a
          (%i4) subst (%, [eq_1, eq_2]);
                   196 a     5 (29 a - 17 b)
          (%o4) [--------- - --------------- = 17,
                 5 b + 3 a      5 b + 3 a
                                            196 b     3 (29 a - 17 b)
                                          --------- + --------------- = 29]
                                          5 b + 3 a      5 b + 3 a
          (%i5) ratsimp (%);
          (%o5)                  [17 = 17, 29 = 29]

     `is(<a> = <b>)' avalia `<a> = <b>' para `true' quando <a> e <b>
     são sintaticamente iguais (isto é, identicos).  Expressões podem
     ser equivalentes e não sintaticamente iguais.

          (%i1) a : (x + 1) * (x - 1);
          (%o1)                    (x - 1) (x + 1)
          (%i2) b : x^2 - 1;
                                        2
          (%o2)                        x  - 1
          (%i3) [is (a = b), is (a # b)];
          (%o3)                     [false, true]
          (%i4) [is (equal (a, b)), is (notequal (a, b))];
          (%o4)                     [true, false]

     Alguns operadores avaliam `=' e `#' para `true' ou `false'.

          (%i1) if expand ((x + y)^2) = x^2 + 2 * x * y + y^2 then FOO else BAR;
          (%o1)                          FOO
          (%i2) eq_3 : 2 * x = 3 * x;
          (%o2)                       2 x = 3 x
          (%i3) eq_4 : exp (2) = %e^2;
                                        2     2
          (%o3)                       %e  = %e
          (%i4) [eq_3 and eq_4, eq_3 or eq_4, not eq_3];
          (%o4)                  [false, true, true]

     Devido a `not <expr>' fazer com que a avaliação de <expr> ocorra,
     `not <a> = <b>' é equivalente a `is(<a> # <b>)'.

          (%i1) [2 * x # 3 * x, not (2 * x = 3 * x)];
          (%o1)                   [2 x # 3 x, true]
          (%i2) is (2 * x # 3 * x);
          (%o2)                         true


 -- Operador: and
     O operador lógico de conjunção.  `and' é um operador n-ário infixo;
     seus operandos são expressões Booleanas, e seu resultado é um
     valor Booleano.

     `and' força avaliação (como `is') de um ou mais operandos, e pode
     forçar a avaliação de todos os operandos.

     Operandos são avaliados na ordem em que aparecerem.  `and' avalia
     somente quantos de seus operandos forem necessários para
     determinar o resultado.  Se qualquer operando for `false', o
     resultado é `false' e os operandos restantes não são avaliados.

     O sinalizador global `prederror' governa o comportamento de `and'
     quando um operando avaliado não pode ser determinado como sendo
     `true' ou `false'.  `and' imprime uma mensagem de erro quando
     `prederror' for `true'.  De outra forma, operandos que não avaliam
     para `true' ou para `false' são aceitos, and o resultado é uma
     expressão Booleana.

     `and' não é comutativo: `a and b' pode não ser igual a `b and a'
     devido ao tratamento de operandos indeterminados.


 -- Operador: or
     O operador lógico de disjunção.  `or' é um operador n-ário infixo;
     seus operandos são expressões Booleanas, e seu resultado é um
     valor Booleano.

     `or' força avaliação (como `is') de um ou mais operandos, e pode
     forçar a avaliação de todos os operandos.

     Operandos são avaliados na ordem em que aparecem.  `or' avalia
     somente quantos de seus operandos forem necessários para
     determinar o resultado.  Se qualquer operando for `true', o
     resultado é `true' e os operandos restantes não são avaliados.

     O sinalizador global `prederror' governa o comportamento de `or'
     quando um operando avaliado não puder ser determinado como sendo
     `true' ou `false'.  `or' imprime uma mensagem de erro quando
     `prederror' for `true'.  De outra forma, operandos que não avaliam
     para `true' ou para `false' são aceitos, E o resultado é uma
     expressão Booleana.

     `or' não é comutativo: `a or b' pode não ser igual a `b or a'
     devido ao tratamento de operando indeterminados.


 -- Operador: not
     O operador lógico de negação.  `not' é operador prefixado; Seu
     operando é uma expressão Booleana, e seu resultado é um valor
     Booleano.

     `not' força a avaliação (como `is') de seu operando.

     O sinalizador global `prederror' governa o comportamento de `not'
     quando seu operando não pode ser determinado em termos de `true'
     ou `false'.  `not' imprime uma mensagem de erro quando `prederror'
     for `true'.  De outra forma, operandos que não avaliam para `true'
     ou para `false' são aceitos, e o resultado é uma expressão
     Booleana.


 -- Função: abs (<expr>)
     Retorna o valor absoluto de <expr>.  Se <expr> for um número
     complexo, retorna o módulo complexo de <expr>.


 -- Palavra chave: additive
     Se `declare(f,additive)' tiver sido executado, então:

     (1) Se `f' for uma função de uma única variável, sempre que o
     simplificador encontrar `f' aplicada a uma adição, `f' será
     distribuído sobre aquela adição.  I.e. `f(y+x)' irá simplificar
     para `f(y)+f(x)'.

     (2) Se `f' for uma função de 2 ou mais argumentos, a adição é
     definida como adição no primeiro argumento para `f', como no caso
     de `sum' ou `integrate', i.e. `f(h(x)+g(x),x)' irá simplificar
     para `f(h(x),x)+f(g(x),x)'.  Essa simplificação não ocorre quando
     `f' é aplicada para expressões da forma
     `sum(x[i],i,lower-limit,upper-limit)'.


 -- Palavra chave: allbut
     trabalha com os comandos `part' (i.e. `part', `inpart',
     `substpart', `substinpart', `dpart', e `lpart').  Por exemplo,

          (%i1) expr : e + d + c + b + a;
          (%o1)                   e + d + c + b + a
          (%i2) part (expr, [2, 5]);
          (%o2)                         d + a

     enquanto

          (%i1) expr : e + d + c + b + a;
          (%o1)                   e + d + c + b + a
          (%i2) part (expr, allbut (2, 5));
          (%o2)                       e + c + b

     `allbut' é também reconhecido por `kill'.

          (%i1) [aa : 11, bb : 22, cc : 33, dd : 44, ee : 55];
          (%o1)                 [11, 22, 33, 44, 55]
          (%i2) kill (allbut (cc, dd));
          (%o0)                         done
          (%i1) [aa, bb, cc, dd];
          (%o1)                   [aa, bb, 33, 44]

     `kill(allbut(<a_1>, <a_2>, ...))' tem o mesmo efeito que
     `kill(all)' exceto que não elimina os símbolos <a_1>, <a_2>, ... .


 -- Declaração: antisymmetric
     Se `declare(h,antisymmetric)' é concluída, diz ao simplicador que
     `h' é uma função antisimétrica.  E.g. `h(x,z,y)' simplificará para
     `- h(x, y, z)'.  Isto é, dará (-1)^n vezes o resultado dado por
     `symmetric' ou `commutative', quando n for o número de
     interescolhas de dois argumentos necessários para converter isso
     naquela forma.


 -- Função: cabs (<expr>)
     Retorna o valor absoluto complexo (o módulo complexo) de <expr>.


 -- Função: ceiling (<x>)
     Quando <x> for um número real, retorna o último inteiro que é
     maior que ou igual a <x>.

     Se <x> for uma expressão constante (`10 * %pi', por exemplo),
     `ceiling' avalia <x> usando grandes números em ponto flutuante, e
     aplica `ceiling' para o grande número em ponto flutuante
     resultante. Porque `ceiling' usa avaliação de ponto flutuante, é
     possível, embora improvável, que `ceiling' possa retornar uma
     valor errôneo para entradas constantes. Para prevenir erros, a
     avaliação de ponto flutuante é concluída usando três valores para
     `fpprec'.

     Para entradas não constantes, `ceiling' tenta retornar um valor
     simplificado.  Aqui está um exemplo de simplificações que `ceiling'
     conhece:

          (%i1) ceiling (ceiling (x));
          (%o1)                      ceiling(x)
          (%i2) ceiling (floor (x));
          (%o2)                       floor(x)
          (%i3) declare (n, integer)$
          (%i4) [ceiling (n), ceiling (abs (n)), ceiling (max (n, 6))];
          (%o4)                [n, abs(n), max(n, 6)]
          (%i5) assume (x > 0, x < 1)$
          (%i6) ceiling (x);
          (%o6)                           1
          (%i7) tex (ceiling (a));
          $$\left \lceil a \right \rceil$$
          (%o7)                         false

     A função `ceiling' não mapeia automaticamente sobre listas ou
     matrizes.  Finalmente, para todas as entradas que forem
     manifestamente complexas, `ceiling' retorna uma forma substantiva.

     Se o intervalo de uma função é um subconjunto dos inteiros, o
     intervalo pode ser declarado `integervalued'. Ambas as funções
     `ceiling' e `floor' podem usar essa informação; por exemplo:

          (%i1) declare (f, integervalued)$
          (%i2) floor (f(x));
          (%o2)                         f(x)
          (%i3) ceiling (f(x) - 1);
          (%o3)                       f(x) - 1


 -- Função: charfun (<p>)
     Retorna 0 quando o predicado <p> avaliar para `false'; retorna 1
     quando o predicado avaliar para `true'.  Quando o predicado
     avaliar para alguma coisa que não `true' ou `false' (`unknown'),
     retorna uma forma substantiva.

     Exemplos:

          (%i1) charfun (x < 1);
          (%o1)                    charfun(x < 1)
          (%i2) subst (x = -1, %);
          (%o2)                           1
          (%i3) e : charfun ('"and" (-1 < x, x < 1))$
          (%i4) [subst (x = -1, e), subst (x = 0, e), subst (x = 1, e)];
          (%o4)                       [0, 1, 0]


 -- Declaração: commutative
     Se `declare(h,commutative)' é concluída, diz ao simplicador que
     `h' é uma função comutativa.  E.g. `h(x,z,y)' irá simplificar para
     `h(x, y, z)'.  Isto é o mesmo que `symmetric'.


 -- Função: compare (<x>, <y>)
     Retorna um operador de comparação <op> (`<', `<=', `>', `>=', `=',
     ou `#') tal que `is (<x> <op> <y>)' avalia para `true'; quando ou
     <x> ou <y> dependendo de `%i' e `<x> # <y>', retorna
     `notcomparable'; Quando não existir tal operador ou Maxima não
     estiver apto a determinar o operador, retorna `unknown'.

     Exemplos:

          (%i1) compare (1, 2);
          (%o1)                           <
          (%i2) compare (1, x);
          (%o2)                        unknown
          (%i3) compare (%i, %i);
          (%o3)                           =
          (%i4) compare (%i, %i + 1);
          (%o4)                     notcomparable
          (%i5) compare (1/x, 0);
          (%o5)                           #
          (%i6) compare (x, abs(x));
          (%o6)                          <=

     A função `compare' não tenta de terminar se o domínio real de seus
     argumentos é não vazio; dessa forma

          (%i1) compare (acos (x^2 + 1), acos (x^2 + 1) + 1);
          (%o1)                           <

     O domínio real de `acos (x^2 + 1)' é vazio.


 -- Função: entier (<x>)
     Retorna o último inteiro menor que ou igual a <x> onde <x> é
     numérico.  `fix' (como em `fixnum') é um sinônimo disso, então
     `fix(<x>)' é precisamente o mesmo.


 -- Função: equal (<a>, <b>)
     Representa a equivalência, isto é, valor igual.

     Por si mesma, `equal' não avalia ou simplifica.  A função `is'
     tenta avaliar `equal' para um valor Booleano.  `is(equal(<a>,
     <b>))' retorna `true' (ou `false') se e somente se <a> e <b> forem
     iguais (ou não iguais) para todos os possíveis valores de suas
     variáveis, como determinado através da avaliação de `ratsimp(<a> -
     <b>)'; se `ratsimp' retornar 0, as duas expressões são
     consideradas equivalentes.  Duas expressões podem ser equivalentes
     mesmo se mesmo se elas não forem sintaticamente iguais (i.e.,
     identicas).

     Quando `is' falhar em reduzir `equal' a `true' ou `false', o
     resultado é governado através do sinalizador global `prederror'.
     Quando `prederror' for `true', `is' reclama com uma mensagem de
     erro.  De outra forma, `is' retorna `unknown'.

     Complementando `is', alguns outros operadores avaliam `equal' e
     `notequal' para `true' ou `false', a saber `if', `and', `or', e
     `not'.

     A negação de `equal' é `notequal'.

     Exemplos:

     Por si mesmo, `equal' não avalia ou simplifica.

          (%i1) equal (x^2 - 1, (x + 1) * (x - 1));
                                  2
          (%o1)            equal(x  - 1, (x - 1) (x + 1))
          (%i2) equal (x, x + 1);
          (%o2)                    equal(x, x + 1)
          (%i3) equal (x, y);
          (%o3)                      equal(x, y)

     A função `is' tenta avaliar `equal' para um valor Booleano.
     `is(equal(<a>, <b>))' retorna `true' quando `ratsimp(<a> - <b>)'
     retornar 0.  Duas expressões podem ser equivalentes mesmo se não
     forem sintaticamente iguais (i.e., identicas).

          (%i1) ratsimp (x^2 - 1 - (x + 1) * (x - 1));
          (%o1)                           0
          (%i2) is (equal (x^2 - 1, (x + 1) * (x - 1)));
          (%o2)                         true
          (%i3) is (x^2 - 1 = (x + 1) * (x - 1));
          (%o3)                         false
          (%i4) ratsimp (x - (x + 1));
          (%o4)                          - 1
          (%i5) is (equal (x, x + 1));
          (%o5)                         false
          (%i6) is (x = x + 1);
          (%o6)                         false
          (%i7) ratsimp (x - y);
          (%o7)                         x - y
          (%i8) is (equal (x, y));
          (%o8)                        unknown
          (%i9) is (x = y);
          (%o9)                         false

     Quando `is' falha em reduzir `equal' a `true' ou `false', o
     resultado é governado através do sinalizador global `prederror'.

          (%i1) [aa : x^2 + 2*x + 1, bb : x^2 - 2*x - 1];
                              2             2
          (%o1)             [x  + 2 x + 1, x  - 2 x - 1]
          (%i2) ratsimp (aa - bb);
          (%o2)                        4 x + 2
          (%i3) prederror : true;
           (%o3)                         true
          (%i4) is (equal (aa, bb));
          Maxima was unable to evaluate the predicate:
                 2             2
          equal(x  + 2 x + 1, x  - 2 x - 1)
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i5) prederror : false;
          (%o5)                         false
          (%i6) is (equal (aa, bb));
          (%o6)                        unknown

     Alguns operadores avaliam `equal' e `notequal' para `true' ou
     `false'.

          (%i1) if equal (y, y - 1) then FOO else BAR;
          (%o1)                          BAR
          (%i2) eq_1 : equal (x, x + 1);
          (%o2)                    equal(x, x + 1)
          (%i3) eq_2 : equal (y^2 + 2*y + 1, (y + 1)^2);
                                   2                   2
          (%o3)             equal(y  + 2 y + 1, (y + 1) )
          (%i4) [eq_1 and eq_2, eq_1 or eq_2, not eq_1];
          (%o4)                  [false, true, true]

     Devido a `not <expr>' fazer com que ocorra a avaliação de <expr>,
     `not equal(<a>, <b>)' é equivalente a `is(notequal(<a>, <b>))'.

          (%i1) [notequal (2*z, 2*z - 1), not equal (2*z, 2*z - 1)];
          (%o1)            [notequal(2 z, 2 z - 1), true]
          (%i2) is (notequal (2*z, 2*z - 1));
          (%o2)                         true


 -- Função: floor (<x>)
     Quando <x> for um número real, retorna o maior inteiro que é menor
     que ou igual a <x>.

     Se <x> for uma expressão constante (`10 * %pi', for exemplo),
     `floor' avalia <x> usando grandes números em ponto flutuante, e
     aplica `floor' ao grande número em ponto flutuante resultante.
     Porque `floor' usa avaliação em ponto flutuante, é possível,
     embora improvável, que `floor' não possa retornar um valor errôneo
     para entradas constantes.  Para prevenir erros, a avaliação de
     ponto flutuante é concluída usando três valores para `fpprec'.

     Para entradas não constantes, `floor' tenta retornar um valor
     simplificado.  Aqui está exemplos de simplificações que `floor'
     conhece:

          (%i1) floor (ceiling (x));
          (%o1)                      ceiling(x)
          (%i2) floor (floor (x));
          (%o2)                       floor(x)
          (%i3) declare (n, integer)$
          (%i4) [floor (n), floor (abs (n)), floor (min (n, 6))];
          (%o4)                [n, abs(n), min(n, 6)]
          (%i5) assume (x > 0, x < 1)$
          (%i6) floor (x);
          (%o6)                           0
          (%i7) tex (floor (a));
          $$\left \lfloor a \right \rfloor$$
          (%o7)                         false

     A função `floor' não mapeia automaticamente sobre listas ou
     matrizes.  Finalmente, para todas as entradas que forem
     manifestamente complexas, `floor' retorna uma forma substantiva.

     Se o intervalo de uma função for um subconjunto dos inteiros, o
     intervalo pode ser declarado `integervalued'. Ambas as funções
     `ceiling' e `floor' podem usar essa informação; por exemplo:

          (%i1) declare (f, integervalued)$
          (%i2) floor (f(x));
          (%o2)                         f(x)
          (%i3) ceiling (f(x) - 1);
          (%o3)                       f(x) - 1


 -- Função: notequal (<a>, <b>)
     Represents the negation of `equal(<a>, <b>)'.

     Exemplos:

          (%i1) equal (a, b);
          (%o1)                      equal(a, b)
          (%i2) maybe (equal (a, b));
          (%o2)                        unknown
          (%i3) notequal (a, b);
          (%o3)                    notequal(a, b)
          (%i4) not equal (a, b);
          (%o4)                    notequal(a, b)
          (%i5) maybe (notequal (a, b));
          (%o5)                        unknown
          (%i6) assume (a > b);
          (%o6)                        [a > b]
          (%i7) equal (a, b);
          (%o7)                      equal(a, b)
          (%i8) maybe (equal (a, b));
          (%o8)                         false
          (%i9) notequal (a, b);
          (%o9)                    notequal(a, b)
          (%i10) maybe (notequal (a, b));
          (%o10)                        true


 -- Operador: eval
     Como um argumento em uma chamada a `ev (<expr>)', `eval' causa uma
     avaliação extra de <expr>.  Veja `ev'.


 -- Função: evenp (<expr>)
     Retorna `true' se <expr> for um inteiro sempre.  `false' é
     retornado em todos os outros casos.


 -- Função: fix (<x>)
     Um sinônimo para `entier (<x>)'.


 -- Função: fullmap (<f>, <expr_1>, ...)
     Similar a `map', mas `fullmap' mantém mapeadas para baixo todas as
     subexpressões até que os operadores principais não mais sejam os
     mesmos.

     `fullmap' é usada pelo simplificador do Maxima para certas
     manipulações de matrizes; dessa forma, Maxima algumas vezes gera
     uma mensagem de erro concernente a `fullmap' mesmo apesar de
     `fullmap' não ter sido explicitamente chamada pelo usuário.

     Exemplos:

          (%i1) a + b * c;
          (%o1)                        b c + a
          (%i2) fullmap (g, %);
          (%o2)                   g(b) g(c) + g(a)
          (%i3) map (g, %th(2));
          (%o3)                     g(b c) + g(a)


 -- Função: fullmapl (<f>, <list_1>, ...)
     Similar a `fullmap', mas `fullmapl' somente mapeia sobre listas e
     matrizes.

     Exemplo:

          (%i1) fullmapl ("+", [3, [4, 5]], [[a, 1], [0, -1.5]]);
          (%o1)                [[a + 3, 4], [4, 3.5]]


 -- Função: is (<expr>)
     Tenta determinar se a <expr> predicada (expressões que avaliam
     para `true' ou `false') é dedutível de fatos localizados na base
     de dados de `assume'.

     Se a dedutibilidade do predicado for `true' ou `false', `is'
     retorna `true' ou `false', respectivamente.  De outra forma, o
     valor de retorno é governado através do sinalizador global
     `prederror'.  Quando `prederror' for `true', `is' reclama com uma
     mensagem de erro.  De outra forma, `is' retorna `unknown'.

     `ev(<expr>, pred)' (que pode ser escrita da forma  `<expr>, pred'
     na linha de comando interativa) é equivalente a `is(<expr>)'.

     Veja também `assume', `facts', e `maybe'.

     Exemplos:

     `is' causa avaliação de predicados.

          (%i1) %pi > %e;
          (%o1)                       %pi > %e
          (%i2) é (%pi > %e);
          (%o2)                         true

     `is' tenta derivar predicados da base de dados do `assume'.

          (%i1) assume (a > b);
          (%o1)                        [a > b]
          (%i2) assume (b > c);
          (%o2)                        [b > c]
          (%i3) é (a < b);
          (%o3)                         false
          (%i4) é (a > c);
          (%o4)                         true
          (%i5) é (equal (a, c));
          (%o5)                         false

     Se `is' não puder nem comprovar nem refutar uma forma predicada a
     partir da base de dados de `assume', o sinalizador global
     `prederror' governa o comportamento de `is'.

          (%i1) assume (a > b);
          (%o1)                        [a > b]
          (%i2) prederror: true$
          (%i3) é (a > 0);
          Maxima was unable to evaluate the predicate:
          a > 0
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) prederror: false$
          (%i5) é (a > 0);
          (%o5)                        unknown


 -- Função: maybe (<expr>)
     Tenta determinar se a <expr> predicada é dedutível dos fatos na
     base de dados de `assume'.

     Se a dedutibilidade do predicado for `true' ou `false', `maybe'
     retorna `true' ou `false', respectivamente.  De outra forma,
     `maybe' retorna `unknown'.

     `maybe' é funcinalmente equivalente a `is' com `prederror: false',
     mas o resultado é computado sem atualmente atribuir um valor a
     `prederror'.

     Veja também `assume', `facts', e `is'.

     Exemplos:

          (%i1) maybe (x > 0);
          (%o1)                        unknown
          (%i2) assume (x > 1);
          (%o2)                        [x > 1]
          (%i3) maybe (x > 0);
          (%o3)                         true


 -- Função: isqrt (<x>)
     Retorna o "inteiro raíz quadrada" do valor absoluto de <x>, que é
     um inteiro.


 -- Função: lmax (<L>)
     Quando <L> for uma lista ou um conjunto, retorna `apply ('max,
     args (<L>))'.  Quando <L> não for uma lista ou também não for um
     conjunto, sinaliza um erro.


 -- Função: lmin (<L>)
     Quando <L> for uma lista ou um conjunto, retorna `apply ('min,
     args (<L>))'. Quando <L> não for uma lista ou ou também não for um
     conjunto, sinaliza um erro.


 -- Função: max (<x_1>, ..., <x_n>)
     Retorna um valor simplificado para o máximo entre as expressões
     <x_1> a <x_n>.  Quando `get (trylevel, maxmin)', for dois ou mais,
     `max' usa a simplificação `max (e, -e) --> |e|'.  Quando `get
     (trylevel, maxmin)' for 3 ou mais, <max> tenta eliminar expressões
     que estiverem entre dois outros argumentos; por exemplo, `max (x,
     2*x, 3*x) --> max (x, 3*x)'. Para escolher o valor de `trylevel'
     para 2, use `put (trylevel, 2, maxmin)'.


 -- Função: min (<x_1>, ..., <x_n>)
     Retorna um valor simplificado para o mínimo entre as expressões
     `x_1' até `x_n'.  Quando `get (trylevel, maxmin)', for 2 ou mais,
     `min' usa a simplificação `min (e, -e) --> -|e|'.  Quando `get
     (trylevel, maxmin)' for 3 ou mais, `min' tenta eliminar expressões
     que estiverem entre dois outros argumentos; por exemplo, `min (x,
     2*x, 3*x) --> min (x, 3*x)'. Para escolher o valor de `trylevel'
     para 2, use `put (trylevel, 2, maxmin)'.


 -- Função: polymod (<p>)
 -- Função: polymod (<p>, <m>)
     Converte o polinômio <p> para uma representação modular com
     relação ao módulo corrente que é o valor da variável `modulus'.

     `polymod (<p>, <m>)' especifica um módulo <m> para ser usado em
     lugar do valor corrente de `modulus'.

     Veja `modulus'.


 -- Função: mod (<x>, <y>)
     Se <x> e <y> forem números reais e <y> for não nulo, retorna `<x>
     - <y> * floor(<x> / <y>)'.  Adicionalmente para todo real <x>, nós
     temos `mod (<x>, 0) = <x>'. Para uma discursão da definição `mod
     (<x>, 0) = <x>', veja a Seção 3.4, de "Concrete Mathematics," por
     Graham, Knuth, e Patashnik. A função `mod (<x>, 1)' é uma
     função dente de serra com período 1 e com `mod (1, 1) = 0' e `mod
     (0, 1) = 0'.

     Para encontrar o argumento (um número no intervalo `(-%pi, %pi]')
     de um número complexo, use a função `<x> |-> %pi - mod (%pi - <x>,
     2*%pi)', onde <x> é um argumento.

     Quando <x> e <y> forem expressões constantes (`10 * %pi', por
     exemplo), `mod' usa o mesmo esquema de avaliação em ponto
     flutuante que `floor' e `ceiling' usam.  Novamente, é possível,
     embora improvável, que `mod' possa retornar um valor errôneo
     nesses casos.

     Para argumentos não numéricos <x> ou <y>, `mod 'conhece muitas
     regras de simplificação:

          (%i1) mod (x, 0);
          (%o1)                           x
          (%i2) mod (a*x, a*y);
          (%o2)                      a mod(x, y)
          (%i3) mod (0, x);
          (%o3)                           0


 -- Função: oddp (<expr>)
     é `true' se <expr> for um inteiro ímpar.  `false' é retornado em
     todos os outros casos.


 -- Operador: pred
     Como um argumento em uma chamada a `ev (<expr>)', `pred' faz com
     que predicados (expressões que avaliam para `true' ou `false')
     sejam avaliados.  Veja `ev'.


 -- Função: make_random_state (<n>)
 -- Função: make_random_state (<s>)
 -- Função: make_random_state (true)
 -- Função: make_random_state (false)
     Um objeto de estado randômico representa o estado do gerador de
     números randômicos (aleatórios).  O estado compreende 627 palavras
     de 32 bits.

     `make_random_state (<n>)' retorna um novo objeto de estado
     randômico criado de um valor inteiro semente igual a <n> modulo
     2^32.  <n> pode ser negativo.

     `make_random_state (<s>)' retorna uma copia do estado randômico
     <s>.

     `make_random_state (true)' retorna um novo objeto de estado
     randômico, usando a hora corrente  do relógio do computador como
     semente.

     `make_random_state (false)' retorna uma cópia do estado corrente
     do gerador de números randômicos.


 -- Função: set_random_state (<s>)
     Copia <s> para o estado do gerador de números randômicos.

     `set_random_state' sempre retorna `done'.


 -- Função: random (<x>)
     Retorna um número pseudorandômico. Se <x> é um inteiro, `random
     (<x>)' retorna um inteiro de 0 a `<x> - 1' inclusive. Se <x> for
     um número em ponto flutuante, `random (<x>)' retorna um número não
     negativo em ponto flutuante menor que <x>.  `random' reclama com
     um erro se <x> não for nem um inteiro nem um número em ponto
     flutuante, ou se <x> não for positivo.

     As funções `make_random_state' e `set_random_state' mantém o
     estado do gerador de números randômicos.

     O gerador de números randômicos do Maxima é uma implementação do
     algorítmo de Mersenne twister MT 19937.

     Exemplos:

          (%i1) s1: make_random_state (654321)$
          (%i2) set_random_state (s1);
          (%o2)                         done
          (%i3) random (1000);
          (%o3)                          768
          (%i4) random (9573684);
          (%o4)                        7657880
          (%i5) random (2^75);
          (%o5)                11804491615036831636390
          (%i6) s2: make_random_state (false)$
          (%i7) random (1.0);
          (%o7)                   .2310127244107132
          (%i8) random (10.0);
          (%o8)                   4.394553645870825
          (%i9) random (100.0);
          (%o9)                   32.28666704056853
          (%i10) set_random_state (s2);
          (%o10)                        done
          (%i11) random (1.0);
          (%o11)                  .2310127244107132
          (%i12) random (10.0);
          (%o12)                  4.394553645870825
          (%i13) random (100.0);
          (%o13)                  32.28666704056853


 -- Função: rationalize (<expr>)
     Converte todos os números em ponto flutuante de precisão dupla e
     grandes números em ponto flutuante na expressão do Maxima <expr>
     para seus exatos equivalentes racionais. Se você não estiver
     faminilarizado com a representação binária de números em ponto
     flutuante, você pode se surpreender que `rationalize (0.1)' não
     seja igual a 1/10.  Esse comportamento não é especial para o
     Maxima - o número 1/10 tem uma representação binária repetitiva e
     não terminada.

          (%i1) rationalize (0.5);
                                          1
          (%o1)                           -
                                          2
          (%i2) rationalize (0.1);
                                         1
          (%o2)                          --
                                         10
           (%i3) fpprec : 5$
          (%i4) rationalize (0.1b0);
                                       209715
          (%o4)                        -------
                                       2097152
          (%i5) fpprec : 20$
          (%i6) rationalize (0.1b0);
                               236118324143482260685
          (%o6)                ----------------------
                               2361183241434822606848
          (%i7) rationalize (sin (0.1*x + 5.6));
                                        x    28
          (%o7)                     sin(-- + --)
                                        10   5

     Exemplo de utilização:

          (%i1) unitfrac(r) := block([uf : [], q],
              if not(ratnump(r)) then error("The input to 'unitfrac' must be a rational number"),
              while r # 0 do (
                  uf : cons(q : 1/ceiling(1/r), uf),
                  r : r - q),
              reverse(uf));
          (%o1) unitfrac(r) := block([uf : [], q],
          if not ratnump(r) then error("The input to 'unitfrac' must be a rational number"
                                               1
          ), while r # 0 do (uf : cons(q : ----------, uf), r : r - q),
                                                   1
                                           ceiling(-)
                                                   r
          reverse(uf))
          (%i2) unitfrac (9/10);
                                      1  1  1
          (%o2)                      [-, -, --]
                                      2  3  15
          (%i3) apply ("+", %);
                                         9
          (%o3)                          --
                                         10
          (%i4) unitfrac (-9/10);
                                            1
          (%o4)                       [- 1, --]
                                            10
          (%i5) apply ("+", %);
                                          9
          (%o5)                         - --
                                          10
          (%i6) unitfrac (36/37);
                                  1  1  1  1    1
          (%o6)                  [-, -, -, --, ----]
                                  2  3  8  69  6808
          (%i7) apply ("+", %);
                                         36
          (%o7)                          --
                                         37


 -- Função: sign (<expr>)
     Tenta determinar o sinal de <expr> a partir dos fatos na base de
     dados corrente.  Retorna uma das seguintes respostar: `pos'
     (positivo), `neg' (negativo), `zero', `pz' (positivo ou zero),
     `nz' (negativo ou zero), `pn' (positivo ou negativo), ou `pnz'
     (positivo, negativo, ou zero, i.e. nada se sabe sobre o sinal da
     epressão).


 -- Função: signum (<x>)
     Para um <x> numérico retorna 0 se <x> for 0, de outra forma
     retorna -1 ou +1 à medida que <x> seja menor ou maior que 0,
     respectivamente.

     Se <x> não for numérico então uma forma simplificada mas
     equivalente é retornada.  Por exemplo, `signum(-x)' fornece
     `-signum(x)'.


 -- Função: sort (<L>, <P>)
 -- Função: sort (<L>)
     Organiza uma lista <L> coforme o predicado `P' de dois argumentos,
     de forma que `<P> (<L>[k], <L>[k + 1])' seja `true' para qualquer
     dois elementos sucessivos.  O predicado pode ser especificado como
     o nome de uma função ou operador binário infixo, ou como uma
     expressão `lambda'.  Se especificado como o nome de um operador, o
     nome deve ser contido entre "aspas duplas".

     A lista ordenada é retornada como novo objeto; o argumento <L> não
     é modificado.  Para construir o valor de retorno, `sort' faz uma
     cópia superficial dos elementos de <L>.  Se o predicado <P> não
     for uma ordem total sobre os elementos de <L>, então `sort'
     possivelvente pode executar para concluir sem error, mas os
     resultados são indefinidos.  `sort' reclama se o predicado avaliar
     para alguma outra coisa que não seja `true' ou `false'.

     `sort (<L>)' é equivalente a `sort (<L>, orderlessp)'.  Isto é, a
     ordem padrão de organização é ascendente, como determinado por
     `orderlessp'.  Todos os átomos do Maxima e expressões são
     comparáveis sob `orderlessp', embora exista exemplos isolados de
     expressões para as quais `orderlessp' não é transitiva; isso é uma
     falha.

     Exemplos:

          (%i1) sort ([11, -17, 29b0, 7.55, 3, -5/2, b + a, 9 * c, 19 - 3 * x]);
                         5
          (%o1) [- 17, - -, 3, 7.55, 11, 2.9b1, b + a, 9 c, 19 - 3 x]
                         2
          (%i2) sort ([11, -17, 29b0, 7.55, 3, -5/2, b + a, 9 * c, 19 - 3 * x], ordergreatp);
                                                             5
          (%o2) [19 - 3 x, 9 c, b + a, 2.9b1, 11, 7.55, 3, - -, - 17]
                                                             2
          (%i3) sort ([%pi, 3, 4, %e, %gamma]);
          (%o3)                [3, 4, %e, %gamma, %pi]
          (%i4) sort ([%pi, 3, 4, %e, %gamma], "<");
          (%o4)                [%gamma, %e, 3, %pi, 4]
          (%i5) my_list : [[aa, hh, uu], [ee, cc], [zz, xx, mm, cc], [%pi, %e]];
          (%o5) [[aa, hh, uu], [ee, cc], [zz, xx, mm, cc], [%pi, %e]]
          (%i6) sort (my_list);
          (%o6) [[%pi, %e], [aa, hh, uu], [ee, cc], [zz, xx, mm, cc]]
          (%i7) sort (my_list, lambda ([a, b], orderlessp (reverse (a), reverse (b))));
          (%o7) [[%pi, %e], [ee, cc], [zz, xx, mm, cc], [aa, hh, uu]]


 -- Função: sqrt (<x>)
     A raíz quadrada de <x>. É representada internamente por
     `<x>^(1/2)'.  Veja também `rootscontract'.

     `radexpand' se `true' fará com que n-ésimas raízes de fatores de
     um produto que forem potências de n sejam colocados fora do
     radical, e.g.  `sqrt(16*x^2)' retonará `4*x' somente se
     `radexpand' for `true'.


 -- Variável de opção: sqrtdispflag
     Valor padrão: `true'

     Quando `sqrtdispflag' for `false', faz com que `sqrt' seja
     mostrado como expoente 1/2.


 -- Função: sublis (<lista>, <expr>)
     Faz multiplas substituições paralelas dentro de uma expressão.

     A variável `sublis_apply_lambda' controla a simplificação após
     `sublis'.

     Exemplo:



 -- Função: sublist (<lista>, <p>)
     Retorna a lista de elementos da <lista> da qual o predicado `p'
     retornar `true'.

     Exemplo:

          (%i1) L: [1, 2, 3, 4, 5, 6];
          (%o1)                  [1, 2, 3, 4, 5, 6]
          (%i2) sublist (L, evenp);
          (%o2)                       [2, 4, 6]


 -- Variável de opção: sublis_apply_lambda
     Valor padrão: `true' - controla se os substitutos de `lambda' são
     aplicados na simplificação após as `sublis' serem usadas ou se
     você tem que fazer um `ev' para pegar coisas para aplicar.  `true'
     significa faça a aplicação.


 -- Função: subst (<a>, <b>, <c>)
     Substitue <a> por <b> em <c>.  <b> deve ser um átomo ou uma
     subexpressão completa de <c>.  Por exemplo, `x+y+z' é uma
     subexpressão completa de `2*(x+y+z)/w' enquanto `x+y' não é.
     Quando <b> não tem essas características, pode-se algumas vezes
     usar `substpart' ou `ratsubst' (veja abaixo).  Alternativamente,
     se <b> for da forma de `e/f' então se poderá usar `subst (a*f, e,
     c)' enquanto se <b> for da forma `e^(1/f)' então se poderá usar
     `subst (a^f, e, c)'.  O comando `subst' também discerne o `x^y' de
     `x^-y' de modo que `subst (a, sqrt(x), 1/sqrt(x))' retorna `1/a'.
     <a> e <b> podem também ser operadores de uma expressão contida
     entre aspas duplas `"' ou eles podem ser nomes de função.  Se se
     desejar substituir por uma variável independente em formas
     derivadas então a função `at' (veja abaixo) poderá ser usada.

     `subst' é um álias para `substitute'.

     `subst (<eq_1>, <expr>)' ou `subst ([<eq_1>, ..., <eq_k>], <expr>)'
     são outras formas permitidas.  As <eq_i> são equações indicando
     substituições a serem feitas.  Para cada equação, o lado direito
     será substituído pelo lado esquerdo na expressão <expr>.

     `exptsubst' se `true' permite que substituições como `y' por
     `%e^x' em `%e^(a*x)' ocorram.

     Quando `opsubst' for `false', `subst' tentará substituir dentro do
     operador de uma expressão.  E.g. `(opsubst: false, subst (x^2, r,
     r+r[0]))' trabalhará.

     Exemplos:

          (%i1) subst (a, x+y, x + (x+y)^2 + y);
                                              2
          (%o1)                      y + x + a
          (%i2) subst (-%i, %i, a + b*%i);
          (%o2)                       a - %i b

     Para exemplos adicionais, faça `example (subst)'.


 -- Função: substinpart (<x>, <expr>, <n_1>, ..., <n_k>)
     Similar a `substpart', mas `substinpart' trabalha sobre a
     representação interna de <expr>.

     Exemplos:

          (%i1) x . 'diff (f(x), x, 2);
                                        2
                                       d
          (%o1)                   x . (--- (f(x)))
                                         2
                                       dx
          (%i2) substinpart (d^2, %, 2);
                                            2
          (%o2)                        x . d
          (%i3) substinpart (f1, f[1](x + 1), 0);
          (%o3)                       f1(x + 1)

     Se o último argumento para a função `part' for uma lista de
     índices então muitas subexpressões são escolhidas, cada uma
     correspondendo a um índice da lista.  Dessa forma

          (%i1) part (x + y + z, [1, 3]);
          (%o1)                         z + x

     `piece' recebe o valor da última expressão selecionada quando
     usando as funções `part'.  `piece' é escolhida durante a
     execução da função e dessa forma pode ser referenciada para a
     própria função como mostrado abaixo.  Se `partswitch' for
     escolhida para `true' então `end' é retornado quando uma parte
     selecionada de uma expressão não existir, de outra forma uma
     mensagem de erro é fornecida.

          (%i1) expr: 27*y^3 + 54*x*y^2 + 36*x^2*y + y + 8*x^3 + x + 1;
                        3         2       2            3
          (%o1)     27 y  + 54 x y  + 36 x  y + y + 8 x  + x + 1
          (%i2) part (expr, 2, [1, 3]);
                                            2
          (%o2)                         54 y
          (%i3) sqrt (piece/54);
          (%o3)                        abs(y)
          (%i4) substpart (factor (piece), expr, [1, 2, 3, 5]);
                                         3
          (%o4)               (3 y + 2 x)  + y + x + 1
          (%i5) expr: 1/x + y/x - 1/z;
                                       1   y   1
          (%o5)                      - - + - + -
                                       z   x   x
          (%i6) substpart (xthru (piece), expr, [2, 3]);
                                      y + 1   1
          (%o6)                       ----- - -
                                        x     z

     Também, escolhendo a opção `inflag' para `true' e chamando `part'
     ou `substpart' é o mesmo que chamando `inpart' ou `substinpart'.


 -- Função: substpart (<x>, <expr>, <n_1>, ..., <n_k>)
     Substitue <x> para a subexpressão selecionada pelo resto dos
     argumentos como em `part'.  Isso retorna o novo valor de <expr>.
     <x> pode ser algum operador a ser substituído por um operador de
     <expr>.  Em alguns casos <x> precisa ser contido em aspas duplas
     `"' (e.g.  `substpart ("+", a*b, 0)' retorna `b + a').

          (%i1) 1/(x^2 + 2);
                                         1
          (%o1)                        ------
                                        2
                                       x  + 2
          (%i2) substpart (3/2, %, 2, 1, 2);
                                         1
          (%o2)                       --------
                                       3/2
                                      x    + 2
          (%i3) a*x + f (b, y);
          (%o3)                     a x + f(b, y)
          (%i4) substpart ("+", %, 1, 0);
          (%o4)                    x + f(b, y) + a

     Também, escolhendo a opção `inflag' para `true' e chamando `part'
     ou `substpart' é o mesmo que chamando `inpart' ou `substinpart'.


 -- Função: subvarp (<expr>)
     Retorna `true' se <expr> for uma variável subscrita (i.e. que
     possui índice ou subscrito em sua grafia), por exemplo `a[i]'.


 -- Função: symbolp (<expr>)
     Retorna `true' se <expr> for um símbolo, de outra forma retorna
     `false'.  com efeito, `symbolp(x)' é equivalente ao predicado
     `atom(x) and not numberp(x)'.

     Veja também *note Identificadores::


 -- Função: unorder ()
     Disabilita a ação de alias criada pelo último uso dos comandos de
     ordenação `ordergreat' e `orderless'. `ordergreat' e `orderless'
     não podem ser usados mais que uma vez cada sem chamar `unorder'.
     Veja também `ordergreat' e `orderless'.

     Exemplos:

          (%i1) unorder();
          (%o1)                          []
          (%i2) b*x + a^2;
                                             2
          (%o2)                       b x + a
          (%i3) ordergreat (a);
          (%o3)                         done
          (%i4) b*x + a^2;
           %th(1) - %th(3);
                                       2
          (%o4)                       a  + b x
          (%i5) unorder();
                                        2    2
          (%o5)                        a  - a


 -- Função: vectorpotential (<givencurl>)
     Retorna o potencial do vetor de um dado vetor de torção, no
     sistema de coordenadas corrente.  `potentialzeroloc' tem um papel
     similar ao de `potential', mas a ordem dos lados esquerdos das
     equações deve ser uma permutação cíclica das variáveis de
     coordenadas.


 -- Função: xthru (<expr>)
     Combina todos os termos de <expr> (o qual pode ser uma adição)
     sobre um denominador comum sem produtos e somas exponenciadas como
     `ratsimp' faz.  `xthru' cancela fatores comuns no numerador e
     denominador de expressões racionais mas somente se os fatores são
     explícitos.

     Algumas vezes é melhor usar `xthru' antes de `ratsimp' em uma
     expressão com o objetivo de fazer com que fatores explicitos do
     máximo divisor comum entre o numerador e o denominador seja
     cancelado simplificando dessa forma a expressão a ser aplicado o
     `ratsimp'.

          (%i1) ((x+2)^20 - 2*y)/(x+y)^20 + (x+y)^(-19) - x/(x+y)^20;
                                          20
                           1       (x + 2)   - 2 y       x
          (%o1)        --------- + --------------- - ---------
                              19             20             20
                       (y + x)        (y + x)        (y + x)
          (%i2) xthru (%);
                                           20
                                    (x + 2)   - y
          (%o2)                     -------------
                                             20
                                      (y + x)


 -- Função: zeroequiv (<expr>, <v>)
     Testa se a expressão <expr> na variável <v> é equivalente a zero,
     retornando `true', `false', ou `dontknow' (não sei).

     `zeroequiv' Tem essas restrições:
       1. Não use funções que o Maxima não sabe como diferenciar e
          avaliar.

       2. Se a expressão tem postes sobre o eixo real, podem existir
          erros no resultado (mas isso é improvável ocorrer).

       3. Se a expressão contem funções que não são soluções para
          equações diferenciais de primeira ordem (e.g.  funções de
          Bessel) pode ocorrer resultados incorretos.

       4. O algorítmo usa avaliação em pontos aleatóriamente escolhidos
          para subexpressões selecionadas cuidadosamente.  Isso é
          sempre negócio um tanto quanto perigoso, embora o algorítmo
          tente minimizar o potencial de erro.

     Por exemplo  `zeroequiv (sin(2*x) - 2*sin(x)*cos(x), x)' retorna
     `true' e `zeroequiv (%e^x + x, x)' retorna `false'.  Por outro
     lado `zeroequiv (log(a*b) - log(a) - log(b), a)' retorna
     `dontknow' devido à presença de um parâmetro extra `b'.



File: maxima.info,  Node: Expressões,  Next: Simplificação,  Prev: Operadores,  Up: Top

6 Expressões
************

* Menu:

* Introdução a Expressões::
* Complexo::
* Substantivos e Verbos::
* Identificadores::
* Seqüências de caracteres::
* Desigualdade::
* Sintaxe::
* Funções e Variáveis Definidas para Expressões::


File: maxima.info,  Node: Introdução a Expressões,  Next: Complexo,  Prev: Expressões,  Up: Expressões

6.1 Introdução a Expressões
===========================

Existe um conjunto de palavras reservadas que não pode ser usado como
nome de variável.   Seu uso pode causar um possível erro crítico de
sintaxe.

     integrate            next           from                 diff
     in                   at             limit                sum
     for                  and            elseif               then
     else                 do             or                   if
     unless               product        while                thru
     step

   Muitas coisas em Maxima são expressões.   Uma seqüência de expressões
pode ser feita dentro de uma expressão maior através da separação
dessas através de vírgulas e colocando parêntesis em torno dela.   Isso
é similar ao C expressão com vírgula.

     (%i1) x: 3$
     (%i2) (x: x+1, x: x^2);
     (%o2)                          16
     (%i3) (if (x > 17) then 2 else 4);
     (%o3)                           4
     (%i4) (if (x > 17) then x: 2 else y: 4, y+x);
     (%o4)                          20

   Mesmo ciclos em Maxima são expressões, embora o valor de retorno
desses ciclos não seja muito útil (eles retornam sempre `done').

     (%i1) y: (x: 1, for i from 1 thru 10 do (x: x*i))$
     (%i2) y;
     (%o2)                         done

   contanto que o que você realmente queira seja provavelmente incluir
um terceiro termo na expressão com vírgula que fornece de volta o valor
atualizado.

     (%i3) y: (x: 1, for i from 1 thru 10 do (x: x*i), x)$
     (%i4) y;
     (%o4)                        3628800


File: maxima.info,  Node: Complexo,  Next: Substantivos e Verbos,  Prev: Introdução a Expressões,  Up: Expressões

6.2 Complexo
============

Uma expressão complexa é especificada no Maxima através da adição da
parte real da expressão a `%i' vezes a parte imaginária.  Dessa forma as
raízes da equação `x^2 - 4*x + 13 = 0' são `2 + 3*%i' e `2 - 3*%i'.
Note que produtos de simplificação de expressões complexas podem ser
efetuadas através da expansão do produto.  Simplificação de quocientes,
raízes, e outras funções de expressões complexas podem usualmente serem
realizadas através do uso das funções `realpart', `imagpart',
`rectform', `polarform', `abs', `carg'.


File: maxima.info,  Node: Substantivos e Verbos,  Next: Identificadores,  Prev: Complexo,  Up: Expressões

6.3 Substantivos e Verbos
=========================

Maxima distingue entre operadores que são "substantivos" e operadores
que são "verbos".  Um verbo é um operador que pode ser executado.  Um
substantivo é um operador que aparece como um símbolo em uma expressão,
sem ser executado.  Por padrão, nomes de função são verbos.  Um verbo
pode ser mudado em um substantivo através da adição de um apóstrofo no
início do nome da função ou aplicando a função `nounify'.  Um
substantivo pode ser mudado em um verbo através da aplicação da
função `verbify'.  O sinalizador de avaliação `nouns' faz com que `ev'
avalie substantivos em uma expressão.

   A forma verbal é distinguida através de um sinal de dólar `$' no
início do símbolo Lisp correspondente.  De forma oposta, a forma
substantiva é distinguida através de um sinal de `%' no início do
símbolo Lisp correspondente.  Alguns substantivos possuem propriedades
especiais de exibição, tais como `'integrate' e `'derivative'
(retornado por `diff'), mas muitos não.  Por padrão, as formas
substantiva e verbal de uma função são idênticas quando mostradas.  O
sinalizador global `noundisp' faz com que Maxima mostre substantivos
com um apóstrofo no início `''.

   Veja também `noun', `nouns', `nounify', e `verbify'.

   Exemplos:

     (%i1) foo (x) := x^2;
                                          2
     (%o1)                     foo(x) := x
     (%i2) foo (42);
     (%o2)                         1764
     (%i3) 'foo (42);
     (%o3)                        foo(42)
     (%i4) 'foo (42), nouns;
     (%o4)                         1764
     (%i5) declare (bar, noun);
     (%o5)                         done
     (%i6) bar (x) := x/17;
                                          x
     (%o6)                    ''bar(x) := --
                                          17
     (%i7) bar (52);
     (%o7)                        bar(52)
     (%i8) bar (52), nouns;
                                    52
     (%o8)                          --
                                    17
     (%i9) integrate (1/x, x, 1, 42);
     (%o9)                        log(42)
     (%i10) 'integrate (1/x, x, 1, 42);
                                  42
                                 /
                                 [   1
     (%o10)                      I   - dx
                                 ]   x
                                 /
                                  1
     (%i11) ev (%, nouns);
     (%o11)                       log(42)


File: maxima.info,  Node: Identificadores,  Next: Seqüências de caracteres,  Prev: Substantivos e Verbos,  Up: Expressões

6.4 Identificadores
===================

Identificadores do Maxima podem compreender caracteres alfabéticos,
mais os numerais de 0 a 9, mais qualquer caractere especial precedido
por um caractere contra-barra `\'.

   Um numeral pode ser o primeiro caractere de um identificador se esse
numeral for precedido por uma contra-barra.  Numerais que forem o
segundo ou o último caractere não precisam ser precedidos por uma
contra barra.

   Caracteres podem ser declarados para serem alfabéticos por meio da
função `declare'.  Se então declarados alfabéticos, eles não precisam
serem precedidos de uma contrabarra em um identificador.  Os caracteres
alfabéticos vão inicialmente de `A' a `Z', de `a' a `z', `%', e `_'.

   Maxima é sensível à caixa . Os identificadores `algumacoisa',
`ALGUMACOISA', e `Algumacoisa' são distintos.  Veja *note Lisp e
Maxima:: para mais sobre esse ponto.

   Um identificador Maxima é um símbolo Lisp que começa com um sinal de
dólar `$'.  Qualquer outro símbolo Lisp é precedido por um ponto de
interrogação `?' quando aparecer no Maxima.  Veja *note Lisp e Maxima::
para maiores detalhes sobre esse ponto.

   Exemplos:

     (%i1) %an_ordinary_identifier42;
     (%o1)               %an_ordinary_identifier42
     (%i2) embedded\ spaces\ in\ an\ identifier;
     (%o2)           embedded spaces in an identifier
     (%i3) symbolp (%);
     (%o3)                         true
     (%i4) [foo+bar, foo\+bar];
     (%o4)                 [foo + bar, foo+bar]
     (%i5) [1729, \1729];
     (%o5)                     [1729, 1729]
     (%i6) [symbolp (foo\+bar), symbolp (\1729)];
     (%o6)                     [true, true]
     (%i7) [is (foo\+bar = foo+bar), is (\1729 = 1729)];
     (%o7)                    [false, false]
     (%i8) baz\~quux;
     (%o8)                       baz~quux
     (%i9) declare ("~", alphabetic);
     (%o9)                         done
     (%i10) baz~quux;
     (%o10)                      baz~quux
     (%i11) [is (foo = FOO), is (FOO = Foo), is (Foo = foo)];
     (%o11)                [false, false, false]
     (%i12) :lisp (defvar *my-lisp-variable* '$foo)
     *MY-LISP-VARIABLE*
     (%i12) ?\*my\-lisp\-variable\*;
     (%o12)                         foo


File: maxima.info,  Node: Seqüências de caracteres,  Next: Desigualdade,  Prev: Identificadores,  Up: Expressões

6.5 Seqüências de caracteres
============================

Strings (seqüências de caracteres) são contidas entre aspas duplas `"'
em entradas de dados usados pelo Maxima, e mostradas com ou sem as
aspas duplas, dependendo do valor escolhido para a variável global
`stringdisp'.

   Seqüências de caracteres podem conter quaisquer caracteres,
incluindo tabulações (tab), nova linha (ou fim de linha), e caracteres
de retorno da cabeça de impressão (carriage return).  A seqüência `\"'
é reconhecida com uma aspa dupla literal, e `\\' como uma contrabarra
literal.  Quando a contrabarra aparecer no final de uma linha, a
contrabarra e a terminação de linha (ou nova linha ou retorno de carro
e nova linha) são ignorados, de forma que a seqüência de caracteres
continue na próxima linha.  Nenhuma outra combinação especial de
contrabarra com outro caractere é reconhecida; quando a contrabarra
aparecer antes de qualquer outro caractere que não seja `"', `\', ou um
fim de linha, a contrabarra é ignorada.  Não exite caminho para
representar um caractere especial (tal como uma tabulação, nova linha,
ou retorno da cabeça de impressão) exceto através de encaixar o
caractere literal na seqüência de caracteres.

   Não existe tipo de caractere no Maxima; um caractere simples é
representado como uma seqüência de caracteres de um único caractere.

   Seqüências de caracteres no Maxima são implementadas como símbolos
do Lisp, não como seqüencias de caracteres do not Lisp; o que pode
mudar em futuras versões do Maxima.  Maxima pode mostrar seqüências de
caracteres do Lisp e caracteres do Lisp, embora algumas outras
operações (por exemplo, testes de igualdade) possam falhar.

   O pacote adicional `stringproc' contém muitas funções que trabalham
com seqüências de caracteres.

   Exemplos:

     (%i1) s_1 : "Isso é uma seqüência de caracteres  do Maxima.";
     (%o1)               Isso é uma seqüência de caracteres  do Maxima.
     (%i2) s_2 : "Caracteres \"aspas duplas\" e contrabarras \\ encaixados em uma seqüência de caracteres.";
     (%o2) Caracteres "aspas duplas" e contrabarra \ encaixados em uma seqüência de caracteres.
     (%i3) s_3 : "Caractere de fim de linha encaixado
     nessa seqüência de caracteres.";
     (%o3) Caractere de fim de linha encaixado
     nessa seqüência de caracteres.
     (%i4) s_4 : "Ignore o \
     caractere de \
     fim de linha nessa \
     seqüência de caracteres.";
     (%o4) Ignore o caractere de fim de linha nessa seqüência de caracteres.
     (%i5) stringdisp : false;
     (%o5)                         false
     (%i6) s_1;
     (%o6)               Isso é uma seqüência de caracteres  do Maxima.
     (%i7) stringdisp : true;
     (%o7)                         true
     (%i8) s_1;
     (%o8)              "Isso é uma seqüência de caracteres  do Maxima."


File: maxima.info,  Node: Desigualdade,  Next: Sintaxe,  Prev: Seqüências de caracteres,  Up: Expressões

6.6 Desigualdade
================

Maxima tem os operadores de desigualdade `<', `<=', `>=', `>', `#', e
`notequal'.  Veja `if' para uma descrição de expressões condicionais.


File: maxima.info,  Node: Sintaxe,  Next: Funções e Variáveis Definidas para Expressões,  Prev: Desigualdade,  Up: Expressões

6.7 Sintaxe
===========

É possível definir novos operadores com precedência especificada,
remover a definição de operadores existentes, ou redefinir a
precedência de operadores existentes.  Um operador pode ser unário
prefixado ou unário pósfixado, binario infixado, n-ário infixado,
matchfix, ou nofix.  "Matchfix" significa um par de símbolos que
abraçam seu argumento ou seus argumentos, e "nofix" significa um
operador que não precisa de argumentos.  Como exemplos dos diferentes
tipos de operadores, existe o seguinte.

unário prefixado
     negação `- a'

unário posfixado
     fatorial `a!'

binário infixado
     exponenciação `a^b'

n-ário infixado
     adição `a + b'

matchfix
     construção de lista `[a, b]'

   (Não existe operadores internos nofix; para um exemplo de tal
operador, veja `nofix'.)

   O mecanismo para definir um novo operador é direto.  Somente é
necessário declarar uma função como um operador; a função operador pode
ou não estar definida previamente.

   Um exemplo de operadores definidos pelo usuário é o seguinte.  Note
que a chamada explícita de função `"dd" (a)' é equivalente a `dd a', da
mesma forma `"<-" (a, b)' é equivalente a `a <- b'.  Note também que as
funções `"dd"' e `"<-"' são indefinidas nesse exemplo.

     (%i1) prefix ("dd");
     (%o1)                          dd
     (%i2) dd a;
     (%o2)                         dd a
     (%i3) "dd" (a);
     (%o3)                         dd a
     (%i4) infix ("<-");
     (%o4)                          <-
     (%i5) a <- dd b;
     (%o5)                      a <- dd b
     (%i6) "<-" (a, "dd" (b));
     (%o6)                      a <- dd b

   As funções máxima que definem novos operadores estão sumarizadas
nessa tabela, equilibrando expoente associado esquerdo (padrão) e o
expoente associado direito ("eae" e "ead", respectivamente).
(Associação de expoentes determina a precedência do operador. todavia,
uma vez que os expoentes esquerdo e direito podem ser diferentes,
associação de expoentes é até certo ponto mais complicado que
precedência.)  Alguma das funções de definição de operações tomam
argumentos adicionais; veja as descrições de função para maiores
detalhes.

`prefixado'
     ead=180

`posfixado'
     eae=180

`infixado'
     eae=180, ead=180

`nário'
     eae=180, ead=180

`matchfix'
     (associação de expoentes não é aplicável)

`nofix'
     (associação de expoentes não é aplicável)

   Para comparação, aqui está alguns operadores internos e seus
expoentes associados esquerdo e direito.

     Operador   eae     ead

       :        180     20
       ::       180     20
       :=       180     20
       ::=      180     20
       !        160
       !!       160
       ^        140     139
       .        130     129
       *        120
       /        120     120
       +        100     100
       -        100     134
       =        80      80
       #        80      80
       >        80      80
       >=       80      80
       <        80      80
       <=       80      80
       not              70
       and      65
       or       60
       ,        10
       $        -1
       ;        -1

   `remove' e `kill' removem propriedades de operador de um átomo.
`remove ("<a>", op)' remove somente as propriedades de operador de <a>.
`kill ("<a>")' remove todas as propriedades de <a>, incluindo as
propriedades de operador.  Note que o nome do operador dever estar
abraçado por aspas duplas.

     (%i1) infix ("##");
     (%o1)                          ##
     (%i2) "##" (a, b) := a^b;
                                          b
     (%o2)                     a ## b := a
     (%i3) 5 ## 3;
     (%o3)                          125
     (%i4) remove ("##", op);
     (%o4)                         done
     (%i5) 5 ## 3;
     Incorrect syntax: # is not a prefix operator
     5 ##
       ^
     (%i5) "##" (5, 3);
     (%o5)                          125
     (%i6) infix ("##");
     (%o6)                          ##
     (%i7) 5 ## 3;
     (%o7)                          125
     (%i8) kill ("##");
     (%o8)                         done
     (%i9) 5 ## 3;
     Incorrect syntax: # is not a prefix operator
     5 ##
       ^
     (%i9) "##" (5, 3);
     (%o9)                       ##(5, 3)


File: maxima.info,  Node: Funções e Variáveis Definidas para Expressões,  Prev: Sintaxe,  Up: Expressões

6.8 Funções e Variáveis Definidas para Expressões
=================================================

 -- Função: at (<expr>, [<eqn_1>, ..., <eqn_n>])
 -- Função: at (<expr>, <eqn>)
     Avalia a expressão <expr> com as variáveis assumindo os valores
     como especificado para elas na lista de equações `[<eqn_1>, ...,
     <eqn_n>]' ou a equação simples <eqn>.

     Se uma subexpressão depender de qualquer das variáveis para a qual
     um valor foi especificado mas não existe `atvalue' especificado e
     essa subexpressão não pode ser avaliada de outra forma, então uma
     forma substantiva de `at' é retornada que mostra em uma forma
     bidimensional.

     `at' realiza múltiplas substituições em série, não em paralelo.

     Veja também `atvalue'.  Para outras funções que realizam
     substituições, veja também `subst' e `ev'.

     Exemplos:

          (%i1) atvalue (f(x,y), [x = 0, y = 1], a^2);
                                          2
          (%o1)                          a
          (%i2) atvalue ('diff (f(x,y), x), x = 0, 1 + y);
          (%o2)                        @2 + 1
          (%i3) printprops (all, atvalue);
                                          !
                            d             !
                           --- (f(@1, @2))!       = @2 + 1
                           d@1            !
                                          !@1 = 0

                                               2
                                    f(0, 1) = a

          (%o3)                         done
          (%i4) diff (4*f(x, y)^2 - u(x, y)^2, x);
                            d                          d
          (%o4)  8 f(x, y) (-- (f(x, y))) - 2 u(x, y) (-- (u(x, y)))
                            dx                         dx
          (%i5) at (%, [x = 0, y = 1]);
                                                   !
                        2              d           !
          (%o5)     16 a  - 2 u(0, 1) (-- (u(x, y))!            )
                                       dx          !
                                                   !x = 0, y = 1


 -- Função: box (<expr>)
 -- Função: box (<expr>, <a>)
     Retorna <expr> dentro de uma caixa.  O valor de retorno é uma
     expressão com `box' como o operador e <expr> como o argumento.
     Uma caixa é desenhada sobre a tela quando `display2d' for `true'.

     `box (<expr>, <a>)' Empacota <expr> em uma caixa rotulada pelo
     símbolo <a>.  O rótulo é truncado se for maior que a largura da
     caixa.

     `box' avalia seu argumento.  Todavia, uma expressão dentro de uma
     caixa não avalia para seu conteúdo, então expressões dentro de
     caixas são efetivamente excluídas de cálculos.

     `boxchar' é o caractere usado para desenhar a caixa em `box' e nas
     funções `dpart' e `lpart'.

     Exemplos:

          (%i1) box (a^2 + b^2);
                                      """""""""
                                      " 2    2"
          (%o1)                       "b  + a "
                                      """""""""
          (%i2) a : 1234;
          (%o2)                         1234
          (%i3) b : c - d;
          (%o3)                         c - d
          (%i4) box (a^2 + b^2);
                                """"""""""""""""""""
                                "       2          "
          (%o4)                 "(c - d)  + 1522756"
                                """"""""""""""""""""
          (%i5) box (a^2 + b^2, term_1);
                                term_1""""""""""""""
                                "       2          "
          (%o5)                 "(c - d)  + 1522756"
                                """"""""""""""""""""
          (%i6) 1729 - box (1729);
                                           """"""
          (%o6)                     1729 - "1729"
                                           """"""
          (%i7) boxchar: "-";
          (%o7)                           -
          (%i8) box (sin(x) + cos(y));
                                  -----------------
          (%o8)                   -cos(y) + sin(x)-
                                  -----------------


 -- Variável de opção: boxchar
     Valor padrão: `"'

     `boxchar' é o caractere usado para desenhar a caixa por `box' e
     nas funções `dpart' e `lpart'.

     Todas as caixas em uma expressão são desenhadas com o valor atual
     de `boxchar'; o caractere de desenho não é armazenado com a
     expressão de caixa. Isso quer dizer que se você desenhar uma caixa
     e em seguida mudar o caractere de desenho a caixa anteriormente
     desenhada será redesenhada com o caractere mudado caso isso seja
     solicitado.


 -- Função: carg (<z>)
     Retorna o argumento complexo de <z>.  O argumento complexo é um
     ângulo `theta' no intervalo de `(-%pi, %pi]' tal que `r exp (theta
     %i) = <z>' onde `r' é o módulo de <z>.

     `carg' é uma função computacional, não uma função de
     simplificação.

     `carg' ignora a declaração `declare (<x>, complex)', e trata <x>
     como uma variável real.  Isso é um erro.  Veja também `abs'
     (módulo de número complexo), `polarform', `rectform', `realpart',
     e `imagpart'.

     Exemplos:

          (%i1) carg (1);
          (%o1)                           0
          (%i2) carg (1 + %i);
                                         %pi
          (%o2)                          ---
                                          4
          (%i3) carg (exp (%i));
          (%o3)                           1
          (%i4) carg (exp (%pi * %i));
          (%o4)                          %pi
          (%i5) carg (exp (3/2 * %pi * %i));
                                          %pi
          (%o5)                         - ---
                                           2
          (%i6) carg (17 * exp (2 * %i));
          (%o6)                           2


 -- Opereador especial: constant
     `declare (<a>, constant)' declara <a> para ser uma constante.
     Veja `declare'.


 -- Função: constantp (<expr>)
     Retorna `true' se <expr> for uma expressão constante, de outra
     forma retorna `false'.

     Uma expressão é considerada uma expressão constante se seus
     argumentos forem números (incluindo números racionais, como
     mostrado com `/R/'), constantes simbólicas como `%pi', `%e', e
     `%i', variáveis associadas a uma constante ou constante declarada
     através de `declare', ou funções cujos argumentos forem constantes.

     `constantp' avalia seus argumentos.

     Exemplos:

          (%i1) constantp (7 * sin(2));
          (%o1)                                true
          (%i2) constantp (rat (17/29));
          (%o2)                                true
          (%i3) constantp (%pi * sin(%e));
          (%o3)                                true
          (%i4) constantp (exp (x));
          (%o4)                                false
          (%i5) declare (x, constant);
          (%o5)                                done
          (%i6) constantp (exp (x));
          (%o6)                                true
          (%i7) constantp (foo (x) + bar (%e) + baz (2));
          (%o7)                                false
          (%i8)


 -- Função: declare (<a_1>, <p_1>, <a_2>, <p_2>, ...)
     Atribui aos átomos ou lista de átomos <a_i> a propriedade ou lista
     de propriedades <p_i>.  Quando <a_i> e/ou <p_i> forem listas, cada
     um dos átomos recebe todas as propriedades.

     `declare' não avalia seus argumentos.  `declare' sempre retorna
     `done'.

     Como colocado na descrição para cada sinalizador de declaração,
     para alguns sinalizadores `featurep(<objeto>, <recurso>)' retorna
     `true' se <objeto> tiver sido declarado para ter <recurso>.
     Todavia, `featurep' não reconhece alguns sinalizadores; isso é um
     erro.

     Veja também `features'.

     `declare' reconhece as seguintes propriedades:

    `evfun'
          Torna <a_i> conhecido para `ev' de forma que a função nomeada
          por <a_i> é aplicada quando <a_i> aparece como um sinalizador
          argumento de `ev'.  Veja `evfun'.

    `evflag'
          Torna <a_i> conhecido para a função `ev' de forma que <a_i> é
          associado a `true' durante a execução de `ev' quando <a_i>
          aparece como um sinalizador argumento de `ev'.  Veja `evflag'.

    `bindtest'
          Diz ao Maxima para disparar um erro quando <a_i> for avaliado
          como sendo livre de associação.

    `noun'
          Diz ao Maxima para passar <a_i> como um substantivo.  O
          efeito disso é substituir intâncias de <a_i> com `'<a_i>' ou
          `nounify(<a_i>)', ependendo do contexto.

    `constant'
          Diz ao Maxima para considerar <a_i> uma constante simbólica.

    `scalar'
          Diz ao Maxima para considerar <a_i> uma variável escalar.

    `nonscalar'
          Diz ao Maxima para considerar <a_i> uma variável não escalar.
          The usual application is to declare a variable as a symbolic
          vector or matrix.

    `mainvar'
          Diz ao Maxima para considerar <a_i> uma "variável principal"
          (`mainvar').  `ordergreatp' determina a ordenação de átomos
          como segue:

          (variáveis principais) > (outras variáveis) > (variáveis
          escalares) > (constantes) > (números)

    `alphabetic'
          Diz ao Maxima para reconhecer todos os caracteres em <a_i>
          (que deve ser uma seqüência de caracteres) como caractere
          alfabético.

    `feature'
          Diz ao Maxima para reconhecer <a_i> como nome de um recurso.
          Other atoms may then be declared to have the <a_i> property.

    `rassociative', `lassociative'
          Diz ao Maxima para reconhecer <a_i> como uma funcão
          associativa a direita ou associativa a esquerda.

    `nary'
          Diz ao Maxima para reconhecer <a_i> como uma função n-ária
          (com muitos argumentos).

          A declaração `nary' não tem o mesmo objetivo que uma chamada
          à função `nary'.  O único efeito de `declare(foo, nary)' é
          para instruir o simplificador do Maxima a melhorar as
          próximas expressões, por exemplo, para simplificar `foo(x,
          foo(y, z))' para `foo(x, y, z)'.

    `symmetric', `antisymmetric', `commutative'
          Diz ao Maxima para reconhecer <a_i> como uma função simétrica
          ou antisimétrica.  `commutative' é o mesmo que `symmetric'.


          `oddfun', `evenfun' Diz ao Maxima para reconhecer <a_i> como
          uma função par ou uma função ímpar.

    `outative'
          Diz ao Maxima para simplificar expressões <a_i> colocando
          fatores constantes em evidência no primeiro argumento.

          Quando <a_i> tiver um argumento, um fator é onsiderado
          constante se for um literal ou se for declarado como sendo
          constante.

          Quando <a_i> tiver dois ou mais argumentos, um fator é
          considerado constante se o segundo argumento for um símbolo e
          o fator estiver livre do segundo argumento.

    `multiplicative'
          Diz ao Maxima para simplificar expressões do tipo <a_i>
          através da substituição `<a_i>(x * y * z * ...)' `-->'
          `<a_i>(x) * <a_i>(y) * <a_i>(z) * ...'.  A substituição é
          realizada no primeiro argumento somente.

    `additive'
          Diz ao Maxima para simplificar expressões do tipo <a_i>
          através da substituição `<a_i>(x + y + z + ...)' `-->'
          `<a_i>(x) + <a_i>(y) + <a_i>(z) + ...'.  A substituição é
          realizada no primeiro argumento somente.

    `linear'
          Equivalente a declarar <a_i> ao mesmo tempo `outative' e
          `additive'.

    `integer', `noninteger'
          Diz ao Maxima para reconhecer <a_i> como como uma variável
          inteira ou como uma variável não inteira.

          Maxima reconhece os seguintes recursos de objetos:

    `even', `odd'
          Diz ao Maxima para reconhecer <a_i> como uma variável inteira
          par ou como uma variável inteira ímpar.

    `rational', `irrational'
          Diz ao Maxima para reconhecer <a_i> como uma variável real e
          racional ou como uma variável real e irracional.

    `real', `imaginary', `complex'
          Dia ao Maxima para reconhecer <a_i> como uma variável real,
          imaginária pura ou complexa.

    `increasing', `decreasing'
          Dia ao Maxima para reconhecer <a_i> como uma função de
          incremento ou decremento.

    `posfun'
          Diz ao Maxima para reconhecer <a_i> como uma função positiva.

    `integervalued'
          Diz ao Maxima para reconhecer <a_i> como uma função de
          valores inteiros.


     Exemplos:

     Declarações `evfun' e `evflag'.
          (%i1) declare (expand, evfun);
          (%o1)                         done
          (%i2) (a + b)^3;
                                             3
          (%o2)                       (b + a)
          (%i3) (a + b)^3, expand;
                               3        2      2      3
          (%o3)               b  + 3 a b  + 3 a  b + a
          (%i4) declare (demoivre, evflag);
          (%o4)                         done
          (%i5) exp (a + b*%i);
                                       %i b + a
          (%o5)                      %e
          (%i6) exp (a + b*%i), demoivre;
                                a
          (%o6)               %e  (%i sin(b) + cos(b))

     Declaração `bindtest'.
          (%i1) aa + bb;
          (%o1)                        bb + aa
          (%i2) declare (aa, bindtest);
          (%o2)                         done
          (%i3) aa + bb;
          aa unbound variable
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) aa : 1234;
          (%o4)                         1234
          (%i5) aa + bb;
          (%o5)                       bb + 1234

     Declaração `noun'.
          (%i1) factor (12345678);
                                       2
          (%o1)                     2 3  47 14593
          (%i2) declare (factor, noun);
          (%o2)                         done
          (%i3) factor (12345678);
          (%o3)                   factor(12345678)
          (%i4) ''%, nouns;
                                       2
          (%o4)                     2 3  47 14593

     Declarações `constant', `scalar', `nonscalar', e `mainvar'.

     Declaração `alphabetic'.
          (%i1) xx\~yy\`\@ : 1729;
          (%o1)                         1729
          (%i2) declare ("~`@", alphabetic);
          (%o2)                         done
          (%i3) xx~yy`@ + @yy`xx + `xx@@yy~;
          (%o3)               `xx@@yy~ + @yy`xx + 1729
          (%i4) listofvars (%);
          (%o4)                  [@yy`xx, `xx@@yy~]

     Declaração `feature'.
          (%i1) declare (FOO, feature);
          (%o1)                         done
          (%i2) declare (x, FOO);
          (%o2)                         done
          (%i3) featurep (x, FOO);
          (%o3)                         true

     Declarações `rassociative' e `lassociative'.

     Declaração `nary'.
          (%i1) H (H (a, b), H (c, H (d, e)));
          (%o1)               H(H(a, b), H(c, H(d, e)))
          (%i2) declare (H, nary);
          (%o2)                         done
          (%i3) H (H (a, b), H (c, H (d, e)));
          (%o3)                   H(a, b, c, d, e)

     Declarações `symmetric' e `antisymmetric'.
          (%i1) S (b, a);
          (%o1)                        S(b, a)
          (%i2) declare (S, symmetric);
          (%o2)                         done
          (%i3) S (b, a);
          (%o3)                        S(a, b)
          (%i4) S (a, c, e, d, b);
          (%o4)                   S(a, b, c, d, e)
          (%i5) T (b, a);
          (%o5)                        T(b, a)
          (%i6) declare (T, antisymmetric);
          (%o6)                         done
          (%i7) T (b, a);
          (%o7)                       - T(a, b)
          (%i8) T (a, c, e, d, b);
          (%o8)                   T(a, b, c, d, e)

     Declarações `oddfun' e `evenfun'.
          (%i1) o (- u) + o (u);
          (%o1)                     o(u) + o(- u)
          (%i2) declare (o, oddfun);
          (%o2)                         done
          (%i3) o (- u) + o (u);
          (%o3)                           0
          (%i4) e (- u) - e (u);
          (%o4)                     e(- u) - e(u)
          (%i5) declare (e, evenfun);
          (%o5)                         done
          (%i6) e (- u) - e (u);
          (%o6)                           0

     Declaração `outative'.
          (%i1) F1 (100 * x);
          (%o1)                       F1(100 x)
          (%i2) declare (F1, outative);
          (%o2)                         done
          (%i3) F1 (100 * x);
          (%o3)                       100 F1(x)
          (%i4) declare (zz, constant);
          (%o4)                         done
          (%i5) F1 (zz * y);
          (%o5)                       zz F1(y)

     Declaração `multiplicative'.
          (%i1) F2 (a * b * c);
          (%o1)                       F2(a b c)
          (%i2) declare (F2, multiplicative);
          (%o2)                         done
          (%i3) F2 (a * b * c);
          (%o3)                   F2(a) F2(b) F2(c)

     Declaração `additive'.
          (%i1) F3 (a + b + c);
          (%o1)                     F3(c + b + a)
          (%i2) declare (F3, additive);
          (%o2)                         done
          (%i3) F3 (a + b + c);
          (%o3)                 F3(c) + F3(b) + F3(a)

     Declaração `linear'.
          (%i1) 'sum (F(k) + G(k), k, 1, inf);
                                 inf
                                 ====
                                 \
          (%o1)                   >    (G(k) + F(k))
                                 /
                                 ====
                                 k = 1
          (%i2) declare (nounify (sum), linear);
          (%o2)                         done
          (%i3) 'sum (F(k) + G(k), k, 1, inf);
                               inf          inf
                               ====         ====
                               \            \
          (%o3)                 >    G(k) +  >    F(k)
                               /            /
                               ====         ====
                               k = 1        k = 1


 -- Função: disolate (<expr>, <x_1>, ..., <x_n>)
     é similar a `isolate (<expr>, <x>)' exceto que essa função
     habilita ao usuário isolar mais que uma variável simultâneamente.
     Isso pode ser útil, por exemplo, se se tiver tentado mudar
     variáveis em uma integração múltipla, e em mudança de variável
     envolvendo duas ou mais das variáveis de integração.  Essa
     função é chamada automaticamente de `simplification/disol.mac'.
     Uma demostração está disponível através de `demo("disol")$'.


 -- Função: dispform (<expr>)
     Retorna a representação externa de <expr> com relação a seu
     principal operador.  Isso pode ser útil em conjunção com `part' que
     também lida com a representação externa.  Suponha que <expr> seja
     -A .  Então a representação interna de <expr> é  "*"(-1,A),
     enquanto que a representação externa é "-"(A). `dispform (<expr>,
     all)' converte a expressão inteira (não apenas o nível mais alto)
     para o formato externo.  Por exemplo, se `expr: sin (sqrt (x))',
     então `freeof (sqrt, expr)' e `freeof (sqrt, dispform (expr))'
     fornece `true', enquanto `freeof (sqrt, dispform (expr, all))'
     fornece `false'.


 -- Função: distrib (<expr>)
     Distribue adições sobre produtos.  `distrib' difere de `expand' no
     fato de que `distrib' trabalha em somente no nível mais alto de
     uma expressão, i.e., `distrib' não é recursiva e `distrib' é mais
     rápida que `expand'.  `distrib' difere de `multthru' no que
     `distrib' expande todas as adições naquele nível.

     Exemplos:

          (%i1) distrib ((a+b) * (c+d));
          (%o1)                 b d + a d + b c + a c
          (%i2) multthru ((a+b) * (c+d));
          (%o2)                 (b + a) d + (b + a) c
          (%i3) distrib (1/((a+b) * (c+d)));
                                          1
          (%o3)                    ---------------
                                   (b + a) (d + c)
          (%i4) expand (1/((a+b) * (c+d)), 1, 0);
                                          1
          (%o4)                 ---------------------
                                b d + a d + b c + a c


 -- Função: dpart (<expr>, <n_1>, ..., <n_k>)
     Seleciona a mesma subexpressão que `part', mas em lugar de apenas
     retornar aquela subexpressão como seu valor, isso retorna a
     expressão completa com a subexpressão selecionada mostrada dentro
     de uma caixa.  A caixa é atualmente parte da expressão.

          (%i1) dpart (x+y/z^2, 1, 2, 1);
                                       y
          (%o1)                       ---- + x
                                         2
                                      """
                                      "z"
                                      """


 -- Função: exp (<x>)
     Representa função exponencial.  Instâncias de `exp (<x>)' em uma
     entrada são simplificadas para `%e^<x>'; `exp' não aparece em
     expressões simplificadas.

     `demoivre' se `true' faz com que `%e^(a + b %i)' simplificar para
     `%e^(a (cos(b) + %i sin(b)))' se `b' for livre de `%i'. veja
     `demoivre'.

     `%emode', quando `true', faz com que `%e^(%pi %i x)' seja
     simplificado. Veja `%emode'.

     `%enumer', quando `true' faz com que `%e' seja substituído por
     2.718...  quando `numer' for `true'. Veja `%enumer'.


 -- Variável de opção: %emode
     Valor padrão: `true'

     Quando `%emode' for `true', `%e^(%pi %i x)' é simplificado como
     segue.

     `%e^(%pi %i x)' simplifica para `cos (%pi x) + %i sin (%pi x)' se
     `x' for um inteiro ou um multiplo de 1/2, 1/3, 1/4, ou 1/6, e
     então é adicionalmente simplificado.

     Para outro `x' numérico, `%e^(%pi %i x)' simplifica para `%e^(%pi
     %i y)' onde `y' é `x - 2 k' para algum inteiro `k' tal que `abs(y)
     < 1'.

     Quando `%emode' for `false', nenhuma simplificação adicional de
     `%e^(%pi %i x)' é realizada.


 -- Variável de opção: %enumer
     Valor padrão: `false'

     Quando `%enumer' for `true', `%e' é substituido por seu valor
     numérico 2.718...  mesmo que `numer' seja `true'.

     Quando `%enumer' for `false', essa substituição é realizada
     somente se o expoente em `%e^x' avaliar para um número.

     Veja também `ev' e `numer'.


 -- Variável de opção: exptisolate
     Valor padrão: `false'

     `exptisolate', quando `true', faz com que `isolate (expr, var)'
     examine expoentes de átomos (tais como `%e') que contenham `var'.


 -- Variável de opção: exptsubst
     Valor padrão: `false'

     `exptsubst', quando `true', permite substituições tais como `y'
     para `%e^x' em `%e^(a x)'.


 -- Função: freeof (<x_1>, ..., <x_n>, <expr>)
     `freeof (<x_1>, <expr>)' Retorna `true' se nenhuma subexpressão de
     <expr> for igual a <x_1> ou se <x_1> ocorrer somente uma variável
     que não tenha associação fora da expressão <expr>, e retorna
     `false' de outra forma.

     `freeof (<x_1>, ..., <x_n>, <expr>)' é equivalente a `freeof
     (<x_1>, <expr>) and ... and freeof (<x_n>, <expr>)'.

     Os argumentos <x_1>, ..., <x_n> podem ser nomes de funções e
     variáveis, nomes subscritos, operadores (empacotados em aspas
     duplas), ou expressões gerais.  `freeof' avalia seus argumentos.

     `freeof' opera somente sobre <expr> como isso representa (após
     simplificação e avaliação) e não tenta determinar se alguma
     expressão equivalente pode fornecer um resultado diferente.  Em
     particular, simplificação pode retornar uma expressão equivalente
     mas diferente que compreende alguns diferentes elementos da forma
     original de <expr>.

     Uma variável é uma variável dummy em uma expressão se não tiver
     associação fora da expressão.  Variáveis dummy recoreconhecidas
     através de `freeof' são o índice de um somatório ou produtório, o
     limite da variável em `limit', a variável de integração na forma
     de integral definida de `integrate', a variável original em
     `laplace', variáveis formais em expressoes `at', e argumentos em
     expressões `lambda'.  Variáveis locais em `block' não são
     reconhecidas por `freeof' como variáveis dummy; isso é um bug.

     A forma indefinida de `integrate' not é livre de suas variáveis de
     integração.

        * Argumentos são nomes de funções, variáveis, nomes subscritos,
          operadores, e expressões.  `freeof (a, b, expr)' é
          equivalente a `freeof (a, expr) and freeof (b, expr)'.

               (%i1) expr: z^3 * cos (a[1]) * b^(c+d);
                                                d + c  3
               (%o1)                   cos(a ) b      z
                                            1
               (%i2) freeof (z, expr);
               (%o2)                         false
               (%i3) freeof (cos, expr);
               (%o3)                         false
               (%i4) freeof (a[1], expr);
               (%o4)                         false
               (%i5) freeof (cos (a[1]), expr);
               (%o5)                         false
               (%i6) freeof (b^(c+d), expr);
               (%o6)                         false
               (%i7) freeof ("^", expr);
               (%o7)                         false
               (%i8) freeof (w, sin, a[2], sin (a[2]), b*(c+d), expr);
               (%o8)                         true

        * `freeof' avalia seus argumentos.

               (%i1) expr: (a+b)^5$
               (%i2) c: a$
               (%i3) freeof (c, expr);
               (%o3)                         false

        * `freeof' não considera expressões equivalentes.
          Simplificação pode retornar uma expressão equivalente mas
          diferente.

               (%i1) expr: (a+b)^5$
               (%i2) expand (expr);
                         5        4       2  3       3  2      4      5
               (%o2)    b  + 5 a b  + 10 a  b  + 10 a  b  + 5 a  b + a
               (%i3) freeof (a+b, %);
               (%o3)                         true
               (%i4) freeof (a+b, expr);
               (%o4)                         false
               (%i5) exp (x);
                                                x
               (%o5)                          %e
               (%i6) freeof (exp, exp (x));
               (%o6)                         true

        * Um somatório ou uma integral definida está livre de uma
          variável dummy.  Uma integral indefinida não é livre de suas
          variáveis de integração.

               (%i1) freeof (i, 'sum (f(i), i, 0, n));
               (%o1)                         true
               (%i2) freeof (x, 'integrate (x^2, x, 0, 1));
               (%o2)                         true
               (%i3) freeof (x, 'integrate (x^2, x));
               (%o3)                         false


 -- Função: genfact (<x>, <y>, <z>)
     Retorna o fatorial generalizado, definido como `x (x-z) (x - 2 z)
     ... (x - (y - 1) z)'.  Dessa forma, para integral <x>, `genfact
     (x, x, 1) = x!' e `genfact (x, x/2, 2) = x!!'.


 -- Função: imagpart (<expr>)
     Retorna a parte imaginária da expressão <expr>.

     `imagpart' é uma função computacional, não uma função de
     simplificação.

     Veja também `abs', `carg', `polarform', `rectform', e `realpart'.


 -- Função: infix (<op>)
 -- Função: infix (<op>, <lbp>, <rbp>)
 -- Função: infix (<op>, <lbp>, <rbp>, <lpos>, <rpos>, <pos>)
     Declara <op> para ser um operador infixo.  Um operador infixo é
     uma função de dois argumentos, com o nome da função escrito entre
     os argumentos.  Por exemplo, o operador de subtração `-' é um
     operador infixo.

     `infix (<op>)' declara <op> para ser um operador infixo com
     expoentes associados padrão (esquerdo e direito ambos iguais a 180)
     e podendo ser qualquer entre prefixado, infixado, posfixado, nário,
     matchfix e nofix (esquerdo e direito ambos iguais a `any').

     `infix (<op>, <lbp>, <rbp>)' declara <op> para ser um operador
     infixo com expoentes associados esquerdo e diretio equilibrados e
     podendo ser qualquer entre prefixado, infixado, posfixado, nário,
     matchfix e nofix (esquerdo e direito ambos iguais a `any').

     `infix (<op>, <lbp>, <rbp>, <lpos>, <rpos>, <pos>)' declara <op>
     para ser um operdor infixo com expoentes associados padrão e
     podendo ser um entre prefixado, infixado, posfixado, nário,
     matchfix e nofix.

     A precedência de <op> com relação a outros operadores derivam dos
     expoentes associados diretiro e esquerdo dos operadores em questão.
     Se os expoentes associados esquerdo e direito de <op> forem ambos
     maiores que o expoente associado esquerdo e o direito de algum
     outro operador, então <op> tem prededência sobre o outro operador.
     Se os expoentes associados não forem ambos maior ou menor, alguma
     relação mais complicada ocorre.

     A associatividade de <op> depende de seus expoentes associados.
     Maior expoente associado esquerdo (<eae>) implica uma instância de
     <op> é avaliadas antes de outros operadores para sua esquerda em
     uma expressão, enquanto maior expoente associado direito (<ead>)
     implica uma instância de <op> é avaliada antes de outros
     operadores para sua direita em uma expressão.  Dessa forma maior
     <eae> torna <op> associativo à direita, enquanto maior <ead> torna
     <op> associativa à esquerda.  Se <eae> for igual a <ead>, <op> é
     associativa à esquerda.

     Veja também `Syntax'.

     Exemplos:

     Se os expoentes associados esquerdo e direito de <op> forem ambos
     maiores que os expoentes associados à direita e à esquerda de
     algum outro operador, então <op> tem precedência sobre o outro
     operador.

          (%i1) :lisp (get '$+ 'lbp)
          100
          (%i1) :lisp (get '$+ 'rbp)
          100
          (%i1) infix ("##", 101, 101);
          (%o1)                          ##
          (%i2) "##"(a, b) := sconcat("(", a, ",", b, ")");
          (%o2)       (a ## b) := sconcat("(", a, ",", b, ")")
          (%i3) 1 + a ## b + 2;
          (%o3)                       (a,b) + 3
          (%i4) infix ("##", 99, 99);
          (%o4)                          ##
          (%i5) 1 + a ## b + 2;
          (%o5)                       (a+1,b+2)

     grande <eae> torna <op> associativa à direita, enquanto grande
     <ead> torna <op> associativa à esquerda.

          (%i1) infix ("##", 100, 99);
          (%o1)                          ##
          (%i2) "##"(a, b) := sconcat("(", a, ",", b, ")")$
          (%i3) foo ## bar ## baz;
          (%o3)                    (foo,(bar,baz))
          (%i4) infix ("##", 100, 101);
          (%o4)                          ##
          (%i5) foo ## bar ## baz;
          (%o5)                    ((foo,bar),baz)


 -- Variável de opção: inflag
     Velor padrão: `false'

     Quando `inflag' for `true', funções para extração de partes
     inspecionam a forma interna de `expr'.

     Note que o simplificador re-organiza expressões.  Dessa forma
     `first (x + y)' retorna `x' se `inflag' for `true' e `y' se
     `inflag' for `false'.  (`first (y + x)' fornece os mesmos
     resultados.)

     Também, escolhendo `inflag' para `true' e chamando `part' ou
     `substpart' é o mesmo que chamar `inpart' ou `substinpart'.

     As funções afetadas pela posição do sinalizador `inflag' são:
     `part', `substpart', `first', `rest', `last', `length', a
     estrutura `for' ... `in', `map', `fullmap', `maplist', `reveal' e
     `pickapart'.


 -- Função: inpart (<expr>, <n_1>, ..., <n_k>)
     É similar a `part' mas trabalha sobre a representação interna da
     expressão em lugar da forma de exibição e dessa forma pode ser
     mais rápida uma vez que nenhuma formatação é realizada.  Cuidado
     deve ser tomado com relação à ordem de subexpressões em adições e
     produtos (uma vez que a ordem das variáveis na forma interna é
     muitas vezes diferente daquela na forma mostrada) e no manuseio
     com menos unário, subtração, e divisão (uma vez que esses
     operadores são removidos da expressão). `part (x+y, 0)' ou `inpart
     (x+y, 0)' retorna `+', embora com o objetivo de referirse ao
     operador isso deva ser abraçado por aspas duplas.  Por exemplo
     `... if inpart (%o9,0) = "+" then ...'.

     Exemplos:

          (%i1) x + y + w*z;
          (%o1)                      w z + y + x
          (%i2) inpart (%, 3, 2);
          (%o2)                           z
          (%i3) part (%th (2), 1, 2);
          (%o3)                           z
          (%i4) 'limit (f(x)^g(x+1), x, 0, minus);
                                            g(x + 1)
          (%o4)                 limit   f(x)
                                x -> 0-
          (%i5) inpart (%, 1, 2);
          (%o5)                       g(x + 1)


 -- Função: isolate (<expr>, <x>)
     Retorna <expr> com subexpressões que são adições e que não possuem
     <x> substituido por rótulos de expressão intermediária (esses
     sendo símbolos atômicos como `%t1', `%t2', ...).  Isso é muitas
     vezes útil para evitar expansões desnecessárias de subexpressões
     que não possuam a variável de interesse.  Uma vez que os rótulos
     intermediários são associados às subexpressões eles podem todos
     ser substituídos de volta por avaliação da expressão em que
     ocorrerem.

     `exptisolate' (valor padrão: `false') se `true' fará com que
     `isolate' examine expoentes de átomos (como `%e') que contenham
     <x>.

     `isolate_wrt_times' se `true', então `isolate' irá também isolar
     com relação a produtos. Veja `isolate_wrt_times'.

     Faça `example (isolate)' para exemplos.


 -- Variável de opção: isolate_wrt_times
     Valor padrão: `false'

     Quando `isolate_wrt_times' for `true', `isolate' irá também isolar
     com relação a produtos.  E.g. compare ambas as escolhas do
     comutador em

          (%i1) isolate_wrt_times: true$
          (%i2) isolate (expand ((a+b+c)^2), c);

          (%t2)                          2 a


          (%t3)                          2 b


                                    2            2
          (%t4)                    b  + 2 a b + a

                               2
          (%o4)               c  + %t3 c + %t2 c + %t4
          (%i4) isolate_wrt_times: false$
          (%i5) isolate (expand ((a+b+c)^2), c);
                               2
          (%o5)               c  + 2 b c + 2 a c + %t4


 -- Variável de opção: listconstvars
     Valor padrão: `false'

     Quando `listconstvars' for `true', isso fará com que `listofvars'
     inclua `%e', `%pi', `%i', e quaisquer variáveis declaradas
     contantes na lista seja retornado se aparecer na expressão que
     chamar `listofvars'.  O comportamento padrão é omitir isso.


 -- Variável de opção: listdummyvars
     Valor padrão: `true'

     Quando `listdummyvars' for `false', "variáveis dummy" na expressão
     não serão incluídas na lista retornada por `listofvars'.  (O
     significado de "variável dummy" é o mesmo que em `freeof'.
     "Variáveis dummy" são conceitos matemáticos como o índice de um
     somatório ou produtório, a variável limite, e a variável da
     integral definida.)  Exemplo:

          (%i1) listdummyvars: true$
          (%i2) listofvars ('sum(f(i), i, 0, n));
          (%o2)                        [i, n]
          (%i3) listdummyvars: false$
          (%i4) listofvars ('sum(f(i), i, 0, n));
          (%o4)                          [n]


 -- Função: listofvars (<expr>)
     Retorna uma lista de variáveis em <expr>.

     `listconstvars' se `true' faz com que `listofvars' inclua `%e',
     `%pi', `%i', e quaisquer variáveis declaradas constantes na lista
     é retornada se aparecer em <expr>.  O comportamento padrão é
     omitir isso.

          (%i1) listofvars (f (x[1]+y) / g^(2+a));
          (%o1)                     [g, a, x , y]
                                            1


 -- Função: lfreeof (<lista>, <expr>)
     Para cada um dos membros <m> de lista, chama `freeof (<m>,
     <expr>)'.  Retorna `false' se qualquer chamada a `freeof' for
     feita e `true' de outra forma.

 -- Função: lopow (<expr>, <x>)
     Retorna o menor expoente de <x> que explicitamente aparecer em
     <expr>.  Dessa forma

          (%i1) lopow ((x+y)^2 + (x+y)^a, x+y);
          (%o1)                       min(a, 2)


 -- Função: lpart (<rótulo>, <expr>, <n_1>, ..., <n_k>)
     é similar a `dpart' mas usa uma caixa rotulada. Uma moldura
     rotulada é similar à que é produzida por `dpart' mas a produzida
     por `lpart' tem o nome na linha do topo.


 -- Função: multthru (<expr>)
 -- Função: multthru (<expr_1>, <expr_2>)
     Multiplica um fator (que pode ser uma adição) de <expr> pelos
     outros fatores de <expr>.  Isto é, <expr> é `<f_1> <f_2> ... <f_n>'
     onde ao menos um fator, digamos <f_i>, é uma soma de termos.  Cada
     termo naquela soma é multiplicado por outros fatores no produto.
     (A saber todos os fatores exceto <f_i>).  `multthru' não expande
     somas exponenciais.  Essa função é o caminho mais rápido para
     distribuir produtos (comutativos ou não) sobre adições.  Uma vez
     que quocientes são representados como produtos `multthru' podem
     ser usados para dividir adições por produtos também.

     `multthru (<expr_1>, <expr_2>)' multiplica cada termo em <expr_2>
     (que pode ser uma adição ou uma equção) por <expr_1>.  Se <expr_1>
     não for por si mesmo uma adição então essa forma é equivalente a
     `multthru (<expr_1>*<expr_2>)'.

          (%i1) x/(x-y)^2 - 1/(x-y) - f(x)/(x-y)^3;
                                1        x         f(x)
          (%o1)             - ----- + -------- - --------
                              x - y          2          3
                                      (x - y)    (x - y)
          (%i2) multthru ((x-y)^3, %);
                                     2
          (%o2)             - (x - y)  + x (x - y) - f(x)
          (%i3) ratexpand (%);
                                     2
          (%o3)                   - y  + x y - f(x)
          (%i4) ((a+b)^10*s^2 + 2*a*b*s + (a*b)^2)/(a*b*s^2);
                                  10  2              2  2
                           (b + a)   s  + 2 a b s + a  b
          (%o4)            ------------------------------
                                            2
                                       a b s
          (%i5) multthru (%);  /* note que isso não expande (b+a)^10 */
                                                  10
                                 2   a b   (b + a)
          (%o5)                  - + --- + ---------
                                 s    2       a b
                                     s
          (%i6) multthru (a.(b+c.(d+e)+f));
          (%o6)            a . f + a . c . (e + d) + a . b
          (%i7) expand (a.(b+c.(d+e)+f));
          (%o7)         a . f + a . c . e + a . c . d + a . b


 -- Função: nounify (<f>)
     Retorna a forma substantiva do nome da função <f>.  Isso é
     necessário se se quer referir ao nome de uma função verbo como se
     esse nome fosse um substantivo.  Note que algumas funções verbos
     irão retornar sua forma substantiva senão puderem ser avaliadas
     para certos argumentos.  A forma substantiva é também a forma
     retornada se uma chamada de função é precedida por um apóstrofo.


 -- Função: nterms (<expr>)
     Retorna o número de termos que <expr> pode ter se for
     completamente expandida e nenhum cancelamento ou combinação de
     termos acontecer.  Note expressões como `sin (<expr>)', `sqrt
     (<expr>)', `exp (<expr>)', etc.  contam como apenas um termo
     independentemente de quantos termos <expr> tenha (se <expr> for uma
     adição).


 -- Função: op (<expr>)
     Retorna o operador principal da expressão <expr>.  `op (<expr>)' é
     equivalente a `part (<expr>, 0)'.

     `op' retorna uma seqüência de caracteres se o operador principal
     for uma operador interno ou definido pelo usuário como prefixado,
     binário ou n-ário infixo, posfixado, matchfix ou nofix.  De outra
     forma, se <expr> for uma expressão de função subscrita, `op'
     retorna uma função subscrita; nesse caso o valor de retorno não é
     um átomo.  De outro modo, <expr> é uma função de array ou uma
     expressão de função comum, e `op' retorna um símbolo.

     `op' observa o valor do sinalizador global `inflag'.

     `op' avalia seus argumentos.

     Veja também `args'.

     Exemplos:

          (%i1) stringdisp: true$
          (%i2) op (a * b * c);
          (%o2)                          "*"
          (%i3) op (a * b + c);
          (%o3)                          "+"
          (%i4) op ('sin (a + b));
          (%o4)                          sin
          (%i5) op (a!);
          (%o5)                          "!"
          (%i6) op (-a);
          (%o6)                          "-"
          (%i7) op ([a, b, c]);
          (%o7)                          "["
          (%i8) op ('(if a > b then c else d));
          (%o8)                         "if"
          (%i9) op ('foo (a));
          (%o9)                          foo
          (%i10) prefix (foo);
          (%o10)                        "foo"
          (%i11) op (foo a);
          (%o11)                        "foo"
          (%i12) op (F [x, y] (a, b, c));
          (%o12)                        F
                                         x, y
          (%i13) op (G [u, v, w]);
          (%o13)                          G


 -- Função: operatorp (<expr>, <op>)
 -- Função: operatorp (<expr>, [<op_1>, ..., <op_n>])
     `operatorp (<expr>, <op>)' retorna `true' se <op> for igual ao
     operador de <expr>.

     `operatorp (<expr>, [<op_1>, ..., <op_n>])' retorna `true' se
     algum elementos de <op_1>, ..., <op_n> for igual ao operador de
     <expr>.


 -- Função: optimize (<expr>)
     Retorna uma expressão que produz o mesmo valor e efeito que <expr>
     mas faz de forma mais eficientemente por evitar a recomputação de
     subexpressões comuns.  `optimize' também tem o mesmo efeito de
     "colapsar" seus argumentos de forma que todas as subexpressões
     comuns são compartilhadas.  Faça `example (optimize)' para
     exemplos.


 -- Variável de opção: optimprefix
     Valor padrão: `%'

     `optimprefix' é o prefixo usado para símbolos gerados pelo comando
     `optimize'.


 -- Função: ordergreat (<v_1>, ..., <v_n>)
     Escolhe aliases para as variáveis <v_1>, ..., <v_n> tais que <v_1>
     > <v_2> > ...  > <v_n>, e <v_n> > qualquer outra variável não
     mencionada como um argumento.

     Veja também `orderless'.


 -- Função: ordergreatp (<expr_1>, <expr_2>)
     Retorna `true' se <expr_2> precede <expr_1> na ordenação escolhida
     com a função `ordergreat'.


 -- Função: orderless (<v_1>, ..., <v_n>)
     Escolhe aliases para as variáveis <v_1>, ..., <v_n> tais que <v_1>
     < <v_2> < ...  < <v_n>, and <v_n> < qualquer outra variável não
     mencionada como um argumento.

     Dessa forma a escala de ordenação completa é: constantes numéricas
     < constantes declaradas < escalares declarados < primeiro
     argumento para `orderless' < ...  < último argumento para
     `orderless' < variáveis que começam com A < ...  < variáveis que
     começam com Z < último argumento para `ordergreat' <  ... <
     primeiro argumento para `ordergreat' < `mainvar's - variáveis
     principais declaradas.

     Veja também `ordergreat' e `mainvar'.


 -- Função: orderlessp (<expr_1>, <expr_2>)
     Retorna `true' se <expr_1> precede <expr_2> na ordenação escolhida
     pelo comando `orderless'.


 -- Função: part (<expr>, <n_1>, ..., <n_k>)
     Retorna partes da forma exibida de `expr'. Essa função obtém a
     parte de `expr' como especificado pelos índices <n_1>, ..., <n_k>.
     A primeira parte <n_1> de `expr' é obtida, então a parte <n_2>
     daquela  é obtida, etc.  O resultado é parte <n_k> de ... parte
     <n_2> da parte <n_1> da `expr'.

     `part' pode ser usada para obter um elemento de uma lista, uma
     linha de uma matriz, etc.

     Se o último argumento para uma função `part' for uma lista de
     índices então muitas subexpressões serão pinçadas, cada uma
     correspondendo a um índice da lista.  Dessa forma `part (x + y +
     z, [1, 3])' é `z+x'.

     `piece' mantém a última expressão selecionada quando usando as
     funções `part'.  Isso é escolhido durante a execução da função e
     dessa forma pode referir-se à função em si mesma como mostrado
     abaixo.

     Se `partswitch' for escolhido para `true' então `end' é retornado
     quando uma parte selecionada de uma expressão não existir, de
     outra forma uma mensagem de erro é forncecida.

     Exemplo: `part (z+2*y, 2, 1)' retorna 2.

     `example (part)' mostra exemplos adicionais.


 -- Função: partition (<expr>, <x>)
     Retorna uma lista de duas expressões.  Elas são (1) os fatores de
     <expr> (se essa expressão for um produto), os termos de <expr> (se
     isso for uma adição), ou a lista (se isso for uma lsita) que não
     contiver `var' e, (2) os fatores, termos, ou lista que faz.

          (%i1) partition (2*a*x*f(x), x);
          (%o1)                     [2 a, x f(x)]
          (%i2) partition (a+b, x);
          (%o2)                      [b + a, 0]
          (%i3) partition ([a, b, f(a), c], a);
          (%o3)                  [[b, c], [a, f(a)]]


 -- Variável de opção: partswitch
     Valor padrão: `false'

     Quando `partswitch' for `true', `end' é retornado quando uma parte
     selecionada de uma expressão não existir, de outra forma uma
     mensagem de erro é fornecida.


 -- Função: pickapart (<expr>, <n>)
     Atribui rótulos de expressão intermediária a subexpressões de
     <expr> de comprimento <n>, um inteiro.  A subexpressões maiores ou
     menores não são atribuidos rótulos.  `pickapart' retorna uma
     expressão em termos de expressões intermediárias equivalentes à
     expressão original <expr>.

     Veja também `part', `dpart', `lpart', `inpart', e `reveal'.

     Exemplos:

          (%i1) expr: (a+b)/2 + sin (x^2)/3 - log (1 + sqrt(x+1));
                                                    2
                                               sin(x )   b + a
          (%o1)       - log(sqrt(x + 1) + 1) + ------- + -----
                                                  3        2
          (%i2) pickapart (expr, 0);

                                                    2
                                               sin(x )   b + a
          (%t2)       - log(sqrt(x + 1) + 1) + ------- + -----
                                                  3        2

          (%o2)                          %t2
          (%i3) pickapart (expr, 1);

          (%t3)                - log(sqrt(x + 1) + 1)


                                            2
                                       sin(x )
          (%t4)                        -------
                                          3


                                        b + a
          (%t5)                         -----
                                          2

          (%o5)                    %t5 + %t4 + %t3
          (%i5) pickapart (expr, 2);

          (%t6)                 log(sqrt(x + 1) + 1)


                                            2
          (%t7)                        sin(x )


          (%t8)                         b + a

                                   %t8   %t7
          (%o8)                    --- + --- - %t6
                                    2     3
          (%i8) pickapart (expr, 3);

          (%t9)                    sqrt(x + 1) + 1


                                          2
          (%t10)                         x

                            b + a              sin(%t10)
          (%o10)            ----- - log(%t9) + ---------
                              2                    3
          (%i10) pickapart (expr, 4);

          (%t11)                     sqrt(x + 1)

                                2
                           sin(x )   b + a
          (%o11)           ------- + ----- - log(%t11 + 1)
                              3        2
          (%i11) pickapart (expr, 5);

          (%t12)                        x + 1

                             2
                        sin(x )   b + a
          (%o12)        ------- + ----- - log(sqrt(%t12) + 1)
                           3        2
          (%i12) pickapart (expr, 6);
                            2
                       sin(x )   b + a
          (%o12)       ------- + ----- - log(sqrt(x + 1) + 1)
                          3        2


 -- Variável de sistema: piece
     Mantém a ultima expressão selecionada quando usando funções `part'.
     Isso é escolhido durante a execução da função e dessa forma pode
     referir-se à função em si mesma.


 -- Função: polarform (<expr>)
     Retorna uma expressão `r %e^(%i theta)' equivalente a <expr>, tal
     que `r' e `theta' sejam puramente reais.


 -- Função: powers (<expr>, <x>)
     Fornece os expoentes de <x> que ocorrem em expressão <expr>.

     `load (powers)' chama essa função.


 -- Função: product (<expr>, <i>, <i_0>, <i_1>)
     Representa um produto dos velores de `expr' com o índice <i>
     variando de <i_0> a <i_1>.  A forma substantiva `'product' é
     mostrada como um pi maiísculo.

     `product' avalia <expr> e os limites inferior e superior <i_0> e
     <i_1>, `product' coloca um apóstrofo (não avalia) o índice <i>.

     Se os limites superiores e inferiores diferirem por um inteiro,
     <expr> é avaliada para cada valor do índice <i>, e o resultado  um
     produto explícito.

     de outra forma, o intervalo do índice é indefinido.  Algumas
     regras são aplicads para simplificar o produto.  Quando a variável
     global `simpproduct' for `true', regras adicionais são aplicadas.
     Em alguns casos, simplificação um resultado que não é um produto;
     de outra forma, o resultado é uma forma substantiva `'product'.

     Veja também `nouns' e `evflag'.

     Exemplos:

          (%i1) product (x + i*(i+1)/2, i, 1, 4);
          (%o1)           (x + 1) (x + 3) (x + 6) (x + 10)
          (%i2) product (i^2, i, 1, 7);
          (%o2)                       25401600
          (%i3) product (a[i], i, 1, 7);
          (%o3)                 a  a  a  a  a  a  a
                                 1  2  3  4  5  6  7
          (%i4) product (a(i), i, 1, 7);
          (%o4)          a(1) a(2) a(3) a(4) a(5) a(6) a(7)
          (%i5) product (a(i), i, 1, n);
                                       n
                                     /===\
                                      ! !
          (%o5)                       ! !  a(i)
                                      ! !
                                     i = 1
          (%i6) product (k, k, 1, n);
                                         n
                                       /===\
                                        ! !
          (%o6)                         ! !  k
                                        ! !
                                       k = 1
          (%i7) product (k, k, 1, n), simpproduct;
          (%o7)                          n!
          (%i8) product (integrate (x^k, x, 0, 1), k, 1, n);
                                       n
                                     /===\
                                      ! !    1
          (%o8)                       ! !  -----
                                      ! !  k + 1
                                     k = 1
          (%i9) product (if k <= 5 then a^k else b^k, k, 1, 10);
                                        15  40
          (%o9)                        a   b


 -- Função: realpart (<expr>)
     Retorna a parte real de <expr>. `realpart' e `imagpart' irão
     trabalhar sobre expressões envolvendo funções trigonométricas e
     hiperbólicas, bem como raízes quadradas, logarítmos, e
     exponenciação.


 -- Função: rectform (<expr>)
     Retorna uma expressão `a + b %i' equivalente a <expr>, tal que <a>
     e <b> sejam puramente reais.


 -- Função: rembox (<expr>, unlabelled)
 -- Função: rembox (<expr>, <rótulo>)
 -- Função: rembox (<expr>)
     Remove caixas de <expr>.

     `rembox (<expr>, unlabelled)' remove todas as caixas sem rótulos
     de <expr>.

     `rembox (<expr>, <rótulo>)' remove somente caixas contendo
     <rótulo>.

     `rembox (<expr>)' remove todas as caixas, rotuladas e nã rotuladas.

     Caixas são desenhadas pelas funções `box', `dpart', e `lpart'.

     Exemplos:

          (%i1) expr: (a*d - b*c)/h^2 + sin(%pi*x);
                                            a d - b c
          (%o1)                sin(%pi x) + ---------
                                                2
                                               h
          (%i2) dpart (dpart (expr, 1, 1), 2, 2);
                                  """""""    a d - b c
          (%o2)               sin("%pi x") + ---------
                                  """""""      """"
                                               " 2"
                                               "h "
                                               """"
          (%i3) expr2: lpart (BAR, lpart (FOO, %, 1), 2);
                            FOO"""""""""""   BAR""""""""
                            "    """"""" "   "a d - b c"
          (%o3)             "sin("%pi x")" + "---------"
                            "    """"""" "   "  """"   "
                            """"""""""""""   "  " 2"   "
                                             "  "h "   "
                                             "  """"   "
                                             """""""""""
          (%i4) rembox (expr2, unlabelled);
                                            BAR""""""""
                             FOO"""""""""   "a d - b c"
          (%o4)              "sin(%pi x)" + "---------"
                             """"""""""""   "    2    "
                                            "   h     "
                                            """""""""""
          (%i5) rembox (expr2, FOO);
                                            BAR""""""""
                                 """""""    "a d - b c"
          (%o5)              sin("%pi x") + "---------"
                                 """""""    "  """"   "
                                            "  " 2"   "
                                            "  "h "   "
                                            "  """"   "
                                            """""""""""
          (%i6) rembox (expr2, BAR);
                             FOO"""""""""""
                             "    """"""" "   a d - b c
          (%o6)              "sin("%pi x")" + ---------
                             "    """"""" "     """"
                             """"""""""""""     " 2"
                                                "h "
                                                """"
          (%i7) rembox (expr2);
                                            a d - b c
          (%o7)                sin(%pi x) + ---------
                                                2
                                               h


 -- Função: sum (<expr>, <i>, <i_0>, <i_1>)
     Representa um somatório dos valores de <expr> com o índice <i>
     variando de <i_0> a <i_1>.  A forma substantiva `'sum' é mostrada
     com uma letra sigma maiúscula.  `sum' avalia seu somando <expr> e
     limites inferior e superior <i_0> e <i_1>, `sum' coloca apóstrofo
     (não avalia) o índice <i>.

     Se os limites superiores e inferiores diferirem de um número
     inteiro, o somatoriando <expr> é avaliado para cada valor do
     índice do somatório <i>, e o resultado é uma adição explícita.

     De outra forma, o intervalo dos índices é indefinido.  Algumas
     regras são aplicadas para simplificar o somatório.  Quando a
     variável global `simpsum' for `true', regras adicionais são
     aplicadas.  Em alguns casos, simplificações retornam um resultado
     que não é um somatório; de outra forma, o resultado é uma forma
     substantiva `'sum'.

     Quando o `evflag' (sinalizador de avaliação) `cauchysum' for
     `true', um produto de somatórios é mostrado como um produto de
     Cauchy, no qual o índice do somatório mais interno é uma função de
     índice de um nível acima, em lugar de variar independentemente.

     A variável global `genindex' é o prefixo alfabético usado para
     gerar o próximo índice do somatório, quando um índice
     automaticamente gerado for necessário.

     `gensumnum' é o sufixo numérico usando para gerar o próximo índice
     do somatório, quando um índice gerado automaticamente for
     necessário.  Quando `gensumnum' for `false', um índice gerado
     automaticamente é somente `genindex' sem sufixo numérico.

     Veja também `sumcontract', `intosum', `bashindices', `niceindices',
     `nouns', `evflag', e `zeilberger'.

     Exemplos:

          (%i1) sum (i^2, i, 1, 7);
          (%o1)                          140
          (%i2) sum (a[i], i, 1, 7);
          (%o2)           a  + a  + a  + a  + a  + a  + a
                           7    6    5    4    3    2    1
          (%i3) sum (a(i), i, 1, 7);
          (%o3)    a(7) + a(6) + a(5) + a(4) + a(3) + a(2) + a(1)
          (%i4) sum (a(i), i, 1, n);
                                      n
                                     ====
                                     \
          (%o4)                       >    a(i)
                                     /
                                     ====
                                     i = 1
          (%i5) sum (2^i + i^2, i, 0, n);
                                    n
                                   ====
                                   \       i    2
          (%o5)                     >    (2  + i )
                                   /
                                   ====
                                   i = 0
          (%i6) sum (2^i + i^2, i, 0, n), simpsum;
                                        3      2
                             n + 1   2 n  + 3 n  + n
          (%o6)             2      + --------------- - 1
                                            6
          (%i7) sum (1/3^i, i, 1, inf);
                                      inf
                                      ====
                                      \     1
          (%o7)                        >    --
                                      /      i
                                      ====  3
                                      i = 1
          (%i8) sum (1/3^i, i, 1, inf), simpsum;
                                          1
          (%o8)                           -
                                          2
          (%i9) sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf);
                                        inf
                                        ====
                                        \     1
          (%o9)                      30  >    --
                                        /      2
                                        ====  i
                                        i = 1
          (%i10) sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf), simpsum;
                                            2
          (%o10)                       5 %pi
          (%i11) sum (integrate (x^k, x, 0, 1), k, 1, n);
                                      n
                                     ====
                                     \       1
          (%o11)                      >    -----
                                     /     k + 1
                                     ====
                                     k = 1
          (%i12) sum (if k <= 5 then a^k else b^k, k, 1, 10));
          Incorrect syntax: Too many )'s
          else b^k, k, 1, 10))
                            ^
          (%i12) linenum:11;
          (%o11)                         11
          (%i12) sum (integrate (x^k, x, 0, 1), k, 1, n);
                                      n
                                     ====
                                     \       1
          (%o12)                      >    -----
                                     /     k + 1
                                     ====
                                     k = 1
          (%i13) sum (if k <= 5 then a^k else b^k, k, 1, 10);
                    10    9    8    7    6    5    4    3    2
          (%o13)   b   + b  + b  + b  + b  + a  + a  + a  + a  + a


 -- Função: lsum (<expr>, <x>, <L>)
     Representas a adição de <expr> a cada elemento <x> em <L>.

     Uma forma substantiva `'lsum' é retornada se o argumento <L> não
     avaliar para uma lista.

     Exemplos:

          (%i1) lsum (x^i, i, [1, 2, 7]);
                                      7    2
          (%o1)                      x  + x  + x
          (%i2) lsum (i^2, i, rootsof (x^3 - 1));
                               ====
                               \      2
          (%o2)                 >    i
                               /
                               ====
                                             3
                               i in rootsof(x  - 1)


 -- Função: verbify (<f>)
     Retorna a forma verbal da função chamada <f>.

     Veja também `verb', `noun', e `nounify'.

     Exemplos:

          (%i1) verbify ('foo);
          (%o1)                          foo
          (%i2) :lisp $%
          $FOO
          (%i2) nounify (foo);
          (%o2)                          foo
          (%i3) :lisp $%
          %FOO



File: maxima.info,  Node: Simplificação,  Next: Montando Gráficos,  Prev: Expressões,  Up: Top

7 Simplificação
***************

* Menu:

* Funções e Variáveis Definidas para Simplificação::


File: maxima.info,  Node: Funções e Variáveis Definidas para Simplificação,  Prev: Simplificação,  Up: Simplificação

7.1 Funções e Variáveis Definidas para Simplificação
====================================================

 -- Variável de sistema: askexp
     Quando `asksign' é chamada, `askexp' é a expressão que `asksign'
     está testando.

     Antigamente, era possível para um usuário inspecionar `askexp'
     entrando em uma parada do Maxima com control-A.

 -- Função: askinteger (<expr>, integer)
 -- Função: askinteger (<expr>)
 -- Função: askinteger (<expr>, even)
 -- Função: askinteger (<expr>, odd)
     `askinteger (<expr>, integer)' tenta determinar a partir da base
     de dados do `assume' se <expr> é um inteiro.  `askinteger'
     pergunta ao usuário pela linha de comando se isso não puder ser
     feito de outra forma, e tenta instalar a informação na base de
     dados do `assume' se for possível.  `askinteger (<expr>)' é
     equivalente a `askinteger (<expr>, integer)'.

     `askinteger (<expr>, even)' e `askinteger (<expr>, odd)' da mesma
     forma tentam determinar se <expr> é um inteiro par ou inteiro
     ímpar, respectivamente.


 -- Função: asksign (<expr>)
     Primeiro tenta determinar se a expressão especificada é positiva,
     negativa, ou zero.  Se isso não for possível, `asksign' pergunta ao
     usuário pelas questões necessárias para completar a sua dedução.
     As respostas do usuário são guardadas na base de dados pelo tempo
     que durar a computação corrente. O valor de retorno de `asksign' é
     um entre `pos', `neg', ou `zero'.


 -- Função: demoivre (<expr>)
 -- Variável de opção: demoivre
     A função `demoivre (expr)' converte uma expressão sem escolher a
     variável global `demoivre'.

     Quando a variável `demoivre' for `true', exponenciais complexas
     são convertidas em expressões equivalentes em termos de funções
     circulares: `exp (a + b*%i)' simplifica para `%e^a * (cos(b) +
     %i*sin(b))' se `b' for livre de `%i'.  `a' e `b' não são
     expandidos.

     O valor padrão de `demoivre' é `false'.

     `exponentialize' converte funções circulares e hiperbólicas para a
     forma exponencial.  `demoivre' e `exponentialize' não podem ambas
     serem `true' ao mesmo tempo.


 -- Variável de opção: domain
     Valor padrão: `real'

     Quando `domain' for escolhida para `complex', `sqrt (x^2)'
     permanecerá `sqrt (x^2)' em lugar de retornar `abs(x)'.


 -- Função: expand (<expr>)
 -- Função: expand (<expr>, <p>, <n>)
     Expande a expressão <expr>.  Produtos de somas e somas
     exponenciadas são multiplicadas para fora, numeradores de
     expressões racionais que são adições são quebradas em suas
     respectivas parcelas, e multiplicação (comutativa e não
     comutativa) é distribuída sobre a adição em todos os níveis de
     <expr>.

     Para polinômios se pode usar freqüêntemente `ratexpand' que possui
     um algorítmo mais eficiente.

     `maxnegex' e `maxposex' controlam o máximo expoente negativo e o
     máximo expoente positivo, respectivamente, que irão expandir.

     `expand (<expr>, <p>, <n>)' expande <expr>, usando <p> para
     `maxposex' e <n> para `maxnegex'.  Isso é útil com o objetivo de
     expandir partes mas não tudo em uma expressão.

     `expon' - o expoente da maior potência negativa que é
     automaticamente expandida (independente de chamadas a `expand').
     Por Exemplo se `expon' for 4 então `(x+1)^(-5)' não será
     automaticamente expandido.

     `expop' - o maior expoente positivo que é automaticamente
     expandido.  Dessa forma `(x+1)^3', quando digitado, será
     automaticamente expandido somente se `expop' for maior que ou
     igual a 3.  Se for desejado ter `(x+1)^n' expandido onde `n' é
     maior que `expop' então executando `expand ((x+1)^n)' trabalhará
     somente se `maxposex' não for menor que `n'.

     O sinalizador `expand' usado com `ev' causa expansão.

     O arquivo `simplification/facexp.mac' contém muitas funções
     relacionadas (em particular `facsum', `factorfacsum' e
     `collectterms', que são chamadas automaticamente) e variáveis
     (`nextlayerfactor' e `facsum_combine') que fornecem ao usuário com
     a habilidade para estruturar expressões por expansão controlada.
     Descrições breves de função estão disponível em
     `simplification/facexp.usg'.  Um arquivo demonstrativo está
     disponível fazendo `demo("facexp")'.


 -- Função: expandwrt (<expr>, <x_1>, ..., <x_n>)
     Expande a expressão `expr' com relação às variáveis <x_1>, ...,
     <x_n>.  Todos os produtos envolvendo as variáveis aparecem
     explicitamente.  A forma retornada será livre de produtos de somas
     de expressões que não estão livres das variáveis.   <x_1>, ...,
     <x_n> podem ser variáveis, operadores, ou expressões.

     Por padrão, denominadores não são expandidos, mas isso pode ser
     controlado através do comutador `expandwrt_denom'.

     Essa função, `expandwrt', não é automaticamente chamada a partir de
     `simplification/stopex.mac'.


 -- Variável de opção: expandwrt_denom
     Valor padrão: `false'

     `expandwrt_denom' controla o tratamento de expressões racionais
     por `expandwrt'.  Se `true', então ambos o numerador e o
     denominador da expressão serão expandidos conforme os argumentos
     de `expandwrt', mas se `expandwrt_denom' for `false', então somente
     o numerador será expandido por aquele caminho.


 -- Função: expandwrt_factored (<expr>, <x_1>, ..., <x_n>)
     é similar a `expandwrt', mas trata expressões que são produtos um
     tanto quanto diferentemente.  `expandwrt_factored' expande somente
     sobre esses fatores de `expr' que contiverem as variáveis <x_1>,
     ..., <x_n>.

     Essa função é automaticamente chamada a aprtir de
     `simplification/stopex.mac'.


 -- Variável de opção: expon
     Valor padrão: 0

     `expon' é o expoente da maior potência negativa que é
     automaticamente expandido (independente de chamadas a `expand').
     Por exemplo, se `expon' for 4 então `(x+1)^(-5)' não será
     automaticamente expandido.


 -- Função: exponentialize (<expr>)
 -- Variável de opção: exponentialize
     A função `exponentialize (expr)' converte funções circulares e
     hiperbólicas em <expr> para exponenciais, sem escolher a variável
     global `exponentialize'.

     Quando a variável `exponentialize' for `true', todas as funções
     circulares e hiperbólicas  são convertidas para a forma
     exponencial.  O valor padrão é `false'.

     `demoivre' converte exponenciais complexas em funções circulares.
     `exponentialize' e `demoivre' não podem ambas serem `true' ao
     mesmo tempo.


 -- Variável de opção: expop
     Valor padrão: 0

     `expop' - o maior expoente positivo que é automaticamente
     expandido.  Dessa forma `(x+1)^3', quando digitado, será
     automaticamente expandido somente se `expop' for maior que ou
     igual a 3.  Se for desejado ter `(x+1)^n' expandido onde `n' é
     maior que `expop' então executando `expand ((x+1)^n)' trabalhará
     somente se `maxposex' não for menor que `n'.


 -- Variável de opção: factlim
     Valor padrão: -1

     `factlim' especifica o maior fatorial que é automaticamente
     expandido.  Se for -1 então todos os inteiros são expandidos.


 -- Função: intosum (<expr>)
     Move fatores multiplicativos fora de um somatório para dentro.  Se
     o índice for usado na expressão de fora, então a função tentará
     achar um índice razoável, o mesmo que é feito para `sumcontract'.
     Isso é essencialmente a idéia inversa da propriedade `outative' de
     somatórios, mas note que isso não remove essa propriedade, somente
     pula sua verificação.

     Em alguns casos, um `scanmap (multthru, <expr>)' pode ser
     necessário antes de `intosum'.


 -- Declaração: lassociative
     `declare (g, lassociative)' diz ao simplificador do Maxima que `g'
     é associativa à esquerda.  E.g., `g (g (a, b), g (c, d))' irá
     simplificar para `g (g (g (a, b), c), d)'.


 -- Declaração: linear
     Uma das propriedades operativas do Maxima.  Para funções de uma
     única variável `f' então declarada, a "expansão" `f(x + y)'
     retorna `f(x) + f(y)', `f(a*x)' retorna `a*f(x)' tomando lugar
     onde `a' for uma "constante".  para funções de dois ou mais
     argumentos, "linearidade" é definida para ser como no caso de
     `sum' ou `integrate', i.e., `f (a*x + b, x)' retorna `a*f(x,x) +
     b*f(1,x)' para `a' e `b' livres de `x'.

     `linear' é equivalente a `additive' e `outative'.  Veja também
     `opproperties'.


 -- Declaração: mainvar
     Você pode declarar variáveis para serem `mainvar' (variável
     principal).  A escala de ordenação para átomos é essencialmente:
     números < constantes (e.g., `%e', `%pi') < escalares < outras
     variáveis < mainvars.  E.g., compare `expand ((X+Y)^4)' com
     `(declare (x, mainvar), expand ((x+y)^4))'.  (Nota: Cuidado deve
     ser tomado se você eleger o uso desse recurso acima.  E.g., se
     você subtrair uma expressão na qual `x' for uma `mainvar' de uma
     na qual `x' não seja uma `mainvar', resimplificação e.g. com `ev
     (expr, simp)' pode ser necessária se for para ocorrer um
     cancelamento.  Também, se você grava uma expressão na qual `x' é
     uma `mainvar', você provavelmente pode também gravar `x'.)


 -- Variável de opção: maxapplydepth
     Valor padrão: 10000

     `maxapplydepth' é a máxima definição para a qual `apply1' e
     `apply2' irão pesquisar.


 -- Variável de opção: maxapplyheight
     Valor padrão: 10000

     `maxapplyheight' é a elevação máxima a qual `applyb1' irá
     alcançar antes de abandonar.


 -- Variável de opção: maxnegex
     Valor padrão: 1000

     `maxnegex' é o maior expoente negativo que será expandido pelo
     comando `expand' (veja também `maxposex').


 -- Variável de opção: maxposex
     Valor padrão: 1000

     `maxposex' é o maior expoente que será expandido com o comando
     `expand' (veja também `maxnegex').


 -- Declaração: multiplicative
     `declare (f, multiplicative)' diz ao simplificador do Maxima que
     `f' é multiplicativa.

       1. Se `f' for uma função de uma única variável, sempre que o
          simplificador encontrar `f' aplicada a um produto, `f'
          distribue sobre aquele produto.  E.g., `f(x*y)' simplifica
          para `f(x)*f(y)'.

       2. Se `f' é uma função de 2 ou mais argumentos,
          multiplicatividade é definida como multiplicatividade no
          primeiro argumento para `f', e.g., `f (g(x) * h(x), x)'
          simplifica para `f (g(x) ,x) * f (h(x), x)'.

     Essa simplificação não ocorre quando `f' é aplicada a expressões da
     forma `product (x[i], i, m, n)'.


 -- Variável de opção: negdistrib
     Valor padrão: `true'

     Quando `negdistrib' for `true', -1 distribue sobre uma expressão.
     E.g., `-(x + y)' transforma-se em `- y - x'.  Mudando o valor de
     `negdistrib' para `false' permitirá que `- (x + y)' seja mostrado
     como foi escrito.  Isso algumas vezes é útil mas seja muito
     cuidadoso: como o sinalizador `simp', isso é um sinalizador que
     você pode não querer escolher para `false' como algo natural ou
     necessário com excessão de usar localmente no seu Maxima.


 -- Variável de opção: negsumdispflag
     Valor padrão: `true'

     Quando `negsumdispflag' for `true', `x - y' é mostrado como `x - y'
     em lugar de como `- y + x'.  Escolhendo isso para `false' faz com
     que a verificação especial em visualização para a diferença das
     duas expressões não seja concluída.  Uma aplicação é que dessa
     forma `a + %i*b' e `a - %i*b' podem ambos serem mostrados pelo
     mesmo caminho.


 -- Símbolo especial: noeval
     `noeval' suprime a fase de avaliação de `ev'.  Isso é útil em
     conjunção com outros comutadores e para fazer com que expressões
     sejam resimplificadas sem serem reavaliadas.


 -- Declaração: noun
     `noun' é uma das opções do comando `declare'.  Essa opção faz com
     que um função seja declarada como "noun" (substantivo),
     significando que ela não deve ser avaliada automaticamente.


 -- Variável de opção: noundisp
     Valor padrão: `false'

     Quando `noundisp' for `true', substantivos (nouns) são mostrados
     com um apóstrofo.  Esse comutador é sempre `true' quando mostrando
     definições de função.


 -- Símbolo especial: nouns
     `nouns' é um `evflag' (sinalizador de avaliação). Quando usado
     como uma opção para o comando `ev', `nouns' converte todas as
     formas substantivas ("noun") que ocorrem na expressão que está
     sendo avaliada para verbos ("verbs"), i.e., avalia essas
     expressões.  Veja também `noun', `nounify', `verb', e `verbify'.


 -- Símbolo especial: numer
     `numer' faz com que algumas funções matemáticas (incluindo
     exponenciação) com argumentos numéricos sejam avaliados em ponto
     flutuante. Isso faz com que variáveis em `expr' às quais tenham
     sido dados valores numéricos a elas sejam substituídas pelos seus
     valores correspondentes.  `numer' também escolhe o sinalizador
     `float' para `on'.


 -- Função: numerval (<x_1>, <expr_1>, ..., <var_n>, <expr_n>)
     Declara as variáveis `x_1', ..., <x_n> para terem valores
     numéricos iguais a `expr_1', ..., `expr_n'.  O valor numérico é
     avaliado e substituido para a variável em quaisquer expressões na
     qual a variável ocorra se o sinalizador `numer' for `true'. Veja
     também `ev'.

     As expressões `expr_1', ..., `expr_n' podem ser quaisquer
     expressões, não necessariamente numéricas.

 -- Variável de sistema: opproperties
     `opproperties' é a lista de propriedades de operadores especiais
     reconhecidas pelo simplificador do Maxima: `linear', `additive',
     `multiplicative', `outative' (veja logo abaixo), `evenfun',
     `oddfun', `commutative', `symmetric', `antisymmetric', `nary',
     `lassociative', `rassociative'.


 -- Variável de opção: opsubst
     Valor padrão: `true'

     Quando `opsubst' for `false', `subst' não tenta substituir dentro
     de um operador de uma expressão.  E.g., `(opsubst: false, subst
     (x^2, r, r+r[0]))' irá trabalhar.


 -- Declaração: outative
     `declare (f, outative)' diz ao simplificador do Maxima que fatores
     constantes no argumento de `f' podem ser puxados para fora.

       1. Se `f' for uma função de uma única variável, sempre que o
          simplificador encontrar `f' aplicada a um produto, aquele
          produto será particionado em fatores que são constantes e
          fatores que não são e os fatores constantes serão puxados
          para fora.  E.g., `f(a*x)' simplificará para `a*f(x)' onde
          `a' é uma constante.  Fatores de constantes não atômicas não
          serão puxados para fora.

       2. Se `f' for uma função de 2 ou mais argumentos, a colocação
          para fora é definida como no caso de `sum' ou `integrate',
          i.e., `f (a*g(x), x)' irá simplificar para `a * f(g(x), x)'
          sendo `a' livre de `x'.

     `sum', `integrate', e `limit' são todas `outative'.


 -- Declaração: posfun
     `declare (f, posfun)' declara `f' para ser uma função positiva.
     `is (f(x) > 0)' retorna `true'.


 -- Função: radcan (<expr>)
     Simplifica <expr>, que pode conter logarítmos, exponenciais, e
     radicais, convertendo essa expressão em uma forma que é canônica
     sobre uma ampla classe de expressões e uma dada ordenação de
     variáveis; isto é, todas formas funcionalmente equivalentes são
     mapeadas em uma única forma.  Para uma classe um tanto quanto
     ampla de expressões, `radcan' produz uma forma regular.  Duas
     expressões equivalentes nessa classe não possuem necessáriamente a
     mesma aparência, mas suas diferenças podem ser simplificadas por
     `radcan' para zero.

     Para algumas expressões `radcan' é que consome inteiramente o
     tempo.  Esse é o custo de explorar certos relacionamentos entre os
     componentes da expressão para simplificações baseadas sobre
     fatoração e expansões de fração-parcial de expoentes.

     Quando `%e_to_numlog' for `true', `%e^(r*log(expr))' simplifica
     para `expr^r' se `r' for um número racional.

     Quando `radexpand' for `false', certas transformações são inibidas.
     `radcan (sqrt (1-x))' permanece `sqrt (1-x)' e não é simplificada
     para `%i sqrt (x-1)'.  `radcan (sqrt (x^2 - 2*x + 11))' permanece
     `sqrt (x^2 - 2*x + 1)' e não é simplificada para `x - 1'.

     `example (radcan)' mostra alguns exemplos.


 -- Variável de opção: radexpand
     Valor padrão: `true'

     `radexpand' controla algumas simplificações de radicais.

     Quando `radexpand' for `all', faz com que n-ésimas raízes de
     fatores de um produto que são potências de n sejam puxados para
     fora do radical.  E.g. Se `radexpand' for `all', `sqrt (16*x^2)'
     simplifica para `4*x'.

     Mais particularmente, considere `sqrt (x^2)'.
        * Se `radexpand' for `all' or `assume (x > 0)' tiver sido
          executado, `sqrt(x^2)' simplifica para `x'.

        * Se `radexpand' for `true' e `domain' for `real' (isso é o
          padrão), `sqrt(x^2)' simplifica para `abs(x)'.

        * Se `radexpand' for `false', ou `radexpand' for `true' e
          `domain' for `complex', `sqrt(x^2)' não é simplificado.

     Note que `domain' somente interessa quando `radexpand' for `true'.


 -- Variável de opção: radsubstflag
     Valor padrão: `false'

     `radsubstflag', se `true', permite a `ratsubst' fazer
     substituições tais como `u' por `sqrt (x)' em `x'.


 -- Declaração: rassociative
     `declare (g, rassociative)' diz ao simplificador do Maxima que `g'
     é associativa à direita.  E.g., `g(g(a, b), g(c, d))' simplifica
     para `g(a, g(b, g(c, d)))'.


 -- Função: scsimp (<expr>, <rule_1>, ..., <rule_n>)
     Simplificação Seqüêncial Comparativa (método devido a Stoute).
     `scsimp' tenta simplificar <expr> conforme as regras <rule_1>,
     ..., <rule_n>.  Se uma expressão pequena for obtida, o processo
     repete-se.  De outra forma após todas as simplificações serem
     tentadas, `scsimp' retorna a resposta original.

     `example (scsimp)' mostra alguns exemplos.


 -- Variável de opção: simpsum
     Valor padrão: `false'

     Quando `simpsum' for `true', o resultado de uma `sum' é
     simplificado.  Essa simplificação pode algumas vezes estar apta a
     produzir uma forma fechada.  Se `simpsum' for `false' ou se a
     forma com apóstrofo `'sum' for usada, o valor é uma forma
     substantiva aditiva que é uma representação da notação sigma usada
     em matemática.


 -- Função: sumcontract (<expr>)
     Combina todas as parcelas de um somatório que possuem limites
     superiores e inferiores que diferem por constantes. O resultado é
     uma expressão contendo um somatório para cada escolha de cada tais
     somatórios adicionados a todos os termos extras apropriados que
     tiveram de ser extraídos para a forma dessa adição.  `sumcontract'
     combina todas as somas compatíveis e usa os indices de uma as
     somas se puder, e então tenta formar um índice razoável se não for
     usar qualquer dos fornecidos.

     Isso pode ser necessário fazer um `intosum (<expr>)' antes de
     `sumcontract'.


 -- Variável de opção: sumexpand
     Valor padrão: `false'

     Quando `sumexpand' for `true', produtos de somas e somas
     exponeciadas simplificam para somas aninhadas.

     Veja também `cauchysum'.

     Exemplos:

          (%i1) sumexpand: true$
          (%i2) sum (f (i), i, 0, m) * sum (g (j), j, 0, n);
                               m      n
                              ====   ====
                              \      \
          (%o2)                >      >     f(i1) g(i2)
                              /      /
                              ====   ====
                              i1 = 0 i2 = 0
          (%i3) sum (f (i), i, 0, m)^2;
                               m      m
                              ====   ====
                              \      \
          (%o3)                >      >     f(i3) f(i4)
                              /      /
                              ====   ====
                              i3 = 0 i4 = 0


 -- Variável de opção: sumsplitfact
     Valor padrão: `true'

     Quando `sumsplitfact' for `false', `minfactorial' é aplicado após
     um `factcomb'.


 -- Declaração: symmetric
     `declare (h, symmetric)' diz ao simplificador do Maxima que `h' é
     uma função simétrica.  E.g., `h (x, z, y)' simplifica para `h (x,
     y, z)'.

     `commutative' é sinônimo de `symmetric'.


 -- Função: unknown (<expr>)
     Retorna `true' se e somente se <expr> contém um operador ou
     função não reconhecida pelo simplificador do Maxima.



File: maxima.info,  Node: Montando Gráficos,  Next: Entrada e Saída,  Prev: Simplificação,  Up: Top

8 Montando Gráficos
*******************

* Menu:

* Funções e Variáveis Definidas para Montagem de Gráficos::


File: maxima.info,  Node: Funções e Variáveis Definidas para Montagem de Gráficos,  Prev: Montando Gráficos,  Up: Montando Gráficos

8.1 Funções e Variáveis Definidas para Montagem de Gráficos
===========================================================

 -- Função: contour_plot (<expr>, <x_range>, <y_range>, <opções>, ...)
     Monta gráficos de contorno (curvas de nível) de <expr> sobre a
     região <x_range> por <y_range>.  Quaisquer argumentos adicionals
     são tratados da mesma forma que em `plot3d'.

     `contour_plot' somente trabalha quando o formato do gráfico for
     `gnuplot' ou `gnuplot_pipes'.

     Veja também `implicit_plot'.

     Exemplos:

          (%i1) contour_plot (x^2 + y^2, [x, -4, 4], [y, -4, 4]);
          (%o1)
          (%i2) contour_plot (sin(y) * cos(x)^2, [x, -4, 4], [y, -4, 4]);
          (%o2)
          (%i3) F(x, y) := x^3 + y^2;
                                             3    2
          (%o3)                  F(x, y) := x  + y
          (%i4) contour_plot (F, [u, -4, 4], [v, -4, 4]);
          (%o4)
          (%i5) contour_plot (F, [u, -4, 4], [v, -4, 4], [gnuplot_preamble, "set size ratio -1"]);
          (%o5)
          (%i6) set_plot_option ([gnuplot_preamble, "set cntrparam levels 12"])$

          (%i7) contour_plot (F, [u, -4, 4], [v, -4, 4]);


 -- Variável: in_netmath
     Valor padrão: `false'

     Quando `in_netmath' é `true', `plot3d' imprime uma saída OpenMath
     para o console se `plot_format' é `openmath'; caso contrário
     `in_netmath' (mesmo se `true') não tem efeito.  `in_netmath' não
     tem efeito sobre `plot2d'.


 -- Função: plot2d (<expr>, <x_range>, ..., <opções>, ...)
 -- Função: plot2d ([<expr_1>, ..., <expr_n>], ..., <opções>, ...)
 -- Função: plot2d ([<expr_1>, ..., <expr_n>], <x_range>,..., <opções>,
          ...)
     onde <expr>, <expr_1>, ..., <expr_n> pode ser uma entre
     expressões, ou funções do Lisp ou do Maxima ou operadores, ou uma
     lista com qualquer das formas: `[discrete, [<x1>, ..., <xn>],
     [<y1>, ..., <yn>]]', `[discrete, [[<x1>, <y1>], ..., [<xn>, ...,
     <yn>]]' ou `[parametric, <x_expr>, <y_expr>, <t_range>]'.

     Mostra um gráfico de uma ou mais expressões como uma função de uma
     variável.

     `plot2d' monta o gráfico da expressão <expr> ou muitas expressões
     `[<name_1>, ..., <name_n>]'. As expressões que não forem
     paramétricas ou discretas podem todas depender somente de uma
     variável <var> e isso torna obrigatório o uso de <x_range> para
     nome daquela variável e fornece seus valores de máximo e de
     mínimo, usando a sintaxe: `[<variable>, <min>, <max>]'. O gráfico
     irá mostrar o eixo horizontal associado aos valores de <min> e de
     <max>.

     Uma expressão a ser montado o gráfico pode também ser fornecida na
     forma discreta ou na forma paramétrica. A saber, como uma lista
     iniciando-se com a palavra "discrete" ou a palavra "parametric". A
     palavra chave <discrete> deve ser seguida por duas listas de
     valores, ambas com o mesmo comprimento, que são as coodenadas
     horizontais e as coordenadas verticais de um conjunto de pontos;
     alternativamente, as coordenadas de cada ponto pode ser colocada
     dentro de uma lista com dois valores, e todas as coordenadas dos
     pontos podem estar dentro de outra lista. A palavra chave
     <parametric> deve ser seguida por douas expressões <x_expr> e
     <y_expr>, e um intervalo da forma `[<param>, <min>, <max>]'. As
     duas expressões devem depender somente do parâmetro <param>, e o
     gráfico irá mostrar o caminho percorrido pelo ponto com
     coordenadas (<x_expr>, <y_expr>) com <param> variando de <min> a
     <max>.

     O intervalo do eixo vertical não é obrigatório. É somente mais uma
     das opções para o comando, com a sintaxe: `[y, <min>, <max>]'. Se
     aquela opção for usada, o gráfico irá mostrar aquele intervalo
     completo, mesmo se a expressão não ocupe todo aquele intervalo. De
     outra forma, se um intervalo vertical não for especificado através
     de `set_plot_option', as extremidade do eixo vertical serão
     encontrada automaticamente.

     Todas as outras opções podem também serem listas, iniciando-se com
     o nome da opção. A opção <xlabel> pode ser usada para fornecer um
     ótulo para o eixo horizontal; se aquela opção não for usada, o
     eixo horizontal irá ser rotulado com o nome da variável
     especificada em <x_range>, ou com a expressão <x_expr> no caso de
     apenas uma expressão paramétrica, ou isso irá ser deichado em
     branco de outra forma.

     Um rótulo para o eixo vertical pode ser fornecido com a opção
     <ylabel>. Se existir somente uma expressão a ser montado o gráfico
     e a opção <ylabel> não tiver sido usada, o eixo vertical irá ser
     rotulado com aquela expressão, a menos que ela seja muito larga,
     ou com a expressão <y_expr> se a expressão for paramétrica, ou com
     o texto "discrete data" se a expressão for discreta.

     As opções `[logx]' e `[logy]' não precisam de quaisquer
     parâmetros. Elas irão tornar os eixos horizontal e vertical sejam
     escritos em escala logarítmica.

     Se houverem muitas expressões para serem montados os gráficos
     respectivos, uma legenda irá ser escrita para identificar cada uma
     das expressões. Os rótulos que podem ser usados naquela legenda
     podem ser fornecidos com a opção <legend>. Se a opção <legend> não
     for usada, Maxima irá criar rótulos a partir das expressões.

     Por padrão, as expressões terão seus gráficos montados como um
     conjunto de segmentos de reta saltando pontos adjacentes dentro de
     um conjunt de pontos que é um dos fornecidos entre a forma
     <discrete>, ou calculado automaticamente a partir da expressão
     fornecida, usando um algorítmo que automaticamente adapta os
     passos entre os pontos usando como uma estimativa inicial do total
     número de pontos o conjunto de valores com a opção <nticks>. A
     opção <style> pode ser usada para fazer uma das expressões serem
     representadas como um conjunto de pontos isolados, ou como pontos
     e segmentos de reta.

     Existem muitas opções globais armazenadas na lsita <plot_options>
     que pode ser modificada com a função `set_plot_option'; qualque
     daquelas opções globais pode ser sobrescrita com opções fornecidas
     no comando <plot2d>.

     Uma função a ter seu gráfico montado pode ser especificada como o
     nome de uma função do Maxima ou do Lisp ou um operador, uma
     expressão lambda do Maxima, ou uma expressão geral do Maxima.  Se
     especificado como um nome ou uma expressão lambda, a função deve
     ser uma função de um argumento.

     Exemplos:

     Gráficos de funções comuns.

          (%i1) plot2d (sin(x), [x, -5, 5])$

          (%i2) plot2d (sec(x), [x, -2, 2], [y, -20, 20], [nticks, 200])$

     Montando gráfico de funções pelo nome.

          (%i3) F(x) := x^2 $

          (%i4) :lisp (defun |$g| (x) (m* x x x))

          $g
          (%i5) H(x) := if x < 0 then x^4 - 1 else 1 - x^5 $

          (%i6) plot2d (F, [u, -1, 1])$

          (%i7) plot2d ([F, G, H], [u, -1, 1])$

     Podemos montar o gráfico de um círculo usando um gráfico
     paramétrico com um parâmetro <t>. Não é necessário fornecer um
     intervalo para intervalo horizontal, uma vez que o intervalo do
     parâmetro <t> detrmina o domínio. Todavia, uma vez que os
     comprimentos dos eixos horizontal e vertical do gráfico estão na
     proporção de 4 para 3, usaremos a opção <xrange> para obter a
     mesma escala em ambos os eixos:

          (%i8) plot2d ([parametric, cos(t), sin(t), [t,-%pi,%pi], [nticks,80]],
                     [x, -4/3, 4/3])$

     Se repetirmos aquele gráfico com somente 8 pontos e extendendo o
     intervalo do parâmetro para fornecer dois turnos, obteremos o
     gráfico de uma estrela:

          (%i9) plot2d ([parametric, cos(t), sin(t), [t, -%pi*2, %pi*2],
                  [nticks, 8]], [x, -2, 2], [y, -1.5, 1.5])$

     Combinação de um gráfico comum de um polinômio cúbico com um
     gráfico paramétrico de um círculo:

          (%i10) plot2d ([x^3 + 2, [parametric, cos(t), sin(t), [t, -5, 5],
                  [nticks, 80]]], [x, -3, 3])$

     Exemplo de um gráfico logarítmico:
          (%i11) plot2d (exp(3*s), [s, -2, 2], [logy])$

     Para mostrar alguns exemplos de gráficos discretos, iniciaremos
     por inserir as coordenadas de 5 pontos, por dois diferentes
     cominhos que podem ser usados:

          (%i12) xx:[10, 20, 30, 40, 50]$
          (%i13) yy:[.6, .9, 1.1, 1.3, 1.4]$
          (%i14) xy:[[10,.6], [20,.9], [30,1.1], [40,1.3], [50,1.4]]$

     Para montar o gráfico daqueles pontos, unidos com segmentos de
     reta, usamos:
          (%i15) plot2d([discrete,xx,yy])$

     Iremos agora mostrar o gráfico com somente pontoss, e ilustrando o
     uso do segundo caminho de fornecer as coordenadas dos pontos:

          (%i16) plot2d([discrete, xy], [style, points])$

     O gráfico de pontos pode ser mostrado juntamente com um gráfico da
     função teorética/doutrinária/estética que prevê as coordenads dos
     pontos:

          (%i17) plot2d([[discrete,xy], 2*%pi*sqrt(l/980)], [l,0,50],
                  [style, [points,3,5], [lines,1,3]], [legend,"experiment","theory"],
                  [xlabel,"pendulum's length (cm)"], [ylabel,"period (s)"])$

     Veja também `plot_options', que descreve opções de montagem de
     gráfico e tem mais exemplos.


 -- Função: xgraph_curves (<list>)
     transforma em gráfico a lista de `grupos de pontos' dados em lista
     usando xgraph.  Se o programa xgraph não estiver instalado, esse
     comando irá falhar.

     Um conjunto de pontos pode ser da forma

          [x0, y0, x1, y1, x2, y2, ...]
     ou
          [[x0, y0], [x1, y1], ...]
     Um conjunto de pontos pode também conter símbolos que fornecem
     rótulos ou outra informação.

          xgraph_curves ([pt_set1, pt_set2, pt_set3]);

     transforma em gráfico os três conjuntos de pontos como três curvas.

          pt_set: append (["NoLines: True", "LargePixels: true"],
                                    [x0, y0, x1, y1, ...]);

     fizemos com que os grupos de pontos (e os próprios subseqüêntes),
     não possuam linhas entre si, e usassem pixels grandes.  Veja a
     página de manual sobre o xgraph para especificar mais opções.

          pt_set: append ([concat ("\"", "x^2+y")], [x0, y0, x1, y1, ...]);

     fizemos aí aparecer um "rótulo" de "x^2+y" para esse grupo de
     pontos em particular.  As aspas, `"', no início é que dizem ao
     xgraph isso é um rótulo.

          pt_set: append ([concat ("TitleText: Dados da Amostra")], [x0, ...])$

     fizemos o título principal do gráfico ser "Dados da Amostra" ao
     invés de "Maxima Plot".

     Para fazer um gráfico em barras com largura de 0.2 unidades, e
     para montar o gráfico com duas possibilidades diferentes dos tais
     gráficos em barras:
          (%i1) xgraph_curves ([append (["BarGraph: true", "NoLines: true",
                "BarWidth: .2"], create_list ([i - .2, i^2], i, 1, 3)),
                append (["BarGraph: true", "NoLines: true", "BarWidth: .2"],
                create_list ([i + .2, .7*i^2], i, 1, 3))]);

     Um arquivo temporário `xgraph-out' é usado.


 -- Variável de sistema: plot_options
     Elementos dessa lista estabelecem as opções padrão para a montagem
     do gráfico.  Se uma opção está presente em uma chamada a `plot2d'
     ou `plot3d', esse valor tem precedência sobre a opção padrão.  De
     outra forma, o valor em `plot_options' é usado.  Opções padrão são
     atribuídas por `set_plot_option'.

     Cada elemento de `plot_options' é uma lista de dois ou mais ítens.
     O primeiro item é o nome de uma opção, e os restantes compreendem
     o valor ou valores atribuídos à opção.  Em alguns casos, o valor
     atribuído é uma lista, que pode compreender muitos ítens.

     As opções de montagem de gráfico que são reconhecidas por `plot2d'
     e `plot3d' são as seguintes:

        * Opção: `plot_format'

          Determina qual interface gráfica é usada por `plot2d' e por
          `plot3d'.

             * Valor: `gnuplot' padrão para windows

               Gnuplot é o mais avançado pacote de montagem de gráficos
               entre os pacotes disponíveis no Maxima. Esse valor
               requer uma instalação externa do gnuplot.

             * Valor: `gnuplot_pipes' padrão nas plantaformas não
               windows

               Similar ao formato `gnuplot' exceto que a comunicação
               com o gnuplot é realizada através de um pipe. Esse valor
               pode ser usado para montar um gráfico na tela, para
               redirecionar a saída do gráfico para um arquivos é
               melhor usar o formato `gnuplot'.

             * Valor: `mgnuplot'

               Mgnuplot é um ambiente montado em volta do gnuplot
               baseado no Tk.  Esse ambiente está incluído na
               distribuíção do Maxima.  Mgnuplot oferece uma GUI
               rudimentar para o gnuplot, mas tem menos recursos em
               geral que a interface plana do gnuplot.  Mgnuplot requer
               uma instalação externa do gnuplot e Tcl/Tk.

             * Valor: `openmath'

               Openmath é um programa gráfico escrito em Tcl/Tk. Este
               formato é fornecido pelo pacote Xmaxima, que é
               distribuído junto com Maxima; com o objetivo de usar esse
               formato você pode instalar o pacote Xmaxima, e o
               Openmath irá trabalhar não somente a partir do Xmaxima
               em si mesmo, mas também a apartir da linha de comando e
               outras GUI's para o Maxima.

        * Opção: `run_viewer'

          Controla se o visualizador apropriado para o formato da
          montagem do gráfico pode ou não ser executado.

             * Valor padrão: `true'

               Executa o programa visualizador.

             * Valor: `false'

               Não executa o programa visualizador.

        * Opção: `y'

          O intervalo vertical do gráfico.

          Exemplo:

               [y, - 3, 3]
          Especifica intervalo vertical para [-3, 3].

        * Opção: `plot_realpart'

          Quando `plot_realpart' for `true', a parte real de um valor
          complexo <x> é mostrada; isso é equivalente a mostrar
          `realpart(<x>)' em lugar de <x>.  De outra forma, somente
          valores com a parte imaginária igual a 0 são mostrados na
          tela, e valores complexos são ignorados.

          Exemplo:

               plot2d (log(x), [x, -5, 5], [plot_realpart, false]);
               plot2d (log(x), [x, -5, 5], [plot_realpart, true]);
          O valor padrão é `false'.

        * Opção: `nticks'

          Em plot2d, essa opção é fornece o número inicial de pontos
          usado pela rotina adaptativa de montagem de gráficos para
          funções de montagem de gráfico. Ess número inicial de pontos
          é também o número de pontos que isrá ser mostrado em um
          gráfico paramétrico.

          Exemplo:

               [nticks, 20]
          O padrão para `nticks' é 10.

        * Opção: `adapt_depth'

          O número maximo de quebras usada pela rotina adaptativa de
          montagem do gráfico.

          Exemplo:

               [adapt_depth, 5]
          O padrão para `adapt_depth' é 10.

        * Opção: `xlabel'

          O rótulo para o eixo horizontal em um gráfico bidimensional.

          Exemplo:
               [xlabel, "Time in seconds"]

        * Opção: `ylabel'

          O rótulo do eixo vertical em gráficos bidimensionais.

          Exemplo:
               [ylabel, "Temperatura"]

        * Opção: `logx'

          Essa opção faz com que o eixo horizontal de um gráfico
          bidimensional seja desenhado em proporção logarítmica. Essa
          opção não precisa de quaisquer parâmetros adicionais.

        * Opção: `logy'

          Essa opção faz com que o eixo vertical de um gráfico
          bidimensional seja desenhado em proporção logarítmica. Essa
          opção não precisa de quaisquer parâmetros adicionais.

        * Opção: `legend'

          Os rótulos para várias expressões em um gráfico bidimensional
          com muitas expressões. Se houverem mais expressões que o
          número de rótulos fornecidos, eles irão ser repetidos. Por
          padrão, os nomes das expressões ou funçõe irão ser usados, ou
          as palavras discrete1, discrete2, ..., para conjuntos
          discretos de pontos.

          Exemplo:
               [legend, "Conj 1", "Conj 2", "Conj 3"]

        * Opção: `style'

          Os estilos que irão ser usados para várias funções ou
          conjuntos de dados em um gráfico bidimensional. A palavra
          <style> deve ser seguida por um ou mais estilos. Se houverem
          mais funções e conjuntos de pontos que estilos fornecidos, os
          estilos irão ser repetidos. Cada estilo pode ser um entre os
          seguintes <lines> para segmentos de reta, <points> para
          pontos isolados, <linespoints> para segmentos e pontos, ou
          <dots> para pequenos pontos isolados. Gnuplot aceita também o
          estilo <impulses>.

          Cada um dos estilos pode também ser fechado dentro de uma
          lista com alguns parâmetros adicionais. <lines> aceita um ou
          dois números: a largura da linha e um inteiro que identifica
          uma cor. <points> aceita um ou dois parâmetros; o primeiro
          parâmetro é o raio dos pontos e o segundo parâmetro é um
          inteiro que para o Gnuplot seleciona diferentes ajustes e
          cores para os ponots e em Openmath modifica a cor usada para
          os pontos. <linesdots> aceita até quatro parâmetros; os
          primerios dois possuem o mesmo significado que em <lines> e
          os últimos dois possuem o mesmo significado que em <points>.

          Exemplo:
               [style,[lines,2,3],[points,1,4]]

          No Gnuplot, esse exemplo irá montar o gráfico da primeira (e
          terceira, quinta, etc) expressão com segmentos de retas azuis
          de largura 2, ea segunda (e quarta, sexta, etc) expressão com
          quadrados verdes de tamanho 1. No Openmath, a primeira
          expressão irá ser mostrada com segmentos da cor magenta de
          largura 2, e o segundo com pontos alaranjados de raio 1; note
          que openmath_color(3) openmath_color(4) retornam "magenta" e
          "orange" (alaranjado).

          O padrão para a opção de estilo é <lines> com largura 1, e
          diferentes cores.

        * Opção: `grid'

          Escolhe o número de pontos da grade para usar nas direções x
          e y para montagem de gráficos tridimensionais.

          Exemplo:
               [grid, 50, 50]
          Escolhe a grade para 50 por 50 pontos.  A grade padrão é 30
          por 30.

        * Opção: `transform_xy'

          Permite que transformações sejam aplicadas à montagem de
          gráficos tridimensionais.

          Exemplo:
               [transform_xy, false]
          O valor padrão de `transform_xy' é `false'.  Se o valor
          padrão de `transform_xy' não é `false', pode ser a saída de

               make_transform ([x, y, z], f1(x, y, z), f2(x, y, z), f3(x, y, z))$
          A transformação `polar_xy' é previamente definida no Maxima.
          Isso fornece a mesma transformação que
               make_transform ([r, th, z], r*cos(th), r*sin(th), z)$

     Opções do Gnuplot:

     Existem muitas opções de montagem de gráfico específicas para
     gnuplot.  Algumas dessas opções são naturais do gnuplot,
     especificados como seqüências de caracteres. Consulte a
     documentação do gnuplot para mais detalhes.

        * Opção: `gnuplot_term'

          Escolhe a saída para o tipo terminal para o gnuplot.
             * Valor padrão: `default'

               A saída do Gnuplot é mostrada em uma janela gráfica
               separada.

             * Valor: `dumb'

               A sída do Gnuplot é mostrada no console do Maxima por
               meio de uma "concepção artística em ASCII" aproximada
               para gráficos.

             * Valor: `ps'

               Gnuplot gera comandos na linguagem PostScript de
               descrição de página.  Se a opção `gnuplot_out_file' for
               escolhida para <nomearquivo>, gnuplot escreve os
               comandos PostScript em <nomearquivo>.  De outra forma,
               Esse arquivo é salvo com o nome `maxplot.ps'.

             * Valor: qualquer outra especificação válida do terminal
               `term' do gnuplot

               Gnuplot pode gerar saídas em muitos outros formatos
               gráficos tais como png, jpeg, svg etc.  Paa criar
               gráficos em todos esses formatos a opção `gnuplot_term'
               pode ser escolhida para qualquer terminalsuportado pelo
               gnuplot (símbolo) ou mesmo especificação completa de
               terminal do gnuplot com quaisquer opções (seqüência de
               caracteres).  Por exemplo `[gnuplot_term,png]' cria
               saídas no formato PNG (Portable +Network Graphics)
               enquanto `[gnuplot_term,"png size 1000,1000"]' cria PNG
               de tamanho 1000x1000 pixels.  Se a opção
               `gnuplot_out_file' for escolhida para <nomearquivo>,
               gnuplot escreve a saída para <nomearquivo>. De outra
               forma, esse arquivo é gravado com o nome de
               `maxplot.<term>', onde <term> é o nome do terminal do
               gnuplot .

        * Opção: `gnuplot_out_file'

          Escreve a saída do gnuplot para um arquivo.

             * Valor padrão: `false'

               Nenhum arquivo de saída especificado.

             * Valor: <nomearquivo>

               Exemplo: `[gnuplot_out_file, "meugrafico.ps"]' Esse
               exemplo envia a saída PostScript para o arquivo
               `meugrafico.ps' quando usada conjuntamente com o
               terminal PostScript do gnuplot.

        * Opção: `gnuplot_pm3d'

          Controla o uso do modo PM3D, que tem recursos avançados em
          3D.  PM3D está somente disponível no gnuplot em versões após
          a 3.7.  O valor padrão para `gnuplot_pm3d' é `false'.

          Exemplo:

               [gnuplot_pm3d, true]

        * Opção: `gnuplot_preamble'

          Insere comandos antes que o gráfico seja desenhado.
          Quaisquer comandos válidos para o gnuplot podem ser usados.
          Multiplos comandos podem ser separados com um ponto e
          vírgula.  O exemplo mostrado produz uma escala numérica na
          montagem do gráfico.  O valor padrão para `gnuplot_preamble'
          é uma seqüência de caracteres vazia `""'.

          Exemplo:

               [gnuplot_preamble, "set log y"]

        * Opção: `gnuplot_curve_titles'

          Controla os títulos dados na chave da montagem do gráfico.  O
          valor padrão é `[default]', que automaticamente escolhe o
          título de cada curva para a função cujo gráfico está sendo
          construído. Se não contiver `[default]',
          `gnuplot_curve_titles' pode conter uma lista de seqüências de
          caracteres, cada uma das quais é `"title '<title_string>'"'.
          (Para disabilitar a chave de impressão de gráfico, adicione
          `"set nokey"' a `gnuplot_preamble'.)

          Exemplo:

               [gnuplot_curve_titles,
               ["title 'Minha primeira função'", "title 'Minha segunda função'"]]

        * Opção: `gnuplot_curve_styles'

          Uma lista de seqüências de caracteres controlando a aparência
          das curvas, i.e., cor, largura, brilho, etc., para serem
          enviadas para o comando de montagem do gráfico do gnuplot.  O
          valor padrão é `["with lines 3", "with lines 1", "with lines
          2", "with lines 5", "with lines 4", "with lines 6", "with
          lines 7"]', que circula através de diferentes cores.  Veja a
          documentação do gnuplot de `plot' para maiores informações.

          Exemplo:

               [gnuplot_curve_styles, ["with lines 7", "with lines 2"]]

        * Opção: `gnuplot_default_term_command'

          O comando gnuplot para escolher o tipo de terminal para o
          terminal padrão. O valor padrão é `set term windows "Verdana"
          15' em sistemas windows, e `set term x11 font "Helvetica,16"'
          em sistemas de janelas do X11.

          Exemplo:

               [gnuplot_default_term_command, "set term x11"]

        * Opção: `gnuplot_dumb_term_command'

          O comando gnuplot para escolher o tipo de terminal para o
          terminal dumb.  O valor padrão é `"set term dumb 79 22"', que
          faz a saída texto com 79 caracteres por 22 caracteres.

          Exemplo:

               [gnuplot_dumb_term_command, "set term dumb 132 50"]

        * Opção: `gnuplot_ps_term_command'

          O comando gnuplot para escolher o tipo de terminal para o
          terminal PostScript.  O valor padrão é `"set size 1.5,
          1.5;set term postscript eps enhanced color solid 24"', que
          escolhe o tamanho para 1.5 vezes o padrão do gnuplot, e o
          tamanho da fonte para 24, além de outras coisas.  Veja a
          documentação do gnuplot de `set term postscript' para mais
          informação.

          Exemplo:

          Todos os números nos exemplos para a função <plot2d> nesse
          manual foram obtidos de arquivos Postscript que foram gerados
          após escolher `gnuplot_ps_term_command' como:

               [gnuplot_ps_term_command,
               "set size 1.3, 1.3; set term postscript eps color solid lw 2.5 30"]


     Exemplos:

        * Grava um gráfico de `sin(x)' para o arquivo `sin.eps'.

          (%i1) plot2d (sin(x), [x, 0, 2*%pi], [gnuplot_term, ps],
                                  [gnuplot_out_file, "sin.eps"])$

        * Usa a opção do y para arrancar singularidades e a opção
          gnuplot_preamble para colocar a chave na parte inferior do
          gráfico em lugar de no topo.

          (%i2) plot2d ([gamma(x), 1/gamma(x)], [x, -4.5, 5], [y, -10, 10],
                               [gnuplot_preamble, "set key bottom"])$

        * Usa um muito complicado `gnuplot_preamble' para produzir
          elegantes rótulos para o eixo x.  (Note que a seqüência de
          caracteres `gnuplot_preamble' deve ser fornecida inteiramente
          sem qualquer quebra de linha.)

          (%i3) my_preamble: "set xzeroaxis; set xtics ('-2pi' -6.283, \
          '-3pi/2' -4.712, '-pi' -3.1415, '-pi/2' -1.5708, '0' 0, \
          'pi/2' 1.5708, 'pi' 3.1415,'3pi/2' 4.712, '2pi' 6.283)"$

          (%i4) plot2d([cos(x), sin(x), tan(x), cot(x)],
                 [x, -2*%pi, 2.1*%pi], [y, -2, 2],
                 [gnuplot_preamble, my_preamble]);

        * Usa um muito complicad `gnuplot_preamble' para produzir
          elegantes rótulos para o eixo x, e produzir saídas PostScript
          que aproveita as vantagens do formato de texto avançado
          disponível no gnuplot.  (Note que a seqüência de caracteres
          `gnuplot_preamble' deve ser fornecida inteiramente sem
          qualquer quebra de linha.)

          (%i5) my_preamble: "set xzeroaxis; set xtics ('-2{/Symbol p}' \
          -6.283, '-3{/Symbol p}/2' -4.712, '-{/Symbol p}' -3.1415, \
          '-{/Symbol p}/2' -1.5708, '0' 0,'{/Symbol p}/2' 1.5708, \
          '{/Symbol p}' 3.1415,'3{/Symbol p}/2' 4.712, '2{/Symbol p}' \
          6.283)"$

          (%i6) plot2d ([cos(x), sin(x), tan(x)], [x, -2*%pi, 2*%pi],
              [y, -2, 2], [gnuplot_preamble, my_preamble],
              [gnuplot_term, ps], [gnuplot_out_file, "trig.eps"]);

        * Uma montagem de gráfico tridimensional usando o terminal
          gnuplot pm3d.

          (%i7) plot3d (atan (-x^2 + y^3/4), [x, -4, 4], [y, -4, 4],
                  [grid, 50, 50], [gnuplot_pm3d, true])$

        * Uma montagem de gráfico tridimensional sem a malha e com
          contornos projetados no plano inferior.

          (%i8) my_preamble: "set pm3d at s;unset surface;set contour;\
          set cntrparam levels 20;unset key"$
          (%i9) plot3d(atan(-x^2 + y^3/4), [x, -4, 4], [y, -4, 4],
              [grid, 50, 50], [gnuplot_pm3d, true],
              [gnuplot_preamble, my_preamble])$

        * Uma montagem de gráfico onde o eixo z é representado apenas
          por cores.  (Note que a seqüência de caracteres
          `gnuplot_preamble' deve ser fornecida inteiramente sem
          qualquer quebra de linha.)

          (%i10) plot3d (cos (-x^2 + y^3/4), [x, -4, 4], [y, -4, 4],
              [gnuplot_preamble, "set view map; unset surface"],
              [gnuplot_pm3d, true], [grid, 150, 150])$


 -- Função: plot3d ([<expr_1>, <expr_2>, <expr_3>], <x_range>,
          <y_range>, ..., <opções>, ...)
 -- Função: plot3d (<expr>, <x_range>, <y_range>, ..., <opções>, ...)
 -- Função: plot3d (<name>, <x_range>, <y_range>, ..., <opções>, ...)
 -- Função: plot3d ([<expr_1>, <expr_2>, <expr_3>], <x_rge>, <y_rge>)
 -- Função: plot3d ([<nome_1>, <nome_2>, <nome_3>], <x_range>,
          <y_range>, ..., <opções>, ...)
     Mostra um gráfico de uma ou três expressões como funções de duas
     variáveis.

          (%i1) plot3d (2^(-u^2 + v^2), [u, -3, 3], [v, -7, 7]);

     monta o gráfico de `z = 2^(-u^2+v^2)' com `u' e `v' variando no
     intervalo fechado [-3,3] e no intervalo fechado de [-2,2]
     respectivamente, e com <u> sobre o eixo x, e `v' sobre o eixo y.

     O mesmo gráfico pode ser visualizado usando openmath (se Xmaxima
     estiver instalado):

          (%i2)  plot3d (2^(-u^2 + v^2), [u, -3, 3], [v, -2, 2],
                         [plot_format, openmath]);

     nesse caso o mouse pode ser usado para rotacionar a
     visualização para olhar na superfície de diferentes ângulos.

     Um exemplo do terceiro modelo de argumento é

          (%i3) plot3d ([cos(x)*(3 + y*cos(x/2)), sin(x)*(3 + y*cos(x/2)),
             y*sin(x/2)], [x, -%pi, %pi], [y, -1, 1], ['grid, 50, 15]);

     que monta o gráfico da banda de Moebius, parametrizada por três
     expressões fornecidas como o primeiro argumento para `plot3d'.  O
     argumento adiconal porém opcional `['grid, 50, 15]' fornece o
     número de retâgulos da grade na direção x e na direção y.

     Uma função a ter seu gráfico montado pode ser especificada como o
     nome de uma função Maxima ou como o nome de uma função Lisp ou
     como um operador, como uma expressão lambda do Maxima, ou como uma
     expressão geral do Maxima.  Se especificada como um nome ou como
     expressão lambda, a função deve ser uma função de um argumento.

     Esse exemplo mostra uma montagem de gráfico da parte real de
     `z^1/3'.

          (%i4) plot3d (r^.33*cos(th/3), [r, 0, 1], [th, 0, 6*%pi],
                ['grid, 12, 80], ['transform_xy, polar_to_xy]);

     Outro exemplo é uma superfície de Klein:

          (%i5) expr_1: 5*cos(x)*(cos(x/2)*cos(y) + sin(x/2)*sin(2*y)
                + 3.0) - 10.0$
          (%i6) expr_2: -5*sin(x)*(cos(x/2)*cos(y) + sin(x/2)*sin(2*y)
                + 3.0)$
          (%i7) expr_3: 5*(-sin(x/2)*cos(y) + cos(x/2)*sin(2*y))$

          (%i8) plot3d ([expr_1, expr_2, expr_3], [x, -%pi, %pi],
                [y, -%pi, %pi], ['grid, 40, 40]);

     e um toro

          (%i9) expr_1: cos(y)*(10.0+6*cos(x))$
          (%i10) expr_2: sin(y)*(10.0+6*cos(x))$
          (%i11) expr_3: -6*sin(x)$
          (%i12) plot3d ([expr_1, expr_2, expr_3], [x, 0, 2*%pi],       [y, 0, 2*%pi], ['grid, 40, 40]);

     Algumas vezes isso é necessário para definir uma função para
     montar o graico da expressão. Todos os argumentos para plot3d são
     avaliados antes de serem passados para plot3d. Tentar fazer um
     expressão que faz apenas o que é preciso pode ser difícil e pode
     ser mais fácil fazer uma função.

          (%i13) M: matrix([1, 2, 3, 4], [1, 2, 3, 2], [1, 2, 3, 4],
                 [1, 2, 3, 3])$
          (%i14) f(x, y) := float (M [?round(x), ?round(y)])$
          (%i15) plot3d (f, [x, 1, 4], [y, 1, 4], ['grid, 4, 4])$

     Veja `plot_options' para mais exemplos.


 -- Função: make_transform (<vars>, <fx>, <fy>, <fz>)
     Retorna uma função adequada para a função transformação em plot3d.
     Use com a opção de montagem de gráfico `transform_xy'.
          make_transform ([r, th, z], r*cos(th), r*sin(th), z)$
     é uma transformação para coordenadas polares.

 -- Função: set_plot_option (<opção>)
     Atribui uma das varáveis globais para impressão.  <opção> é
     especificada como uma lista de dois ou mais elementos, na qual o
     primeiro elemento é uma das palavras chave dentro da lista
     `plot_options'.

     `set_plot_option' avalia seu argumento e retorna a liasta completa
     `plot_options' (após modificar um de seus elementos).

     Veja também `plot_options', `plot2d', e `plot3d'.

     Exemplos:

     Modifica a malha (`grid') e valores de `x'.  Quando uma palavra
     chave em `plot_options' tem um valor atribuído, colocar um
     apóstrofo evita avaliação.

          (%i1) set_plot_option ([grid, 30, 40]);
          (%o1) [[x, - 1.755559702014E+305, 1.755559702014E+305],
          [y, - 1.755559702014E+305, 1.755559702014E+305], [t, - 3, 3],
          [grid, 30, 40], [transform_xy, false], [run_viewer, true],
          [plot_format, gnuplot], [gnuplot_term, default],
          [gnuplot_out_file, false], [nticks, 10], [adapt_depth, 10],
          [gnuplot_pm3d, false], [gnuplot_preamble, ],
          [gnuplot_curve_titles, [default]],
          [gnuplot_curve_styles, [with lines 3, with lines 1,
          with lines 2, with lines 5, with lines 4, with lines 6,
          with lines 7]], [gnuplot_default_term_command, ],
          [gnuplot_dumb_term_command, set term dumb 79 22],
          [gnuplot_ps_term_command, set size 1.5, 1.5;set term postscript #
          eps enhanced color solid 24]]
          (%i2) x: 42;
          (%o2)                          42
          (%i3) set_plot_option (['x, -100, 100]);
          (%o3) [[x, - 100.0, 100.0], [y, - 1.755559702014E+305,
          1.755559702014E+305], [t, - 3, 3], [grid, 30, 40],
          [transform_xy, false], [run_viewer, true],
          [plot_format, gnuplot], [gnuplot_term, default],
          [gnuplot_out_file, false], [nticks, 10], [adapt_depth, 10],
          [gnuplot_pm3d, false], [gnuplot_preamble, ],
          [gnuplot_curve_titles, [default]],
          [gnuplot_curve_styles, [with lines 3, with lines 1,
          with lines 2, with lines 5, with lines 4, with lines 6,
          with lines 7]], [gnuplot_default_term_command, ],
          [gnuplot_dumb_term_command, set term dumb 79 22],
          [gnuplot_ps_term_command, set size 1.5, 1.5;set term postscript #
          eps enhanced color solid 24]]


8.1.1 Funções para trabalhar com o formato `gnuplot_pipes'
----------------------------------------------------------

 -- Função: gnuplot_start ()
     Abre o pipe para o gnuplot usado para montar um gráfico com o
     formato `gnuplot_pipes'. Não é necessário abrir manualmente o pipe
     antes de montar o gráfico.


 -- Função: gnuplot_close ()
     Fecha o pipe para o gnuplot que está sendo usado com o formato
     `gnuplot_pipes'.


 -- Função: gnuplot_restart ()
     Fecha o pipe para o gnuplot que é usado com o formato
     `gnuplot_pipes' e abre um novo pipe.


 -- Função: gnuplot_replot ()
 -- Função: gnuplot_replot (<s>)
     Atualiza a janela gráfica do gnuplot. Se `gnuplot_replot' for
     chamado com um comando gnuplot em uma seqüência de caracteres <s>,
     então `s' é enviado para o gnuplot antes de atualizar a janela.


 -- Função: gnuplot_reset ()
     Restaura o estado inicial padrão do gnuplot usado com o formato
     `gnuplot_pipes'. Para atualizar a janela do gnuplot chama
     `gnuplot_replot' após `gnuplot_reset'.



File: maxima.info,  Node: Entrada e Saída,  Next: Ponto Flutuante,  Prev: Montando Gráficos,  Up: Top

9 Entrada e Saída
*****************

* Menu:

* Comentários::
* Arquivos::
* Funções e Variáveis Definidas para Entrada e Saída::


File: maxima.info,  Node: Comentários,  Next: Arquivos,  Prev: Entrada e Saída,  Up: Entrada e Saída

9.1 Comentários
===============

Um comentário na entrada do Maxima é qualquer texto entre `/*' e `*/'.

   O analisador do Maxima trata um comentário como espação em branco
para o propósito de encontrar indicações no fluxo de entrada; uma
indicação sempre termina um comentário.  Uma entrada tal como `a/* foo
*/b' contém duas indicações, `a' e `b', e não uma indicação simples
`ab'.  Comentários são de outra ignorados pelo Maxima; nem o conteúdo
nem a localização dos comentários são armazenados pelo analisador de
expressões de entrada.

   Comentários podem ser aninhados de forma a terem um nível de
estratificação arbitrario.  O delimitador `/*' e o delimitador `*/'
formam pares.  A quantidade de `/*' deve ser a mesma quantidade de `*/'.

   Exemplos:

     (%i1) /* aa is a variable of interest */  aa : 1234;
     (%o1)                         1234
     (%i2) /* Value of bb depends on aa */  bb : aa^2;
     (%o2)                        1522756
     (%i3) /* User-defined infix operator */  infix ("b");
     (%o3)                           b
     (%i4) /* Parses same as a b c, not abc */  a/* foo */b/* bar */c;
     (%o4)                         a b c
     (%i5) /* Comments /* can be nested /* to arbitrary depth */ */ */  1 + xyz;
     (%o5)                        xyz + 1


File: maxima.info,  Node: Arquivos,  Next: Funções e Variáveis Definidas para Entrada e Saída,  Prev: Comentários,  Up: Entrada e Saída

9.2 Arquivos
============

Um arquivo é simplesmente uma área sobre um dispositivo particular de
armazenagem que contém dados ou texto.  Arquivos em disco são
figurativamente agrupados dentro de "diretórios".  Um diretório é
apenas uma lista de arquivos.  Comandos que lidam com arquivos são:
`save', `load', `loadfile', `stringout', `batch', `demo', `writefile',
`closefile', e `appendfile'.



Local Variables:
coding: iso-8859-1
End:
